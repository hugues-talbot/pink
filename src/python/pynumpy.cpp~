/*
  This software is licensed under 
  CeCILL FREE SOFTWARE LICENSE AGREEMENT

  This software comes in hope that it will be useful but 
  without any warranty to the extent permitted by applicable law.
  
  (C) UjoImro, 2012 <ujoimro@gmail.com>
  ProCarPlan s.r.o.
*/

// Pink NumPy Conversion routine

#include <Python.h>
#include <boost/python.hpp>
#include <numpy/arrayobject.h>
#include <boost/smart_ptr.hpp>

#include "pink_python.h"

namespace pink {
    namespace python {

        // this code has been borrowed from
        // Copyright (c) 2008, Michael Droettboom

        namespace detail {

            template<class T>
            class numpy_type_map {
            public:
                static const int typenum;
            };

            template<>
            const int numpy_type_map<float>::typenum = NPY_FLOAT;

            template<>
            const int numpy_type_map<std::complex<float> >::typenum = NPY_CFLOAT;

            template<>
            const int numpy_type_map<double>::typenum = NPY_DOUBLE;

            template<>
            const int numpy_type_map<std::complex<double> >::typenum = NPY_CDOUBLE;

            template<>
            const int numpy_type_map<long double>::typenum = NPY_LONGDOUBLE;

            template<>
            const int numpy_type_map<std::complex<long double> >::typenum = NPY_CLONGDOUBLE;

            template<>
            const int numpy_type_map<boost::int8_t>::typenum = NPY_INT8;

            template<>
            const int numpy_type_map<boost::uint8_t>::typenum = NPY_UINT8;

            template<>
            const int numpy_type_map<boost::int16_t>::typenum = NPY_INT16;

            template<>
            const int numpy_type_map<boost::uint16_t>::typenum = NPY_UINT16;

            template<>
            const int numpy_type_map<boost::int32_t>::typenum = NPY_INT32;

            template<>
            const int numpy_type_map<boost::uint32_t>::typenum = NPY_UINT32;

            template<>
            const int numpy_type_map<boost::int64_t>::typenum = NPY_INT64;

            template<>
            const int numpy_type_map<boost::uint64_t>::typenum = NPY_UINT64;
        }   


        struct sentinel_t {
            ~sentinel_t () {
                std::cout << "the result has been returned" << std::endl;                
            }           
        };        
            

        template <class image_type>
        PyObject * 
        wrap2numpy( image_type & image )
        {
            sentinel_t sentinel;
            
            // the dimension of the image
            int32_t nd = image.get_size().size();
            _DEBUG(nd);            
            // the sizes of the image
            boost::shared_array<npy_intp> dims( new npy_intp[nd] );            
            for ( index_t q=0; q<nd; ++q ) {
                dims[q] = image.get_size()[q];
                _DEBUG(dims[q]);
            }
            
            PyArrayObject* numpy_array;
            numpy_array = (PyArrayObject*)PyArray_SimpleNewFromData (
                nd,
                dims.get(),
                detail::numpy_type_map<typename image_type::pixel_type>::typenum,
                reinterpret_cast<void*>(image.get_pixels().get())
                );
             
            if (numpy_array == NULL)
                pink_error("Couldn't allocate the NumPy array.");

            return (PyObject*)numpy_array;
        }

        
        template <class image_type>
        boost::python::object
        numpy2pink( boost::python::object & array )
        {

            // PyArrayObject* PyArray_GETCONTIGUOUS(PyObject* op)
            // PyObject* arrayPyArray_NewCopy( array.get(), NPY_CORDER );
            
            // if (!PyArray_ISCONTIGUOUS(array.get())) // the array is not continuous
                // pink_error("This function can only wrap continuous arrays");
                
        }
        
        
    } /* namespace python */
} /* namespace pink */


const std::string wrap2numpy_doc =
                             "Converts a pink::ujimage object to a numpy array. The data is NOT copied"
                             ", only the pointer is carried, which means that if you change the numpy "
                             "array the image values change too. In exchange the conversion does no copy and "
                             "is therefore in constant time.";

const std::string wrap2pink_doc =
                             "Converts a numpy array into a pink::ujimage object. The method fails "
                             "if the data is not continuous. If the function succeeds, the data is NOT copied"
                             ", only the pointer is carried, which means that if you change the numpy "
                             "array the image values change too. In exchange the conversion does no copy and "
                             "is therefore in constant time.";

                             
void numpy_export()
{
    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::char_image>,     ( boost::python::arg("image") ), wrap2numpy_doc );
    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::short_image>,    ( boost::python::arg("image") ), wrap2numpy_doc );
    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::int_image>,      ( boost::python::arg("image") ), wrap2numpy_doc );
    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::float_image>,    ( boost::python::arg("image") ), wrap2numpy_doc );
    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::double_image>,   ( boost::python::arg("image") ), wrap2numpy_doc );
    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::fcomplex_image>, ( boost::python::arg("image") ), wrap2numpy_doc );
    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::dcomplex_image>, ( boost::python::arg("image") ), wrap2numpy_doc );

    boost::python::def( "wrap2pink", &pink::python::wrap2pink, ( boost::python::arg("array") ), wrap2numpy_doc );

    import_array();  // numpy initialization
}

// LuM end of file
