/* $Id: animscenes.c,v 1.2 2009-01-06 13:18:06 mcouprie Exp $ */
/*! \file animscenes.c

\brief generates intermediate scenes by interpolation

<B>Usage:</B> animscenes prefix_in begin end prefix_out nbsamples

<B>Description:</B>
The input scenes must be stored in files with names of the form  
\b prefix_inXXXX.3sc, where XXXX is an integer between \b begin
and \b end. They must all contain the same number of objects, 
and object types must match from one scene to each other (order matters).

Between the scenes of the series, a total number of \b nbsamples scenes 
are generated by spline interpolation.

<B>Types supported:</B> scene 3D

<B>Category:</B> draw geo
\ingroup  draw geo

\author Michel Couprie
*/

#include <stdio.h>
#include <stdint.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <mccodimage.h>
#include <mcimage.h>
#include <mcsplines.h>
#include <mcgeo.h>
#include <ldraw.h>

#define VERBOSE

/* =============================================================== */
int main(int argc, char **argv)
/* =============================================================== */
{
  int32_t s, o, p, n, nobj, begin, end, nbsamples, lenprefix, nbscenes;
  char buf[1024];
  scene **tabscene_in;
  scene **tabscene_out;
  object *obj;
  double *x, *y, *z, *X, *Y, *Z;

  if (argc != 6)
  {
    fprintf(stderr, "usage: %s prefix_in begin end prefix_out nbsamples\n", argv[0]);
    exit(1);
  }

  strcpy(buf, argv[1]);
  begin = atoi(argv[2]);
  end = atoi(argv[3]);
  nbsamples = atoi(argv[5]);
  lenprefix = strlen(buf);
  nbscenes = end - begin + 1;
  tabscene_in = (scene **)calloc(1,nbscenes * sizeof(scene *));
  x = (double *)calloc(1,nbscenes * sizeof(double));
  y = (double *)calloc(1,nbscenes * sizeof(double));
  z = (double *)calloc(1,nbscenes * sizeof(double));
  X = (double *)calloc(1,nbsamples * sizeof(double));
  Y = (double *)calloc(1,nbsamples * sizeof(double));
  Z = (double *)calloc(1,nbsamples * sizeof(double));
  if (!tabscene_in || !x || !y || !z || !X || !Y || !Z)
  {
    fprintf(stderr, "%s: malloc failed\n", argv[0]);
    exit(1);
  }

  // LECTURE SCENES
  for (s = begin, n = 0; s <= end; s++, n++)
  {
    sprintf(buf+lenprefix, "%04d\0", s);
    strcat(buf, ".3sc");
#ifdef VERBOSE
    printf("reading %s\n", buf);
#endif
    tabscene_in[n] = readscene(buf);
    if (tabscene_in[n] == NULL)
    {
      fprintf(stderr, "%s: readscene failed\n", argv[0]);
      exit(1);
    }
  } // for (s = begin; s <= end; s++)
  nobj = tabscene_in[0]->nobj;

  // VERIFICATION SCENES HOMOGENES
  for (s = 1; s < nbscenes; s++)
  {
    if (tabscene_in[0]->nobj != nobj)
    {
      fprintf(stderr, "%s: incompatible object numbers\n", argv[0]);
      exit(1);
    }
    for (o = 0; o < nobj; o++)
    {
      if (tabscene_in[0]->tabobj[o]->objtype != tabscene_in[s]->tabobj[o]->objtype)
      {
	fprintf(stderr, "%s: incompatible object types\n", argv[0]);
	exit(1);
      }
      if (tabscene_in[0]->tabobj[o]->npoints != tabscene_in[s]->tabobj[o]->npoints)
      {
	fprintf(stderr, "%s: incompatible object sizes\n", argv[0]);
	exit(1);
      }
    } // for (o = 0; o < nobj; o++)
  } // for (s = 1; s < nbscenes; s++)

  // INTERPOLATION SCENES
  tabscene_out = (scene **)calloc(1,nbsamples * sizeof(scene *));
  if (tabscene_out == NULL)
  {
    fprintf(stderr, "%s: malloc failed\n", argv[0]);
    exit(1);
  }  
  for (s = 0; s < nbsamples; s++) tabscene_out[s] = copyscene(tabscene_in[0]);

  for (o = 0; o < nobj; o++)
  {
    for (p = 0; p < tabscene_in[0]->tabobj[o]->npoints; p++)
    {
      for (s = 0; s < nbscenes; s++)
      {
	obj = tabscene_in[s]->tabobj[o];
	x[s] = obj->points[p].x;
	y[s] = obj->points[p].y;
	z[s] = obj->points[p].z;
      } // for (s = 0; s < nbscenes; s++)

      scn_samplespline3d(x, y, z, nbscenes, nbsamples, X, Y, Z);
      
      for (s = 0; s < nbsamples; s++)
      {
	tabscene_out[s]->tabobj[o]->points[p].x = X[s];
	tabscene_out[s]->tabobj[o]->points[p].y = Y[s];
	tabscene_out[s]->tabobj[o]->points[p].z = Z[s];
      } // for (s = 0; s < nbsamples; s++)
    } // for (p = 0; p < obj->npoints; p++)
  } // for (o = 0; o <= tabscene_in[0]->nobj; o++)

  // ECRITURE RESULTAT
  strcpy(buf, argv[4]);
  lenprefix = strlen(buf);
  for (s = 0; s < nbsamples; s++)
  {
    sprintf(buf+lenprefix, "%04d\0", s);
    strcat(buf, ".3sc");
#ifdef VERBOSE
    printf("writing %s\n", buf);
#endif

    writescene(tabscene_out[s], buf);
  }

  free(x); free(y); free(z);
  free(X); free(Y); free(Z);
  return 0;
} /* main */
