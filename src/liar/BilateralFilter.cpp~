#include "BilateralFilter.h"

#include <math.h>
#include <iostream>
#include <vector>
#include <stdlib.h>


// Constructor
BilateralFilter::BilateralFilter(PixelType *_image, int _window_size, int _alpha, int _beta, int _dimx, int _dimy, int _dimz) :
    image(_image),
    window_size(_window_size),
    alpha(_alpha),
    beta(_beta),
    dimx(_dimx),
    dimy(_dimz),
    dimz(_dimz){}


inline int BilateralFilter :: index3D(int x, int y, int z)
{
    return (x+dimx*y+dimx*dimy*z);
}

inline int BilateralFilter :: index2D(int x, int y)
{
    return (x+dimx*y);
}

void BilateralFilter::Execute3D()
{
    int const image_size=dimx*dimy*dimz;
    std::vector<PixelType> outputI(image_size);

  	//copy of the input data
	std::memcpy(&outputI[0], &image[0],image_size*sizeof(PixelType));

    int const r_window=floor(window_size/2);

    int z, y ,x, dz, dy, dx;
    float w, v;
    float W=0, V=0;

    for (z=0; z<dimz; z++)
    {
        for (y=0; y<dimy; y++)
        {
            for (x=0; x<dimx; x++)
            {
                for (dz=-r_window; dz<=r_window; dz++)
                {
                    for (dy=-r_window; dy<=r_window; dy++)
                    {
                        for (dx=-r_window; dx<=r_window; dx++)
                        {
                            // (X,Y,Z) : Coordinates of the current pixel in the window centered on the (x,y,z) pixel
                            int X=x+dx;
                            int Y=y+dy;
                            int Z=z+dz;

                            if (X>=0 && X<dimx && Y>=0 && Y<dimy && Z>=0 && Z<dimz) // If the current pixel is inside the image
                            {
                                float d=sqrt(pow(dx,2)+pow(dy,2)+pow(dz,2)); // Distance between the central pixel and the current pixel
                                int dI=abs(image[this->index3D(X,Y,Z)]-image[this->index3D(x,y,z)]); // Difference of intensity between the central pixel and the current pixel

                                w=exp(-alpha*d)*exp(-beta*dI); // Weight of the (X,Y,Z) pixel.
                                v=w*image[this->index3D(X,Y,Z)]; // New intensity of the central pixel depending only on the current pixel.

                                W+=w; // Sum of the weight
                                V+=v; // Sum of the intensity
                            }
                        }
                    }
                }

                V=int(V/W+0.5); // Normalisation and conversion to int
                outputI[this->index3D(x,y,z)]=V;
            }
        }
    }

	// Copy output data
	std::memcpy( &image[0], &outputI,image_size*sizeof(PixelType));
}

void BilateralFilter::Execute2D()
{
    int const image_size=dimx*dimy;
    std::vector<PixelType> outputI(image_size);

  	//copy of the input data
	std::memcpy(&outputI[0], &image[0],image_size*sizeof(PixelType));

    int const r_window=floor(window_size/2);


    int y ,x, dy, dx;
    float w, v;
    float W=0, V=0;

    for (y=0; y<dimy; y++)
    {
        for (x=0; x<dimx; x++)
        {
            for (dy=-r_window; dy<=r_window; dy++)
            {
                for (dx=-r_window; dx<=r_window; dx++)
                {
                    // (X,Y) : Coordinates of the current pixel in the window centered on the (x,y,z) pixel
                    int X=x+dx;
                    int Y=y+dy;

                    if (X>=0 && X<dimx && Y>=0 && Y<dimy) // If the current pixel is inside the image
                    {
                        float d=sqrt(pow(dx,2)+pow(dy,2)); // Distance between the central pixel and the current pixel
                        int dI=abs(image[this->index2D(X,Y)]-image[this->index2D(x,y)]); // Difference of intensity between the central pixel and the current pixel

                        w=exp(-alpha*d)*exp(-beta*dI); // Weight of the (X,Y) pixel.
                        v=w*image[this->index2D(X,Y)]; // New intensity of the central pixel depending only on the current pixel.

                        W+=w; // Sum of the weight
                        V+=v; // Sum of the intensity
                    }
                }
            }

            V=int(V/W+0.5); // Normalisation and conversion to int
            outputI[this->index2D(x,y)]=V;

        }
    }

	// Copy output data
	std::memcpy( &image[0], &outputI,image_size*sizeof(PixelType));
}
