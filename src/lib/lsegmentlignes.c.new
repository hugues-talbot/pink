/* operateur de segmentation de structures lineaires */
/* utilise une File d'Attente Hierarchique */
/* Michel Couprie - janvier 1998 */

#define PARANO                 /* even paranoid people have ennemies */
#define VERBOSE

/*
   Methode : 

   1/ etiquetage des minima (M != 0)

   2/ selection des minima lineaires (sans point multiples) :
      - les voisins des minimas lineaires sont mis dans la FAH

   3/ inondation :
      tq !fahvide
        x = fahpop
        h = F[x]
        parcours du h-plateau de x : 
          si tous les points du h-plateau 
             et tous les points etiquetes du voisinage du h-plateau
             sont de degre < 2
            etiquette les points du h-plateau
            empile les voisins > du h-plateau
*/

#include <stdio.h>
#include <mccodimage.h>
#include <mcimage.h>
#include <mcfah.h>
#include <mclifo.h>
#include <mcindic.h>
#include <llabelextrema.h>
#include <lsegmentlignes.h>

#define EN_FAH 0
#define MARQUE1 1
#define TRAITE 2

/* ==================================== */
int lsegmentlignes(
        struct xvimage *image,
        int connex,
        int seuil)
/* ==================================== */
{
  register int i;                       /* index muet */
  register int x;                       /* index muet de pixel */
  register int y;                       /* index muet (generalement un voisin de x) */
  register int z;                       /* index muet de pixel */
  register int w;                       /* index muet de pixel */
  register int k;                       /* index muet */
  register int l;                       /* index muet */
  register int h;
  int rs = rowsize(image);     /* taille ligne */
  int cs = colsize(image);     /* taille colonne */
  int N = rs * cs;             /* taille image */
  unsigned char *F = UCHARDATA(image);      /* l'image de depart */
  struct xvimage *lab;         /* l'image d'etiquettes de composantes connexes */
  unsigned long *M;            /* l'image d'etiquettes de composantes connexes (data) */
  unsigned char *V;            /* l'image des nombres de voisins */
  int *NBPTMULT;               /* pour le stockage du nombre de points multiples 
                                  des composantes
                               */
  int nminima;                 /* nombre de minima differents */
  Fah * FAH;                   /* la file d'attente hierarchique */
  Lifo * LIFO;                 /* pour parcourir un plateau */
  Lifo * PLAT;                 /* pour memoriser les pts d'un plateau */
  Lifo * VPLAT;                /* pour memoriser les voisins d'un plateau */
  int incr_vois;
  int nbmult;
  int lineaire;

  if (depth(image) != 1) 
  {
    fprintf(stderr, "lsegmentlignes: cette version ne traite pas les images volumiques\n");
    exit(0);
  }

  switch (connex)
  {
    case 4: incr_vois = 2; break;
    case 8: incr_vois = 1; break;
    default: 
      fprintf(stderr, "lsegmentlignes: mauvaise connexite: %d\n", connex);
      return 0;
  } /* switch (connex) */

  IndicsInit(N);
  FAH = CreeFahVide(N+1);
  if (FAH == NULL)
  {   fprintf(stderr, "lsegmentlignes() : CreeFah failed\n");
      return(0);
  }

  LIFO = CreeLifoVide(N/4);
  PLAT = CreeLifoVide(N/4);
  VPLAT = CreeLifoVide(N/4);
  if ((LIFO == NULL) || (PLAT == NULL) || (VPLAT == NULL))
  {   fprintf(stderr, "lsegmentlignes() : CreeLifoVide failed\n");
      return(0);
  }

  lab = allocimage(NULL, rs, cs, 1, VFF_TYP_4_BYTE);
  if (lab == NULL)
  {   
    fprintf(stderr, "lsegmentlignes: allocimage failed\n");
    return 0;
  }
  M = ULONGDATA(lab);

  if (!llabelextrema(image, connex, LABMIN, lab, &nminima))
  {   
    fprintf(stderr, "lsegmentlignes: llabelextrema failed\n");
    return 0;
  }

  NBPTMULT = (int *)calloc(nminima, sizeof(int));   /* init a 0 */
  if (NBPTMULT == NULL)
  {   fprintf(stderr, "lsegmentlignes() : malloc failed for NBPTMULT\n");
      return(0);
  }

  V = (unsigned char *)calloc(N, sizeof(char));   /* init a 0 */
  if (V == NULL)
  {   fprintf(stderr, "lsegmentlignes() : malloc failed for V\n");
      return(0);
  }

/*
   2/ selection des minima lineaires (sans point multiples) :
      - les voisins des minimas lineaires sont mis dans la FAH
*/

  for (x = 0; x < N; x++)
  {
    if ((M[x]) && (!IsSet(x, TRAITE)))
    {     
      h = F[x];
      lineaire = 1;

      /* 1er parcours du plateau de x */ 
      LifoPush(LIFO, x);       
      while (! LifoVide(LIFO))
      {
        w = LifoPop(LIFO);
        i = 0;                 /* pour compter la nb de voisins de w dans la comp. */
        for (k = 0; k < 8; k += incr_vois)
        {
          y = voisin(w, k, rs, N);
          if ((y != -1) && (M[y] == M[w])) i++;     /* compte le nb de voisins */
          if ((y != -1) && (F[y] == h) && (!IsSet(y, MARQUE1)))
          {
            Set(y, MARQUE1);
            LifoPush(LIFO, y);
          }
        } /* for (k = 0; k < 8; k += incr_vois) */
        if (i > 2) lineaire = 0; else V[w] = i;
      } /* while (! LifoVide(LIFO)) */

      LifoPush(LIFO, x);       /* 2nd parcours du plateau de x */ 
      while (! LifoVide(LIFO))
      {
        w = LifoPop(LIFO);
        if (!lineaire) M[w] = 0;
        Set(w, TRAITE);
        for (k = 0; k < 8; k += incr_vois)
        {
          y = voisin(w, k, rs, N);
          if ((y != -1) && (F[y] == h) && (IsSet(y, MARQUE1)))
          {
            UnSet(y, MARQUE1);
            LifoPush(LIFO, y);
          }
          if (lineaire && (y != -1) && (F[y] > h) && (!IsSet(y, EN_FAH)))
          {
            Set(y, EN_FAH);
            FahPush(FAH, y, F[y]);
          }
        } /* for (k = 0; k < 8; k += incr_vois) */
      } /* while (! LifoVide(LIFO)) */
    } /* if (M[x]) */
  } /* for (x = 0; x < N; x++) */

/*
   3/ inondation :
      tq !fahvide
        x = fahpop
        h = F[x]
        parcours du h-plateau de x : 
          si tous les points du h-plateau 
             et tous les points etiquetes du voisinage du h-plateau
             sont de degre < 2
            etiquette les points du h-plateau
*/

  while(!FahVide(FAH))
  {
    x = FahPop(FAH);
    if (!IsSet(x, TRAITE))
    {     
      h = F[x];

      /* 1er parcours du plateau de x : on memorise, dans les files PLAT et VPLAT, */
      /* les points du plateau et les points voisins du plateau qui sont etiquetes. */

      LifoFlush(PLAT);
      LifoFlush(VPLAT);
      LifoPush(LIFO, x);
      while (! LifoVide(LIFO))
      {
        w = LifoPop(LIFO);     /* w est un point du h-plateau */
        LifoPush(PLAT, w);
        for (k = 0; k < 8; k += incr_vois)
        {
          y = voisin(w, k, rs, N);
          if (y != -1)
          {
            if (M[y]) LifoPush(VPLAT, y);
            if ((F[y] == h) && (!IsSet(y, MARQUE1)))
            {
              Set(y, MARQUE1);
              LifoPush(LIFO, y);
            }
          } /* if (y != -1) */
        } /* for (k = 0; k < 8; k += incr_vois) */
      } /* while (! LifoVide(LIFO)) */

      /* parcours du plateau : on met a jour les V (nb de voisins dans la (future?) comp) */
      /* (on retire en meme temps MARQUE1) */
      for (i = 0; i < PLAT->Sp; i++)
      {
        w = PLAT->Pts[i];
        UnSet(w, MARQUE1);
        V[w] = 0;
        for (k = 0; k < 8; k += incr_vois)
        {
          y = voisin(w, k, rs, N);
          if ((y != -1) && (M[y] || (F[y] == h))) V[w]++;
        } /* for (k = 0; k < 8; k += incr_vois) */
      } /* for (i = 0; i < PLAT->Sp; i++) */

      /* parcours des voisins etiquetes du plateau */
      /* on met a jour les V (nb de voisins dans la (future?) comp) */
      for (i = 0; i < VPLAT->Sp; i++)
      {
        w = VPLAT->Pts[i];
        V[w] = 0;
        for (k = 0; k < 8; k += incr_vois)
        {
          y = voisin(w, k, rs, N);
          if ((y != -1) && (M[y] || (F[y] == h))) V[w]++;
        } /* for (k = 0; k < 8; k += incr_vois) */
      } /* for (i = 0; i < PLAT->Sp; i++) */

      /* verifie la condition "lineaire" pour les points de PLAT et de VPLAT : */
      /* les points de degre n > 2 doivent posseder dans leur voisinage n-2 points extremite */
      lineaire = 1;
      for (i = 0; i < PLAT->Sp; i++)
      {
        w = PLAT->Pts[i];
        if (V[w] > 2) { lineaire = 0; break; }
      } /* for (i = 0; i < PLAT->Sp; i++) */
      if (lineaire) for (i = 0; i < VPLAT->Sp; i++)
      {
        w = VPLAT->Pts[i];
        if (V[w] > 2) { lineaire = 0; break; }
      } /* for (i = 0; i < VPLAT->Sp; i++) */

      /* si la condition "lineaire" est vraie, on etiquette les points de PLAT */
      /* et on empile les voisins > du plateau dans la FAH */
      if (lineaire) for (i = 0; i < PLAT->Sp; i++)
      {
        w = PLAT->Pts[i];
        M[w] = nminima+1;
        Set(w, TRAITE);
        for (k = 0; k < 8; k += incr_vois)
        {
          y = voisin(w, k, rs, N);
          if ((y != -1) && (F[y] > h) && (!IsSet(y, EN_FAH))) 
          {
            Set(y, EN_FAH);
            FahPush(FAH, y, F[y]);
          }
        } /* for (k = 0; k < 8; k += incr_vois) */
      } /* for (i = 0; i < PLAT->Sp; i++) */

      /* si la condition "lineaire" est fausse, on remet a jour les V des points de VPLAT */
      else for (i = 0; i < VPLAT->Sp; i++)
      {
        w = VPLAT->Pts[i];
        V[w] = 0;
        for (k = 0; k < 8; k += incr_vois)
        {
          y = voisin(w, k, rs, N);
          if ((y != -1) && M[y]) V[w]++;
        } /* for (k = 0; k < 8; k += incr_vois) */
      } /* for (i = 0; i < VPLAT->Sp; i++) */

    } /* if (!IsSet(x, TRAITE)) */
  } /* while(!FahVide(FAH)) */

  for (x = 0; x < N; x++)
    if (M[x]) F[x] = NDG_MAX;
    else      F[x] = NDG_MIN;

  /* ================================================ */
  /* UN PEU DE MENAGE                                 */
  /* ================================================ */

  free(V);
  free(NBPTMULT);
  IndicsTermine();
  FahTermine(FAH);
  LifoTermine(LIFO);
  LifoTermine(PLAT);
  LifoTermine(VPLAT);
  freeimage(lab);
  return(1);
}

