diff -r 8b1af7363833 .hgignore
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/.hgignore	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,4 @@
+re:.*~$
+re:.*\.orig
+re:include/python_doc.h
+re:/_.*
diff -r 8b1af7363833 .hgtags
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/.hgtags	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,1 @@
+d6cea6da58eef96f371fa8eda183e17fba606c95 start
diff -r 8b1af7363833 CMakeLists.txt
--- a/CMakeLists.txt	Sat May 25 21:53:33 2013 +0200
+++ b/CMakeLists.txt	Mon Jan 13 15:50:10 2014 +0100
@@ -376,7 +376,6 @@
     if(NOT PYTHON_INCLUDE)
 	find_package(PythonLibs)
 	SET(PYTHON_INCLUDE ${PYTHON_INCLUDE_PATH} CACHE PATH "The directory of the python headers." )
-	message( STATUS "PYTHON_INCLUDE = " ${PYTHON_INCLUDE} )
     endif(NOT PYTHON_INCLUDE)
 
     find_package(Boost COMPONENTS python thread )
diff -r 8b1af7363833 data/configs/pink_windows_config_python26_64.txt~
--- a/data/configs/pink_windows_config_python26_64.txt~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,63 +0,0 @@
-# -*- sh -*-
-
-## commandline to compile:
-# D:\Build\compilevars.bat
-## three times
-# "c:\Program Files (x86)\CMake 2.8\bin\cmake.exe" -G "NMake Makefiles" -C ..\pink_windows_config.txt ..\pink-hg
-
-SET( 64BIT ON CACHE BOOL "desc." )
-SET( BOOST_INCLUDEDIR "/usr/include" CACHE PATH "desc." )
-#SET( CFITSIO_DIR:PATH=CFITSIO_DIR-NOTFOUND )
-SET( CMAKE_BUILD_TYPE "Release" CACHE STRING "desc." )
-SET( CMAKE_COLOR_MAKEFILE ON CACHE BOOL "desc.")
-#SET( CMAKE_CXX_COMPILER "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/bin/amd64/cl.exe" CACHE FILEPATH "desc." )
-#SET( CMAKE_C_COMPILER "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/bin/amd64/cl.exe" CACHE FILEPATH "desc." )
-SET( CMAKE_INSTALL_PREFIX "install" CACHE PATH "desc." )
-#SET( CMAKE_LINKER "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/bin/amd64/link.exe" CACHE FILEPATH "desc." )
-SET( CMAKE_MAKE_PROGRAM "nmake" CACHE STRING "desc." )
-SET( CMAKE_PROJECT_NAME "pink-image" CACHE STATIC "desc." )
-#SET( CMAKE_RC_COMPILER "C:/Program Files/Microsoft SDKs/Windows/v7.1/Bin/x64/RC.Exe" CACHE FILEPATH "desc." )
-SET( CMAKE_VERBOSE_MAKEFILE ON CACHE BOOL "desc." )
-SET( DEVELOPMENT ON CACHE BOOL "desc." )
-SET( GSLCBLAS_LIB "D:/Build/gsl-1.15/build.vc10/lib/x64/Release/cblas.lib" CACHE FILEPATH "desc." )
-SET( GSL_LIB "D:/Build/gsl-1.15/build.vc10/lib/x64/Release/gsl.lib" CACHE FILEPATH "desc." )
-SET( LAPACK_LIB "D:/Build/lapack/manual_build64/SRC/lapack.lib" CACHE FILEPATH "desc." )
-SET( BLAS_LIB "D:/Build/lapack/manual_build64/BLAS/SRC/blas.lib" CACHE FILEPATH "desc." )
-SET( LIBF2C_LIB "D:/Build/lapack/manual_build64/F2CLIBS/libf2c/libf2c.lib" CACHE FILEPATH "desc." )
-SET( NUMA OFF CACHE BOOL "desc." )
-SET( OPENCL OFF CACHE BOOL "desc." )
-SET( PYTHON_FRONT_END ON CACHE BOOL "desc." )
-SET( SIMD ON CACHE BOOL "desc." )
-SET( TIFF_INCLUDE_DIR "D:/Build/tiff-4.0.2/libtiff" CACHE PATH "desc." )
-SET( TIFF_LIBRARY "D:/Build/tiff-4.0.2/libtiff/libtiff.lib" CACHE FILEPATH "desc." )
-SET( GSL_INCLUDE "D:/Build/gsl-1.15/include" CACHE PATH "desc." )
-SET( EIGEN_INCLUDE "D:/Build/eigen-eigen-b23437e61a07" CACHE PATH "desc." )
-
-SET( NUMPY OFF CACHE BOOL "desc." )
-SET( CMAKE_INSTALL_PREFIX "install" CACHE PATH "desc." )
-SET( PINK_PACKAGE_TYPE "NSIS-WINDOWS" CACHE STRING "Generate a Windows(tm) installer." )
-SET( CPACK_MODULE_PATH "C:/Users/ujoimro/Pink/pink-hg" CACHE PATH "The path for the NSIS installer templates" )
-
-###########################################################################
-### Python 2.7
-###########################################################################
-SET( Boost_DIR "D:/Build/boost_1_49_0/boost_python26/boost_1_49_0" CACHE PATH "desc." )
-SET( Boost_INCLUDE_DIR "D:/Build/boost_1_49_0/boost_python26/boost_1_49_0" CACHE PATH "desc." )
-SET( Boost_PYTHON "D:/Build/boost_1_49_0/boost_python26/boost_1_49_0/stage/lib/libboost_python-vc100-mt-s-1_49.lib" CACHE FILEPATH "desc." )
-SET( Boost_PYTHON_LIBRARY "D:/Build/boost_1_49_0/boost_python26/boost_1_49_0/stage/lib/libboost_python-vc100-mt-s-1_49.lib" CACHE FILEPATH "The Boost PYTHON library." )
-SET( Boost_PYTHON_LIBRARY_DEBUG "D:/Build/boost_1_49_0/boost_python26/boost_1_49_0/stage/lib/libboost_python-vc100-mt-sgd-1_49.lib" CACHE FILEPATH "Boost python library (debug)" )
-#Boost_PYTHON_LIBRARY_DEBUG:FILEPATH=Boost_PYTHON_LIBRARY_DEBUG-NOTFOUND
-SET( Boost_PYTHON_LIBRARY_RELEASE "D:/Build/boost_1_49_0/boost_python26/boost_1_49_0/stage/lib/libboost_python-vc100-mt-s-1_49.lib" CACHE FILEPATH "desc." )
-SET( Boost_THREAD "D:/Build/boost_1_49_0/boost_python26/boost_1_49_0/stage/lib/libboost_thread-vc100-mt-s-1_49.lib" CACHE FILEPATH "desc." )
-#Boost_THREAD_LIBRARY_DEBUG:FILEPATH=Boost_THREAD_LIBRARY_DEBUG-NOTFOUND
-SET( Boost_THREAD_LIBRARY_RELEASE "D:/Build/boost_1_49_0/boost_python26/boost_1_49_0/stage/lib/libboost_thread-vc100-mt-s-1_49.lib" CACHE FILEPATH "desc." )
-#PYTHON_DEBUG_LIBRARY:FILEPATH=PYTHON_DEBUG_LIBRARY-NOTFOUND
-SET( PYTHON_EXECUTABLE "D:/Build/Python26_64/python.exe" CACHE FILEPATH "desc." )
-SET( PYTHON_INCLUDE "D:/Build/Python26_64/include" CACHE FILEPATH "desc." )
-SET( PYTHON_INCLUDE_DIR "D:/Build/Python26_64/include" CACHE FILEPATH "desc." )
-SET( PYTHON_LIBRARY "D:/Build/Python26_64/libs/python26.lib" CACHE FILEPATH "desc." )
-SET( PACKAGE_INSTALL_DIRECTORY "C:\\\\Python26\\\\Lib\\\\site-packages" CACHE STRING "The path of the Python installation." )
-###########################################################################
-### end of Python 2.6
-###########################################################################
-SET( CMAKE_REQUIRED_INCLUDES ${GSL_INCLUDE};${EIGEN_INCLUDE};${Boost_INCLUDE_DIR} CACHE PATH "desc." )
\ No newline at end of file
diff -r 8b1af7363833 doc/aide.txt
--- a/doc/aide.txt	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,228 +0,0 @@
-2dcolor
-2dkhalimskize
-2dthin
-2elisp      i [b [u]] o    generation d'un dump affichable sous emacs
-2latex      i [b [u]] o    generation d'un dump formate en latex
-3dcolor     i o            colorie les points objet dans la grille de Khalimsky, selon leur type
-3dinvariants
-3disthmus   i o            destruction des isthmes 1d d'un objet dans la grille de Khalimsky
-3dkhalimskize i c o        conversion d'une image binaire 3d dans la grille de Khalimsky (c=6,26)
-3dlabel
-3drecons
-3dskelsurf
-3dthin      i n o          amincissement homotopique 3d de n etapes dans la grille de Khalimsky
-add         i1 i2 o        addition de 2 images ndg - seuil a NDG_MAX
-addconst    i1 c o         addition d'une constante a une image ndg - seuil a NDG_MAX ou NDG_MIN
-areaopening i c a o        ouverture areolaire - c=connex - a=aire
-areaselnb
-asf         i [a] b o      filtre sequentiel alterne - a=rayon min - b=rayon max
-asfr        i [a] b o      filtre sequentiel alterne par reconstruction - a=rayon min - b=rayon max
-atf
-attribute   i c r a o      calcule l'attribut 'a' des regions de type 'r' : 
-                           c=connex, r=[min|max|pla], a=[area|perim|circ|trous|excen|orien]
-autocrop    i o            extraction d'une sous-image rectangulaire minimale
-ball
-barycentre
-barycentrelab
-blob
-bmp2ppm     i o            conversion bmp vers ppm
-border      i c o          frontiere d'une image binaire - c = connex
-bouchecavites i c o        bouche les cavites 3D - c=connex (SCRIPT)
-bouchetrous i c s o        bouche les trous 2D de taille inferieure a s - c=connex (SCRIPT)
-bruite      i n a o        bruite une image - n entier positif, 0 <= a <= 1
-byte2long   i o            conversion de format byte vers long
-cadre       i o            produit une image dont seul le cadre est a 255
-catgif                     serie gifs -> animation gif
-catpgm      p b e o        serie 2D -> image 3D - p: name_prefix, b: index_begin, e: index_end, o: name_out
-ccv         i es o         carre du coefficient de variation dans un voisinage es
-changename  i o [a]        change le nom de l'image
-click2d     i [l] zoom o   specification interactive de marqueurs (2D)
-click3d     i [l] zoom o   specification interactive de marqueurs et visualisation (3D)
-close       i es x y o     fermeture numerique par un e.s. plan (SCRIPT)
-colorize    i o            genere une image couleurs a partir d'une image ndg et d'une LookUp Table
-comphisto   i n o          compression d'histogramme (n est le nombre de niveaux voulu)
-concat3d    i1 i2 o        concatenation de deux images 3D
-contours    h sh sb o      extraction de contours a partir d'un noyau hom. h et deux seuils
-convexhull  i o [o.txt]    enveloppe convexe - algorithme de Jarvis
-convol      i m o          convolution par le masque m
-convol3     i m o          convolution par le masque 3x3 m
-crestrestoration  i c n o  restauration de cretes
-crop        i x y w h o    extraction d'une sous-image rectangulaire, coord: x, y, dim: w, h
-delaunay    l g [i o]      triangulation de Delaunay 
-deriche     i a c [l] o    filtres de cany-deriche
-deriche3d   i a c [l] o    filtres de cany-deriche en 3d
-desfilsclairs3d i [m] c o  destruction topologique des fils clairs en 3D (m=mask, c=connexite des minima)
-desfilssombres3d i [m] c o destruction topologique des fils sombres en 3D (m=mask, c=connexite des minima)
-despics     i [m] c o      destruction topologique des pics (m=mask, c=connexite des minima)
-despics3d   i [m] c o      destruction topologique des pics en 3D (m=mask, c=connexite des minima)
-despuits    i [m] c o      destruction topologique des puits (m=mask, c=connexite des minima)
-despuits3d  i [m] c o      destruction topologique des puits en 3D (m=mask, c=connexite des minima)
-detectcercles
-diffimages  i1 i2 o        difference de deux images en valeur absolue (SCRIPT)
-dilat       i es x y o     dilatation numerique (es = el. struct. PLAN, x y centre)
-dilatbin    i es x y o     dilatation binaire (es = element structurant, x y centre)
-dilatbin3d  i es x y z o   dilatation binaire 3d (es = element structurant, x y centre)
-dilatfast   i es o         dilatation numerique (es = element structurant 3x3)
-dilatfast3d i es o         dilatation numerique 3d (es = element structurant 3x3x3)
-dilatnum
-dir
-directions
-dist        i d o          transformation distance (d = 0 (dist. euclidienne), 4, 8)
-distgeo     i m c o        distance geodesique - m = mask ; c = connex
-dynrecons   f g c o        reconstruction avec preservation de la dynamique des maxima 
-ecarttype   i es o         ecart-type dans un voisinage es
-egalise     i n o          egalisation d'histogramme (n est le nombre de niveaux voulu)
-ellipticite i c o          calcule un facteur d'ellipticite pour chaque composante connexe
-encadre     i g o          rajoute un cadre de valeur de gris g
-eros        i es x y o     erosion numerique (es = el. struct. PLAN, x y centre)
-erosbin     i es x y o     erosion binaire (es = element structurant, x y centre)
-erosbin3d   i es x y z o   erosion binaire 3d (es = element structurant, x y centre)
-erosfast    i es o         erosion numerique (es = element structurant 3x3)
-erosfast3d  i es o         erosion numerique 3d (es = element structurant 3x3x3)
-erosnum
-expandframe
-explode     i p            convertit une image 3d en une serie d'images 2d (p=prefixe pour les noms)
-extractplane i n d o       extrait le plan n de l'image 3d i dans la direction normale a d
-fermetrous3d i c s o       ferme les trous 3d de taille inferieure a s - c=connex
-filtreordre i es x y r o   filtre d'ordre de rang r (exprime en flottant entre 0 et 1)
-fusreg      i m mem o      fusion de plateaux a partir de plateaux marques
-filtopo     i o            filtrage topologique de bruit impulsionel  (SCRIPT)
-genbicol    g1 g2 o        genere une image a 2 niveaux g1 et g2
-genbini     o              genere une image binaire (0-255) version interactive
-genimage    rs cs ds c o   genere une image uniforme de couleur c de taille rs x cs x ds
-genplane    rs cs ds a n o genere une image taille rs x cs x ds contenant le plan a=n (a=x|y|z)
-gradill     i alpha o      introduit un gradient d'illumination - 0 < alpha <= 1
-gradinf     i o            gradient inf (8-voisinage)
-gradinf3d   i o            gradient inf volumique (26-voisinage)
-gradmorph   i e x y o      gradient morphologique - e = el. struct. d'origine x,y  (SCRIPT)
-gradsup     i o            gradient sup (8-voisinage)
-grid        i s o          surimpressionne a l'image i un grille de pas s
-hautdeforme i o            transformation "chapeau haut de forme"  (SCRIPT)
-heightmaxima i c h o       operateur hmaxima - c=connex - h=hauteur
-heightselnb
-histo       i [m] o        sauve dans o l'histogramme de i (m = masque optionnel)
-histo2      i1 i2 [m] o    histogramme bi-variable de i1 et de i2 (m = masque optionnel)
-histscal    i a A b B o    transformation multi-lineaire de l'echelle de gris [a,b] -> [A,B]
-hls2rgb     h l s o        convertit trois images h, l, s (h long, l,s byte) en une image rgb o.ppm
-hmaxima     i h o          transformation h-maxima de parametre h (SCRIPT)
-houghcercles i r p n o     detection de cercles de rayons r,r+p,...,r+np - o : resultat=image 3d
-hthin       f g c n m o    amincissement homotopique de f conditionellement a g de n iterations
-hthin3d
-hthiniso
-hthick      f g c n m o    epaississement homotopique de f conditionellement a g de n iterations
-hthick3d
-htkern      f g c o        noyau homotopique de f conditionellement a g par abaissement
-htkern3d
-htkern3dbin
-htkernu     f g c o        noyau homotopique de f conditionellement a g par elevation
-htkernu3d
-insere      a b x y z o    insere l'image a dans l'image b a la position x,y,z
-inverse     i o            complementaire a NDG_MAX
-jones
-kern
-label       i c f o        etiquetage des c-extrema (f=min,f=max) ou des c-plateaux (f=pla)
-lambdakern  i c lambda o   noyau homotopique avec parametre
-lambdalevkern i c lambda o noyau de nivellement avec parametre
-lambdasquel i c lambda o   squelette en niveaux de gris avec parametre
-levialdi
-list2pgm    il ip o        dessine les points de la liste il dans l'image ip
-long2byte   i [m] o        conversion de format long vers byte (m=0:seuil, 1:modulo, 2:scale)
-lpemeyer    i b [bf] o     ligne de partage des eaux - algo de Meyer (b: marq., bf: marq. fond)
-lpemeyer3d  i b [trace] o  ligne de partage des eaux volumique - algo de Meyer (b: marqueurs)
-lpetopo     i b [trace] o  ligne de partage des eaux topologique a partir de marqueurs (b)
-lpetoporeg  i s [trace] o  ligne de partage des eaux topologique avec regularisation (s = seuil)
-lthick
-lthin
-lvkern      f g c o        noyau de nivellement de f conditionellement a g par abaissement
-lvkernu     f g c o        noyau de nivellement de f conditionellement a g par elevation
-matchellipse
-matchrect
-max         i1 i2 o        max de 2 images ndg
-maxima      i c o          ensemble des c-maxima
-meshwarp    i ncol o       mesh warper - ncol = nb de colonnes de la grille
-min         i1 i2 o        min de 2 images ndg
-minima      i c o          ensemble des c-minima
-moments     i c <min|max>  calcule des indicateurs bases sur les moments pour chaque comp. conn.
-montecols   i c n o        restauration de lignes de cretes - c=connexite, n=nb. iterations
-moyenne     i1..iN o       moyenne des images i1..iN
-nbtopo
-nbvois
-offset      i ox oy o      decale les pixels en x et en y - image torique
-open        i es x y o     ouverture numerique par un e.s. plan (SCRIPT)
-pgm2list    i [b|n] ol     traduit en liste de points ol l'ensemble des points non nuls de i
-pgm2list1d
-pgm2pov     i m [k] op     traduit une image 3D en fichier de commande POV
-pgm2ppm     r g b o        reconstitue une image couleur a partir de 3 images ndg
-pgm2ps
-pgm2raw     i o            sauve l'image i en format raw (sans entete) sous le nom o
-pgm2slc
-point
-ppm2bmp
-ppm2pgm     i r g b        extrait les composantes r, g, b d'une image couleurs
-printhisto  i [m]          affiche l'histogramme de i (m = masque optionnel)
-profil
-proj
-proj3d      i dx dy dz o   projection d'une image 3d sur un plan (perspective cavaliere)
-propgeo     i m c f o      propagation geodesique de i dans m - connexite c - fonction f
-randimage   w h o          genere une image aleatoire (bruit blanc) de taille w X h
-randpoints  i p b h o      remplace une proportion p de pts par des valeurs aleatoires entre b et h
-randrgb     i o            remplace les niveaux de gris par des couleurs aleatoires
-raw2pgm     i rs cs ds o   ajoute un header pgm a une image "raw" 
-readgif
-reconnex    i h o          reconnexion de contours de cellules de parametre h (SCRIPT)
-recons      i m c mem o    reconstruction d'une segmentation binaire 
-reconsdilat g f es o       reconstruction par dilatation de g sous f
-reconsdilat3d  g f es o    reconstruction 3d par dilatation de g sous f
-reconseros  g f es o       reconstruction par erosion de g au dessus de f
-reconseros3d   g f es o    reconstruction 3d par erosion de g au dessus de f
-reconsplateaux
-reformat    i              transcrit le fichier image au format pgm ascii
-regul       i f o          operateur de regularisation - f = 0 : haute, 1 : basse, 2 : les deux
-relief
-remspnoise  i g k o        elimination du bruit "salt and peper"
-rgb2hls     i h l s        convertit une image i.ppm en trois images h, l, s (h long, l,s byte)
-rotate      i m o          rotations d'angles multiples de PI/2 autour des axes x,y,z
-scale       i f o          produit d' une image par un scalaire - seuil a NDG_MAX
-segbi       i c m M o      segmente i par bi-propagation a partir des min (connex c) et des max 
-segment     i c m s b o    segmente une image - c=connex - m=surf|prof|vol - s=seuil - b=min|max 
-segment3d   i c m s b o    segmente une image 3d - c=connex - m=surf|prof|vol - s=seuil - b=min|max
-segmentarea i c a o        segmentation par aire - c=connex - a=aire
-segmentheight i c h o      segmentation par hauteur - c=connex - h=hauteur
-segmentlignes i c b h o    operateur de segmentation de structures lineaires
-segmentnum  i m s o        segmente une image multiniveaux - m = surf|prof|vol - s = seuil
-segmenti    i c o          segmente une image - c=connex - version interactive
-segment3di  i c o          segmente une image 3d - c=connex - version interactive
-segmentnumi i o            segmente une image multiniveaux - version interactive
-segmentvol  i c v o        segmentation par volume - c=connex - v=volume
-selndg      i inf sup o    selectionne les ndg compris entre inf et sup inclus - resultat binaire
-selrect     i x y w h o    selectionne une portion rectangulaire d'image - le reste est mis a 0
-seltopo
-seuil       i sb sh b h o  seuillage - sb = seuil bas, sh = seuil haut, b,h: val. de remplacement
-seuilbin    i s o          seuillage - ce qui est au dessous de s est mis a 0, au dessus a NDG_MAX
-seuilhisto  i p [m] o      seuillage - p=proportion voulue de points blancs (m: masque optionnel)
-seuilhistoglobal
-seuilhistolocal
-seuilhyst   i h b o        seuillage avec hysteresis - h=seuil haut, b=seuil bas (SCRIPT)
-seuili      i o            seuillage interactif - resultat binaire
-shake       i p o          ajoute un bruit centre uniforme a i (param. p entier)
-showname    i              affiche le nom de l'image i
-skew
-squel       i s1 s2 o      squelette 2.5D - s1 = seuil ndg - s2 = seuil dist.
-squelbin    i c s o        squelette 2D - c = connex - s = seuil dist.
-stretch     i o            etirement des valeurs de gris entre NDG_MIN et NDG_MAX
-sub         i1 i2 o        difference de 2 images (i1 - i2) - seuil a NDG_MIN
-surfacerestoration
-surrect
-sym         i m o          symetrie verticale (m=v) , horizontale (m=h) ou centrale (m=c)
-topotypes   i o            types topologiques des points de l'image
-traceellipses i t [fill] o trace les ellipses decrites dans le fichier texte t, dans l'image i
-tracevect   i t o          trace les vecteurs lus dans le fichier texte t, dans l'image i
-visu3d
-volmaxima
-volselnb
-warp
-yuv2rgb     b w h [-split] convertit 3 fichiers b.Y b.U b.V, de dim. w x h, en un ppm ou 3 pgm
-zoom        i z o          zoom in (z < 1) avec moyennage
-zoomint     i z o          zoom in (z<1) ou out (z>1) d'un facteur entier |z|
-zoomintrgb  i z o          zoom in (z<1) ou out (z>1) pour image couleur ppm d'un facteur entier |z| (SCRIPT)
-zoomrgb     i z o          zoom in pour image couleur ppm (z < 1) avec moyennage (SCRIPT)
diff -r 8b1af7363833 doc/pinkdoc.html
--- a/doc/pinkdoc.html	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,36 +0,0 @@
-<html><head>
-<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
-<title>Pink</title>
-</head><body bgcolor="#ffffff">
-<center>
-<a class="qindex" href="html/index.html"><h1>Pink Documentation</h1></a> </center>
-<br>
-<br>
-
-<center>
-<IMG BORDER=0 SRC="panthererose.gif" HEIGHT=180 WIDTH=236>
-</center>
-
-<br>
-<br>
-
-<a name="warning"><h2>Avertissement</h2></a>
-<p>
-Cette bibliothèque d'opérateurs de traitement d'images a été
-      développée exclusivement à des fins d'enseignement, 
-      de recherche et d'expérimentation. Elle ne doit en aucun cas
-      être diffusée sans l'accord de: 
-<p>
-<div class="fragment"><pre>
-Michel Couprie  -  Professeur associe  -  Laboratoire A2SI
-ESIEE 2, Bd Blaise Pascal - B.P. 99
-93162 Noisy-Le-Grand CEDEX
-mail: m.couprie@esiee.fr 
-url:  http://www.esiee.fr/~coupriem
-tel:  01 45 92 66 88          fax:  01 45 92 66 99          
-</pre></div>
-</body>
-</html>
-
-
-
diff -r 8b1af7363833 general.make
--- a/general.make	Sat May 25 21:53:33 2013 +0200
+++ b/general.make	Mon Jan 13 15:50:10 2014 +0100
@@ -281,6 +281,7 @@
 $(BDIR)/skel_ACK3_pers \
 $(BDIR)/skel_AK2 \
 $(BDIR)/skel_AMK \
+$(BDIR)/skel_CK2_pers \
 $(BDIR)/skel_CK3 \
 $(BDIR)/skel_CK3a \
 $(BDIR)/skel_CK3p \
@@ -1475,7 +1476,7 @@
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/hthiniso.c $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mctopo.o $(ODIR)/lhthiniso.o $(LIBS) -o $(BDIR)/hthiniso
 
 $(BDIR)/hthinpar:	$(CDIR)/hthinpar.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/lskelpar.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mctopo.o $(ODIR)/lskelpar.o 
-	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/hthinpar.c $(OBJ_COMMON) $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar.o $(ODIR)/mclifo.o $(LIBS) -o $(BDIR)/hthinpar
+	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/hthinpar.c $(OBJ_COMMON) $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/hthinpar
 
 $(BDIR)/htkern:	$(CDIR)/htkern.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mcindic.h $(IDIR)/mcfah.h $(IDIR)/mclifo.h $(IDIR)/lhisto.h $(IDIR)/llabelextrema.h $(IDIR)/lhtkern.h $(IDIR)/lhtkern3d.h $(OBJ_COMMON) $(ODIR)/libpink.a
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/htkern.c $(OBJ_COMMON) $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/htkern
@@ -1622,7 +1623,7 @@
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_ACK3_pers.c $(OBJ_COMMON) $(ODIR)/mctopo3d.o $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar3d.o $(ODIR)/mclifo.o $(ODIR)/mcindic.o $(ODIR)/mcrlifo.o $(LIBS) -o $(BDIR)/skel_ACK3_pers
 
 $(BDIR)/skel_AK2:	$(CDIR)/skel_AK2.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/lskelpar.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mctopo.o $(ODIR)/lskelpar.o 
-	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_AK2.c $(OBJ_COMMON) $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar.o $(ODIR)/mclifo.o $(LIBS) -o $(BDIR)/skel_AK2
+	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_AK2.c $(OBJ_COMMON) $(ODIR)/libpink.a -o $(BDIR)/skel_AK2
 
 $(BDIR)/skel_AMK:	$(CDIR)/skel_AMK.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mcindic.h $(IDIR)/lskelpar3d.h $(IDIR)/ldist.h $(IDIR)/mcgeo.h $(IDIR)/lmedialaxis.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mcindic.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/lballincl.o $(ODIR)/lmedialaxis.o $(ODIR)/avsimage.o $(ODIR)/llut.o $(ODIR)/ltopotypes.o $(ODIR)/lskelpar3d.o $(ODIR)/lskelpar.o $(ODIR)/mcrlifo.o
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_AMK.c $(OBJ_COMMON) $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar.o $(ODIR)/lskelpar3d.o $(ODIR)/mcindic.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/lballincl.o $(ODIR)/lmedialaxis.o $(ODIR)/avsimage.o $(ODIR)/llut.o $(ODIR)/ltopotypes.o $(ODIR)/mcrlifo.o $(LIBS) -o $(BDIR)/skel_AMK
@@ -1642,6 +1643,9 @@
 $(BDIR)/skel_CKG:	$(CDIR)/skel_CKG.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mctopo3d.h $(IDIR)/mckhalimsky3d.h $(IDIR)/mcindic.h $(IDIR)/lskeletons.h $(IDIR)/ldist.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mckhalimsky3d.o $(ODIR)/mcindic.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/mcrlifo.o $(ODIR)/lskeletons.o $(ODIR)/bdd1.alphacube.o $(ODIR)/bdd2.alpha.o $(ODIR)/bdd2.beta.o $(ODIR)/bdd3.o 
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_CKG.c $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_CKG
 
+$(BDIR)/skel_CK2_pers:	$(CDIR)/skel_CK2_pers.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mctopo3d.h $(IDIR)/mckhalimsky3d.h $(IDIR)/mcindic.h $(IDIR)/lskeletons.h $(IDIR)/ldist.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mckhalimsky3d.o $(ODIR)/mcindic.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/mcrlifo.o $(ODIR)/lskeletons.o $(ODIR)/bdd1.alphacube.o $(ODIR)/bdd2.alpha.o $(ODIR)/bdd2.beta.o $(ODIR)/bdd3.o $(ODIR)/libpink.a
+	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_CK2_pers.c $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_CK2_pers
+
 $(BDIR)/skel_CKG_map:	$(CDIR)/skel_CKG_map.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mctopo3d.h $(IDIR)/mckhalimsky3d.h $(IDIR)/mcindic.h $(IDIR)/lskeletons.h $(IDIR)/ldist.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mckhalimsky3d.o $(ODIR)/mcindic.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/mcrlifo.o $(ODIR)/lskeletons.o $(ODIR)/bdd1.alphacube.o $(ODIR)/bdd2.alpha.o $(ODIR)/bdd2.beta.o $(ODIR)/bdd3.o 
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_CKG_map.c $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_CKG_map
 
@@ -1652,13 +1656,13 @@
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_EK3.c $(OBJ_COMMON) $(ODIR)/mctopo3d.o $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar3d.o $(ODIR)/mclifo.o $(ODIR)/mcindic.o $(ODIR)/mcrlifo.o $(LIBS) -o $(BDIR)/skel_EK3
 
 $(BDIR)/skel_MK2:	$(CDIR)/skel_MK2.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/lskelpar.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mctopo.o $(ODIR)/lskelpar.o 
-	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_MK2.c $(OBJ_COMMON) $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar.o $(ODIR)/mclifo.o $(LIBS) -o $(BDIR)/skel_MK2
+	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_MK2.c $(OBJ_COMMON) $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_MK2
 
 $(BDIR)/skel_MK3:	$(CDIR)/skel_MK3.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/lskelpar3d.h $(IDIR)/mctopo3d.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mctopo3d.o $(ODIR)/mctopo.o $(ODIR)/lskelpar3d.o $(ODIR)/mcindic.o $(ODIR)/mcrlifo.o 
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_MK3.c $(OBJ_COMMON) $(ODIR)/mctopo3d.o $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar3d.o $(ODIR)/mclifo.o $(ODIR)/mcindic.o $(ODIR)/mcrlifo.o $(LIBS) -o $(BDIR)/skel_MK3
 
 $(BDIR)/skel_NK2:	$(CDIR)/skel_NK2.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/lskelpar.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mctopo.o $(ODIR)/lskelpar.o 
-	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_NK2.c $(OBJ_COMMON) $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar.o $(ODIR)/mclifo.o $(LIBS) -o $(BDIR)/skel_NK2
+	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_NK2.c $(OBJ_COMMON) $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_NK2
 
 $(BDIR)/skel_PSG:	$(CDIR)/skel_PSG.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mctopo3d.h $(IDIR)/mckhalimsky3d.h $(IDIR)/mcindic.h $(IDIR)/lskeletons.h $(IDIR)/ldist.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mckhalimsky3d.o $(ODIR)/mcindic.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/mcrlifo.o $(ODIR)/lskeletons.o $(ODIR)/bdd1.alphacube.o $(ODIR)/bdd2.alpha.o $(ODIR)/bdd2.beta.o $(ODIR)/bdd3.o 
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_PSG.c $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_PSG
diff -r 8b1af7363833 include/jclderiche.h
--- a/include/jclderiche.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/jclderiche.h	Mon Jan 13 15:50:10 2014 +0100
@@ -39,14 +39,14 @@
 /* prototype for lderiche.c */
 /* ============== */
 
-extern int32_t jclderiche_lderiche(
+extern int32_t lderiche(
         struct xvimage *image1,
         double alpha,
         int32_t function,
         double l
 );
 
-extern void jclderiche_derichegen(double *x,               /* image a traiter */
+extern void derichegen(double *x,               /* image a traiter */
                 int32_t M,                   /* taille ligne */
                 int32_t N,                   /* taille colonne */
                 double *y1,              /* zone temporaire de la taille d'une colonne */
diff -r 8b1af7363833 include/lbdigitalline.h
--- a/include/lbdigitalline.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lbdigitalline.h	Mon Jan 13 15:50:10 2014 +0100
@@ -13,6 +13,10 @@
              
 typedef int32_t Z;
 
+//int abs(int u)        { if ( u >= 0 ) return u; else  return -u; }
+static int max(int a, int b) { if ( a > b  ) return a; else  return  b; }
+static int min(int a, int b) { if ( a < b  ) return a; else  return  b; }
+
 class Q
 {
   public :
diff -r 8b1af7363833 include/lcrop.h
--- a/include/lcrop.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lcrop.h	Mon Jan 13 15:50:10 2014 +0100
@@ -29,22 +29,17 @@
 data to be ensured and,  more generally, to use and operate it in the 
 same conditions as regards security. 
 
-The fact that y#ifdef NOT_USED_TO_BE_REMOVED
-ou are presently reading this means that you have had
+The fact that you are presently reading this means that you have had
 knowledge of the CeCILL license and that you accept its terms.
 */
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#ifdef NOT_USED_TO_BE_REMOVED
-    /* same for python */
-    int lpycrop(struct xvimage *in, struct xvimage *out, int32_t x, int32_t y,int32_t w, int32_t h);
-#endif
-
 extern struct xvimage * lcrop(struct xvimage *in, int32_t x, int32_t y, int32_t w, int32_t h);
 extern struct xvimage * lcrop3d(struct xvimage *in, int32_t x, int32_t y, int32_t z, int32_t w, int32_t h, int32_t d);
 extern struct xvimage * lautocrop(struct xvimage *in, double seuil);
+extern void lautocrop2(struct xvimage *in, double seuil, index_t *Xmin, index_t *Ymin, index_t *Zmin, index_t *w, index_t *h, index_t *p);
 extern void lsetframe(struct xvimage *image, int32_t grayval);
 extern void lsetthickframe(struct xvimage *image, int32_t width, int32_t grayval);
 extern struct xvimage * lenframe(struct xvimage *image, int32_t grayval, int32_t width);
diff -r 8b1af7363833 include/lderiche.h
--- a/include/lderiche.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lderiche.h	Mon Jan 13 15:50:10 2014 +0100
@@ -39,7 +39,7 @@
 /* prototype for lderiche.c */
 /* ============== */
 
-extern void lderiche_derichegen(double *x,
+extern void derichegen(double *x,
 		       int32_t M,
 		       int32_t N,
 		       double *y1,
@@ -49,7 +49,7 @@
 		       double a5, double a6, double a7, double a8, 
 		       double b1, double b2, double b3, double b4);
 
-extern int32_t lderiche_lderiche(
+extern int32_t lderiche(
         struct xvimage *image1,
         double alpha,
         int32_t function,
@@ -65,7 +65,7 @@
         double l
 );
 
-    extern int32_t lderiche_llisseurrec3d(
+extern int32_t llisseurrec3d(
         struct xvimage *image1,
         double alpha
 );
diff -r 8b1af7363833 include/lderiche3d.h
--- a/include/lderiche3d.h	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-/* $Id: lderiche3d.h,v 1.1.1.1 2008-11-25 08:02:37 mcouprie Exp $ */
-/* ============== */
-/* prototype for lderiche3d.c */
-/* ============== */
-
-extern int32_t lderiche3d_lderiche3d(
-        struct xvimage *image1,
-        double alpha,
-        int32_t function,
-        double l
-);
-
-extern int32_t lderiche3d_llisseurrec3d(
-        struct xvimage *image1,
-        double alpha
-);
-
diff -r 8b1af7363833 include/ldilatbin3d.h
--- a/include/ldilatbin3d.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/ldilatbin3d.h	Mon Jan 13 15:50:10 2014 +0100
@@ -39,7 +39,7 @@
 /* prototype for ldilatbin3d.c */
 /* ============== */
 
-extern int32_t ldilatbin3d_ldilatbin3d(
+extern int32_t ldilatbin3d(
         struct xvimage *f,
         struct xvimage *m,
         int32_t x,
diff -r 8b1af7363833 include/ldilateros3d.h
--- a/include/ldilateros3d.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/ldilateros3d.h	Mon Jan 13 15:50:10 2014 +0100
@@ -35,7 +35,7 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
-extern int32_t ldilateros3d_ldilatbin3d(struct xvimage *f, struct xvimage *m, int32_t xc, int32_t yc, int32_t zc);
+extern int32_t ldilatbin3d(struct xvimage *f, struct xvimage *m, int32_t xc, int32_t yc, int32_t zc);
 extern int32_t ldilatbin3d2(struct xvimage *f, int32_t nptb, int32_t *tab_es_x, int32_t *tab_es_y, int32_t *tab_es_z, 
 			int32_t xc, int32_t yc, int32_t zc);
 extern int32_t ldilateros3d_lerosbin3d(struct xvimage *f, struct xvimage *m, int32_t xc, int32_t yc, int32_t zc);
diff -r 8b1af7363833 include/lgeodesic.h
--- a/include/lgeodesic.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lgeodesic.h	Mon Jan 13 15:50:10 2014 +0100
@@ -41,8 +41,5 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
-extern int32_t lgeodilat(
-        struct xvimage *g,
-        struct xvimage *f,
-        int32_t connex,
-        int32_t niter) ;
+extern int32_t lgeodilat(struct xvimage *g, struct xvimage *f, int32_t connex, int32_t niter) ;
+extern int32_t lgeodilat2d(struct xvimage *g, struct xvimage *f, int32_t connex, int32_t niter) ;
@@ -49,0 +46,5 @@
+extern int32_t lgeodilat2d_short(struct xvimage *g, struct xvimage *f, int32_t connex, int32_t niter) ;
+extern int32_t lgeodilat2d_long(struct xvimage *g, struct xvimage *f, int32_t connex, int32_t niter) ;
+extern int32_t lgeodilat3d(struct xvimage *g, struct xvimage *f, int32_t connex, int32_t niter) ;
+extern int32_t lgeodilat3d_short(struct xvimage *g, struct xvimage *f, int32_t connex, int32_t niter) ;
+extern int32_t lgeodilat3d_long(struct xvimage *g, struct xvimage *f, int32_t connex, int32_t niter) ;
@@ -49,5 +51,5 @@
 
-extern int32_t lgeodesic_lreconsdilat(
+extern int32_t lreconsdilat(
         struct xvimage *g,
         struct xvimage *f,
         int32_t connex) ;
@@ -70,13 +72,7 @@
         int32_t y, 
         int32_t z) ;
 
-extern int32_t lgeodilat3d(
-        struct xvimage *g,
-        struct xvimage *f,
-        int32_t connex,
-        int32_t niter) ;
-
-extern int32_t lgeodesic_lreconsdilat3d(
+extern int32_t lreconsdilat3d(
         struct xvimage *g,
         struct xvimage *f,
         int32_t connex) ;
@@ -87,7 +83,7 @@
         int32_t connex,
         int32_t niter) ;
 
-extern int32_t lgeodesic_lreconseros3d(
+extern int32_t lreconseros3d(
         struct xvimage *g,
         struct xvimage *f,
         int32_t connex) ;
diff -r 8b1af7363833 include/lhtkern.h
--- a/include/lhtkern.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lhtkern.h	Mon Jan 13 15:50:10 2014 +0100
@@ -51,7 +51,7 @@
         int32_t connex
 );
 
-extern int32_t lhtkern_lhtkernu(
+extern int32_t lhtkernu(
         struct xvimage *image,
         struct xvimage *imagecond,
         int32_t connex
diff -r 8b1af7363833 include/lhtkernu.h
--- a/include/lhtkernu.h	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,10 +0,0 @@
-/* $Id: lhtkernu.h,v 1.1.1.1 2008-11-25 08:02:37 mcouprie Exp $ */
-/* ============== */
-/* prototype for lhtkernu.c */
-/* ============== */
-
-extern int32_t lhtkernu_lhtkernu(
-        struct xvimage *image,
-        int32_t nitermax,
-        int32_t connex
-);
diff -r 8b1af7363833 include/llpemeyer.h
--- a/include/llpemeyer.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/llpemeyer.h	Mon Jan 13 15:50:10 2014 +0100
@@ -43,7 +43,7 @@
 /* prototype for llpemeyer.c */
 /* ============== */
 
-extern int32_t llpemeyer_llpemeyer(
+extern int32_t llpemeyer(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
@@ -51,7 +51,7 @@
         int32_t connex
 );
 
-extern int32_t llpemeyer_llpemeyersansligne(
+extern int32_t llpemeyersansligne(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
@@ -60,14 +60,14 @@
         struct xvimage *result	
 );
 
-extern int32_t llpemeyer_llpemeyersanslignelab(
+extern int32_t llpemeyersanslignelab(
         struct xvimage *image,
         struct xvimage *marqueurs, // entree-sortie
         struct xvimage *masque,
         int32_t connex
 );
 
-extern int32_t llpemeyer_llpemeyer2(
+extern int32_t llpemeyer2(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *masque,
@@ -100,7 +100,7 @@
         int32_t connex
 );
 
-extern int32_t llpemeyer_llpemeyer3d(
+extern int32_t llpemeyer3d(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
@@ -108,7 +108,7 @@
         int32_t connex
 );
 
-extern int32_t llpemeyer_llpemeyer3dsansligne(
+extern int32_t llpemeyer3dsansligne(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
@@ -124,14 +124,14 @@
         int32_t connex
 );
 
-extern int32_t llpemeyer_llpemeyer3d2(
+extern int32_t llpemeyer3d2(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *masque,
         int32_t connex
 );
 
-extern int32_t llpemeyer_llpemeyer3d2b(
+extern int32_t llpemeyer3d2b(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *masque,
@@ -144,21 +144,21 @@
         int32_t connex
 );
 
-extern int32_t llpemeyer_llpemeyerkhalimsky(
+extern int32_t llpemeyerkhalimsky(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
         struct xvimage *masque
 );
 
-extern int32_t llpemeyer_llpemeyerbiconnecte(
+extern int32_t llpemeyerbiconnecte(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
         struct xvimage *masque,
         int32_t parite);
 
-int32_t llpemeyer_llpemeyerbiconnecte3d(
+int32_t llpemeyerbiconnecte3d(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
diff -r 8b1af7363833 include/llpemeyer3d.h
--- a/include/llpemeyer3d.h	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,11 +0,0 @@
-/* $Id: llpemeyer3d.h,v 1.1.1.1 2008-11-25 08:02:37 mcouprie Exp $ */
-/* ============== */
-/* prototype for llpemeyer3d.c */
-/* ============== */
-
-extern int32_t llpemeyer3d_llpemeyer3d(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        int32_t trace
-);
-
diff -r 8b1af7363833 include/llpemeyer_regular.h
--- a/include/llpemeyer_regular.h	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,72 +0,0 @@
-/* $Id: llpemeyer_regular.h,v 1.1.1.1 2008-11-25 08:02:37 mcouprie Exp $ */
-/* ============== */
-/* prototype for llpemeyer.c */
-/* ============== */
-
-extern int32_t llpemeyer_regular_llpemeyer(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque,
-        int32_t connex
-);
-
-extern int32_t llpemeyer_regular_llpemeyersansligne(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque,
-        int32_t connex,
-        struct xvimage *result	
-);
-
-extern int32_t llpemeyer_regular_llpemeyer2(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *masque,
-        int32_t connex
-);
-
-extern int32_t llpemeyer_regular_llpemeyer3d(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque,
-        int32_t connex
-);
-
-extern int32_t llpemeyer_regular_llpemeyer3dsansligne(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque,
-        int32_t connex,
-        struct xvimage *result	
-);
-
-extern int32_t llpemeyer_regular_llpemeyer3d2(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *masque,
-        int32_t connex
-);
-
-extern int32_t llpemeyer_regular_llpemeyerkhalimsky(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque
-);
-
-extern int32_t llpemeyer_regular_llpemeyerbiconnecte(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque,
-        int32_t parite);
-
-int32_t llpemeyer_regular_llpemeyerbiconnecte3d(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque);
diff -r 8b1af7363833 include/llvkern.h
--- a/include/llvkern.h	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,11 +0,0 @@
-/* $Id: llvkern.h,v 1.1.1.1 2008-11-25 08:02:37 mcouprie Exp $ */
-/* ============== */
-/* prototype for llvkern.c */
-/* ============== */
-
-extern int32_t llvkern(
-        struct xvimage *image,
-        int32_t nitermax,
-        int32_t connex
-);
-
diff -r 8b1af7363833 include/lmedialaxis.h
--- a/include/lmedialaxis.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lmedialaxis.h	Mon Jan 13 15:50:10 2014 +0100
@@ -32,9 +32,6 @@
 The fact that you are presently reading this means that you have had
 knowledge of the CeCILL license and that you accept its terms.
 */
-
-#include "mcimage.h"
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -60,7 +57,7 @@
 typedef int32_t * Tabuff;
 typedef int32_t * TabDTg;
 
-typedef struct Weighting{
+typedef struct  Weighting{
     int32_t x, y, z, RR;
 }  Weighting;
 
diff -r 8b1af7363833 include/lmeshwarp.h
--- a/include/lmeshwarp.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lmeshwarp.h	Mon Jan 13 15:50:10 2014 +0100
@@ -39,7 +39,7 @@
 /* prototype for lmeshwarp.c */
 /* ============== */
 
-extern int32_t lmeshwarp_lmeshwarp(
+extern int32_t lmeshwarp(
   struct xvimage * in,
   int32_t mrs
 );
diff -r 8b1af7363833 include/lreconsdilat.h
--- a/include/lreconsdilat.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lreconsdilat.h	Mon Jan 13 15:50:10 2014 +0100
@@ -35,7 +35,7 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
-extern int32_t lreconsdilat_lreconsdilat(
+extern int32_t lreconsdilat(
         struct xvimage *g,
         struct xvimage *f,
         uint8_t *mask
diff -r 8b1af7363833 include/lreconsdilat3d.h
--- a/include/lreconsdilat3d.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lreconsdilat3d.h	Mon Jan 13 15:50:10 2014 +0100
@@ -40,7 +40,7 @@
 /* ============== */
 
 
-extern int32_t lreconsdilat3d_lreconsdilat3d(
+extern int32_t lreconsdilat3d(
         struct xvimage *g,
         struct xvimage *f,
         uint8_t *mask
diff -r 8b1af7363833 include/lreconseros.h
--- a/include/lreconseros.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lreconseros.h	Mon Jan 13 15:50:10 2014 +0100
@@ -39,7 +39,7 @@
 /* prototype for lreconseros.c */
 /* ============== */
 
-extern int32_t lreconseros_lreconseros(
+extern int32_t lreconseros(
         struct xvimage *g,
         struct xvimage *f,
         uint8_t *mask
diff -r 8b1af7363833 include/lreconseros3d.h
--- a/include/lreconseros3d.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lreconseros3d.h	Mon Jan 13 15:50:10 2014 +0100
@@ -40,7 +40,7 @@
 /* ============== */
 
 
-extern int32_t lreconseros3d_lreconseros3d(
+extern int32_t lreconseros3d(
         struct xvimage *g,
         struct xvimage *f,
         uint8_t *mask
diff -r 8b1af7363833 include/lsalembier.h
--- a/include/lsalembier.h	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,15 +0,0 @@
-/* $Id: lsalembier.h,v 1.1.1.1 2008-11-25 08:02:37 mcouprie Exp $ */
-extern int32_t lsegreconsheight(struct xvimage *image, int32_t connex, int32_t param);
-extern int32_t lsegmentheight(struct xvimage *image, int32_t connex, int32_t param, int32_t max);
-extern int32_t lsegmentarea(struct xvimage *image, int32_t connex, int32_t param, int32_t max);
-extern int32_t lsegmentvol(struct xvimage *image, int32_t connex, int32_t param, int32_t max);
-extern int32_t lareaopening(struct xvimage *image, int32_t connex, int32_t param);
-extern int32_t lareaclosing(struct xvimage *image, int32_t connex, int32_t param);
-extern int32_t lheightmaxima(struct xvimage *image, int32_t connex, int32_t param);
-extern int32_t lheightselnb(struct xvimage *image, int32_t connex, int32_t param, int32_t mode);
-extern int32_t lareaselnb(struct xvimage *image, int32_t connex, int32_t param);
-extern int32_t lvolselnb(struct xvimage *image, int32_t connex, int32_t param);
-extern int32_t lvolmaxima(struct xvimage *image, int32_t connex, int32_t param);
-extern int32_t ldynamique(struct xvimage *image, int32_t connex);
-extern int32_t lwshedval(struct xvimage *image, int32_t connex);
-extern int32_t lwshedtopo(struct xvimage *image, int32_t connex);
diff -r 8b1af7363833 include/lskelpar.h
--- a/include/lskelpar.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lskelpar.h	Mon Jan 13 15:50:10 2014 +0100
@@ -119,17 +119,12 @@
 extern int32_t lskelrosenfeld(struct xvimage *image,
 			      int32_t nsteps,
 			      struct xvimage *inhibit);
-
-int32_t is_hall_2dendpoint(struct xvimage* img, uint32_t x, uint32_t rs, uint32_t N, uint32_t type);
-
-int32_t is_self_deletable(struct xvimage *img, uint32_t x, uint32_t rs, uint32_t N, uint32_t type);
-
-int32_t is_double_deletable(struct xvimage *img, uint32_t x, uint32_t rs, uint32_t N, uint32_t type);
-
-int32_t is_surrounded_by_radius2_ring(struct xvimage *img, uint32_t x, uint32_t rs, uint32_t N);
-
-int32_t is_square_deletable(struct xvimage *img, uint32_t x, uint32_t rs, uint32_t N, uint32_t type);
-
+extern int32_t lskelrosenfeld_var1(struct xvimage *image,
+			           int32_t nsteps,
+			           struct xvimage *inhibit);
+extern int32_t lskelrosenfeld_var2(struct xvimage *image,
+			           int32_t nsteps,
+			           struct xvimage *inhibit);
 extern int32_t lskelnemethpalagyi(struct xvimage *image,
 					int32_t nsteps,
 					struct xvimage *inhibit,
@@ -139,6 +134,8 @@
 extern int32_t lskelCK2(struct xvimage *image,
 			int32_t nsteps,
 			struct xvimage *inhibit);
+extern int32_t lskelCK2_pers(struct xvimage *image, 
+			     struct xvimage *persistence);
 #ifdef __cplusplus
 }
 #endif
diff -r 8b1af7363833 include/lwshedtopo.h
--- a/include/lwshedtopo.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lwshedtopo.h	Mon Jan 13 15:50:10 2014 +0100
@@ -42,7 +42,7 @@
 #endif
 extern int32_t lwshedtopo_lwshedtopo(struct xvimage *image, int32_t connex);
 extern int32_t lreconsdilat(struct xvimage *g, struct xvimage *f, int32_t connex);
-extern int32_t lwshedtopo_lreconseros(struct xvimage *g, struct xvimage *f, int32_t connex);
+extern int32_t lreconseros(struct xvimage *g, struct xvimage *f, int32_t connex);
 extern int32_t lwshedtopobin(struct xvimage *image, struct xvimage *marqueur, int32_t connex);
 #ifdef __cplusplus
 }
diff -r 8b1af7363833 include/lzoom.h
--- a/include/lzoom.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/lzoom.h	Mon Jan 13 15:50:10 2014 +0100
@@ -45,20 +45,13 @@
 /* ============== */
 /* prototype for lzoom.c */
 /* ============== */
-    
-    int32_t lzoom(
-        struct xvimage * in,
-        struct xvimage ** out,
-        double zoomx, double zoomy, double zoomz
-        );
-    
-    int32_t lresize_lzoom(
-        struct xvimage * in,
-        struct xvimage ** out,
-        double z );
-    
 
-    
+extern int32_t lzoom(
+  struct xvimage * in,
+  struct xvimage ** out,
+  double zoomx, double zoomy, double zoomz
+);
+
 extern int32_t lzoom2(
   struct xvimage * in,
   struct xvimage ** out,
diff -r 8b1af7363833 include/mcfahdouble.h
--- a/include/mcfahdouble.h	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,76 +0,0 @@
-/* $Id: mcfahdouble.h,v 1.1.1.1 2008-11-25 08:02:37 mcouprie Exp $ */
-
-typedef struct FAHDELT {
-  int32_t Point1;
-  int32_t Point2;
-  struct FAHDELT * Next;
-} FahdElt;
-
-#define NPRIO 256
-
-typedef struct {
-  int32_t Max;             /* taille max de la fahd (en nombre de points) */
-  int32_t Niv;             /* niveau a partir duquel des listes existent */
-  int32_t Util;            /* nombre de points courant dans la fahd */
-  int32_t Maxutil;         /* nombre de points utilises max */
-  FahdElt *Tete[NPRIO]; /* tableau des tetes de liste (la ou l'on insere) */
-  FahdElt *Queue;       /* queue de liste (la ou l'on preleve) */
-  FahdElt *Libre;       /* pile des cellules libres */
-  FahdElt Elts[1];      /* tableau des elements physiques */
-} Fahd;
-
-/* ============== */
-/* prototypes     */
-/* ============== */
-
-extern Fahd * CreeFahdVide(
-  int32_t taillemax
-);
-
-extern void FahdFlush(
-  Fahd * L
-);
-
-extern int32_t FahdVide(
-  Fahd * L
-);
-
-extern int32_t FahdVideUrg(
-  Fahd * L
-);
-
-extern int32_t FahdVideNiveau(
-  Fahd * L,
-  int32_t niv
-);
-
-extern int32_t FahdNiveau(
-  Fahd * L
-);
-
-extern void FahdPop(
-  Fahd * L,
-  int32_t *P1,
-  int32_t *P2
-);
-
-extern void FahdFirst(
-  Fahd * L,
-  int32_t *P1,
-  int32_t *P2
-);
-
-extern void FahdPush(
-  Fahd * L,
-  int32_t P1,
-  int32_t P2,
-  int32_t Ni
-);
-
-extern void FahdTermine(
-  Fahd * L
-);
-
-extern void FahdPrint(
-  Fahd * L
-);
diff -r 8b1af7363833 include/mcrbt.h
--- a/include/mcrbt.h	Sat May 25 21:53:33 2013 +0200
+++ b/include/mcrbt.h	Mon Jan 13 15:50:10 2014 +0100
@@ -72,8 +72,8 @@
 extern Rbt * mcrbt_CreeRbtVide(
   index_t taillemax);
 
-// extern void RbtFlush(
-//   Rbt * T);
+extern void RbtFlush(
+  Rbt * T);
 
 extern int32_t mcrbt_RbtVide(
   Rbt * T);
@@ -81,6 +81,6 @@
 extern void mcrbt_RbtTermine(
   Rbt * T);
 
-// extern void RbtPrint(
-//   Rbt * T);
+extern void RbtPrint(
+  Rbt * T);
 
@@ -87,2 +87,2 @@
-extern RbtElt * mcrbt_RbtSearch(
+extern RbtElt * RbtSearch(
   Rbt * T, TypRbtKey k);
@@ -89,9 +89,9 @@
 
 extern RbtElt * mcrbt_RbtMinimum(
   Rbt * T, RbtElt * x);
 
-// extern RbtElt * RbtMaximum(
-//   Rbt * T, RbtElt * x);
+extern RbtElt * RbtMaximum(
+  Rbt * T, RbtElt * x);
 
 extern RbtElt * RbtSuccessor(
   Rbt * T, RbtElt * x);
@@ -102,13 +102,13 @@
 extern void RbtDelete(
   Rbt * T, RbtElt * z);
 
-extern TypRbtAuxData mcrbt_RbtPopMin(
+extern TypRbtAuxData RbtPopMin(
   Rbt * T);
 
-// extern TypRbtAuxData RbtPopMax(
-//   Rbt * T);
+extern TypRbtAuxData RbtPopMax(
+  Rbt * T);
 
-extern TypRbtKey mcrbt_RbtMinLevel(
+extern TypRbtKey RbtMinLevel(
   Rbt * T);
 
 extern TypRbtKey RbtMaxLevel(
diff -r 8b1af7363833 include/mcrbt1.h
--- a/include/mcrbt1.h	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,80 +0,0 @@
-/* $Id: mcrbt1.h,v 1.1.1.1 2008-11-25 08:02:37 mcouprie Exp $ */
-#define RBT_Black 0
-#define RBT_Red   1
-
-typedef struct {
-  double x;
-  double y;
-  double z;
-} TypRbtKey;
-typedef int32_t TypRbtAuxData;
-
-#define EQUALKEY(j,k) ((j.x==k.x)&&(j.y==k.y)&&(j.z==k.z))
-#define LESSKEY(j,k) ((j.x<k.x) || ((j.x==k.x)&&(j.y<k.y)) || ((j.x==k.x)&&(j.y==k.y)&&(j.z<k.z)))
-#define COPYKEY(j,k) {j.x=k.x;j.y=k.y;j.z=k.z;}
-#define PRINTKEY(j) printf("%g %g %g",j.x,j.y,j.z)
-
-typedef struct RBTELT {
-  TypRbtAuxData auxdata;
-  TypRbtKey key;
-  char color;
-  struct RBTELT * left;
-  struct RBTELT * right;
-  struct RBTELT * parent;
-} RbtElt;
-
-typedef struct {
-  int32_t max;             /* taille max du rbt (en nombre de points) */
-  int32_t util;            /* nombre de points courant dans le rbt */
-  int32_t maxutil;         /* nombre de points utilises max (au cours du temps) */
-  RbtElt *root;        /* racine de l'arbre */
-  RbtElt *nil;         /* sentinelle et element dont l'adresse joue le role de NIL */
-  RbtElt *libre;       /* pile des cellules libres */
-  RbtElt elts[1];      /* tableau des elements physiques */
-} Rbt;
-
-/* ============== */
-/* prototypes     */
-/* ============== */
-
-extern Rbt * CreeRbtVide(
-  int32_t taillemax);
-
-// extern void RbtFlush(
-//   Rbt * T);
-
-extern int32_t RbtVide(
-  Rbt * T);
-
-extern void RbtTermine(
-  Rbt * T);
-
-// extern void RbtPrint(
-//   Rbt * T);
-
-extern RbtElt * mcrbt1_RbtSearch(
-  Rbt * T, TypRbtKey k);
-
-extern RbtElt * RbtMinimum(
-  Rbt * T, RbtElt * x);
-
-// extern RbtElt * RbtMaximum(
-//   Rbt * T, RbtElt * x);
-
-extern RbtElt * RbtSuccessor(
-  Rbt * T, RbtElt * x);
-
-extern RbtElt * RbtInsert(
-  Rbt ** T, TypRbtKey k, TypRbtAuxData d);
-
-extern void RbtDelete(
-  Rbt * T, RbtElt * z);
-
-extern TypRbtAuxData mcrbt1_RbtPopMin(
-  Rbt * T);
-
-// extern TypRbtAuxData RbtPopMax(
-//   Rbt * T);
-
-extern TypRbtKey mcrbt1_RbtMinLevel(
-  Rbt * T);
diff -r 8b1af7363833 include/mcscn.h
--- a/include/mcscn.h	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,22 +0,0 @@
-#define TYP_OBJ_LINE         0
-#define TYP_OBJ_CLOSEDLINE   1
-#define TYP_OBJ_SPLINE       2
-#define TYP_OBJ_CLOSEDSPLINE 3
-#define TYP_OBJ_POLYGON      4
-
-#include "stdint.h"
-
-typedef struct {
-  double x, y, z;
-} point3;
-
-typedef struct {
-  int32_t typ_obj;
-  int32_t npoints;
-  point3 * points;
-} scene_obj;
-
-typedef struct {
-  int32_t nobj;
-  scene_obj *objs;
-} scene3d;
diff -r 8b1af7363833 include/python_doc.h
--- a/include/python_doc.h	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,12868 +0,0 @@
-// This file has been generated automatically by the 
-// python_documenter, part of the PInK package (UjoImro, 2011)
-// the date of generation: 2013-05-25T21:40:40Z
-// warning: DO NOT EDIT. All your changes will be lost at 
-// the next generation
-
-#ifndef PINK__PYTHON__DOCUMENTER__HPP__
-#define PINK__PYTHON__DOCUMENTER__HPP__
-#define doc__hthin3d___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__ellipticite__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__levialdi__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__hthiniso__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__float2long__c__ "  float2long.c\n"         \
-"\n"         \
-" converts a \"float\" image to a \"int32_t\" image\n"         \
-"\n"         \
-"Usage: float2long in.pgm offset factor out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Applies the following tranformation to each value x in  in.pgm :\n"         \
-"\n"         \
-"X = round(offset + factor * x)\n"         \
-"\n"         \
-"Types supported: float 2d, float 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgm2GA4d__c__ "  pgm2GA4d.c\n"         \
-"\n"         \
-" Create a 4D edge-weighted graph from a series of 3D images\n"         \
-"\n"         \
-"\n"         \
-"Usage: pgm2GA4d prefix_in first last mode GA4d_out.ga\n"         \
-"\n"         \
-"Description: Create a 4D GA (edge-weighted graph) from the 4D\n"         \
-"image obtained by concatenation of the series of 3D images \n"         \
-"prefix_inxxxx.pgm | xxxx is a four digit decimal integer of the\n"         \
-"interval [ first , last]  . The values of the edges\n"         \
-"are computed according to the parameter mode. If mode is\n"         \
-"set to 0, then the value of an edge { x,y } is the absolute diference\n"         \
-"of intensity between the pixels x and y and if mode is set to 1\n"         \
-"the maximum of intensity between x and y is used. The output\n"         \
-"GA4d_out.ga is a 4D GA, that is a 4D, 8-connected,\n"         \
-"edge-weighted grah, (i.e. the adjacency is the direct adjacency in\n"         \
-"dimension 4).\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, byte 4d\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Jean Cousty - janvier 2006\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawtorus__c__ "  drawtorus.c\n"         \
-"\n"         \
-" generates a binary torus\n"         \
-"\n"         \
-"Usage: drawtorus {in.pgm|null} r1 r2 xc yc zc out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws a binary torus in the image  in.pgm.\n"         \
-"The parameters r1, r2 specify respectively the big \n"         \
-"and the small radius of the torus. \n"         \
-"The parameters xc, yc, zc specify the center of the torus. \n"         \
-"If the first parameter is \"null\", then an image with the\n"         \
-"appropriate size is created.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: draw\n"         \
-"  draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__GA2tikz__c__ "  GA2tikz.c\n"         \
-"\n"         \
-" converts from GA to latex for illustrating small image configurations\n"         \
-"\n"         \
-"Usage: GA2tikz in.ga [b] out.tikz\n"         \
-"\n"         \
-"Description:\n"         \
-"Produces a LaTeX file from a binary or grayscale GA image.\n"         \
-"If b is present, the result is binary otherwise the edges are greyscale colored.\n"         \
-"\n"         \
-"The result should be compiled with pdflatex to produce a pdf file.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Laurent Najman\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__click3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__drawcurve__c__ "  drawcurve.c\n"         \
-"\n"         \
-" draw line segments which are specified by a text file\n"         \
-"\n"         \
-"Usage: drawline in.pgm curve.txt out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The file  curve.txt contains a list of points under the format:\n"         \
-"c nb_points\n"         \
-"x1 y1\n"         \
-"x2 y2\n"         \
-"x3 y3\n"         \
-"...\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: draw\n"         \
-" draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__signal2pgm___notused_c__ "  signal2pgm.c\n"         \
-"\n"         \
-" converts from signal representation to pgm\n"         \
-"\n"         \
-"Usage: signal2pgm in.list [scale] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Reads the file in.list. This file must have one of the following formats:\n"         \
-"  \n"         \
-"    s &lt;n&gt; \n"         \
-"    x1 y1 \n"         \
-"    x2 y2 \n"         \
-"    ...   \n"         \
-"    xn yn \n"         \
-"\n"         \
-"\n"         \
-"The optional parameter  scale allows to scale the y coordinates.\n"         \
-"\n"         \
-"Types supported: signal 1D\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__medialaxis__c__ "  medialaxis.c\n"         \
-"\n"         \
-" medial axis transform\n"         \
-"\n"         \
-"Usage: medialaxis in.pgm distance out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Medial axis of the binary image  X. If x is the center of a maximal ball\n"         \
-"included in X, then the result R(x) is equal to the smallest distance between x \n"         \
-"and a point outside X, otherwise it is equal to 0 .\n"         \
-"The distance is indicated by the parameter distance :\n"         \
-" 0: approximate euclidean distance (Meyer's algorithm)\n"         \
-" 1: exact quadratic euclidean distance (Saito-Toriwaki's skeleton)\n"         \
-" 2: exact quadratic euclidean distance (Coeurjolly's reduced axis)\n"         \
-" 3: exact quadratic euclidean distance (Rémy-Thiel)\n"         \
-" 4: 4-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__catpgm__c__ "  catpgm.c\n"         \
-"\n"         \
-" catenates a sequence of 2d (resp. 1d) images into a 3d (resp. 2d) image\n"         \
-"\n"         \
-"Usage: catpgm name_prefix index_begin index_end [xdim ydim zdim] name_out\n"         \
-"\n"         \
-"Description:\n"         \
-"Original file names must be of the form: name_prefixnnnn.pgm, \n"         \
-"where nnnn is a four digit decimal integer. The integers index_begin\n"         \
-"and index_end specify respectively the first and the last index of the series.\n"         \
-"\n"         \
-"Types supported: sequence of byte 1d or 2d images\n"         \
-"\n"         \
-"Category:  convert\n"         \
-"   convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__crestheight__c__ "  crestheight.c\n"         \
-"\n"         \
-" measures the height of crests in a thinned grayscale image\n"         \
-"\n"         \
-"Usage: crestheight skel.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let F be the input image (parameter skel.pgm), and\n"         \
-"let R be the output image (parameter out.pgm).\n"         \
-"For each point p which is separating for F (connexity\n"         \
-"given by the parameter connex), the output value R(p) is\n"         \
-"equal to calpha8m(F,S,p).\n"         \
-"\n"         \
-"References: \n"         \
-"\"Topological operators for the detection of\n"         \
-"curvilinar structures in grayscale images\", in preparation, 2003.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__crop__c__ "  crop.c\n"         \
-"\n"         \
-" extracts a rectangular (cuboidal in 3d) area from an image\n"         \
-"\n"         \
-"Usage: crop in.pgm x y [z] w h [d] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For a 2d image, extracts the rectangle with upper left corner (x,y),\n"         \
-"of width w and height h from the image in.pgm .\n"         \
-"For a 3d image, extracts the cuboid with upper left corner (x,y, z),\n"         \
-"of width w, height h and depth d from the image in.pgm .\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d, float 2d, byte 3d, int32_t 3d, float 3d.\n"         \
-"\n"         \
-"Category: convert, geo\n"         \
-"  convert, geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skeleton__c__ "  skeleton.c\n"         \
-"\n"         \
-" ultimate binary skeleton guided by a priority image (see [BC07])\n"         \
-"\n"         \
-"Usage: skeleton in.pgm prio connex [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Ultimate binary skeleton guided by a priority image.\n"         \
-"The lowest values of the priority image correspond to the highest priority.\n"         \
-"\n"         \
-"The parameter  prio is either an image (byte, int32_t, float or double), or a numerical code\n"         \
-"indicating that a distance map will be used as a priority image; \n"         \
-"the possible choices are:\n"         \
-" 0: approximate euclidean distance\n"         \
-" 1: approximate quadratic euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-"The parameter  connex indicates the connectivity of the binary object.\n"         \
-"Possible choices are 4, 8 in 2d and 6, 26 in 3d.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is an integer different from -1,\n"         \
-"then the points which correspond to this priority value will be left unchanged. \n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Let X be the set corresponding to the input image  in.pgm.\n"         \
-"Let P be the function corresponding to the priority image.\n"         \
-"Let I be the set corresponding to the inhibit image, if given, or the empty\n"         \
-"set otherwise.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat until stability\n"         \
-"    Select a point x in X  I such that P[x] is minimal\n"         \
-"    If x is simple for X then\n"         \
-"        X = X  {x}\n"         \
-"Result: X\n"         \
-"\n"         \
-"\n"         \
-"Reference: \n"         \
-"[BC07] G. Bertrand and M. Couprie: \"Transformations topologiques discretes\", in G&eacute;om&eacute;trie discr&egrave;te et images num&eacute;riques, D. Coeurjolly and A. Montanvert and J.M. Chassery, pp.&nbsp;187-209, Herm&egrave;s, 2007.\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"skeleton circuit1 8 8 circuit1_skeleton\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"  \n"         \
-"  circuit1\n"         \
-"      circuit1_skeleton\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__gammacor__c__ "  gammacor.c\n"         \
-"\n"         \
-" performs gamma correction on image\n"         \
-"\n"         \
-"Usage: gammacor in.pgm gamma out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Applies the following steps to  in.pgm :\n"         \
-" normalization between 0 and 1\n"         \
-" raise pixel values to the power  gamma\n"         \
-" reverts the normalization\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawsplineorient__c__ "  drawsplineorient.c\n"         \
-"\n"         \
-" draw spline orientations in a vector field\n"         \
-"\n"         \
-"Usage: drawsplineorient in.pgm in.spline out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws spline orientations in a vector field. \n"         \
-"The spline is specified by its control points in a text file.\n"         \
-"The parameter  in.pgm gives a vector field into which the spline is to be drawn.\n"         \
-"The file format for  in.spline is the following for 2D:\n"         \
-"\n"         \
-"c n+1 (where n+1 denotes the number of control points)\n"         \
-"x1 y1\n"         \
-"...\n"         \
-"xn+1 yn+1\n"         \
-"C0X1 C0Y1 C1X1 C1Y1 C2X1 C2Y1 C3X1 C3Y1\n"         \
-"...\n"         \
-"C0Xn C0Yn C1Xn C1Yn C2Xn C2Yn C3Xn C3Yn\n"         \
-"\n"         \
-"and in the 3D case:\n"         \
-"\n"         \
-"C n+1 (where n+1 denotes the number of control points)\n"         \
-"x1 y1 z1\n"         \
-"...\n"         \
-"xn+1 yn+1 zn+1\n"         \
-"C0X1 C0Y1 C0Z1 C1X1 C1Y1 C1Z1 C2X1 C2Y1 C2Z1 C3X1 C3Y1 C3Z1\n"         \
-"...\n"         \
-"C0Xn C0Yn C0Zn C1Xn C1Yn C1Zn C2Xn C2Yn C2Zn C3Xn C3Yn C3Zn\n"         \
-"\n"         \
-"Types supported: spline 2D, spline 3D\n"         \
-"\n"         \
-"Category: draw geo\n"         \
-"  draw geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pol2car__c__ "  pol2car.c\n"         \
-"\n"         \
-" converts a 2d image from polar to cartesian coordinates\n"         \
-"\n"         \
-"Usage: in_pol in_car x_center y_center out\n"         \
-"\n"         \
-"Description:\n"         \
-"Converts a 2d image from polar to cartesian coordinates.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__rotse__c__ "  rotse.c\n"         \
-"\n"         \
-" rotation of a structuring element\n"         \
-"\n"         \
-"Usage: rotse in.pgm angle out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Rotation of a structuring element, by an angle of 0, 90, 180 or 270 degrees.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__MSF4d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__mcm2vtk__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__crestvol__c__ "  crestvol.c\n"         \
-"\n"         \
-" enhances linear structures in a grayscale image\n"         \
-"\n"         \
-"Usage: crestvol in.pgm connex radius out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Enhances linear structures in a grayscale image.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Let F be the original image (\"in.pgm\")\n"         \
-"Let O be the final result (\"out.pgm\")\n"         \
-"Let r be the value of parameter \"radius\"\n"         \
-"Compute k iterations of homotopic thinning, result S\n"         \
-"Lower all separating points p in S down to alpha8m(S, p), result Sp \n"         \
-"For each point x of S which is separating\n"         \
-"  Let Dx be the image with D(x) = F(x), and D(y) = 0 for all y != x\n"         \
-"  Let Fx be the geodesic reconstruction of Dx under F \n"         \
-"  O(x) = volume((Fx-Sp).Br(x)) \n"         \
-"  where Br(x) is the disc centered on x with radius r\n"         \
-"EndFor\n"         \
-"\n"         \
-"\n"         \
-"References: \n"         \
-"\"Topological operators for the detection of\n"         \
-"curvilinar structures in grayscale images\", in preparation.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__zoom__c__ "  zoom.c\n"         \
-"\n"         \
-" zoom (shrink or expand) an image\n"         \
-"\n"         \
-"Usage: zoom in.pgm {f | x rs | y cs | z ds | fx fy fz} out.pgm\n"         \
-"\n"         \
-"Description: \n"         \
-"There are 3 modes, depending on the number of arguments.\n"         \
-"\n"         \
-"1 argument: the same scale factor f is applied to both dimensions \n"         \
-"  x and y (and z in 3D)\n"         \
-"\n"         \
-"2 arguments: if the parameter x is used, \n"         \
-"  followed by an integer number rs, the zoom factor f \n"         \
-"  is computed by dividing rs by the rowsize of in.pgm.\n"         \
-"  If the parameter y is used, followed by an integer number cs, \n"         \
-"  f is computed by dividing cs by the colsize of in.pgm.\n"         \
-"  If the parameter z is used, followed by an integer number ds, \n"         \
-"  f is computed by dividing ds by the depth of in.pgm.\n"         \
-"\n"         \
-"3 arguments: different zoom factors fx, fy, fz\n"         \
-"  are given for directions x, y, z.\n"         \
-"\n"         \
-"Types supported: byte 1d, byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__hello__cpp__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__shake__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__dev_conventions__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__gradcol___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__randrgb__c__ "  randrgb.c\n"         \
-"\n"         \
-" generates random colors from gray levels\n"         \
-"\n"         \
-"Usage: randrgb in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Generates a color image where each gray level is replaced by a randomly\n"         \
-"chosen color\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__curvelength__cxx__ "  curvelength.c\n"         \
-"\n"         \
-" computes the length of a digital curve\n"         \
-"\n"         \
-"Usage: curvelength curve.list closed [out.list]\n"         \
-"\n"         \
-"Description:\n"         \
-"Computes the length of a curve which is specified by the ordered list of its points.\n"         \
-"\n"         \
-"Parameter  closed is a boolean (1 or 0) that indicates whether the curve is closed or not.\n"         \
-"\n"         \
-"Types supported: curve 2D, curve 3D\n"         \
-"\n"         \
-"Category: geo\n"         \
-" geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lambdaskel__c__ "  lambdaskel.c\n"         \
-"\n"         \
-" grayscale filtered topological skeleton\n"         \
-"\n"         \
-"Usage: lambdaskel in.pgm {imcond.pgm|null} connex lambda out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Filtered topological skeleton for 2D grayscale images. \n"         \
-"The parameter  connex gives the connectivity used for the minima;\n"         \
-"possible choices are 4 and 8.\n"         \
-"The parameter  lambda is a contrast parameter (positive integer).\n"         \
-"Let F be the function corresponding to the input image  in.pgm.\n"         \
-"The parameter  imcond.pgm is a constraint function G.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat until stability:\n"         \
-"    Select a point p which is lambda-destructible for F or a peak\n"         \
-"        such that F(p) > G(p) and such that F(p) is minimal\n"         \
-"    F(p) = alpha-(p,F)\n"         \
-"Result: F\n"         \
-"\n"         \
-"\n"         \
-"Reference: \n"         \
-"M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__raw2pgm__c__ "  raw2pgm.c\n"         \
-"\n"         \
-" converts from raw format into pgm format\n"         \
-"\n"         \
-"Usage: raw2pgm in.raw rs cs ds headersize datatype littleendian [xdim ydim zdim] out.pgm\n"         \
-"\n"         \
-"Description: Converts from raw format into pgm format. \n"         \
-"\n"         \
-"Parameters:\n"         \
-"  in.pgm : source file in raw format\n"         \
-"  rs (int32_t): row size (number of voxels in a row)\n"         \
-"  cs (int32_t): column size (number of voxels in a column)\n"         \
-"  ds (int32_t): number of planes\n"         \
-"  headersize (int32_t): size of the header in bytes (information in the header will be ignored)\n"         \
-"  datatype (int32_t): (1 for byte, 2 for short int, 4 for long int, 5 for float)\n"         \
-"  littleendian (int32_t) 1: littleendian, 0: bigendian. Usual choice is 0.\n"         \
-"  xdim (float, optional) : gap (in the real world) between two adjacent voxels in a row.  \n"         \
-"  ydim (float, optional) : gap (in the real world) between two adjacent voxels in a column.  \n"         \
-"  zdim (float, optional) : gap (in the real world) between two adjacent planes.  \n"         \
-"\n"         \
-"Types supported: byte 2D-3D, int16_t 2D-3D, int32_t 2D-3D, float 2D-3D\n"         \
-"\n"         \
-" Signed integers are not supported.\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__blob__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__fft__c__ "  fft.c\n"         \
-"\n"         \
-" fast Fourier transform\n"         \
-"\n"         \
-"Usage: fft in.pgm [dir] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Computes the 2 dimensional Fast Fourier Transform of an image.\n"         \
-"\n"         \
-"This program will compute either a forward or inverse FFT, depending on\n"         \
-"the direction requested with the  dir option.  A  dir value of 0\n"         \
-"will result in a forward FFT, and a  dir value of 1 will result\n"         \
-"in an inverse FFT. \n"         \
-"\n"         \
-"The arguments are described as follows:\n"         \
-"\n"         \
-" in.pgm specifies the input image, which must be of data type COMPLEX.\n"         \
-"\n"         \
-" out.pgm output image, which will be an image of data type COMPLEX. \n"         \
-"If row size or column size of in.pgm is not an integral power of 2, then input data is padded and dimensions of out.pgm may be different from those of in.pgm . \n"         \
-"\n"         \
-" dir (optional)\n"         \
-"specifies the FFT direction.  A  dir of 0 (default) will result in a forward FFT, \n"         \
-"and a  dir of 1 will result in an inverse FFT.\n"         \
-"\n"         \
-"This particular implementation of the DFT uses the transform pair defined as follows:\n"         \
-"\n"         \
-"Let there be two complex arrays each with n rows and m columns.\n"         \
-"\n"         \
-"Index them as \n"         \
-"\n"         \
-"f(x,y):    0 \n"         \
-"\n"         \
-"F(u,v):    -m/2 \n"         \
-"\n"         \
-"Then the forward and inverse transforms are related as follows.\n"         \
-"\n"         \
-"Forward:\n"         \
-"\n"         \
-"F(u,v) =   f(x,y)  i (ux/m + vy/n)}\n"         \
-"\n"         \
-"Inverse:\n"         \
-"\n"         \
-"f(x,y) = 1/(mn)   F(u,v)  i (ux/m + vy/n)}\n"         \
-"\n"         \
-"Therefore, the transforms have these properties:\n"         \
-"\n"         \
-"1.     f(x,y) = F(0,0)\n"         \
-"\n"         \
-"2.  m n   |f(x,y)|^2 =   |F(u,v)|^2\n"         \
-"\n"         \
-"Types supported: complex 2d\n"         \
-"\n"         \
-"Category: signal\n"         \
-" signal\n"         \
-"\n"         \
-" Stefan Gustavson (stegu@itn.liu.se) 2003-10-20\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__colorize__c__ "  colorize.c\n"         \
-"\n"         \
-" generates a color image from a grayscale image and a lookup table\n"         \
-"\n"         \
-"Usage: colorize in.pgm lut.ppm out.ppm\n"         \
-"\n"         \
-"Description:\n"         \
-"Generates a color image from a grayscale image and a lookup table (see genlut.c).\n"         \
-"\n"         \
-"Types supported: byte 2D, long 2D\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_SK3_pers__c__ "  skel_SK3_pers.c\n"         \
-"\n"         \
-" topological persistence of 1D isthmuses, based on parallel 3D asymetric thinning\n"         \
-"\n"         \
-"Usage: skel_SK3_pers in.pgm out.pgm\n"         \
-"\n"         \
-"Description: Topological persistence of 1D isthmuses, based on \n"         \
-"parallel 3D asymetric thinning.\n"         \
-"\n"         \
-"When a point x is detected as a 1D isthmus, a counter p(x) is\n"         \
-"associated to this point and initialized with value 1. This counter is\n"         \
-"incremented a each iteration as long as x is still an isthmus. When this point x is\n"         \
-"eventually deleted, the value of the counter is freezed.\n"         \
-"\n"         \
-" The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dskelsurf__c__ "  3dskelsurf.c\n"         \
-"\n"         \
-" surfacic skeleton\n"         \
-"\n"         \
-"Usage: in.pgm n out.pgm\n"         \
-"\n"         \
-"Description: Surfacic skeleton in the sense defined in ref. [LB99]\n"         \
-"The parameter  n gives the number of parallel steps of simple,\n"         \
-"non surface end point deletions.\n"         \
-"\n"         \
-"Reference: \n"         \
-"[LB99] C. Lohou, Gilles Bertrand: \"Poset approach to 3D parallel thinning\", SPIE Vision Geometry VIII, Vol.&nbsp;3811, pp.&nbsp;45-56, 1999.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__asft__c__ "  asft.c\n"         \
-"\n"         \
-" alternate sequential filter controled by topology\n"         \
-"\n"         \
-"Usage: asft in.pgm {c.pgm cc.pgm|null null} connex rmax out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Alternate sequential filter controled by topology (see [CB04]).\n"         \
-"Disc- or Ball-shaped structuring elements of increasing radius,\n"         \
-"ranging from 1 to rmax,\n"         \
-"are generated. Let D1...Dn be these structuring elements, sorted by increasing radius.\n"         \
-"Let I(0) = in.pgm, the ith intermediate result I(i) is obtained by the \n"         \
-"homotopic pseudo-closing of the homotopic pseudo-opening of I(i-1) \n"         \
-"by the structuring element Di. \n"         \
-"Two images  c.pgm and  cc.pgm can be given to serve as constraints for, respectively,\n"         \
-"the object and its complementary.\n"         \
-"The result out.pgm contains the final result I(n).\n"         \
-"\n"         \
-"Reference: \n"         \
-"[CB04] M. Couprie and G. Bertrand:\n"         \
-"Topology preserving alternating sequential filter for smoothing \n"         \
-"2D and 3D objects,  Journal of Electronic Imaging, Vol.&nbsp;13, No.&nbsp;4, pp.&nbsp;720-730, 2004.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho, topobin\n"         \
-"  morpho, topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__explode__c__ "  explode.c\n"         \
-"\n"         \
-" converts single 3D pgm file into a series of 2D pgm files\n"         \
-"\n"         \
-"Usage: explode in.pgm [begin end step] name_prefix\n"         \
-"\n"         \
-"Description:\n"         \
-"Generated file names are of the form: name_prefixnnnn.pgm, \n"         \
-"where nnnn is a four digit decimal integer. \n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__line__c__ "  line.c\n"         \
-"\n"         \
-" Draws a straight line between the two first points found in image.\n"         \
-"\n"         \
-"Usage: line in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws a straight line between the two first points found in image in.pgm.\n"         \
-"Uses the Bresenham's algorithm.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: draw\n"         \
-"  draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__comptreetime__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__3dsurfacecollapse__c__ "  3dsurfacecollapse.c\n"         \
-"\n"         \
-" parallel directional constrained collapse with surface detection and preservation\n"         \
-"\n"         \
-"Usage: 3dsurfacecollapse in.pgm mode nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel directional constrained collapse with surface detection and preservation.\n"         \
-"\n"         \
-"The parameter  mode selects the strategy used to detect surface elements.\n"         \
-"The possible choices are:\n"         \
-" 1: any 2-dimensional facet\n"         \
-"\n"         \
-"The parameter  nsteps gives the number of \"layers\" to be removes, if\n"         \
-"the value is -1 then the interations continue until stability.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__seuilauto__c__ "  seuilauto.c\n"         \
-"\n"         \
-" automatic threshold\n"         \
-"\n"         \
-"Usage: seuilauto in.pgm L {min|max} [n] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Determine automatically a threshold thanks to the smoothed histogram\n"         \
-"of the picture ( L : smoothing coefficient, 0\n"         \
-"If n is given, it indicates the number of peaks on the histogram to be kept.\n"         \
-"If n isn't given, the threshold separates the picture in two approximatively equivalent groups of points.\n"         \
-"The argument  selects the part of the picture\n"         \
-"to be kept:\n"         \
-"\n"         \
-"  min: Every pixel   =  smax gets value  vmax \n"         \
-"  max: Every pixel >  smin gets value  vmin and every pixel   \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Cedric Allene 2003\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__changename__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__deletecomp__c__ "  deletecomp.c\n"         \
-"\n"         \
-" deletes a connected component\n"         \
-"\n"         \
-"Usage: deletecomp in.pgm x y z out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The connected component of the binary image in.pgm\n"         \
-"which contains the point (x,y,z)\n"         \
-"is deleted.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect, topobin\n"         \
-"  connect, topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_CK3a__c__ "  skel_CK3a.c\n"         \
-"\n"         \
-" parallel 3D binary curvilinear skeleton based on 1D isthmuses\n"         \
-"\n"         \
-"Usage: skel_CK3a in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 3D binary thinning or curvilinear skeleton based on 1D isthmuses. \n"         \
-"The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__temp___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__border__c__ "  border.c\n"         \
-"\n"         \
-" border of a binary image\n"         \
-"\n"         \
-"Usage: border in connex out\n"         \
-"\n"         \
-"Description:\n"         \
-"Let X be the subset of Zn that corresponds to the input image  in, and \n"         \
-"let k be the value of the parameter  connex (that is, 4, 8 (2d) or 6, 26 (3d)), which is the connectivity chosen for X.\n"         \
-"\n"         \
-"The border B(X) of X is defined by:\n"         \
-"B(X) = {x in X, (Gamma_nk(x) inter Xbar) not empty}\n"         \
-"where nk is the complementary connectivity for k.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgmrawmode__c__ "  pgmrawmode.c\n"         \
-"\n"         \
-" converts a pgm file to raw mode\n"         \
-"\n"         \
-"Usage: pgmrawmode filename [outfilename]\n"         \
-"\n"         \
-"Description: Converts a pgm file to raw mode.\n"         \
-"If only parameter  filename is given, then the result\n"         \
-"is also named  filename .\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skelfindelbows__c__ "  skelfindelbows.c\n"         \
-"\n"         \
-" detection of \"elbows\" in a curvilinear skeleton\n"         \
-"\n"         \
-"Usage: skelfindelbows in.skel thickness sharp out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Find \"elbows\" (points making sharp angles) in the curves of skeleton  in.skel.\n"         \
-"Matching points are written as voxels in the returned image  out.pgm.\n"         \
-"\n"         \
-"\n"         \
-"Let  be the points of a cover of the curve C by digital straight line segments (DSSs). \n"         \
-"Let j be an index between 1 and n-2, if angle(S[j-1]S[j], S[j]S[j+1]) \n"         \
-"\n"         \
-"\n"         \
-"Parameter  thick (thickness for DSS recognition) is given in pixels, parameter  sharp in degrees.\n"         \
-"\n"         \
-"Types supported: skel 2d, skel 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2011\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__printstats__c__ "  printstats.c\n"         \
-"\n"         \
-" prints some stats of an image or a region\n"         \
-"\n"         \
-"Usage: printstats in.pgm [mask.pgm]\n"         \
-"\n"         \
-"Description:\n"         \
-"Calculates the histogram of  im.pgm (masked by the binary image\n"         \
-" mask.pgm, if given) and prints it on the screen.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: histo\n"         \
-"  histo\n"         \
-"\n"         \
-" Laurent Najman\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__waterfall__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__insert__c__ " insert.c\n"         \
-"\n"         \
-" inserts an image into another image\n"         \
-"\n"         \
-"Usage: insert a.pgm b.pgm x y z out.ppm\n"         \
-"\n"         \
-"Description: Inserts image  a.pgm into image  b.pgm at position  x,y,z\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d, float 2d, byte 3d, int32_t 3d, float 3d.\n"         \
-"\n"         \
-"Category: convert, geo\n"         \
-" convert, geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__zoomrgb__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__temp3dsimple__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__surfels__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__download__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__localextrema__c__ "  localextrema.c\n"         \
-"\n"         \
-" local extrema \n"         \
-"\n"         \
-"Usage: in.pgm connex minimum out.pgm\n"         \
-"\n"         \
-"Description: \n"         \
-"Selects the local maxima or minima of a grayscale image with connexity connex.\n"         \
-"\n"         \
-"Types supported: byte 2d - byte 3d\n"         \
-"\n"         \
-"Category: connect, topogray\n"         \
-"  connect, topogray\n"         \
-"\n"         \
-" Laurent Najman\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skelpar3d__c__ "  skelpar3d.c\n"         \
-"\n"         \
-" parallel 3D binary skeleton\n"         \
-"\n"         \
-"Usage: skelpar3d in.pgm algorithm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Parallel 3D binary thinning or skeleton. \n"         \
-"\n"         \
-"The parameter  nsteps gives, if positive, the number of parallel\n"         \
-"thinning steps to be processed.  If the value given for  nsteps\n"         \
-"equals -1, the thinning is continued until stability.\n"         \
-"\n"         \
-"For some algorithms (16 to ??), the parameter  nsteps has a\n"         \
-"different meaning which is related to the notion of persistence (see\n"         \
-"[REF A AJOUTER]). It plays the role of a filtering parameter.\n"         \
-"\n"         \
-"The parameter  algorithm is a numerical code\n"         \
-"indicating which method will be used for the thinning.\n"         \
-"The possible choices are:\n"         \
-" 0: ultimate, without constraint (MK3a)\n"         \
-" 1: curvilinear, symmetric, based on 1D isthmus (CK3a)\n"         \
-" 2: medial axis preservation (AK3) - parameter inhibit represents the minimal radius of medial axis balls which are considered\n"         \
-" 3: ultimate (MK3) - if nsteps = -2, returns the topological distance\n"         \
-" 4: curvilinear based on ends (EK3)\n"         \
-" 5: curvilinear based on ends, with end reconstruction (CK3b)\n"         \
-" 6: topological axis (not homotopic)\n"         \
-" 7: curvilinear, based on residual points and 2D isthmus (CK3)\n"         \
-" 8: ultimate, asymmetric (AMK3)\n"         \
-" 9: curvilinear, asymmetric, based on thin 1D isthmus (ACK3a)\n"         \
-" 10: curvilinear, asymmetric, based on 3D and 2D residuals (ACK3)\n"         \
-" 11: surface, symmetric, based on residual points (RK3)\n"         \
-" 12: surface, symmetric, based on 2D isthmuses (SK3)\n"         \
-" 13: ultimate, directional, (DK3)\n"         \
-" 14: surface, directional, based on residual points (DRK3)\n"         \
-" 15: surface, directional, based on 2D isthmuses (DSK3)\n"         \
-" 16: curvilinear, asymmetric, based on thin 1D isthmus with persistence (ACK3p)\n"         \
-" 17: surface, asymmetric, based on thin 2D isthmus with persistence (ASK3p)\n"         \
-" 18: curvilinear, symmetric, based on 1D isthmus with persistence (CK3p)\n"         \
-" 19: surface, symmetric, based on 2D isthmus with persistence (SK3p)\n"         \
-" 20: surface and curvilinear, symmetric, based on 1D and 2D isthmus with persistence (SCK3p)\n"         \
-" 21: surface, symmetric, based on residual points (RK3), variant (uses 26-connectivity to define residual points)\n"         \
-"\n"         \
-"\n"         \
-"In modes other than 2, if the parameter  inhibit is given and is a\n"         \
-"binary image name, then the points of this image will be left\n"         \
-"unchanged.\n"         \
-"\n"         \
-"The following codes give access to auxiliary functions, for isthmus detection. \n"         \
-"Parameter  nsteps will not be used in this case (any value can be given).\n"         \
-"\n"         \
-" 100: 1D isthmus points\n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgm2slc__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lfclose_rect__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__GA2pgm__c__ "  GA2pgm.c\n"         \
-"\n"         \
-" Convert a 4-connected edge-weighted graph (a GA) into a pgm image \n"         \
-"\n"         \
-"Usage: GA2pgm graph.ga param out.pgm \n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Convert a 4-connected edge-weighted graph (graph.ga) into a pgm\n"         \
-"image (out.pgm) where each pixel represents a vertex of the\n"         \
-"input graph and the gray level of a pixel is obtained from the values\n"         \
-"of its incident edges by means of an operation depending of the\n"         \
-"parameter param.\n"         \
-"\n"         \
-"If param = 1, then max is used, and if param = 2, min is used.\n"         \
-"\n"         \
-"Types supported: ga 2d, ga 3d\n"         \
-"\n"         \
-"Category: GA\n"         \
-" GA\n"         \
-"\n"         \
-" Jean Cousty\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ptend__c__ "  ptend.c\n"         \
-"\n"         \
-" detects end points in a binary image\n"         \
-"\n"         \
-"Usage: ptend in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"An end point is a white point, which has exactly 1 white n-neighbour (n = 4, 8 (2d) or 6, 18, 26 (3d), as set by the parameter  connex)\n"         \
-"\n"         \
-"When the type of  in.pgm is 4_BYTE, the image is treated as a label image, where each label is processed as a separate binary image (all other labels are considered as background).\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D, long 3D\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__erosnum__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__histolisse__c__ "  histolisse.c\n"         \
-"\n"         \
-" smoothed histogram of the gray values\n"         \
-"\n"         \
-"Usage: histolisse in.pgm L [mask.pgm] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Generates a binary image which contains the graphical representation\n"         \
-"of the smoothed histogram of  in.pgm (masked by the binary image\n"         \
-" mask.pgm, if given).  L : smoothing coefficient, 0\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: histo\n"         \
-"  histo\n"         \
-"\n"         \
-" Cedric Allene 2003\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__delaunay__c__ "  delaunay.c\n"         \
-"\n"         \
-" delaunay triangulation\n"         \
-"\n"         \
-"Usage: delaunay in.list [mask.pgm] out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Reads a point list in file in.list under the following format:\n"         \
-"  \n"         \
-"    b &lt;n&gt;         n &lt;n&gt;    \n"         \
-"    x1 y1         x1 y1 v1\n"         \
-"    x2 y2   ou    x2 y2 v2\n"         \
-"    ...           ...\n"         \
-"    xn yn         xn yn vn\n"         \
-"  \n"         \
-"\n"         \
-"Computes a Delaunay triangulation and stores the resulting graph \n"         \
-"into file out.graph under the following format:\n"         \
-"\n"         \
-"    G &lt;n&gt;\n"         \
-"    x1 y1 v1 ec1 ns1 s11 s12 ... s1ns1\n"         \
-"    x2 y2 v2 ec2 ns2 s21 s22 ... s1ns2\n"         \
-"    ...\n"         \
-"    xn yn vn ecn nsn sn1 sn2 ... s1nsn\n"         \
-"\n"         \
-"  \n"         \
-"where xi, yi are the coordinates of the ith vertex, vi is the associated \n"         \
-"value (if given in the input file), eci is a int32_t which indicates \n"         \
-"whether the vertex i belongs to the convex hull, nsi denotes the number\n"         \
-"of adjacent vertices, and si1 si2 ... sins1 is the list of the indexes of\n"         \
-"the adjacent vertices (counted from 0).\n"         \
-"\n"         \
-"If the optional parameter mask.pgm is given, then it must be a \n"         \
-"binary byte image. Any edge of the triangulation which intersects the\n"         \
-"mask will be discarded.  \n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"See also: drawtriangulation.c\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" algorithm in O(n^2)\n"         \
-"\n"         \
-" Michel Couprie, Laurent Mercier\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgm2skel__c__ "  pgm2skel.c\n"         \
-"\n"         \
-" decomposition of a curvilinear skeleton into isolated points, end points, curves and junctions\n"         \
-"\n"         \
-"Usage: pgm2skel in.pgm connex [len] out.skel\n"         \
-"\n"         \
-"Description:\n"         \
-"The skeleton found in  in.pgm is decomposed into isolated points, end points, curves and junctions ;\n"         \
-"and its description is stored in  out.skel .\n"         \
-"The parameter  connex sets the adjacency relation used for the object\n"         \
-"(4, 8 (2d) or 6, 18, 26 (3d)).\n"         \
-"\n"         \
-"The optional parameter  indicates the minimum length \n"         \
-"(in pixels/voxels) of a curve. \n"         \
-"\n"         \
-"If a set of curve points with less than  points, then: \n"         \
-"\n"         \
-"a) if it contains at least one end point it will be eliminated\n"         \
-"(together with its end point(s)),\n"         \
-"\n"         \
-"b) otherwise it will be considered as part of a junction.  \n"         \
-"\n"         \
-"If this parameter is given, then isolated points will be eliminated.\n"         \
-"\n"         \
-"The format of the file  is described in\n"         \
-"PINKDIR/doc/formats.txt (section: Curvilinear skeletons).\n"         \
-"\n"         \
-" Points at the border of the image will be ignored.\n"         \
-"\n"         \
-" IMPORTANT LIMITATION: \n"         \
-"different junctions in the original image must not be in direct\n"         \
-"contact with each other (i.e., connected) otherwise they will be\n"         \
-"considered as a single junction. To prevent this to occur, one can\n"         \
-"increase image resolution.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2004, 2009\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawlines__c__ "  drawlines.c\n"         \
-"\n"         \
-" draw line segments which are specified by a text file\n"         \
-"\n"         \
-"Usage: drawlines in.pgm vect.txt out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The file  vect.txt contains a list of line segments under the format:\n"         \
-"l nb_segments\n"         \
-"x11 y11 x12 y12\n"         \
-"x21 y21 x22 y22\n"         \
-"x31 y31 x32 y32\n"         \
-"...\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: draw\n"         \
-"  draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__deriche3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__enframe3d__c__ "  enframe3d.c\n"         \
-"\n"         \
-" adds a border with a given gray value to an image\n"         \
-"\n"         \
-"Usage: enframe3d in.pgm [grayvalue [width [out.pgm]]]\n"         \
-"\n"         \
-"Description:\n"         \
-"Adds a border to the input image, filled with the value  grayvalue (default 0). \n"         \
-"The width of the border may be given as parameter  width, \n"         \
-"otherwise its value is 1.\n"         \
-"\n"         \
-"If  out.pgm is not specified, then out.pgm = in.pgm.\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d, float 2d, byte 3d, int32_t 3d, float 3d.\n"         \
-"\n"         \
-"Category: convert, geo\n"         \
-"  convert, geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__nbcomp__c__ "  nbcomp.c\n"         \
-"\n"         \
-" returning number of connected components of a grayscale or a binary image\n"         \
-"\n"         \
-"Usage: nbcomp in.pgm connex {fgd|bgd|min|max|pla} [out.list]\n"         \
-"\n"         \
-"Description:\n"         \
-"The argument  connex selects the connectivity (4, 8 in 2D; 6, 18, 26 in 3D).\n"         \
-"The argument  selects the kind of flat zone\n"         \
-"to be counted:\n"         \
-"  fgd selects foreground components for a binary image\n"         \
-"  bgd selects background components for a binary image\n"         \
-"  min selects regional minima\n"         \
-"  max selects regional maxima\n"         \
-"  pla selects all flat zones (plateaux).\n"         \
-"\n"         \
-"The result is written in the list out.list.\n"         \
-"\n"         \
-"If the parameter  out.list is ommitted, the result is printed on the standard output.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-"  connect\n"         \
-"\n"         \
-" Cedric Allene\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__histo2__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__max1__c__ "  max1.c\n"         \
-"\n"         \
-" return the maximum of the pixel values of an image\n"         \
-"\n"         \
-"Usage: max1 in.pgm [out.list]\n"         \
-"\n"         \
-"Description:\n"         \
-"This function returns (in the list out.list) \n"         \
-"the maximum of the pixel values of the image  in.pgm .\n"         \
-"\n"         \
-"If the parameter  out.list is ommitted, the result is printed on the standard output.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__affine__c__ "  affine.c\n"         \
-"\n"         \
-" affine transformation of a 2D image\n"         \
-"\n"         \
-"Usage: affine in.pgm {trans.lst | hx hy theta tx ty} out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Applies to in.pgm an affine tranformation composed of a zoom \n"         \
-"(factors  hx,  hy), a rotation (angle  theta in degrees, \n"         \
-"center 0,0), and a translation (vector  tx,  ty). \n"         \
-"Alternatively, the transformation parameters may be given \n"         \
-"in a type \"e\" list file (see doc/formats.txt).\n"         \
-"\n"         \
-"Method: interpolation.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawline__c__ "  drawline.c\n"         \
-"\n"         \
-" draw a straight line segment in a 2D image\n"         \
-"\n"         \
-"Usage: drawline in.pgm x1 y1 [z1] x2 y2 [z2] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Draws a straight line segment between (x1,y1[,z1]) and (x2,y2[,z2])\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: draw\n"         \
-"  draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__qdistance__cpp__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__3dmakepolygons__c__ "  3dmakepolygons.c\n"         \
-"\n"         \
-" identifies polygons from a labelled pure 2D cellular complex\n"         \
-"\n"         \
-"Usage: 3dmakepolygons lab.pgm border.pgm psubdiv pmerge out.vtk\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"The input  lab.pgm contains a labelled pure 2D complex, where each label \n"         \
-"marks a set of 2-facets which is a manifold with boundary\n"         \
-"\n"         \
-"psubdiv: this parameter governs the subdivision of polygon edges \n"         \
-"pmerge: TODO\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__fitcircle__c__ "  fitcircle.c\n"         \
-"\n"         \
-" fits a circle which locally minimizes gray levels\n"         \
-"\n"         \
-"Usage: fitcircle in.pgm x y r [translate] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Identifies the circle C which locally minimizes the mean gray level \n"         \
-"of the image  in.pgm in the vincinity of the circle\n"         \
-"of parameters  x ,  y and  r.\n"         \
-"If the parameter  translate is added, then the minimization is\n"         \
-"done only for dimensions x and y.\n"         \
-"Draws this circle in  out.pgm .\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__seuil__c__ "  seuil.c\n"         \
-"\n"         \
-" simple threshold\n"         \
-"\n"         \
-"Usage: seuil in.pgm n [n2] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"If n2 is not present, for each pixel x, out[x] = if (in[x] \n"         \
-"\n"         \
-"If n2 is present, for each pixel x, out[x] = if (n \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie 1997\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__setorigin__c__ "  setorigin.c\n"         \
-"\n"         \
-" adds origin to file header\n"         \
-"\n"         \
-"Usage: setorigin in.pgm [source_se | xorig yorig zorig] \n"         \
-"\n"         \
-"Description: Adds origin (the one of  se or  xorig  yorig  zorig ) \n"         \
-"to file header of  in.pgm.\n"         \
-"\n"         \
-"Types supported: byte 3d, int32_t 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__rotate3dbin__c__ "  rotate3dbin.c\n"         \
-"\n"         \
-" rotation of an image\n"         \
-"\n"         \
-"Usage: rotate3dbin in.pgm theta axis [c1 c2] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Method: truncated real rotation.\n"         \
-"Rotates the image  in.pgm of the angle  theta (in degrees), \n"         \
-"around the straight line defined by parameters  axis,  c1 and  c2, parallel to one of the main axes x, y, z.\n"         \
-"Parameter  axis may be either x, y or z.\n"         \
-"If  axis = x, then the rotation axis is defined by y =  c1, z =  c2.\n"         \
-"If  axis = y, then the rotation axis is defined by x =  c1, z =  c2.\n"         \
-"If  axis = z, then the rotation axis is defined by x =  c1, y =  c2.\n"         \
-"\n"         \
-"If  in.pgm is not a structuring element, and if parameters  c1 and  c2 are omitted then the default values 0, 0 are assumed and the resulting image size is computed such that no loss of information occur. Otherwise, no resize is made.\n"         \
-"\n"         \
-"If  in.pgm is a structuring element, then parameters  c1 and  c2 are ignored and the coordinates of the rotation axis are taken among the ones of the origin of the structuring element.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__watershedthin__c__ "  watershedthin.c\n"         \
-"\n"         \
-" Thin watershed transformation (Meyer's algorithm on  perfect fusion grid)\n"         \
-"\n"         \
-"Usage: watershedthin in mark {bgmark|null} {roi|null} parite out\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Performs the watershed transformation on the image in,\n"         \
-"considered to be on a perfect fusion grid, taking the set of markers in\n"         \
-"mark.  Returns the divide set.\n"         \
-"\n"         \
-"If this parameter is present, bgmark is used as a\n"         \
-"set of markers for the background.  If this parameter is present,\n"         \
-"roi indicates the region of interest on which the operation is\n"         \
-"performed.  The parameter parite (0 or 1) gives the \n"         \
-"the translation of the fusion grid.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Jean Cousty\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__segmenti__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__gradinf3d___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__reconsdilat__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__rawthreshold__c__ "  rawthreshold.c\n"         \
-"\n"         \
-" converts from raw format into pgm format and applies a double threshold\n"         \
-"\n"         \
-"Usage: rawthreshold in.raw rs cs ds headersize datatype littleendian thresh1 thresh2 [xdim ydim zdim] out.pgm\n"         \
-"\n"         \
-"Description: Converts from raw format into pgm byte format, and selects only pixels which have values V such that thresh1 \n"         \
-"\n"         \
-"Parameters:\n"         \
-"  in.pgm : source file in raw format\n"         \
-"  rs (int32_t): row size (number of voxels in a row)\n"         \
-"  cs (int32_t): column size (number of voxels in a column)\n"         \
-"  ds (int32_t): number of planes\n"         \
-"  headersize (int32_t): size of the header in bytes (information in the header will be ignored)\n"         \
-"  datatype (int32_t): (1 for byte, 2 for short int, 4 for long int, 5 for float)\n"         \
-"  littleendian (int32_t) 1: littleendian, 0: bigendian. Usual choice is 0.\n"         \
-"  thresh1, thresh2 (float): threshold values\n"         \
-"  xdim (float, optional) : gap (in the real world) between two adjacent voxels in a row.  \n"         \
-"  ydim (float, optional) : gap (in the real world) between two adjacent voxels in a column.  \n"         \
-"  zdim (float, optional) : gap (in the real world) between two adjacent planes.  \n"         \
-"\n"         \
-"This operator does not load the complete image into memory. \n"         \
-"\n"         \
-"Types supported: float\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__htkern3d___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__maxima__c__ "  maxima.c\n"         \
-"\n"         \
-" regional maxima \n"         \
-"\n"         \
-"Usage: in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description: \n"         \
-"Selects the regional maxima of a grayscale image with connexity connex.\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d, byte 3d, int32_t 3d\n"         \
-"\n"         \
-"Category: connect, topogray\n"         \
-"  connect, topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lferode3d_rect__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__2dcolor__c__ "  2dcolor.c\n"         \
-"\n"         \
-" gives a specific color to points in a 2D khalimsky grid, \n"         \
-"according to their rank\n"         \
-"\n"         \
-"Usage: 2dcolor in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"gives a specific color to points in a 2D khalimsky grid, \n"         \
-"according to their rank\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_ASK3b___notused_c__ "  skel_ASK3b.c\n"         \
-"\n"         \
-" parallel 3D binary surface, asymetric skeleton based on thin 2D isthmuses\n"         \
-"\n"         \
-"Usage: skel_ASK3b in.pgm nsteps isthmus_persistence [inhibit] out.pgm\n"         \
-"\n"         \
-"Description: Parallel 3D binary thinning or surface,\n"         \
-"asymetric skeleton based on thin 2D isthmuses. The parameter  nsteps\n"         \
-"gives, if positive, the number of parallel thinning steps to be\n"         \
-"processed.  If the value given for  nsteps equals -1, the thinning\n"         \
-"is continued until stability.\n"         \
-"\n"         \
-"When a point x is detected as a 2D isthmus, a counter p(x) is\n"         \
-"associated to this point and initialized with value 1. This counter is\n"         \
-"incremented a each iteration as long as x is still an isthmus. At each\n"         \
-"iteration, the isthmuses x such that p(x) >=  isthmus_persistence are\n"         \
-"stored as a constraint set (see also  inhibit parameter).\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-" The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dflowskeleton__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lfclose3d_line__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__recalagerigide_translateplane__c__ "  recalagerigide.c\n"         \
-"\n"         \
-" rigid registration of two closed contours\n"         \
-"\n"         \
-"Usage: recalagerigide in1 in2 out\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Rigid registration of two closed contours. \n"         \
-"Let X and Y be two point sets, given respectively by  in1 and  in2.\n"         \
-"This procedure identifies the parameters of a rigid deformation R such that\n"         \
-"the \"distance\" between R(X) and Y is a local minimum.\n"         \
-"The distance D(Z,Y) between two sets Z and Y is defined by:\n"         \
-"\n"         \
-"D(Z,Y) = sum { d2(z,Y) ; for all z in Z }\n"         \
-"\n"         \
-"d2(z,Y) = min { d2(z,y) ; for all y in Y }\n"         \
-"\n"         \
-"d2(z,y) = (z - y)^2 ; i.e., the square or the Euclidean distance between z and y.\n"         \
-"\n"         \
-"The rigid deformation R is defined as the composition (in this order) \n"         \
-"of scalings, rotations and translations. \n"         \
-"\n"         \
-"In 2d, the parameters are:\n"         \
-" sx : parameter for the scaling in direction x\n"         \
-" sy : parameter for the scaling in direction y\n"         \
-" theta : angle (in radians) of the rotation around the barycenter of X\n"         \
-" tx : parameter for the translation in direction x\n"         \
-" ty : parameter for the translation in direction y\n"         \
-"\n"         \
-"In 3d, the parameters are:\n"         \
-" sx : parameter for the scaling in direction x\n"         \
-" sy : parameter for the scaling in direction y\n"         \
-" sz : parameter for the scaling in direction z\n"         \
-" theta : angle (in radians) of the rotation around the parallel to the the z axis passing by the barycenter of X\n"         \
-" phi : angle (in radians) of the rotation around the parallel to the the y axis passing by the barycenter of X\n"         \
-" tx : parameter for the translation in direction x\n"         \
-" ty : parameter for the translation in direction y\n"         \
-" tz : parameter for the translation in direction z\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__gradientcd__c__ "  gradientcd.c\n"         \
-"\n"         \
-" Canny-Deriche gradient operator\n"         \
-"\n"         \
-"Usage: gradientcd in.pgm alpha out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Deriche's recursive implementation of the\n"         \
-"Canny's gradient operator. The parameter \n"         \
-" alpha (double) controls the spatial extension of the\n"         \
-"filter: 0 \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: signal\n"         \
-"  signal\n"         \
-"\n"         \
-"Reference:\n"         \
-"\n"         \
-"[Der90] R. Deriche: \"Fast algorithms for low-level vision\",\n"         \
-"IEEE Transactions on PAMI, Vol.&nbsp;12, No.&nbsp;1, pp.&nbsp;78-87, 1990.\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__areaclosing__c__ "  areaclosing.c\n"         \
-"\n"         \
-" area closing\n"         \
-"\n"         \
-"Usage: areaclosing in.pgm connex area out.pgm\n"         \
-"\n"         \
-"Note:  in C main passes an argument 'area+1', whereas python passes the 'area'\n"         \
-"as argument (LuM)\n"         \
-"\n"         \
-"Description:\n"         \
-"Area closing with connexity connex and area area.\n"         \
-"Deletes the components of the lower cross-sections \n"         \
-"which have an area not higher than area.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__byte2long__c__ "  byte2long.c\n"         \
-"\n"         \
-" converts a \"byte\" image to a \"int32_t\" image\n"         \
-"\n"         \
-"Usage: byte2long in [out]\n"         \
-"\n"         \
-"Description: \n"         \
-"\n"         \
-"For each pixel x, out[x] = (int32_t)in[x].\n"         \
-"\n"         \
-"If the last argument  out is omitted, then out = in.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d.\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dist__c__ "  dist.c\n"         \
-"\n"         \
-" distance transform (external)\n"         \
-"\n"         \
-"Usage: dist in.pgm mode out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Distance to the object X defined by the binary image  in.pgm .\n"         \
-"The result function DX(x) is defined by: DX(x) = min {d(x,y), y in X}.\n"         \
-"\n"         \
-"The distance d used depends on the parameter  mode:\n"         \
-" 0: euclidean distance (rounded to the nearest int32)\n"         \
-" 1: approximate quadratic euclidean distance (Danielsson)\n"         \
-" 2: chamfer distance ([5,7] in 2D; [4,5,6] in 3D)\n"         \
-" 3: exact quadratic euclidean distance (int32)\n"         \
-" 4: 4-distance in 2d\n"         \
-" 5: exact euclidean distance (float)\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-" 40: 4-distance in 2d (byte coded ouput)\n"         \
-" 80: 8-distance in 2d (byte coded ouput)\n"         \
-" 60: 6-distance in 3d (byte coded ouput)\n"         \
-" 180: 18-distance in 3d (byte coded ouput)\n"         \
-" 260: 26-distance in 3d (byte coded ouput)\n"         \
-"\n"         \
-"The output  out.pgm is of type int32_t for modes \n"         \
-"\n"         \
-"Types supported: byte 2d,  byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie, Xavier Daragon\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__concat3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__curve2spline__c__ "  curve2spline.c\n"         \
-"\n"         \
-" converts a discrete open curve into a spline\n"         \
-"\n"         \
-"Usage: curve2spline curve.list [tolerance] out.spline\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Let C be the discrete open curve described in curve.list. This program finds a approximation of C\n"         \
-"in the form of a parametric curve P defined by two (in 2D) or three (in 3D) splines \n"         \
-"such that the maximal distance between P and C is beyond the given tolerance.\n"         \
-"The default value for tolerance is 2.\n"         \
-"\n"         \
-"The result is given in the form of the list of control points for the splines, followed by\n"         \
-"the set of coefficients for each spline segment. \n"         \
-"The file format is the following for 2D:\n"         \
-"\n"         \
-"c n+1 (where n+1 denotes the number of control points)\n"         \
-"x1 y1\n"         \
-"...\n"         \
-"xn+1 yn+1\n"         \
-"C0X1 C0Y1 C1X1 C1Y1 C2X1 C2Y1 C3X1 C3Y1\n"         \
-"...\n"         \
-"C0Xn C0Yn C1Xn C1Yn C2Xn C2Yn C3Xn C3Yn\n"         \
-"\n"         \
-"and in the 3D case:\n"         \
-"\n"         \
-"C n+1 (where n+1 denotes the number of control points)\n"         \
-"x1 y1 z1\n"         \
-"...\n"         \
-"xn+1 yn+1 zn+1\n"         \
-"C0X1 C0Y1 C0Z1 C1X1 C1Y1 C1Z1 C2X1 C2Y1 C2Z1 C3X1 C3Y1 C3Z1\n"         \
-"...\n"         \
-"C0Xn C0Yn C0Zn C1Xn C1Yn C1Zn C2Xn C2Yn C2Zn C3Xn C3Yn C3Zn\n"         \
-"\n"         \
-"The ith segment (starting with i=0) of the parametric curve P is then defined by:\n"         \
-"\n"         \
-"x(t) = C3Xi * t^3 + C2Xi * t^2 + C1Xi * t + C0Xi\n"         \
-"y(t) = C3Yi * t^3 + C2Yi * t^2 + C1Yi * t + C0Yi\n"         \
-"z(t) = C3Zi * t^3 + C2Zi * t^2 + C1Zi * t + C0Zi\n"         \
-"with t in [i,i+1]\n"         \
-"\n"         \
-" Closed curves are not allowed.\n"         \
-"\n"         \
-"Reference: \n"         \
-"[Cou10] M. Couprie: \"Short note on natural cubic splines and discrete curves\", internal report, 2010.\n"         \
-"\n"         \
-"Types supported: list 2D, list 3D\n"         \
-"\n"         \
-"Category: draw geo\n"         \
-"  draw geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__attribute__c__ "  attribute.c\n"         \
-"\n"         \
-" labels each connected component with its attribute value \n"         \
-"\n"         \
-"Usage: attribute in.pgm connex seuil typregion attrib out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Labels each connected component with its attribute value.\n"         \
-"\n"         \
-"Argument  connex defines the connectivity.\n"         \
-"\n"         \
-"Argument  seuil defines a threshold: components with attribute value not higher than  seuil are filtered out.\n"         \
-"\n"         \
-"Argument  typregion defines the type of regions:\n"         \
-" 0: regional maxima\n"         \
-" 1: regional minima\n"         \
-" 2: plateaus\n"         \
-"\n"         \
-"Argument  attrib defines the considered attribute:\n"         \
-" 0: area\n"         \
-" 1: perimeter\n"         \
-" 2: circularity\n"         \
-" 3: number of holes\n"         \
-" 4: excentricity\n"         \
-" 5: orientation\n"         \
-" 6: horizontal size (of bounding box)\n"         \
-" 7: vertical size (of bounding box)\n"         \
-" 8: depth size (of bounding box)\n"         \
-" 9: max of horizontal, vertical [and depth] sizes (of bounding box)\n"         \
-" 10: maximum diameter (Euclidean distance between most distant points): not yet implemented\n"         \
-"\n"         \
-" In 3D only the attributes 0 and 6-9 are implemented.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__expandframe__c__ "  expandframe.c\n"         \
-"\n"         \
-" expands the values of the image in a n-pixel wide band outside the image \n"         \
-"\n"         \
-"Usage: expandframe in.pgm n out.pgm\n"         \
-"\n"         \
-"Description: \n"         \
-"Expands the values of the image in a n-pixel wide band outside the image .\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lambdamedialaxis2auto__c__ "  lambdamedialaxis2.c\n"         \
-"\n"         \
-" discrete lambda-medial axis transform\n"         \
-"\n"         \
-"Usage: lambdamedialaxis2 in.pgm lambda opening.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"lambda:\n"         \
-" -1: produce lambdamedialaxis map\n"         \
-"  0: automaticly define lambda parameter\n"         \
-"  >0: produce binary image based on defined lambda\n"         \
-" \n"         \
-"Experimental\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__genbicol__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__meshregul__c__ "  meshregul.c\n"         \
-"\n"         \
-" mesh smoothing\n"         \
-"\n"         \
-"Usage: meshregul in mode [param1 [param2]] out\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Mesh smoothing. \n"         \
-"The possible choices for parameter mode are:\n"         \
-" 0: Laplacian smoothing (param1 = number of iterations, default value 5)\n"         \
-" 1: Hamam method [HC07] (SOWA, param1 = theta, default value 1.0)\n"         \
-" 2: Vollmer, Mencl and Mueller method [VMM] (param1 = alpha, param2 = beta, default values 0.1 and 0.6 resp.)\n"         \
-" 3: Hamam method [HC07], variant: matrix A used instead of AA (FOWA, param1 = theta, default value 1.0)\n"         \
-" 4: Hamam method [HC07], variant: theta = infty (SOWA, param1 = number of iterations, default value 5)\n"         \
-" 5: Hamam method [HC07], conjugate gradient algorithm (SOWA, param1 = theta, default value 1.0)\n"         \
-" 6: Taubin method [Tau95] (param1 = lambda, param2 = mu, param3 = N, default values 0.33 and -0.34 and 60)\n"         \
-" 7: Laplacian smoothing for a 2D polygon, with border edges preservation (param1 = number of iterations, default value 10)\n"         \
-"\n"         \
-"[HC07] Y. Hamam and M. Couprie, \"An optimisation-based approach to mesh smoothing: reformulation and extensions\", to appear, 2007.\n"         \
-"\n"         \
-"[VMM99] J. Vollmer and R. Mencl and H. Muller,\n"         \
-"\"Improved Laplacian Smoothing of Noisy Surface Meshes\",\n"         \
-"Computer Graphics Forum, Vol. 18, N. 3, pp. 131-138, 1999.\n"         \
-"\n"         \
-"[Tau95] G. Taubin, \n"         \
-"\"Curve and surface smoothing without shrinkage\"\n"         \
-"Proceedings of the Fifth International Conference on Computer Vision,\n"         \
-"pp. 852-857, 1995.\n"         \
-"\n"         \
-"Types supported: mesh 3d\n"         \
-"\n"         \
-"Category: mesh3d\n"         \
-"  mesh3d\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lpetopo__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__skelpar3d_others__cxx___ "  skelpar3d_others.cxx\n"         \
-"\n"         \
-" parallel 3D binary skeleton\n"         \
-"DirectionalSkeletonizer\n"         \
-"Usage: skelpar3d in.pgm algorithm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 3D binary thinning or skeleton. The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"The parameter  algorithm is a numerical code\n"         \
-"indicating which method will be used for the thinning.\n"         \
-"The possible choices are:\n"         \
-" 0: Palagyi (curvilinear, 6-subiterations directional, 1998)\n"         \
-" 1: Palagyi (curvilinear, sequential, 2006)\n"         \
-" 2: Palagyi (surface, parallel directional, 2002)\n"         \
-" 3: Palagyi (surface, fully parallel, 2008)\n"         \
-" 4: Raynal  (curvilinear, directional, 2010)\n"         \
-" 5: Raynal  (surface, directional, 2010)\n"         \
-" 6: Lohou-Bertrand  (curvilinear, symmetric, 2007)\n"         \
-" 7: Ma-Wan-Chang (curvilinear, 2 subfields, 2002)\n"         \
-" 8: Tsao-Fu (curvilinear, 6-subiterations directional, 1982)\n"         \
-" 9: Ma-Sonka (curvilinear, fully parallel, does not preserve topology 1996)\n"         \
-" 10: Ma-Wan (curvilinear (18/6) 6 subiterations, CVIU 2000)\n"         \
-" 11: Lohou-Bertrand (curvilinear 6 subiterations, DAM 2005)\n"         \
-" 12: Lohou-Bertrand (curvilinear 12 subiterations, DAM 2004)\n"         \
-" 13: ACK3a\n"         \
-" 14: CKSC\n"         \
-" 15: Ma-Wan-Lee (curvilinear, 4 subfields, 2002)\n"         \
-" 16: Nemeth-Kardos-Palagyi (curvilinear, 2 subfields, 2010, var. 1)\n"         \
-" 17: Nemeth-Kardos-Palagyi (curvilinear, 2 subfields, 2010, var. 2)\n"         \
-" 18: Nemeth-Kardos-Palagyi (curvilinear, 2 subfields, 2010, var. 3)\n"         \
-" 19: Nemeth-Kardos-Palagyi (curvilinear, 4 subfields, 2010, var. 1)\n"         \
-" 20: Nemeth-Kardos-Palagyi (curvilinear, 4 subfields, 2010, var. 2)\n"         \
-" 21: Nemeth-Kardos-Palagyi (curvilinear, 4 subfields, 2010, var. 3)\n"         \
-" 22: Nemeth-Kardos-Palagyi (curvilinear, 8 subfields, 2010, var. 1)\n"         \
-" 23: Nemeth-Kardos-Palagyi (curvilinear, 8 subfields, 2010, var. 2)\n"         \
-" 24: Nemeth-Kardos-Palagyi (curvilinear, 8 subfields, 2010, var. 3)\n"         \
-" 25: She et al. (curvilinear, symmetric, DICTA 2009)\n"         \
-" 26: Tsao-Fu (surface, 6-subiterations directional, 1981)\n"         \
-" 27: Tsao-Fu (curvilinear, 6-subiterations directional, 1981)\n"         \
-" 28: Nemeth-Kardos-Palagyi (curvilinear, 2 subfields, 2010, var. 0)\n"         \
-" 29: Nemeth-Kardos-Palagyi (curvilinear, 4 subfields, 2010, var. 0)\n"         \
-" 30: Nemeth-Kardos-Palagyi (curvilinear, 8 subfields, 2010, var. 0)\n"         \
-" 31: Lohou-Bertrand  (surface, symmetric, 2007)\n"         \
-" 32: Manzanera et al. (surface, symmetric, 1999)\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie, Benjamin Raynal, John Chaussard\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__rgb2ppm__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__diZenzo__c__ "  diZenzo.c\n"         \
-"\n"         \
-" diZenzo gradient pour les images couleurs\n"         \
-"\n"         \
-"Usage: diZenzo imageRVB.ppm alpha [mode] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Le gradient de diZenzo est défini par la donnée de p, q, et t:\n"         \
-"\n"         \
-"p = Rx*Rx + Vx*Vx + Bx*Bx\n"         \
-"\n"         \
-"q = Ry*Ry + Vy*Vy + By*By\n"         \
-"\n"         \
-"t = Rx*Ry + Vx*Vy + Bx*By\n"         \
-"\n"         \
-"(ou Rx = dérivée en x de la bande rouge, Ry est la dérivée en y de la bande rouge, etc.)\n"         \
-"\n"         \
-"et le module est donnée par\n"         \
-"\n"         \
-"G = sqrt(1/2*(p+q+sqrt((p+q)*(p+q) -4(pq-t*t))))\n"         \
-"\n"         \
-"La direction est donnée par 1/2*atan(2*t/(p-q))\n"         \
-"\n"         \
-"Si le mode est égale à 0 (valeur défaut) alors l'image de sortie est le gradient, \n"         \
-"sinon l'image de sortie est une int32_t entre 0 et 360.\n"         \
-"\n"         \
-"Les gradients sont calculés par les filtres de Deriche, de paramètre alpha\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: signal\n"         \
-"  signal\n"         \
-"\n"         \
-" Laurent Najman\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawsplines__c__ "  drawsplines.c\n"         \
-"\n"         \
-" draw spline segments which are specified by a text file\n"         \
-"\n"         \
-"Usage: drawsplines in.pgm splines.txt [len] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws splines which are specified by control points in a text file.\n"         \
-"The parameter  in.pgm gives an image into which the splines are to be drawn.\n"         \
-"The file format for  splines.txt is the following for 2D:\n"         \
-"\n"         \
-"The file  splines.txt contains a list of splines under the format:\n"         \
-"d nb_splines\n"         \
-"nb_points_spline_1  x11 y11  x12 y12 ...\n"         \
-"nb_points_spline_2  x21 y21  x22 y22 ...\n"         \
-"nb_points_spline_3  x31 y31  x32 y32 ...\n"         \
-"...\n"         \
-"or, in 3D:\n"         \
-"D nb_splines\n"         \
-"nb_points_spline_1  x11 y11 z11  x12 y12 z12 ...\n"         \
-"nb_points_spline_2  x21 y21 z21  x22 y22 z22 ...\n"         \
-"nb_points_spline_3  x31 y31 z31  x32 y32 z32 ...\n"         \
-"...\n"         \
-"\n"         \
-"If parameter  len is given and non-zero, the splines are extended on both sides by straight line segments of length  len. \n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: draw geo\n"         \
-"  draw geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__identifyline__c__ "  identifyline.c\n"         \
-"\n"         \
-" identification of a best matching line from a set of 2D points\n"         \
-"\n"         \
-"Usage: identifyline in.list out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Identifies the parameters (a,b) of the equation of the 2D line:\n"         \
-"ax+b=y that minimizes the least square error between this line \n"         \
-"and the given points. Method: basic linear regression.\n"         \
-"\n"         \
-"Types supported: list 1D, list 2D\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__hdilatball__c__ "  hdilatball.c\n"         \
-"\n"         \
-" topologically controlled dilation\n"         \
-"\n"         \
-"Usage: hdilatball in.pgm radius dist connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs a topologically controlled dilation, that is, a homotopic thickening \n"         \
-"constrained by the dilation of the input object.\n"         \
-"\n"         \
-"The parameter  radius gives the radius of the ball which is \n"         \
-"used as structuring element for the dilation.\n"         \
-"\n"         \
-"The parameter  dist is a numerical code\n"         \
-"indicating the distance which is used to compute the dilation.\n"         \
-"The possible choices are:\n"         \
-" 0: approximate euclidean distance\n"         \
-" 1: approximate quadratic euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-"The parameter  connex indicates the connectivity of the binary object.\n"         \
-"Possible choices are 4, 8 in 2d and 6, 26 in 3d.\n"         \
-"\n"         \
-"Let X be the set corresponding to the input image  in.pgm, and let\n"         \
-"Xbar denote its complementary set. The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"I = dilatball(X, dist, r)\n"         \
-"Repeat:\n"         \
-"    Select a point x in [Xbar inter I] such that dist(x,X) is minimal\n"         \
-"    If x is simple for X then\n"         \
-"        X = X union {x}\n"         \
-"	I = I  {x}\n"         \
-"Until [Xbar inter I] = emptyset\n"         \
-"Result: X\n"         \
-"\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ppmascmode__c__ "  ppmascmode.c\n"         \
-"\n"         \
-" converts a ppm file to ascii mode\n"         \
-"\n"         \
-"Usage: ppmascmode filename [outfilename]\n"         \
-"\n"         \
-"Description: Converts a ppm file to ascii mode.\n"         \
-"If only parameter  filename is given, then the result\n"         \
-"is also named  filename .\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawball__c__ "  drawball.c\n"         \
-"\n"         \
-" generates a binary euclidean ball\n"         \
-"\n"         \
-"Usage: drawball in.pgm radius xc yc zc out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws a binary euclidean ball in the image  in.pgm.\n"         \
-"The parameter radius specifies the radius of the ball. \n"         \
-"The parameters xc, yc, zc specify the center of the ball. \n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: draw\n"         \
-"  draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dilatplan__c_notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__comphisto__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__shrinkondisk__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__dup__c__ "  dup.c\n"         \
-"\n"         \
-" duplicates an image\n"         \
-"\n"         \
-"Usage: dup in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = in[x]\n"         \
-"\n"         \
-"Types supported: all types\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ptWsimple__c__ "  ptWsimple.c\n"         \
-"\n"         \
-" detects W-simple points in a 2D binary image\n"         \
-"\n"         \
-"Usage: ptWsimple in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The argument  connex selects the connectivity (4, 8 in 2D).\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: connect\n"         \
-"  connect\n"         \
-"\n"         \
-" Jean Cousty (2007)\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__gradill__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__compiling_windows__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__countvalues__c__ "  countvalues.c\n"         \
-"\n"         \
-" counts the number of distinct values of an image or a region\n"         \
-"\n"         \
-"Usage: countvalues in.pgm [mask.pgm] out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Counts the number of distinct values of  im.pgm (masked by the binary image\n"         \
-" mask.pgm, if given) and saves it in file  out.list .\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: histo\n"         \
-"  histo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__warp__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__2dflowskeleton__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__ecarttype__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__cropondisk__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__randpoints__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__printhisto__c__ "  printhisto.c\n"         \
-"\n"         \
-" prints the histogram of an image or a region\n"         \
-"\n"         \
-"Usage: printhisto in.pgm [mask.pgm]\n"         \
-"\n"         \
-"Description:\n"         \
-"Calculates the histogram of  im.pgm (masked by the binary image\n"         \
-" mask.pgm, if given) and prints it on the screen.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: histo\n"         \
-"  histo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__explodecomp__c__ "  explodecomp.c\n"         \
-"\n"         \
-" converts single 2D pgm file into a series of 2D pgm files,\n"         \
-"  where each file of the series contains one component of the original image\n"         \
-"\n"         \
-"Usage: explodecomp in.pgm connex {min|max|pla} name_prefix\n"         \
-"\n"         \
-"Description:\n"         \
-"Generated file names are of the form: name_prefixnnnn.pgm, \n"         \
-"where nnnn is a four digit decimal integer. \n"         \
-"The argument  connex selects the connectivity (4, 8 in 2D; 6, 18, 26 in 3D).\n"         \
-"The argument  selects the kind of flat zone\n"         \
-"to be labeled:\n"         \
-"  min selects regional minima (or background components for a binary image)\n"         \
-"  max selects regional maxima (or foreground components for a binary image)\n"         \
-"  pla selects all flat zones (plateaux).\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_NK2__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__genplane__c__ "  genplane.c\n"         \
-"\n"         \
-" generates a plane normal to one of the directions x,y,z\n"         \
-"\n"         \
-"Usage: genplane rs cs ds dir n out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The size of the result image out.pgm is given by the parameters \n"         \
-"rs, cs, ds.\n"         \
-"The parameter dir is set to x, y, or z.\n"         \
-"The parameter n is an integer.\n"         \
-"The output binary image out.pgm contains the plane defined by dir=n.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__segmentlignes__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__circular_measure__cpp__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lfdilat3d_rect__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__geoeros__c__ "  geoeros.c\n"         \
-"\n"         \
-" geodesic (grayscale or binary) erosion\n"         \
-"\n"         \
-"Usage: geoeros g.pgm f.pgm connex niter out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Geodesic erosion of g.pgm over f.pgm.\n"         \
-"Let G and F be the two input images. If G is not over F, then \n"         \
-"G is replaced initially by max(G,F).\n"         \
-"The structuring element is specified by the value of the parameter connex, \n"         \
-"which can be one of the following ones: 4, 8 in 2d, or 6, 18, 26 in 3d.\n"         \
-"The parameter  niter sets the number of iterations. If  niter = -1,\n"         \
-"then the iterations continue until stability.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d.\n"         \
-"\n"         \
-"Category: connect, morpho\n"         \
-"  connect, morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__add__c__ "  add.c\n"         \
-"\n"         \
-" pixelwise addition of two images\n"         \
-"\n"         \
-"Usage: add in1.pgm in2.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = in1[x] + in2[x]. If both images are byte images,\n"         \
-"and if out[x] exceeds 255, then out[x] is set to 255.\n"         \
-"Images must be of the same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__visu3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__ppm2GA__c__ "  ppm2GA.c\n"         \
-"\n"         \
-" Computes an edge-weighted graph from an color .ppm image\n"         \
-"\n"         \
-"Usage: ppm2GA im.ppm param out.ga \n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Computes a GA (an edge-weighted graph) from a color image. The values\n"         \
-"of an edge linking two pixels {x,y} is computed according to the\n"         \
-"parameter param.\n"         \
-" \n"         \
-"If param = 0, the maximum, over the RGB chanels, of absolute\n"         \
-"differences of intensities between x and y is used.\n"         \
-"\n"         \
-"If param = 1, the Euclidean distance between the values of x and y is\n"         \
-"used.\n"         \
-"\n"         \
-"If param = 2, fuzzy affinity between x and y is used.\n"         \
-"\n"         \
-"If im.ppm is a 2D (resp. 3D) image, then out.ga is a 2D (resp\n"         \
-"3D GA), that is a 2D 4-connected edge-weighted graph (resp. a 2D\n"         \
-"6-connected edge-weighted graph).\n"         \
-"\n"         \
-"\n"         \
-"Types supported: ppm 2D\n"         \
-"\n"         \
-"Category: \n"         \
-"  GA\n"         \
-"\n"         \
-" Jean Cousty\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__measure__cpp__ "\n"         \
-"    measure.cpp\n"         \
-"\n"         \
-"    Normalized absolute measure calculated from the image.\n"         \
-"   \n"         \
-"   Usage: measure( (float_image)image) -> float_image\n"         \
-"   \n"         \
-"   Description: \n"         \
-"\n"         \
-"   Types supported: float 2d, float 3d\n"         \
-"   \n"         \
-"   Category: signal, development\n"         \
-"    signal, development\n"         \
-"\n"         \
-"   References:\n"         \
-"   [1]  GNU Scientific Library \n"         \
-"    Laszlo Marak, 2009-2010\n"         \
-"\n"         \
-" \n"         \
-"\n"
-
-
-#define doc__sceneconvert__c__ "  sceneconvert.c\n"         \
-"\n"         \
-" converts a 3D scene into another format\n"         \
-"\n"         \
-"Usage: sceneconvert in.3sc format out\n"         \
-"\n"         \
-"Description:\n"         \
-"The file  scene.3sc contains a scene under the 3Dscene format.\n"         \
-"\n"         \
-"The parameter  format indicate the format of the output file \n"         \
-"(choices are POV, POVB).\n"         \
-"The keyword POVB corresponds to a bare Povray mesh: a header and a footer must be\n"         \
-"catenated in order to make a full Povray scene. \n"         \
-"\n"         \
-"Types supported: 3D scene\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__htkernu3d___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__volselnb__c__ "  volselnb.c\n"         \
-"\n"         \
-" volume based segmentation by selection of a given number or components\n"         \
-"\n"         \
-"Usage: volselnb in.pgm connex nb out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Segmentation by selection of a given number or components, based on a \n"         \
-"volume criterion. \n"         \
-"Connexity = connex ; desired number of components = nb.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__hls2rgb__c__ "  hls2rgb.c\n"         \
-"\n"         \
-" converts from hls to rgb color representation\n"         \
-"\n"         \
-"Usage: hls2rgb H.pgm L.pgm S.pgm out.ppm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Constructs 1 ppm from 3 pgm files:\n"         \
-"   H.pgm : Hue (int32_t - 0 to 359)\n"         \
-"   L.pgm : Luminance (byte)\n"         \
-"   S.pgm : Saturation (byte)\n"         \
-"Some particular values of HUE:\n"         \
-"     0  red\n"         \
-"    60  yellow\n"         \
-"   120  green\n"         \
-"   180  cyan\n"         \
-"   240  blue\n"         \
-"   300  magenta\n"         \
-"Based on Foley, Van Damm & al: \"Computer Graphics\", 2nd ed., p. 595\n"         \
-"\n"         \
-"Types supported: int32_t 2D (hue), byte 2D (others)\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__car2pol__c__ "  car2pol.c\n"         \
-"\n"         \
-" converts a 2d image from cartesian to polar coordinates\n"         \
-"\n"         \
-"Usage: in x_center y_center out \n"         \
-"\n"         \
-"Description:\n"         \
-"Converts a 2d image from cartesian to polar coordinates.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__enframe__c__ "  enframe.c\n"         \
-"\n"         \
-" adds a border with a given gray value to an image\n"         \
-"\n"         \
-"Usage: enframe in.pgm [grayvalue [width [out.pgm]]]\n"         \
-"\n"         \
-"Description:\n"         \
-"Adds a border to the input image, filled with the value  grayvalue (default 0). \n"         \
-"The width of the border may be given as parameter  width, \n"         \
-"otherwise its value is 1.\n"         \
-"\n"         \
-"If  out.pgm is not specified, then out.pgm = in.pgm.\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d, float 2d, byte 3d, int32_t 3d, float 3d.\n"         \
-"\n"         \
-"Category: convert, geo\n"         \
-"  convert, geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__convol__c__ "  convol.c\n"         \
-"\n"         \
-" convolution\n"         \
-"\n"         \
-"Usage: convol in.pgm kernel.pgm [mode] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Convolution of  in.pgm by kernel.pgm.\n"         \
-"The result is a float image.\n"         \
-"Depending on the value given for the (optional) parameter mode:\n"         \
-"   mode = 0 (default) : naive algorithm. \n"         \
-"      The image  in.pgm is considered as null out of its support. \n"         \
-"   mode = 1 : naive algorithm. \n"         \
-"      The boundary of image  in.pgm is extended outside its support.\n"         \
-"   mode = 2 : convolution using the FFT.\n"         \
-"      The image  in.pgm is considered as null out of its support. \n"         \
-"   mode = 3 : convolution using the FFT.\n"         \
-"      The boundary of image  in.pgm is extended outside its support.\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d, float 2d\n"         \
-"\n"         \
-"Category: signal\n"         \
-"  signal\n"         \
-"\n"         \
-"\n"         \
-"Naive convolution algorithm is in O(|in|*|kernel|). \n"         \
-"For large kernels, use FFT version which is in \n"         \
-"O(n log n) where n = max(|in|,|kernel|)\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lthin__c__ "  lthin.c\n"         \
-"\n"         \
-" grayscale leveling thinning\n"         \
-"\n"         \
-"Usage: lthin in.pgm {imcond.pgm|null} connex niter out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Grayscale leveling thinning (refs. [BEC97, CBB01]).\n"         \
-"The parameter  connex gives the connectivity used for the minima;\n"         \
-"possible choices are 4, 8 in 2D and 6, 26 in 3D.\n"         \
-"Let F be the function corresponding to the input image  in.pgm.\n"         \
-"Let G be the function corresponding to the input image \n"         \
-" imcond.pgm, or the null function if the keyword  null is used.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat niter times:\n"         \
-"    L = {(p,a) such that T--(p,F) = 1 and a = alpha-(p,F)}\n"         \
-"    While L not empty\n"         \
-"       extract a couple (p,a) from L\n"         \
-"       F(p) = max{ a, alpha-(p,F), G(p) }    \n"         \
-"Result: F\n"         \
-"\n"         \
-"\n"         \
-"If  niter is set to -1, then the operator iterates until stability.\n"         \
-"\n"         \
-"References: \n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D.\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"lthin ur1 null 4 -1 ur1_lthin\n"         \
-"minima ur1_lthin 4 ur1_lthin_m\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"      \n"         \
-"  \n"         \
-"  ur1\n"         \
-"      ur1_lthin\n"         \
-"      ur1_lthin_m\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__catgif__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__offset__c__ "  offset.c\n"         \
-"\n"         \
-" image translation \n"         \
-"\n"         \
-"Usage: in.pgm ox oy oz [mode] out.ppm\n"         \
-"\n"         \
-"Description:\n"         \
-"Translates the image by the offsets  ox,  oy,  oz in the directions\n"         \
-"x, y, z respectively. Offsets may be negative or positive integers.\n"         \
-"If  mode is 0, the points that get out of the image frame are lost. \n"         \
-"If  mode is 1, a torical space is simulated in all dimensions. \n"         \
-"Default mode is 0.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__area__c__ "  area.c\n"         \
-"\n"         \
-" return the number of non-null pixels of an image\n"         \
-"\n"         \
-"Usage: area in.pgm [out.list]\n"         \
-"\n"         \
-"Description:\n"         \
-"This function returns (in the list out.list) \n"         \
-"the number of non-null pixels of the image  in.pgm .\n"         \
-"\n"         \
-"If the parameter  out.list is ommitted, the result is printed on the standard output.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__amont__c__ "  amont.c\n"         \
-"\n"         \
-" amont of a binary marker in a grayscale image\n"         \
-"\n"         \
-"Usage: amont in.pgm mark.pgm connex [s] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let F be the function defined by  in.pgm, \n"         \
-"let X be the set defined by  mark.pgm.\n"         \
-"The amont of X in F is defined as the set of points x such that there exists\n"         \
-"an ascending path from X to x for F with connectivity connex.\n"         \
-"If the parameter s is given, then only strictly ascending paths are \n"         \
-"considered.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__htkernu__c__ "  htkernu.c\n"         \
-"\n"         \
-" grayscale ultimate homotopic thickening\n"         \
-"\n"         \
-"Usage: htkernu in.pgm {imcond.pgm|null} connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Grayscale ultimate homotopic thickening (refs. [BEC97, CBB01]).\n"         \
-"The parameter  connex gives the connectivity used for the minima;\n"         \
-"possible choices are 4, 8 in 2D and 6, 26 in 3D.\n"         \
-"Let F be the function corresponding to the input image  in.pgm.\n"         \
-"Let G be the function corresponding to the input image \n"         \
-" imcond.pgm, or the null function if the keyword  null is used.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat until stability:\n"         \
-"    select p constructible for F such that F(p) is maximal\n"         \
-"    F(p) = min{ delta+(p,F), G(p) }    \n"         \
-"Result: F\n"         \
-"\n"         \
-"\n"         \
-"References: \n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D.\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__volume__c__ "  volume.c\n"         \
-"\n"         \
-" return the sum of the pixel values of an image\n"         \
-"\n"         \
-"Usage: volume in.pgm out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"This function returns (in the list out.list) \n"         \
-"the sum of the pixel values of the image  in.pgm .\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pthseparatinggray__c__ "  pthseparatinggray.c\n"         \
-"\n"         \
-" detects h-separating points in a grayscale image\n"         \
-"\n"         \
-"Usage: pthseparatinggray in.pgm connex h out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"An h-separating point for an image F is a point p, \n"         \
-"such that there exists c verifying F(p)-h \n"         \
-"#CC(X inter N(p)) > 1, with X = {x | F(x) \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie 2010\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__labelfgd__c__ "  labelfgd.c\n"         \
-"\n"         \
-" labeling of the foreground components of a binary image\n"         \
-"\n"         \
-"Usage: labelfgd in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Each connected component of  in.pgm is labeled with a unique integer, starting from 1. The background points are labeled by 0.\n"         \
-"The argument  connex selects the connectivity (4, 8 in 2D; 6, 18, 26 in 3D).\n"         \
-"The output image  out.pgm has the type \"int32_t\".\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-"  connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__asftmed__c__ "  asftmed.c\n"         \
-"\n"         \
-" alternate sequential filter controled by topology\n"         \
-"\n"         \
-"Usage: asftmed in.pgm connex rmax out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Alternate sequential filter controled by topology (see [CB04]).\n"         \
-"Disc- or Ball-shaped structuring elements of increasing radius,\n"         \
-"ranging from 1 to rmax,\n"         \
-"are generated. Let D1...Dn be these structuring elements, sorted by increasing radius.\n"         \
-"Let I(0) = in.pgm, the ith intermediate result I(i) is obtained by the \n"         \
-"homotopic pseudo-closing of the homotopic pseudo-opening of I(i-1) by the structuring element Di. \n"         \
-"Furthermore, the medial axes (distance 8 in 2D, 26 in 3D) of both the input image and its inverse \n"         \
-"are used as constraint sets.\n"         \
-"The result out.pgm contains the final result I(n).\n"         \
-"\n"         \
-"Reference: \n"         \
-"[CB04] M. Couprie and G. Bertrand:\n"         \
-"Topology preserving alternating sequential filter for smoothing \n"         \
-"2D and 3D objects,  Journal of Electronic Imaging, Vol.&nbsp;13, No.&nbsp;4, pp.&nbsp;720-730, 2004.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho, topobin\n"         \
-"  morpho, topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__text___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__pgm2list1d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__erosplan__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__skelendlab__c__ "  skelendlab.c\n"         \
-"\n"         \
-" homotopic skeleton of a 2d or 3d label image with dynamic detection of end points\n"         \
-"\n"         \
-"Usage: skelendlab in.pgm connex [n] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Homotopic skeletonization by iterative removal of simple, non-end points. \n"         \
-"Each label is treated separately as a binary image.\n"         \
-"Breadth-first strategy.\n"         \
-"During the first  n iterations (default 0), the end points\n"         \
-"are removed as well.\n"         \
-"If  n = -1, the end points are always removed.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" This operator is very sensitive to small contour irregularities. \n"         \
-"See skelcurv for a more robust operator. Useful for reducing quasi-curvilinear objects.\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__distc__c__ "  distc.c\n"         \
-"\n"         \
-" distance transform (internal)\n"         \
-"\n"         \
-"Usage: distc in.pgm mode out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Distance to the complementary of the object X defined by the binary \n"         \
-"image  in.pgm .\n"         \
-"The result function DX(x) is defined by: DX(x) = min {d(x,y), y not in X}.\n"         \
-"\n"         \
-"The distance d used depends on the parameter  mode :\n"         \
-" 0: euclidean distance (rounded to the nearest int32)\n"         \
-" 1: approximate quadratic euclidean distance (Danielsson)\n"         \
-" 2: chamfer distance ([5,7] in 2D; [4,5,6] in 3D)\n"         \
-" 3: exact quadratic euclidean distance (int32)\n"         \
-" 4: 4-distance in 2d\n"         \
-" 5: exact euclidean distance (float)\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-" 40: 4-distance in 2d (byte coded ouput)\n"         \
-" 80: 8-distance in 2d (byte coded ouput)\n"         \
-" 60: 6-distance in 3d (byte coded ouput)\n"         \
-" 180: 18-distance in 3d (byte coded ouput)\n"         \
-" 260: 26-distance in 3d (byte coded ouput)\n"         \
-"\n"         \
-"The output  out.pgm is of type int32_t for modes \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie, Xavier Daragon\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgmascmode__c__ "  pgmascmode.c\n"         \
-"\n"         \
-" converts a pgm file to ascii mode\n"         \
-"\n"         \
-"Usage: pgmascmode filename [outfilename | \"wh\" outfilename]\n"         \
-"\n"         \
-"Description: Converts a pgm file to ascii mode.\n"         \
-"If only parameter  filename is given, then the result\n"         \
-"is also named  filename .\n"         \
-"If the keyword \"wh\" is used as second parameter (stands for \"without header\"), then \n"         \
-"an ascii file without header is produced.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dilatnum__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__compiling_make__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lambdapmedialaxis__c__ "  lambdapmedialaxis.c\n"         \
-"\n"         \
-" discrete lambda-medial axis transform (cheaper variant)\n"         \
-"\n"         \
-"Usage: lambdapmedialaxis in.pgm [lambda] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Discrete lambda-medial axis of the binary image  X contained in  in.pgm. \n"         \
-"If the parameter  lambda is given, the output is a binary image. Otherwise, \n"         \
-"it is a float image representing the function x->lambda(x).\n"         \
-"\n"         \
-" Experimental.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__average1__c__ "  average1.c\n"         \
-"\n"         \
-" return the average of the pixel values of an image\n"         \
-"\n"         \
-"Usage: average1 in.pgm [mask.pgm] out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"This function returns (in the list out.list) \n"         \
-"the average of the pixel values of the image  in.pgm .\n"         \
-"If the optional parameter  mask.pgm is given, then only the \n"         \
-"values which correspond to non-null points of mask are averaged.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: signal stats\n"         \
-"  signal stats\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__isnull__c__ "  isnull.c\n"         \
-"\n"         \
-" nullity test\n"         \
-"\n"         \
-"Usage: isnull in.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"This function returns 1 (no error) if for each pixel x, in[x] == 0; \n"         \
-"otherwise it returns 0.\n"         \
-"Images must be of the same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__watershedwithoutlinelab__c__ "  watershedwithoutlinelab.c\n"         \
-"\n"         \
-" watershed transformation without line of separation from labelled marker\n"         \
-"\n"         \
-"Usage: watershedwithoutlinelab in mark {roi|null} connex out\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs the watershed transformation on the image in, taking the\n"         \
-"labelled marker in mark. \n"         \
-"If this parameter is present, roi\n"         \
-"indicates the region of interest on which the operation is performed.\n"         \
-"The parameter connex gives the adjacency relation (4,8 in 2D; 6,18,26 in 3D) \n"         \
-"for the makers.\n"         \
-"\n"         \
-"The image mark is a label image (int32_t)\n"         \
-"\n"         \
-"The image out is a label image (int32_t)\n"         \
-"\n"         \
-"This version does not create any line to separate the catchment basins. \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie and Laurent Najman\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__2dborder__c__ "  2dborder.c\n"         \
-"\n"         \
-" extracts the border of an object in H2\n"         \
-"\n"         \
-"Usage: 2dborder in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Extracts the border of an object in H2. The (internal) border is defined as the set \n"         \
-"of the object points which have at least one neighboring background point. \n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topo \n"         \
-"  topo \n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawfield__c__ "  drawfield.c\n"         \
-"\n"         \
-" draw line segments that represent a vector field\n"         \
-"\n"         \
-"Usage: drawfield in.pgm [len] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The file  in.pgm contains a vector field. This operator generates a (binary) image where each vector is represented by a straight line segment of length  len (default 10).\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: draw\n"         \
-"  draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dilatfast__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__histscal__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__proj3d__c__new__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__mcmbuild__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__readgif__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__log__c__ "  log.c\n"         \
-"\n"         \
-" pixelwise logarithm\n"         \
-"\n"         \
-"Usage: log in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = log(in[x]).\n"         \
-"\n"         \
-"Types supported: float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__simplepair__c__ "  simplepair.c\n"         \
-"\n"         \
-" detects simple pairs in a 3D binary image\n"         \
-"\n"         \
-"Usage: simplepair in.pgm [all] out.pgm\n"         \
-"\n"         \
-"Note:  in the python front-end the parameter 'all' is mandatory, if 0 at most \n"         \
-"one simple pair is found, if it's 1 all simple pairs are looked for\n"         \
-"\n"         \
-"Description:\n"         \
-"Detects simple pairs in a 3D binary image. \n"         \
-"If the optional parameter  all is used, then all simple pairs are searched. \n"         \
-"Otherwise, only one pair (if any) is given.\n"         \
-"\n"         \
-"Reference: \n"         \
-"[PCB08] Nicolas Passat, Michel Couprie, and Gilles Bertrand:\n"         \
-"\"Minimal simple pairs in the 3D cubic grid\", in\n"         \
-"Journal of Mathematical Imaging and Vision, 32 (3), pp.&nbsp;239â249, November 2008.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2008\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgm2raw__c__ "  pgm2raw.c\n"         \
-"\n"         \
-" suppress the header from a pgm file\n"         \
-"\n"         \
-"Usage: pgm2raw in.pgm out.raw\n"         \
-"\n"         \
-"Description: suppress the header from a pgm file\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, short 2d, short 3d, long 2d, long 3d, float 2d, float 3d, double 2d, double 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__threshold__c__ "  threshold.c\n"         \
-"\n"         \
-" simple threshold\n"         \
-"\n"         \
-"Usage: threshold in.pgm n [n2] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"If n2 is not present, for each pixel x, out[x] = if (in[x] \n"         \
-"\n"         \
-"If n2 is present, for each pixel x, out[x] = if (n \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie 2010\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__sub__c__ "  sub.c\n"         \
-"\n"         \
-" substracts an image from another one\n"         \
-"\n"         \
-"Usage: sub in1.pgm in2.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = in1[x] - in2[x]. \n"         \
-"For byte and int32_t image types, if out[x] \n"         \
-"Images must be of the same type and same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__despuits3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__rotatebin__c__ "  rotatebin.c\n"         \
-"\n"         \
-" rotation of an image\n"         \
-"\n"         \
-"Usage: rotatebin in.pgm theta [x y] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"rotates the image  in.pgm of the angle  theta (in degrees).\n"         \
-"Method: truncated real rotation.\n"         \
-"If  x and  y are given, then the center of the rotation is the point \n"         \
-"(x,y) and the image size is left unchanged (hence parts of object \n"         \
-"may be lost). \n"         \
-"Otherwise, the center of the rotation is the point (0,0) and the resulting \n"         \
-"image size is computed such that no loss of information occur.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__minimalsimplepair__c__ "  minimalsimplepair.c\n"         \
-"\n"         \
-" detects minimal simple pairs in a 3D binary image\n"         \
-"\n"         \
-"Usage: minimalsimplepair in.pgm [all] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Detects minimal simple pairs in a 3D binary image. \n"         \
-"If the optional parameter  all is used, then all \n"         \
-"minimal simple pairs are searched.\n"         \
-"Otherwise, only one pair (if any) is given.\n"         \
-"\n"         \
-"If the input image contains no simple point, consider using \"simplepair\" (faster)\n"         \
-"instead of \"minimalsimplepair\".\n"         \
-"\n"         \
-"Reference: \n"         \
-"[PCB08] Nicolas Passat, Michel Couprie, and Gilles Bertrand:\n"         \
-"\"Minimal simple pairs in the 3D cubic grid\", in\n"         \
-"Journal of Mathematical Imaging and Vision, 32 (3), pp.&nbsp;239â249, November 2008.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2008\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__python_export__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__meshoffset__c__ "  meshoffset.c\n"         \
-"\n"         \
-" applies an offset to all points of a mesh (translation)\n"         \
-"\n"         \
-"Usage: meshoffset in [ox oy oz] out\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Applies an offset to all points of a mesh (translation). \n"         \
-"Available input formats: vtk.\n"         \
-"Available output formats: vtk.\n"         \
-"\n"         \
-"Types supported: mesh 3d\n"         \
-"\n"         \
-"Category: mesh3d\n"         \
-"  mesh3d\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__2dlabel__c__ "  2dlabel.c\n"         \
-"\n"         \
-" labels the theta-connected component of a 2D Khalimsky order\n"         \
-"\n"         \
-"Usage: 2dlabel in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Labels the theta-connected component of a 2D Khalimsky order.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__rankmaxopening__c__ "  rankmaxopening.c\n"         \
-"\n"         \
-" rank-max opening \n"         \
-"\n"         \
-"Usage: rankmaxopening in.pgm el.pgm r out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let F be the input image, G be the output image, and E the structuring\n"         \
-"element.\n"         \
-"\n"         \
-"The rank-max opening [Ron86]\n"         \
-"of structuring element $E$ and parameter  r in [0...1]\n"         \
-"may be defined by G = min(F,dilation(rankfilter(F,E,1-r),E))\n"         \
-"\n"         \
-"[Ron86] C. Ronse:\n"         \
-"\"Erosion of narrow image features by combination of local low rank and max filters\",\n"         \
-"Proc. 2nd Int. Conf. on Image Processing and int32_t Applications,\n"         \
-"pages 77-81, 1986.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-" morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__longestplateau__c__ "  longestplateau.c\n"         \
-"\n"         \
-" finds the location of the longest plateau in 1D sequence\n"         \
-"\n"         \
-"Usage: longestplateau in.list [tolerance] out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Reads the sequence S from the file in.list. \n"         \
-"This file must have the following format:\n"         \
-"  \n"         \
-"  e &lt;n&gt;\n"         \
-"  x1\n"         \
-"  x2\n"         \
-"  ...\n"         \
-"  xn\n"         \
-"\n"         \
-"The tolerance t (float) is given by the parameter tolerance\n"         \
-"(default value is 0).\n"         \
-"A plateau is a subsequence P of S formed by consecutive elements of P, \n"         \
-"between indices i and j, and such that max{P[k];i\n"         \
-"The program returns the base index and length of the first occurence of a plateau with \n"         \
-"maximal length in S.\n"         \
-"\n"         \
-"Types supported: list 1D\n"         \
-"\n"         \
-"Category: signal\n"         \
-" signal\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__gradsup__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lfopen3d_rect__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__identifyparabola3__c__ "  identifyparabola3.c\n"         \
-"\n"         \
-" identification of a best matching parabola from a set of 2D points\n"         \
-"\n"         \
-"Usage: identifyparabola3 in.list out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Identifies the parameters (a,b,c) of the equation of the 2D parabola:\n"         \
-"ax^2+bx+c=y that minimizes the least square error between this parabola \n"         \
-"and the given points. Method: basic linear regression.\n"         \
-"\n"         \
-"Types supported: list 1D, list 2D\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__interpolate__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__pgm2list__c__ "  pgm2list.c\n"         \
-"\n"         \
-" converts from pgm format to list format\n"         \
-"\n"         \
-"Usage: pgm2list image.pgm {e|s|b|n|B|N} out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Converts from pgm format to list format:\n"         \
-" e: set of points\n"         \
-" s: 1d digital signal\n"         \
-" b: binary 2D image\n"         \
-" n: grayscale 2D image\n"         \
-" B: binary 3D image\n"         \
-" N: grayscale 3D image\n"         \
-"\n"         \
-"In formats  e,  b and  B, only the points with non-null values are \n"         \
-"considered.\n"         \
-"\n"         \
-"In formats  s,  n and  N, all the points (even those having a \n"         \
-"null value) are considered.\n"         \
-"\n"         \
-"Summary of list formats:\n"         \
-"  \n"         \
-"  e &lt;n&gt;       s &lt;n&gt;         b &lt;n&gt;         n &lt;n&gt;            B &lt;n&gt;            N &lt;n&gt;    \n"         \
-"  x1          x1 v1         x1 y1         x1 y1 v1         x1 y1 z1         x1 y1 z1 v1\n"         \
-"  x2    or    x2 v2   or    x2 y2   or    x2 y2 v2   or    x2 y2 z2   or    z2 x2 y2 v2\n"         \
-"  ...         ...           ...           ...              ...              ...\n"         \
-"  xn          xn vn         xn yn         xn yn vn         xn yn z3         z3 xn yn vn\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D, int32_t 2D, int32_t 3D, float 2D, float 3D\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__short2float__c__ "  short2float.c\n"         \
-"\n"         \
-" converts a \"short\" image to a \"float\" image\n"         \
-"\n"         \
-"Usage: short2float in [out]\n"         \
-"\n"         \
-"Description: \n"         \
-"\n"         \
-"For each pixel x, out[x] = (float)in[x]\n"         \
-"\n"         \
-"If the last argument  out is omitted, then out = in.\n"         \
-"\n"         \
-"Types supported: short 2d, short 3d.\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__rgb2hls__c__ "  rgb2hls.c\n"         \
-"\n"         \
-" converts a ppm color file to hls representation\n"         \
-"\n"         \
-"Usage: in.ppm [mode] h.pgm l.pgm s.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Constructs 3 pgm files from 1 ppm file:\n"         \
-" h.pgm : Hue (int32_t - 0 to 359)\n"         \
-" h.pgm : Luminance (byte)\n"         \
-" h.pgm : Saturation (byte)\n"         \
-"\n"         \
-"Different modes are available [default mode is 0]:\n"         \
-" mode = 0: classical HLS coding, based on [1].\n"         \
-" mode = 1: L1 norm (NYI) (see [2])\n"         \
-" mode = 2: L1 norm with gamma correction (NYI) (see [2])\n"         \
-"\n"         \
-"[1] Foley, Van Damm & al: \"Computer Graphics\", 2nd ed., p. 595\n"         \
-"\n"         \
-"[2] J. Angulo and J. Serra. \"Traitements des images de couleur \n"         \
-"en représentation luminance/saturation/teinte par norme L_1\" (in French). \n"         \
-"Traitement du Signal, Vol. 21, No. 6, pp 583-604, December 2004.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__taf__c__sav__ "  taf.c\n"         \
-"\n"         \
-" topological alternating filter\n"         \
-"\n"         \
-"Usage: taf in.pgm connexmin rayon out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Topological alternating filter (cf. CB04: to appear)\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topo\n"         \
-"  topo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__heightmaxima__c__ "  heightmaxima.c\n"         \
-"\n"         \
-" h-maxima operator\n"         \
-"\n"         \
-"Usage: heightmaxima in.pgm connex height out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"h-maxima with connexity connex and depth height.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ombre__c__ "  ombre.c\n"         \
-"\n"         \
-" binary shadow of a grayscale function\n"         \
-"\n"         \
-"Usage: ombre in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The shadow of a 1D grayscale image is a 2D binary image.\n"         \
-"The shadow of a 2D grayscale image is a 3D binary image.\n"         \
-"\n"         \
-"Types supported: byte 1d, byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__grid__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__argmin__c__ "  argmin.c\n"         \
-"\n"         \
-" return the coordinates of a pixel having the minimal value\n"         \
-"\n"         \
-"Usage: argmin in.pgm [out.list]\n"         \
-"\n"         \
-"Description:\n"         \
-"This function returns (in the list out.list) \n"         \
-"coordinates of a pixel having the minimal value in the image  in.pgm .\n"         \
-"\n"         \
-"If the parameter  out.list is ommitted, the result is printed on the standard output.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ellipseparams__c__ "  ellipseparams.c\n"         \
-"\n"         \
-" ellipse identification and main parameter computation\n"         \
-"\n"         \
-"Usage: ellipseparams pts.list out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Identifies the ellipse E which minimizes the sum of the (approximate) distances\n"         \
-"between the points in  pts.list and E. \n"         \
-"The output is a list containing 6 numbers: a1, a2, r1, r2, r3, r4\n"         \
-"where a1 is the half of the big axis length, a2 is the\n"         \
-"the half of the little axis length, and each ri is the mean \"distance\",\n"         \
-"for quadrant i, between intput points and the computed ellipse \n"         \
-"(the expected value for points forming a perfect ellipse is 0)\n"         \
-"\n"         \
-"Ref: \n"         \
-"Andrew W. Fitzgibbon, Maurizio Pilu, and Robert B. Fisher\n"         \
-"Direct least-squares fitting of ellipses,\n"         \
-"IEEE Transactions on Pattern Analysis and Machine Intelligence, 21(5), 476--480, May 1999\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawtriangulation__c__ "  drawtriangulation.c\n"         \
-"\n"         \
-" draw a triangulation\n"         \
-"\n"         \
-"Usage: drawtriangulation in.list in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Reads a triangulation in file in.list under the following format:\n"         \
-"\n"         \
-"    G &lt;n&gt;\n"         \
-"    x1 y1 v1 ec1 ns1 s11 s12 ... s1ns1\n"         \
-"    x2 y2 v2 ec2 ns2 s21 s22 ... s1ns2\n"         \
-"    ...\n"         \
-"    xn yn vn ecn nsn sn1 sn2 ... s1nsn\n"         \
-"  \n"         \
-"where xi, yi are the coordinates of the ith vertex, vi is the associated \n"         \
-"value (if given in the input file), eci is a int32_t which indicates \n"         \
-"whether the vertex i belongs to the convex hull, nsi denotes the number\n"         \
-"of adjacent vertices, and si1 si2 ... sins1 is the list of the indexes of\n"         \
-"the adjacent vertices (counted from 0).\n"         \
-"\n"         \
-"Draws the triangulation in image in.pgm, output image is out.pgm\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"See also: delaunay.c\n"         \
-"\n"         \
-"Category: geo, draw\n"         \
-"  geo, draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__fits2pgm__o__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__histopgm__c__ "  histopgm.c\n"         \
-"\n"         \
-" histogram of the gray values\n"         \
-"\n"         \
-"Usage: histopgm in.pgm [mask.pgm] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Generates a binary image which contains the graphical representation\n"         \
-"of the histogram of  in.pgm (masked by the binary image\n"         \
-" mask.pgm, if given).\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: histo\n"         \
-"  histo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__compiling_cmake__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__watershedwithoutline__c__ "  watershedwithoutline.c\n"         \
-"\n"         \
-" watershed transformation without line of separation\n"         \
-"\n"         \
-"Usage: watershedwithoutline in mark {bgmark|null} {roi|null} connex out\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs the watershed transformation on the image in, taking the\n"         \
-"set of markers in mark. \n"         \
-"If this parameter is present, bgmark\n"         \
-"is used as a set of markers for the background.\n"         \
-"If this parameter is present, roi\n"         \
-"indicates the region of interest on which the operation is performed.\n"         \
-"The parameter connex gives the adjacency relation (4,8 in 2D; 6,18,26 in 3D) \n"         \
-"for the makers.\n"         \
-"\n"         \
-"The image out is a label image (int32_t)\n"         \
-"\n"         \
-"This version does not create any line to separate the catchment basins. \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie and Laurent Najman\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__gaussianfilter__c__ "  gaussianfilter.c\n"         \
-"\n"         \
-" Gaussian filter operator\n"         \
-"\n"         \
-"Usage: gaussianfilter in.pgm alpha out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Deriche's recursive implementation of the smoothing filter\n"         \
-"operator (approximates the convolution with a Gaussian kernel). \n"         \
-"The parameter  alpha (double) controls the spatial extension of the\n"         \
-"filter: 0 \n"         \
-"Intuitively, the \"width\" of the Gaussian kernel corresponds to 1/ alpha.\n"         \
-"\n"         \
-"Reference: \n"         \
-"[Der90] R. Deriche, \"Fast algorithms for low-level vision\",\n"         \
-"IEEE Transactions on PAMI, 12(1), 78-87, 1990.\n"         \
-"\n"         \
-"Types supported: byte 2d, long 2d, float 2d, byte 3d, long 3d, float 3d\n"         \
-"\n"         \
-"Category: signal\n"         \
-"  signal\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__fmm__c__ "  fmm.c\n"         \
-"\n"         \
-" fast marching method\n"         \
-"\n"         \
-"Usage: fmm speed.pgm seeds.pgm stop threshold seedout.pgm distanceout.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"The fast marching method of J.A. Sethian is a geodesic distance transform.\n"         \
-"It integrates the constant arrival hyperbolic PDE. A rough physical analogy\n"         \
-"is the following: Assume an anisotropic medium with varying propagation\n"         \
-"celerities, and waves starting from various seeds travelling through that\n"         \
-"medium. This function computes the successive arrival times of these\n"         \
-"waves, as well as the propagation of the initial labels. The successive\n"         \
-"arrival times are equivalent to a distance transform. The propagation\n"         \
-"of the label yield a partition similar to a Voronoi.\n"         \
-"\n"         \
-"If the speed function is constant and equal to 1, the arrival times would indeed\n"         \
-"be the Euclidean distance function and the partition the Euclidean Voronoi.\n"         \
-"Due to discretisation issue, the result is only approximately Euclidiean\n"         \
-"(to second order).\n"         \
-"\n"         \
-"Stopping criteria:\n"         \
-"stop is the stopping criteria :\n"         \
-"\n"         \
-" stop = 0 => no stop\n"         \
-" stop = 1 => stop on metric (if speed function >= threshold)\n"         \
-" stop = 2 => stop on distance (if distance > threshold)\n"         \
-"\n"         \
-"the threshold is given after.\n"         \
-"\n"         \
-"Types supported: integer, float Nd (N >= 2)\n"         \
-"speed must be float, seeds must be integer.\n"         \
-"\n"         \
-"Category: morpho\n"         \
-" morpho\n"         \
-"\n"         \
-" Hugues Talbot and Ben Appleton\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__histoelevation__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lpemeyer___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__openball__c__ "  openball.c\n"         \
-"\n"         \
-" morphological binary opening by a ball\n"         \
-"\n"         \
-"Usage: openball in.pgm r [dist] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The structuring element for this opening is a ball (or a disc) of radius  r.\n"         \
-"The opening consists in a erosion (erosball) followed by an dilation (dilatball).\n"         \
-"The erosion and dilation are computed by thresholding a distance map.\n"         \
-"The distance used depends on the optional parameter  dist (default is 0) :\n"         \
-" 0: rounded euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-" The input image  in.pgm must be a binary image. No test is done.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"openball cells 3 cells_openball\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"  \n"         \
-"  cells\n"         \
-"      cells_openball\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_ACK3__c__ "  skel_ACK3.c\n"         \
-"\n"         \
-" parallel 3D binary curvilinear, asymetric skeleton based on 3D and 2D residuals\n"         \
-"\n"         \
-"Usage: skel_ACK3 in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description: Parallel 3D binary thinning or curvilinear,\n"         \
-"asymetric skeleton based on 3D and 2D residuals. The parameter  nsteps\n"         \
-"gives, if positive, the number of parallel thinning steps to be\n"         \
-"processed.  If the value given for  nsteps equals -1, the thinning\n"         \
-"is continued until stability.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__t26pp__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__tuf__c__ "  tuf.c\n"         \
-"\n"         \
-" topological upper filter\n"         \
-"\n"         \
-"Usage: tuf in.pgm connexmin r out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Topological upper filter. Performs the homotopic thinning controlled by\n"         \
-"a radius r, followed by a peak deletion, and a homotopic reconstruction under\n"         \
-"the original image.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__houghcercles__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__ac2pink__c__ "  ac2pink.c\n"         \
-"\n"         \
-" converts a 3D scene from AC3D format to Pink 3Dscene format\n"         \
-"\n"         \
-"Usage: ac2pink in.ac out.3sc\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Reads the file in.ac. This file must be in the AC3D format.\n"         \
-"Generates the output file out.3sc in the 3Dscene format : \n"         \
-"\n"         \
-"FILE ::= '3Dscene' &lt;N&gt; &lt;OBJ&gt;*\n"         \
-"OBJ ::= &lt;LINE&gt; | &lt;CLOSEDLINE&gt; | &lt;SPLINE&gt; | &lt;CLOSEDSPLINE&gt; | &lt;POLYGON&gt;\n"         \
-"LINE ::= 'line' &lt;N&gt; &lt;POINT&gt;*\n"         \
-"CLOSEDLINE ::= 'closedline' &lt;N&gt; &lt;POINT&gt;*\n"         \
-"SPLINE ::= 'spline' &lt;N&gt; &lt;POINT&gt;*\n"         \
-"CLOSEDSPLINE ::= 'closedspline' &lt;N&gt; &lt;POINT&gt;*\n"         \
-"POLYGON ::= 'polygon' &lt;N&gt; &lt;POINT&gt;*\n"         \
-"N ::= ascii_coded_integer\n"         \
-"POINT ::= ascii_coded_float ascii_coded_float ascii_coded_float\n"         \
-"\n"         \
-"Types supported: AC3D\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dilatball__c__ "  dilatball.c\n"         \
-"\n"         \
-" morphological binary dilation by a ball\n"         \
-"\n"         \
-"Usage: dilatball in.pgm r [dist] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Morphological binary dilation by a metric ball.\n"         \
-"If the parameter  r is a positive integer, then\n"         \
-"the structuring element for this dilation is a ball (or a disc) of radius  r.\n"         \
-"In this case the result of the dilation is defined by Y = {x; d(x,X) \n"         \
-"represents the original point set (non-null pixels in the original image).\n"         \
-"If the parameter  r is -1, then \n"         \
-"the structuring element for each point x is a ball (or a disc) of radius  F(x),\n"         \
-"where F is the greyscale image  in.pgm .\n"         \
-"\n"         \
-"The dilation is computed by thresholding a distance map.\n"         \
-"The distance used depends on the optional parameter  dist (default is 0) :\n"         \
-" 0: rounded Euclidean distance\n"         \
-" 1: approximate quadratic Euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic Euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-" Except for the case r=-1, the input image  in.pgm must be a binary image. No test is done.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"dilatball cells 4 cells_dilatball\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"  \n"         \
-"  cells\n"         \
-"      cells_dilatball\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__directionalfilter__c__ "  directionalfilter.c\n"         \
-"\n"         \
-" directional filter for curvilinear feature extraction\n"         \
-"\n"         \
-"Usage: directionalfilter.c in.pgm width length ndir out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let F be the original image from  in.pgm .\n"         \
-"This operator computes the supremum of the convolutions of F\n"         \
-"by a series of kernels K0, ... Kn where n =  ndir - 1, which are defined\n"         \
-"by, for each (x,y) and each i in [0...n]: \n"         \
-"\n"         \
-"\n"         \
-"sigma = 1 / (2*width*width);\n"         \
-"lambda = 1 / (2*length*length);\n"         \
-"theta = i * PI / n;\n"         \
-"xr = cos(theta) * x - sin(theta) * y;\n"         \
-"yr = sin(theta) * x + cos(theta) * y;\n"         \
-"Ki(x,y) = exp(-lambda*yr*yr) *\n"         \
-"          (4*sigma*sigma*xr*xr - 2*sigma) * \n"         \
-"          exp(-sigma*xr*xr) \n"         \
-"\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d, float 2d\n"         \
-"\n"         \
-"Category: signal\n"         \
-"  signal\n"         \
-"\n"         \
-" Michel Couprie 2003\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__laplacian__c__ "  laplacian.c\n"         \
-"\n"         \
-" Laplacian operator\n"         \
-"\n"         \
-"Usage: laplacian in.pgm alpha out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Deriche's recursive implementation of the Laplacian\n"         \
-"operator. The parameter \n"         \
-" alpha (double) controls the spatial extension of the\n"         \
-"filter: 0 \n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: signal\n"         \
-"  signal\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ptjunction__c__ "  ptjunction.c\n"         \
-"\n"         \
-" detects junction points in 2d or 3d binary images\n"         \
-"\n"         \
-"Usage: ptjunction in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Detects junction points in the 2d or 3d binary image  in.pgm, which is supposed to contain a skeleton.\n"         \
-"A junction point is a white point x such that #(Nn[x] inter X) > 2, where Nn[x] stands for the n-neighborhood of x (excluding x), and n = 4, 8 in 2D or n = 6, 18, 26 in 3D, as set by the parameter  connex.\n"         \
-"\n"         \
-"When the type of  in.pgm is 4_BYTE, the image is treated as a label image, where each label is processed as a separate binary image (all other labels are considered as background).\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D, long 3D\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2010\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__hthick__c__ "  hthick.c\n"         \
-"\n"         \
-" grayscale homotopic thickening\n"         \
-"\n"         \
-"Usage: hthick in.pgm {imcond.pgm|null} connex niter out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Grayscale homotopic thickening (refs. [BEC97, CBB01]).\n"         \
-"The parameter  connex gives the connectivity used for the minima;\n"         \
-"possible choices are 4, 8 in 2D and 6, 26 in 3D.\n"         \
-"Let F be the function corresponding to the input image  in.pgm.\n"         \
-"Let G be the function corresponding to the input image \n"         \
-" imcond.pgm, or the blanck function (constant 255) if the keyword  null is used.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat niter times:\n"         \
-"    L = {(p,d) such that p is constructible for F and d = delta+(p,F)}\n"         \
-"    While L not empty\n"         \
-"       extract a couple (p,d) from L\n"         \
-"       F(p) = min{ d, delta+(p,F), G(p) }    \n"         \
-"Result: F\n"         \
-"\n"         \
-"\n"         \
-"If  niter is set to -1, then the operator iterates until stability.\n"         \
-"\n"         \
-"References: \n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D.\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__meshconvert__c__ "  meshconvert.c\n"         \
-"\n"         \
-" mesh format conversion\n"         \
-"\n"         \
-"Usage: meshconvert in [resolution] out\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Mesh format conversion. \n"         \
-"Available input formats: mcm, ifs, vtk.\n"         \
-"Available output formats: mcm, vtk, pgm (points only).\n"         \
-"If the output format is pgm, then the optional argument resolution \n"         \
-"gives the resolution of the grid (homogeneous in x, y and z dimensions). The \n"         \
-"default value is 1.0.\n"         \
-"\n"         \
-"Types supported: mesh 3d\n"         \
-"\n"         \
-"Category: mesh3d, convert\n"         \
-"  mesh3d, convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__histodist__c__ "  histodist.c\n"         \
-"\n"         \
-" computes the distance between two histograms\n"         \
-"\n"         \
-"Usage: histodist h1.list h2.list [type] out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Computes the distance between the two histograms given in  h1.list and  h2.list. The result is written in  out.list.\n"         \
-"\n"         \
-"The distance is an edit distance, it is defined as the minimal number of elementary operations (moving one unit from a bin to the neighboring one) that is necessary to transform h1 into h2.\n"         \
-"\n"         \
-"Parameter  type (default 0) indicates whether the histogram must be interpreted as circular (type = 1) of not (type = 0). Circular interpretation implies that first and last bins are considered as neighbors.\n"         \
-"\n"         \
-"Types supported: list\n"         \
-"\n"         \
-"Category: histo\n"         \
-"  histo\n"         \
-"\n"         \
-" Michel Couprie, Mohamed Amine Salem\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__deriche__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__pgm2vtk__c__ "  pgm2vtk.c\n"         \
-"\n"         \
-" generates a vtk file from a 3D image\n"         \
-"\n"         \
-"Usage: pgm2vtk in.pgm mode out.vtk\n"         \
-"\n"         \
-"Description:\n"         \
-"Create a vtk image from a 3D pgm image.\n"         \
-"If mode = \n"         \
-"     1: surfels (2-faces) from a binary khalimsky grid\n"         \
-"     2: triangulated surfels (2-faces) from a binary khalimsky grid\n"         \
-"     3: voxels (cubes) from a binary image in Z3\n"         \
-"     4: minimal grid from a binary image in Z3\n"         \
-"     5: voxels (octaedrons) from a binary image in Z3\n"         \
-"     6: linels (1-faces) from a binary khalimsky grid\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie (2005)\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__segment__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__toposhrinkgray__c__ "  toposhrinkgray.c\n"         \
-"\n"         \
-" topologically controled grayscale shrinking (one step)\n"         \
-"\n"         \
-"Usage: toposhrinkgray in.pgm connex t+min t+max t--min t--max {0|a|d} [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Topologically controled grayscale shrinking (one step).\n"         \
-"\n"         \
-"The parameter  indicates the action performed on the selected point p:\n"         \
-" 0: it is lowered down to 0;\n"         \
-" a: it is lowered down to alpha-(p,F) where F denotes the original image;\n"         \
-" d: it is lowered down to delta-(p,F) where F denotes the original image.\n"         \
-"\n"         \
-"The parameter  connex indicates the connectivity of the binary object.\n"         \
-"Possible choices are 4, 8 in 2D and 6, 18, 26 in 3D.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image (set Y) will be left unchanged. \n"         \
-"\n"         \
-"\n"         \
-"  For all points p, not in Y, and such that \n"         \
-"      t+min \n"         \
-"    lower p according to the chosen strategy\n"         \
-"\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-"References:\n"         \
-"\n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"\n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-" Nicolas Combaret 2006\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel2pgm__c__ "  skel2pgm.c\n"         \
-"\n"         \
-" generation of a labelled image from a curvilinear skeleton\n"         \
-"\n"         \
-"Usage: skel2pgm in.skel [id] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Generation of a labelled image from a curvilinear skeleton.\n"         \
-"\n"         \
-"If the optional argument  id is given and positive, then only the skeleton element having this index is considered.\n"         \
-"\n"         \
-"If the optional argument  id is given and is -1, then points of the skeleton are labelled with their index in the skeleton structure (warning: no more than 255 elements)\n"         \
-"\n"         \
-"Otherwise, points of the skeleton are labelled with:\n"         \
-" 1: isolated\n"         \
-" 2: end\n"         \
-" 3: curve\n"         \
-" 4: junction\n"         \
-"\n"         \
-"Types supported: 2Dskel, 3Dskel\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2004\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__squelbin__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__dynamiquefilter__c__ "  dynamiquefilter.c\n"         \
-"\n"         \
-" filter components according to the dynamics of the maxima\n"         \
-"\n"         \
-"Usage: dynamiquefilter in.pgm connex value [order] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Computes the ordered dynamics of the maxima, with connectivity connex, \n"         \
-"selects the maxima with a dynamics greater or equal to value,\n"         \
-"and find the maximal components which includes these maxima. \n"         \
-"The definition of the ordered dynamics is the one given in [Ber05]. \n"         \
-"The optional argument order is one of the following:\n"         \
-" 0: altitude [default] \n"         \
-" 1: area\n"         \
-" 2: volume\n"         \
-"\n"         \
-"References: \n"         \
-"[Ber05] G. Bertrand: \"A new definition of the dynamics\", Procs. ISMM05, Springer, series Computational Imaging and Vision, Vol.&nbsp;30, pp.&nbsp;197-206, 2005.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D.\n"         \
-"\n"         \
-"Category: \n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__grayskel__c__ "  grayskel.c\n"         \
-"\n"         \
-" grayscale homotopic skeleton\n"         \
-"\n"         \
-"Usage: grayskel in.pgm {imcond.pgm|null} connex lambda out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Skeleton, either homotopic (lambda = 0) or non-homotopic, for 2D grayscale images\n"         \
-"The skeleton is obtained by iterative lowering of lambda-destructible points\n"         \
-"(see [CBB01]).\n"         \
-"\n"         \
-"Reference: \n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lvkern__c__ "  lvkern.c\n"         \
-"\n"         \
-" grayscale ultimate leveling thinning\n"         \
-"\n"         \
-"Usage: lvkern in.pgm {imcond.pgm|null} connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Grayscale ultimate leveling thinning (refs. [BEC97, CBB01]).\n"         \
-"The parameter  connex gives the connectivity used for the minima;\n"         \
-"possible choices are 4, 8 in 2D and 6, 26 in 3D.\n"         \
-"Let F be the function corresponding to the input image  in.pgm.\n"         \
-"Let G be the function corresponding to the input image \n"         \
-" imcond.pgm, or the null function if the keyword  null is used.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat until stability:\n"         \
-"    select p such that T--(p,F) = 1 and such that F(p) is minimal\n"         \
-"    F(p) = max{ delta-(p,F), G(p) }    \n"         \
-"Result: F\n"         \
-"\n"         \
-"\n"         \
-"References: \n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D.\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"lvkern ur1 null 4 ur1_lvkern\n"         \
-"minima ur1_lvkern 4 ur1_lvkern_m\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"      \n"         \
-"  \n"         \
-"  ur1\n"         \
-"      ur1_lvkern\n"         \
-"      ur1_lvkern_m\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ptmultiple__c__ "  ptmultiple.c\n"         \
-"\n"         \
-" detects multiple points in 2d or 3d binary images\n"         \
-"\n"         \
-"Usage: ptmultiple in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Detects multiple points in the 2d or 3d binary image  in.pgm .\n"         \
-"A multiple point is a white point x such that Tn[x] > 2\n"         \
-"(n = 4, 8 in 2D or n = 6, 18, 26 in 3D, as set by the parameter  connex).\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__proj__c__ "  proj.c\n"         \
-"\n"         \
-" projection parallel to one of the main axes\n"         \
-"\n"         \
-"Usage: proj in.pgm dir mode out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Projection parallel to one of the main axes.\n"         \
-"\n"         \
-"dir = x | y | z\n"         \
-"\n"         \
-"mode = 0 (mean) | 1 (max)\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_PSG__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__souzabanon__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__drawscene__c__ "  drawscene.c\n"         \
-"\n"         \
-" draw a 3D scene which is specified by a text file into a 3D pgm image\n"         \
-"\n"         \
-"Usage: drawscene in.pgm scene.3sc out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The file  scene.3sc contains a scene under the 3Dscene format.\n"         \
-"\n"         \
-"Types supported: byte 3D\n"         \
-"\n"         \
-"Category: draw geo\n"         \
-"  draw geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__2dcollapse__c__ "  2dcollapse.c\n"         \
-"\n"         \
-" ultimate constrained collapse guided by a priority image\n"         \
-"\n"         \
-"Usage: 2dcollapse in.pgm prio [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Ultimate constrained collapse guided by a priority image.\n"         \
-"The lowest values of the priority image correspond to the highest priority.\n"         \
-"\n"         \
-"The parameter  prio is either an image (byte or int32_t), or a numerical code\n"         \
-"indicating that a distance map will be used as a priority image; \n"         \
-"the possible choices are:\n"         \
-" 0: approximate euclidean distance\n"         \
-" 1: approximate quadratic euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name, then\n"         \
-"the elements of this image will be left unchanged.  If the parameter\n"         \
-" inhibit is given and is a number I, then the elements with priority\n"         \
-"greater than or equal to I will be left unchanged.  \n"         \
-"\n"         \
-" The result makes sense only if the input image is a complex.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__t4pp__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__0000__c__ "  \n"         \
-"\n"         \
-"Pink is an image processing library developed\n"         \
-"at ESIEE Engineering for research\n"         \
-"and teaching purposes. It contains implementations of over 200\n"         \
-"algorithms for image segmentation and filtering. Most of the operators\n"         \
-"come from mathematical morphology, but it contains operators from\n"         \
-"different fields. It is a free software licensed under the\n"         \
-" CeCILL \n"         \
-"license. \n"         \
-"\n"         \
-"In august 2011 Pink has been presented at the European Python\n"         \
-"Scientific Conference as a poster. Below you can see the conference\n"         \
-"poster (also in  pdf  and hi-res  jpeg ).\n"         \
-"\n"         \
-" html pink_euroscipy_web_thumb.jpeg \"EuroSciPy 2011 poster\"\n"         \
-"\n"         \
-" screenshots Screenshots\n"         \
-"\n"         \
-"\n"         \
-"Screenshots can be found here. \n"         \
-"\n"         \
-" download Download\n"         \
-"\n"         \
-"The source code and the binary packages can be accessed from the \n"         \
-"download page.\n"         \
-"\n"         \
-" mailing Mailing list \n"         \
-"\n"         \
-"If you are interested in the daily life of Pink, please subscribe to\n"         \
-"the \n"         \
-"Pink Developer mailing list . You can also post questions\n"         \
-"concerning the usage or raise issues. \n"         \
-"\n"         \
-" bughunt Bug-hunt!\n"         \
-"\n"         \
-"If you have discovered a bug, please report it at\n"         \
-"the \n"         \
-"bug tracker.\n"         \
-"\n"         \
-" credits Credits\n"         \
-"\n"         \
-"\n"         \
-"   Code licensed under CeCILL license\n"         \
-"   \n"         \
-"     Michel Couprie \n"         \
-"      Laurent Najman : localextrema, saliency\n"         \
-"          Hugues Talbot  : fmm \n"         \
-"      Jean\n"         \
-"    Cousty : redt 3d (reverse euclidean distance transform -\n"         \
-"    algo de D. Coeurjolly), watershedthin, opÃ©rateurs sur les graphes\n"         \
-"    d'arÃªtes (GA), forÃªts de poids min (MSF), waterfall,\n"         \
-"    recalagerigide_translateplane\n"         \
-"     Xavier Daragon: dist, distc (distance euclidienne quadratique 3D)\n"         \
-"     AndrÃ© Vital Saude: radialopening, divers scripts tcl, hma\n"         \
-"     Nicolas Combaret: toposhrinkgray, ptselectgray\n"         \
-"     John Chaussard: lballincl, cropondisk, shrinkondisk\n"         \
-"     Christophe Doublier: zoomint\n"         \
-"     Hildegard Koehler: lintophat\n"         \
-"     CÃ©dric AllÃ¨ne: gettree, histolisse, labeltree, nbcomp, pgm2vtk, seuilauto\n"         \
-"     Gu Jun: maxdiameter\n"         \
-"     SÃ©bastien Couprie: mcsplines.c\n"         \
-"     Rita Zrour: medialaxis (axe mÃ©dian euclidien exact - algo de RÃ©my-Thiel),\n"         \
-"      dist, distc (distance euclidienne quadratique exacte - algo de Saito-Toriwaki)\n"         \
-"     Laurent Mercier: gestion d'un masque dans delaunay\n"         \
-"      Laszlo Marak (ujoimro) : continuous maximum flows,\n"         \
-"    Unger flows, Python front-end, native Microsoft Windows port\n"         \
-"    Benjamin Raynal: parallel 3D thinning\n"         \
-"    Nivando Bezerra: parallel grayscale thinning\n"         \
-"   \n"         \
-"   Code under different free software licenses\n"         \
-"    \n"         \
-"       David Coeurjolly: lvoronoilabelling.c\n"         \
-"       Dario Bressanini: mcpowell.c\n"         \
-"       Andrew W. Fitzgibbon: lbresen.c\n"         \
-"       Lilian Buzer: lbdigitalline.cxx\n"         \
-"   \n"         \
-"\n"         \
-" compiling Compiling\n"         \
-"\n"         \
-"Pink can be compiled with two sets of tools. For the compilation with\n"         \
-"dependency checking and Python front-end, visit the page \n"         \
-"compiling_cmake. For the classical compilation look at \n"         \
-"compiling_make. You can also compile Pink on windows (including the\n"         \
-"Python front-end). For details on compiling on windows look at \n"         \
-"compiling_windows. \n"         \
-"\n"         \
-"\n"         \
-" development Development\n"         \
-"For developing Pink look at the  dev_conventions page. For\n"         \
-"exporting functions in Python look at the  python_export page. \n"         \
-"\n"         \
-" dependencies Dependencies\n"         \
-"For optimal use, the following packages should be installed:\n"         \
-"\n"         \
-"imview\n"         \
-"Python\n"         \
-"Doxygen\n"         \
-"ActiveTcl 8.3\n"         \
-"VTK\n"         \
-"MPlayer\n"         \
-"Gnuplot\n"         \
-"\n"         \
-"Note, that the detailed dependencies can be found in file\n"         \
-"'dependencies'.\n"         \
-"\n"         \
-"The Python front-end has been financially supported\n"         \
-"by  EDF .  The\n"         \
-"project management is alpha-hosted\n"         \
-"at \n"         \
-"\n"         \
-"width=\"124\" height=\"32\" border=\"0\" alt=\"BerliOS Logo\" />BerliOs.\n"         \
-"\n"         \
-"\n"         \
-"Michel Couprie  -  Professeur  -  ESIEE Paris\n"         \
-"Laboratoire d'Informatique Gaspard-Monge, UniversitÃ© Paris-Est\n"         \
-"ESIEE 2, Bd Blaise Pascal - B.P. 99\n"         \
-"93162 Noisy-Le-Grand CEDEX\n"         \
-"m(dot)couprie(at)esiee(dot)fr \n"         \
-"url:  http://www.esiee.fr/~coupriem\n"         \
-" \n"         \
-"\n"         \
-" inter Interactive operators\n"         \
-" \n"         \
-"\n"         \
-" arith Arithmetic operators\n"         \
-" \n"         \
-"\n"         \
-" convert Format and type conversion \n"         \
-"\n"         \
-"\n"         \
-" morpho Mathematical morphology\n"         \
-"\n"         \
-"\n"         \
-" connect Digital connectivity\n"         \
-"\n"         \
-"\n"         \
-" topobin Digital topology (binary)\n"         \
-"\n"         \
-"\n"         \
-" topogray Digital topology (grayscale)\n"         \
-"\n"         \
-"\n"         \
-" orders Orders topology\n"         \
-"\n"         \
-"\n"         \
-" geo Geometrical operators\n"         \
-"\n"         \
-"\n"         \
-" draw Graphic primitives\n"         \
-"\n"         \
-"\n"         \
-" histo Histogram-based operators\n"         \
-"\n"         \
-"\n"         \
-" signal Signal processing\n"         \
-"\n"         \
-"\n"         \
-" stats Statistics\n"         \
-"\n"         \
-"\n"         \
-" mesh3d Three-dimensional meshing\n"         \
-"\n"         \
-"\n"         \
-" development Development\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__granulometry__c__ "  granulometry.c\n"         \
-"\n"         \
-" granulometry of a binary image\n"         \
-"\n"         \
-"Usage: granulometry in.pgm [rmin] rmax out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Let X be the set of non-null points in in.pgm.\n"         \
-"This operator computes the area (volume in 3d) of the opening of X by \n"         \
-"euclidean balls of increasing radius, ranging from 1 \n"         \
-"(or rmin if this parameter is specified) to rmax. \n"         \
-"The result out.list contains a list of couples r a where \n"         \
-"r is a radius and a is the corresponding area (or volume).\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__heightselnb__c__ "  heightselnb.c\n"         \
-"\n"         \
-" height based segmentation by selection of a given number or components\n"         \
-"\n"         \
-"Usage: heightselnb in.pgm connex nb out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Segmentation by selection of a given number or components, based on a \n"         \
-"height (contrast) criterion. \n"         \
-"Connexity = connex ; desired number of components = nb.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__inverse__c__ "  inverse.c\n"         \
-"\n"         \
-" computes the pixelwise inverse of an image\n"         \
-"\n"         \
-"Usage: inverse in.pgm [out.pgm]\n"         \
-"\n"         \
-"Description:\n"         \
-"Byte images: for each pixel x, out[x] = 255 - in[x].\n"         \
-"Long or float images: for each pixel x, out[x] = VMAX - in[x], where VMAX = max{in[x]}.\n"         \
-"\n"         \
-"If  out.pgm is not specified, then out.pgm = in.pgm.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, long 2d, long 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__labeldil__c__ "  labeldil.c\n"         \
-"\n"         \
-" labeling of the connected components of a binary image\n"         \
-"\n"         \
-"Usage: labeldil in.pgm se.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The argument  se.pgm is a structuring element which must be reflexive and symmetric. \n"         \
-"Connected components are defined by this structuring element.\n"         \
-"The output image  out.pgm has the type \"int32_t\".\n"         \
-"\n"         \
-" No test is done to check properties of the structuring element.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: connect\n"         \
-"  connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__taf__c__ "  taf.c\n"         \
-"\n"         \
-" topological alternating filter\n"         \
-"\n"         \
-"Usage: taf in.pgm connexmin r [lambdap [lambdaw]] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Topological alternating filter. Performs alternatively topological upper filter (tuf)\n"         \
-"and topological lower filter (tlf) with increasing radius until radius r.\n"         \
-"\n"         \
-"If given, parameter lambdap (resp. lambdaw) is an integer which \n"         \
-"indicates that peaks (resp. wells) of height greater than this value must be \n"         \
-"preserved. \n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__asf__c__ "  asf.c\n"         \
-"\n"         \
-" alternate sequential filter\n"         \
-"\n"         \
-"Usage: asf in.pgm [rmin] rmax out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Alternate sequential filter for grayscale images (for binary images\n"         \
-"use preferably asfbin).\n"         \
-"\n"         \
-"Disc-shaped structuring elements of increasing radius, ranging from 1\n"         \
-"(or rmin if this parameter is specified) to rmax, are\n"         \
-"generated.\n"         \
-"\n"         \
-"Let D1...Dn be these structuring elements, sorted by increasing radius.\n"         \
-"\n"         \
-"Let I0 = in.pgm, the ith intermediate result Ii is obtained by\n"         \
-"the closing of the opening of Ii-1 by the structuring element Di.\n"         \
-"\n"         \
-"The result out.pgm contains the final result In.\n"         \
-"\n"         \
-"Giving a value 0 for the optional parameter rmin has the effect\n"         \
-"of beginning by a closing instead of an opening.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__curve2segments__cxx__ "  curve2segments.cxx\n"         \
-"\n"         \
-" computes a covering of a digital curve by digital straigh line segments\n"         \
-"\n"         \
-"Usage: curve2segments curve.list [tolerance] segments.list\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Computes a covering of a digital curve by digital straight line segments. \n"         \
-"The input file contains a curve which is specified by the ordered list of its points.\n"         \
-"The output file is an ordered list of points, which are the extremities of the segments.\n"         \
-"\n"         \
-"Parameter  tolerance gives the thickness of the digital straight line segments. Default value is 1.\n"         \
-"\n"         \
-" Curves must be 8-curves in 2D of 26-curves in 3D. Greedy algorithm.\n"         \
-"\n"         \
-"Types supported: curve 2D, curve 3D\n"         \
-"\n"         \
-"Category: geo\n"         \
-" geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__toposhrink__c__ "  toposhrink.c\n"         \
-"\n"         \
-" topologically controled binary shrinking guided by a priority image\n"         \
-"\n"         \
-"Usage: toposhrink in.pgm prio.pgm connex tmin tmax tbmin tbmax [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Topologically controled binary shrinking guided by a priority image.\n"         \
-"The lowest values of the priority image correspond to the highest priority.\n"         \
-"\n"         \
-"The parameter  prio is an image (byte or int32_t).\n"         \
-"\n"         \
-"The parameter  connex indicates the connectivity of the binary object.\n"         \
-"Possible choices are 4, 8 in 2D and 6, 18, 26 in 3D.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image (set Y) will be left unchanged. \n"         \
-"\n"         \
-"Let X be the set of points of the binary image  in.pgm .\n"         \
-"\n"         \
-"\n"         \
-"Repeat until stability: \n"         \
-"    select a point p of X  Y such that\n"         \
-"        tmin \n"         \
-"        and with the lowest possible priority value\n"         \
-"    X := X  { p }\n"         \
-"\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__reconsplateaux__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__recons___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__complex_real__c__ "  complex_real.c\n"         \
-"\n"         \
-" pixelwise real part of complex\n"         \
-"\n"         \
-"Usage: complex_real in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Applies to complex images only.\n"         \
-"For each pixel p, out[p] = real(in[p]), where \n"         \
-"real(x+iy) = x\n"         \
-"\n"         \
-"Types supported: complex 2d, complex 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__filtreordre__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__convexhull__c__ "  convexhull.c\n"         \
-"\n"         \
-" convex hull of a set of points in the 2D plane\n"         \
-"\n"         \
-"Usage: convewhull in.pgm mode out\n"         \
-"\n"         \
-"Description: Computes the convex hull of the set of non-null points\n"         \
-"in the image in.pgm, by the Jarvis's algorithm as described in \n"         \
-"\"Introduction to algorithms\", T. Cormen, C. Leiserson, R. Rivest, MIT Press.\n"         \
-"\n"         \
-"The parameter  mode selects the format of the result: \n"         \
-" 0: list of the support points of the convex hull\n"         \
-" 1: support points of the convex hull, embedded in the image frame\n"         \
-" 2: contour of the convex hull, embedded in the image frame\n"         \
-" 3: full convex hull, embedded in the image frame\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__graph2ps__c__ "  graph2ps.c\n"         \
-"\n"         \
-" draws a planar graph into a ps file\n"         \
-"\n"         \
-"Usage: graph2ps in.graph out.ps\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws a planar graph into a ps file.\n"         \
-"\n"         \
-"Types supported: graph\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie 2009\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__2dseltopo__c__ "  2dseltopo.c\n"         \
-"\n"         \
-" selects points in the 2d khalimsky grid according to a local topological criterion \n"         \
-"\n"         \
-"Usage: 2dseltopo in d- d+ a- a+ b- b+ out\n"         \
-"\n"         \
-"Description:\n"         \
-"  Selects the elements x of the Khalimsky object K\n"         \
-"  which satisfy the following inequalities : \n"         \
-"\n"         \
-"   d1  \n"         \
-"\n"         \
-"   a1  \n"         \
-"\n"         \
-"   b1  \n"         \
-"\n"         \
-"  where\n"         \
-"\n"         \
-"  d(x) = dimension of x\n"         \
-"\n"         \
-"  a(x) = number of elements under x of dimension d(x) - 1\n"         \
-"\n"         \
-"  b(x) = number of elements over x of dimension d(x) + 1\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: orders\n"         \
-" orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_SK3__c__ "  skel_SK3.c\n"         \
-"\n"         \
-" parallel 3D binary surface skeleton based on 2D isthmuses\n"         \
-"\n"         \
-"Usage: skel_SK3 in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 3D binary thinning or surface skeleton based on 2D isthmuses. \n"         \
-"The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__squelubp3d___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__drawgraph__c__ "  drawline.c\n"         \
-"\n"         \
-" draw a graph in a 2D image\n"         \
-"\n"         \
-"Usage: drawline in.graph in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Draws the graph described in file in.graph into the image in.pgm\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: draw\n"         \
-"  draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dseltopo__c__ "  3dseltopo.c\n"         \
-"\n"         \
-" selects points in the 3d khalimsky grid according to a local topological criterion \n"         \
-"\n"         \
-"Usage: 3dseltopo in d- d+ a- a+ b- b+ out\n"         \
-"\n"         \
-"Description:\n"         \
-"  Selects the elements x of the Khalimsky volume K\n"         \
-"  which satisfy the following inequalities : \n"         \
-"\n"         \
-"   d1  \n"         \
-"\n"         \
-"   a1  \n"         \
-"\n"         \
-"   b1  \n"         \
-"\n"         \
-"  where\n"         \
-"\n"         \
-"  d(x) = dimension of x\n"         \
-"\n"         \
-"  a(x) = number of elements under x of dimension d(x) - 1\n"         \
-"\n"         \
-"  b(x) = number of elements over x of dimension d(x) + 1\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-" orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dynamique__c__ "  dynamique.c\n"         \
-"\n"         \
-" dynamics of the maxima\n"         \
-"\n"         \
-"Usage: dynamique in.pgm connex [order] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Computes the ordered dynamics of the maxima, with connectivity connex.\n"         \
-"The definition of the ordered dynamics is the one given in [Ber05]. \n"         \
-"The optional argument order is one of the following:\n"         \
-" 0: altitude [default] \n"         \
-" 1: area\n"         \
-" 2: volume\n"         \
-"\n"         \
-"References: \n"         \
-"[Ber05] G. Bertrand: \"A new definition of the dynamics\", Procs. ISMM05, Springer, series Computational Imaging and Vision, Vol.&nbsp;30, pp.&nbsp;197-206, 2005.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D.\n"         \
-"\n"         \
-"Category: \n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lferode_line__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__segmentnum__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__ptsimple__c__ "  ptsimple.c\n"         \
-"\n"         \
-" detects simple points in a binary image\n"         \
-"\n"         \
-"Usage: ptsimple in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Detects simple points in a binary image.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2003\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lengthsplines__c__ "  lengthsplines.c\n"         \
-"\n"         \
-" computes the lengths of splines which are specified by their control points in a text file\n"         \
-"\n"         \
-"Usage: lengthsplines splines.txt out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Computes the lengths of splines which are specified by their control points in a text file.\n"         \
-"\n"         \
-"The file format for  splines.txt is the following for 2D:\n"         \
-"\n"         \
-"The file  splines.txt contains a list of splines under the format:\n"         \
-"d nb_splines\n"         \
-"nb_points_spline_1  x11 y11  x12 y12 ...\n"         \
-"nb_points_spline_2  x21 y21  x22 y22 ...\n"         \
-"nb_points_spline_3  x31 y31  x32 y32 ...\n"         \
-"...\n"         \
-"or, in 3D:\n"         \
-"D nb_splines\n"         \
-"nb_points_spline_1  x11 y11 z11  x12 y12 z12 ...\n"         \
-"nb_points_spline_2  x21 y21 z21  x22 y22 z22 ...\n"         \
-"nb_points_spline_3  x31 y31 z31  x32 y32 z32 ...\n"         \
-"...\n"         \
-"\n"         \
-"Types supported: spline 2D, spline 3D\n"         \
-"\n"         \
-"Category: geo\n"         \
-" geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3drecons__c__ "  3drecons.c\n"         \
-"\n"         \
-" geodesic reconstruction in a 3d khalimsky order \n"         \
-"\n"         \
-"Usage: 3drecons g.list f.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Geodesic reconstruction (in the sense of the neighborhood relation theta) \n"         \
-"of the set of points represented by the list  g.list in the set  f.pgm .\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__symse__c__ "  symse.c\n"         \
-"\n"         \
-" inverse of a structuring element\n"         \
-"\n"         \
-"Usage: symse in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Inverse of a structuring element.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d.\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__holeclosing__c__ "  holeclosing.c\n"         \
-"\n"         \
-" 3d hole closing\n"         \
-"\n"         \
-"Usage: holeclosing in connex holesize [guide] out\n"         \
-"\n"         \
-"Description: \n"         \
-"Hole closing in 3d binary images. \n"         \
-"The parameter  connex gives the connectivity used for the object;\n"         \
-"possible choices are 6 and 26.\n"         \
-"Holes which have a \"size\" greater (strictly) than  holesize are let open \n"         \
-"(where -1 is used as a symbol for infinity).\n"         \
-"\n"         \
-"Let X be the set of points of the binary image  in, let Y be a full enclosing box. \n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat until stability:\n"         \
-"    Select a point p of Y  X such that Tb(p,Y) = 1\n"         \
-"        or such that Tb(p,Y) = 2 and d(p,X) > holesize\n"         \
-"        which is at the greatest distance from X\n"         \
-"    Y := Y  {p}\n"         \
-"Result: Y\n"         \
-"\n"         \
-"\n"         \
-"If the optional parameter  guide is given, then replace 'greatest distance from X' by \n"         \
-"'greatest distance from Y' in the algorithm, Y being the set of non-null points of image  guide.\n"         \
-"\n"         \
-" There must be no object point on the border of the image (a test is done).\n"         \
-"\n"         \
-"Reference: \n"         \
-"Z. Aktouf, G. Bertrand, L.Perroton: \n"         \
-"\"A three-dimensional holes closing algorithm\",\n"         \
-"Pattern Recognition Letters, No.23, pp.523-531, 2002.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__recalagerigide__c__ "  recalagerigide.c\n"         \
-"\n"         \
-" rigid registration of two closed contours\n"         \
-"\n"         \
-"Usage: recalagerigide in1 in2 out\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Rigid registration of two closed contours. \n"         \
-"Let X and Y be two point sets, given respectively by  in1 and  in2.\n"         \
-"This procedure identifies the parameters of a rigid deformation R such that\n"         \
-"the \"distance\" between R(X) and Y is a local minimum.\n"         \
-"The distance D(Z,Y) between two sets Z and Y is defined by:\n"         \
-"\n"         \
-"D(Z,Y) = sum { d2(z,Y) ; for all z in Z }\n"         \
-"\n"         \
-"d2(z,Y) = min { d2(z,y) ; for all y in Y }\n"         \
-"\n"         \
-"d2(z,y) = (z - y)^2 ; i.e., the square or the Euclidean distance between z and y.\n"         \
-"\n"         \
-"The rigid deformation R is defined as the composition (in this order) \n"         \
-"of scalings, rotations and translations. \n"         \
-"\n"         \
-"In 2d, the parameters are:\n"         \
-" sx : parameter for the scaling in direction x\n"         \
-" sy : parameter for the scaling in direction y\n"         \
-" theta : angle (in radians) of the rotation around the barycenter of X\n"         \
-" tx : parameter for the translation in direction x\n"         \
-" ty : parameter for the translation in direction y\n"         \
-"\n"         \
-"In 3d, the parameters are:\n"         \
-" sx : parameter for the scaling in direction x\n"         \
-" sy : parameter for the scaling in direction y\n"         \
-" sz : parameter for the scaling in direction z\n"         \
-" theta : angle (in radians) of the rotation around the parallel to the the z axis passing by the barycenter of X\n"         \
-" phi : angle (in radians) of the rotation around the parallel to the the y axis passing by the barycenter of X\n"         \
-" tx : parameter for the translation in direction x\n"         \
-" ty : parameter for the translation in direction y\n"         \
-" tz : parameter for the translation in direction z\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__watershedMeyer_regular__c__ "  watershedMeyer.c\n"         \
-"\n"         \
-" watershed transformation (Meyer's algorithm)\n"         \
-"\n"         \
-"Usage: watershedMeyer in mark {bgmark|null} {roi|null} connex out\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs the watershed transformation on the image in, taking the\n"         \
-"set of markers in mark. \n"         \
-"If this parameter is present, bgmark\n"         \
-"is used as a set of markers for the background.\n"         \
-"If this parameter is present, roi\n"         \
-"indicates the region of interest on which the operation is performed.\n"         \
-"The parameter connex gives the adjacency relation (4,8 in 2D; 6,18,26 in 3D) \n"         \
-"for the makers.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__surf___notused_c__ "  surf.c\n"         \
-"\n"         \
-" topographic view of a 2D image\n"         \
-"\n"         \
-"Usage: surf in.pgm mode out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Creates a gray-scale image\n"         \
-"with shading view 2D gray-scale image as a\n"         \
-"topographical surface. Useful to view\n"         \
-"distance transforms and results of morphological\n"         \
-"operators.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Roberto Lotufo\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skew__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__skel_AMK__c__ "  skel_AMK.c\n"         \
-"\n"         \
-" parallel 2D or 3D binary skeleton, ultimate, asymmetric\n"         \
-"\n"         \
-"Usage: skel_AMK in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 2D or 3D binary ultimate, asymmetric skeleton. The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"The algorithm used here is indeed a variant of alg. NK2 described in [BC08], which allows for an arbitrary (and even null) constraint set.\n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"References:\n"         \
-"[BC08] Gilles Bertrand and Michel Couprie, Two-dimensional thinning algorithms based on critical kernels. Journal of Mathematical Imaging and Vision, 31(1). 2008. pp.35â56.\n"         \
-"http://igm.univ-mlv.fr/LIGM/internal_report/pdf/2006_02.v2.pdf\n"         \
-"\n"         \
-"[XXXX] TODO: add reference for 3D\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__standarddeviation1__c__ "  standarddeviation1.c\n"         \
-"\n"         \
-" return the standard deviation of the pixel values of an image\n"         \
-"\n"         \
-"Usage: standarddeviation1 in.pgm [mask.pgm] out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"This function returns (in the list out.list) \n"         \
-"the standard deviation of the pixel values of the image  in.pgm .\n"         \
-"If the optional parameter  mask.pgm is given, then only the \n"         \
-"values which correspond to non-null points of mask are considered.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lthick__c__ "  lthick.c\n"         \
-"\n"         \
-" grayscale leveling thickening\n"         \
-"\n"         \
-"Usage: lthick in.pgm {imcond.pgm|null} connex niter out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Grayscale leveling thickening (refs. [BEC97, CBB01]).\n"         \
-"The parameter  connex gives the connectivity used for the minima;\n"         \
-"possible choices are 4, 8 in 2D and 6, 26 in 3D.\n"         \
-"Let F be the function corresponding to the input image  in.pgm.\n"         \
-"Let G be the function corresponding to the input image \n"         \
-" imcond.pgm, or the blanck function (constant 255) if the keyword  null is used.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat niter times:\n"         \
-"    L = {(p,a) such that T++(p,F) = 1 and a = alpha+(p,F)}\n"         \
-"    While L not empty\n"         \
-"       extract a couple (p,a) from L\n"         \
-"       F(p) = min{ a, alpha+(p,F), G(p) }    \n"         \
-"Result: F\n"         \
-"\n"         \
-"\n"         \
-"If  niter is set to -1, then the operator iterates until stability.\n"         \
-"\n"         \
-"References: \n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D.\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__saliency__c__ "  saliency.c\n"         \
-"\n"         \
-" salient watershed transformation\n"         \
-"\n"         \
-"Usage: saliency in connex out\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs the salient watershed transformation on the image in, \n"         \
-"The parameter connex gives the adjacency relation (4 or 6b in 2D).\n"         \
-"\n"         \
-"The image out is a int32_t image (int32_t)\n"         \
-"\n"         \
-"In 4 connectivity, the output image is a line graph in the khalimsky\n"         \
-"grid. In 6b connectivity, the result is on the pixels themselves, with\n"         \
-"the gammab neighborhood.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Laurent Najman\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__extractline__c__ "  extractline.c\n"         \
-"\n"         \
-" extracts a line between two given points from a 3D image\n"         \
-"\n"         \
-"Usage: extractline in.pgm x1 y1 x2 y2 out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The original 2D image is in.pgm. \n"         \
-"The output 1D image out.pgm contains the line between \n"         \
-"points (x1,y1) and (x2,y2) extracted from in.pgm.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dkhalimskize__c__ "  3dkhalimskize.c\n"         \
-"\n"         \
-" converts a 3D image into a 3D Khalimsky order\n"         \
-"\n"         \
-"Usage: 3dkhalimskize in.pgm {6|26|h|m|M|a|R|b} out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Converts a 3D image into a 3D Khalimsky order.\n"         \
-"\n"         \
-"Modes 6, 26 and h are for binary images. \n"         \
-"\n"         \
-"Modes m, M and a are for grayscale images. \n"         \
-"\n"         \
-"Mode = \n"         \
-"    6 : emulates 6-connectivity, idem \"miss\", \n"         \
-"    26 : emulates 26-connectivity (\"hit\" transform followed by a kernel transform),   \n"         \
-"    h : \"hit\",\n"         \
-"    m : min, \n"         \
-"    M : max,\n"         \
-"    a : average,\n"         \
-"    R : reverse,\n"         \
-"    b : border.\n"         \
-"\n"         \
-"Types supported: byte 3d, long 3d, float 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__wshedval__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__sup__c__ "  sup.c\n"         \
-"\n"         \
-" pixelwise sup predicate\n"         \
-"\n"         \
-"Usage: sup in1.pgm in2.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, if in1[x] >= in2[x] then out[x] = 255 else out[x] = 0.\n"         \
-"Images must be of the same type and same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgm2vskel__c__ "  pgm2vskel.c\n"         \
-"\n"         \
-" decomposition of a valuated curvilinear skeleton into isolated points, end points, curves and junctions\n"         \
-"\n"         \
-"Usage: pgm2vskel in.pgm val.pgm connex out.skel\n"         \
-"\n"         \
-"Description:\n"         \
-"The skeleton found in  in.pgm is decomposed into isolated points, \n"         \
-"end points, curves and junctions ;\n"         \
-"and its description is stored in  out.skel . \n"         \
-"Each point of the skeleton is valuated by the corresponding value\n"         \
-"found in  val.pgm .\n"         \
-"The parameter  connex sets the adjacency relation used for the object\n"         \
-"(4, 8 (2d) or 6, 18, 26 (3d)).\n"         \
-"\n"         \
-" No verification is done to check that the input image  in.pgm \n"         \
-"contains indeed a curvilinear skeleton.\n"         \
-"In the contrary case, the result would be meaningless.\n"         \
-"\n"         \
-" IMPORTANT LIMITATION: different junctions in the original image \n"         \
-"must not be in direct contact with each other\n"         \
-"(i.e., connected) otherwise they will be considered as a single junction. \n"         \
-"To prevent this to occur, one can increase image resolution. \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2004\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__topotypes__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__3dinvariants__c__ "  3dinvariants.c\n"         \
-"\n"         \
-" computes the numbers of connected components,\n"         \
-"cavities and tunnels of a 3D cubical complex\n"         \
-"\n"         \
-"Usage: 3dinvariants in.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Computes the numbers of connected components,\n"         \
-"cavities and tunnels of a 3D cubical complex\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__using_python__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__desfilsclairs3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__remspnoise__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__fits2pgm__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__2dtopoflow__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lfdilat_line__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__barycentrelab__c__ "  barycentrelab.c\n"         \
-"\n"         \
-" compute the center of gravity of each labeled region\n"         \
-"\n"         \
-"Usage: barycentrelab in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Compute the center of gravity of each labeled region.\n"         \
-"Labels should be consecutive integers. \n"         \
-"Only strictly positive labels are considered. \n"         \
-"The result is an image that contains labelled points. \n"         \
-"More precisely, each barycentre is represented by the nearest grid\n"         \
-"point that is given the same label as the region.\n"         \
-"\n"         \
-"Types supported: long 2d, long 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__hk_tophat_lin_rotall___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__click2d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__segment3di__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__axones___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lengthspline__c__ "  lengthspline.c\n"         \
-"\n"         \
-" computes the length of a spline which is specified by its control points in a text file\n"         \
-"\n"         \
-"Usage: lengthspline spline.txt [out.list]\n"         \
-"\n"         \
-"Description:\n"         \
-"Computes the length of a spline which is specified by its control points in a text file.\n"         \
-"The file format for  spline.txt is the following for 2D:\n"         \
-"\n"         \
-"c n+1 (where n+1 denotes the number of control points)\n"         \
-"x1 y1\n"         \
-"...\n"         \
-"xn+1 yn+1\n"         \
-"C0X1 C0Y1 C1X1 C1Y1 C2X1 C2Y1 C3X1 C3Y1\n"         \
-"...\n"         \
-"C0Xn C0Yn C1Xn C1Yn C2Xn C2Yn C3Xn C3Yn\n"         \
-"\n"         \
-"and in the 3D case:\n"         \
-"\n"         \
-"C n+1 (where n+1 denotes the number of control points)\n"         \
-"x1 y1 z1\n"         \
-"...\n"         \
-"xn+1 yn+1 zn+1\n"         \
-"C0X1 C0Y1 C0Z1 C1X1 C1Y1 C1Z1 C2X1 C2Y1 C2Z1 C3X1 C3Y1 C3Z1\n"         \
-"...\n"         \
-"C0Xn C0Yn C0Zn C1Xn C1Yn C1Zn C2Xn C2Yn C2Zn C3Xn C3Yn C3Zn\n"         \
-"\n"         \
-"Types supported: spline 2D, spline 3D\n"         \
-"\n"         \
-"Category: geo\n"         \
-" geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__reconseros___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__stretch__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__meanfilter__c__ "  meanfilter.c\n"         \
-"\n"         \
-" Mean filter operator\n"         \
-"\n"         \
-"Usage: meanfilter in.pgm roi.pgm niter [inhibit.pgm] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let F be the function stored in image  in.pgm.\n"         \
-"Let R be the function stored in image  roi.pgm (region of interest).\n"         \
-"Let I be the function stored in image  inhibit.pgm (if any).\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat niter times\n"         \
-"  G = F\n"         \
-"  For each image point x\n"         \
-"    If R[x] and not I[x] then\n"         \
-"      S = G[x]; C = 1;\n"         \
-"      For each neighbour y of x\n"         \
-"        If R[y] then S = S + G[y]; C = C + 1;\n"         \
-"      F[x] = S / C;\n"         \
-"Result: F\n"         \
-"\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d, float 2d, byte 3d, int32_t 3d, float 3d\n"         \
-"\n"         \
-"Category: signal\n"         \
-"  signal\n"         \
-"\n"         \
-" Marcin Janaszewski, Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgm2graph__c__ "  pgm2graph.c\n"         \
-"\n"         \
-" converts a binary image into a simple graph\n"         \
-"\n"         \
-"Usage: pgm2graph in.pgm connex out.graph\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"The vertices of the graph are the object pixels of the binary image  in.pgm, and there is an edge between each pair of adjacent pixels (according to  connex).  \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2010\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__despics__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__yuv2rgb__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__zoomint__c__ "  zoomint.c\n"         \
-"\n"         \
-" zoom by an integer factor\n"         \
-"\n"         \
-"Usage: zoomint in.pgm  {f | fx fy fz} [nofill] out.pgm\n"         \
-"\n"         \
-"Description: \n"         \
-"The zoom factor(s) can be unique ( f ) of there can be one zoom factor\n"         \
-"per image dimension ( fx,  fy,  fz ). In the case of a 2d image, set  fz\n"         \
-"to 1.\n"         \
-"The zoom parameter may be a positive or negative integer.\n"         \
-"If it is positive, the image is expanded in the corresponding \n"         \
-"direction. The pixels are replicated in order to fill all the space,\n"         \
-"except if the parameter nofill is used.\n"         \
-"If it is negative, the image is shrinked the corresponding \n"         \
-"directions, by undersampling.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie, Christophe Doublier\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__meshflatten__c__ "  meshflatten.c\n"         \
-"\n"         \
-"   mesh flattening\n"         \
-"\n"         \
-"Usage: meshflatten in out\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Types supported: mesh 3d\n"         \
-"\n"         \
-"Category: mesh3d\n"         \
-"  mesh3d\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3disthmus__c__ "  3disthmus.c\n"         \
-"\n"         \
-" destroys 1D isthmuses in a 3D binary image\n"         \
-"\n"         \
-"Usage: 3disthmus in.pgm out.pgm\n"         \
-"\n"         \
-"Description: destroys 1D isthmuses in a 3D binary image\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ptinterior__c__ "  ptinterior.c\n"         \
-"\n"         \
-" detects interior points in a binary image\n"         \
-"\n"         \
-"Usage: ptinterior in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"An interior point is a white point, all the n-neighbours of which are white\n"         \
-"(n = 4, 8 (2d) or 6, 18, 26 (3d), as set by the parameter  connex)\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2005\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ungerflow__cpp__ "\n"         \
-"    ungerflow.cpp\n"         \
-"\n"         \
-"    Noise filtering with the Ungerflow algorithm [1].\n"         \
-"   \n"         \
-"   Usage: ungerflow( (char_image)source and sink, (float_image)gradient image, (float_image)lambda image, (float_image)guidence image, (int)number of iterations, (float)tau, (float)theta) -> float_image \n"         \
-"   \n"         \
-"   Description: \n"         \
-"\n"         \
-"   The input image is noise filtered according to the following\n"         \
-"   relation:\n"         \
-"   \n"         \
-"      v}\n"         \
-"        g(x)| u|d + \n"         \
-"        + \n"         \
-"        \n"         \
-"       \n"         \
-"     \n"         \
-"   \n"         \
-"   Types supported: float 2d, float 3d, float 4d, ..., float xd\n"         \
-"   \n"         \
-"   Category: signal, development\n"         \
-"     signal, development\n"         \
-"\n"         \
-"   References:\n"         \
-"   [1] Horst Bischof Markus Unger, Thomas Pock. Interactive\n"         \
-"   globally optimal image segmentation. Technical Report ICGTR08/02,\n"         \
-"   Institute for Computer Graphics and Vision Graz University of\n"         \
-"   Technology, Austria, July 2008. \n"         \
-"   [2] M. Unger, T. Pock, and H. Bischof. Continuous\n"         \
-"   globally optimal image segmentation with local constraints. In\n"         \
-"   Computer Vision Winter Workshop 2008, Moravske Toplice, Slovenija,\n"         \
-"   February 2008.\n"         \
-"\n"         \
-"   Examples: can be found in 'tutorial/python/ungerflow'\n"         \
-"\n"         \
-"    Laszlo Marak, 2009-2010\n"         \
-"\n"         \
-"\n"         \
-" \n"         \
-"\n"
-
-
-#define doc__seuili__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__inf__c__ "  inf.c\n"         \
-"\n"         \
-" pixelwise inf predicate\n"         \
-"\n"         \
-"Usage: inf in1.pgm in2.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, if in1[x] \n"         \
-"Images must be of the same type and same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__watershed__c__ "  watershed.c\n"         \
-"\n"         \
-" topological binary watershed (Couprie-Bertrand algorithm)\n"         \
-"\n"         \
-"Usage: watershed in.pgm mark.pgm connex [i] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Topological watershed as defined in [CB97] - connectivity connex.\n"         \
-"A marker image is supplied in mark.pgm. The result is a binary image.\n"         \
-"If the parameter i is given, then the dual operator is applied.\n"         \
-"\n"         \
-"[CB97] M. Couprie and G. Bertrand:\n"         \
-"``Topological Grayscale Watershed Transformation'',\n"         \
-"SPIE Vision Geometry V Proceedings, 3168 (136--146), 1997.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__surimp__c__ "  surimp.c\n"         \
-"\n"         \
-" superimposition of a binary image with a grayscale image\n"         \
-"\n"         \
-"Usage: surimp i1.ndg i2.bin out.ppm\n"         \
-"\n"         \
-"Description: Superimposes the binary image i2.bin (in red) to the \n"         \
-"grayscale image i1.bin. The result is stored as a color image out.ppm.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__regul___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__relabel__c__ "  relabel.c\n"         \
-"\n"         \
-" eliminates 'voids' in the labelling\n"         \
-"\n"         \
-"Usage: relabel in.pgm [out.pgm]\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Modifies the labels of image  in.pgm in such a way that the resulting labels are consecutive integers.\n"         \
-"\n"         \
-"If  out.pgm is not specified, then out.pgm = in.pgm.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: histo\n"         \
-" histo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__xor__c__ "  xor.c\n"         \
-"\n"         \
-" pixelwise xor of two images\n"         \
-"\n"         \
-"Usage: xor in1.pgm in2.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = in1[x] xor in2[x]. \n"         \
-"Images must be of the same type and same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lenoir__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__wshedtopo__c__ "  wshedtopo.c\n"         \
-"\n"         \
-" topological grayscale watershed  (Couprie-Bertrand algorithm)\n"         \
-"\n"         \
-"Usage: wshedtopo in.pgm connex [i] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Topological grayscale watershed as defined in [CB97], preserves the minima - connectivity connex\n"         \
-"If the parameter i is given, then the dual operator is applied.\n"         \
-"\n"         \
-"[CB97] M. Couprie and G. Bertrand:\n"         \
-"``Topological Grayscale Watershed Transformation'',\n"         \
-"SPIE Vision Geometry V Proceedings, 3168 (136--146), 1997.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"wshedtopo ur1 4 ur1_wshedtopo\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"  \n"         \
-"  ur1\n"         \
-"      ur1_wshedtopo\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__test_juliette__cxx__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__pca__c__ "  pca.c\n"         \
-"\n"         \
-" principal component analysis\n"         \
-"\n"         \
-"Usage: pca in.list out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Computes the main directions (2D or 3D vectors) of a set of points in 2D or 3D space, by the method of Pricipal Component Analysis (PCA).\n"         \
-"\n"         \
-"The output is a file in the list \"b\" or \"B\" format that contains the following information:\n"         \
-" center of mass (point)\n"         \
-" first principal direction (vector) \n"         \
-" second principal direction (vector) \n"         \
-" for 3D images, third principal direction (vector) \n"         \
-"\n"         \
-"Types supported: list 2D, list 3D\n"         \
-"\n"         \
-"Category: stats\n"         \
-" stats\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__matchellipse__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__3dmakecomplex__c__ "  3dmakecomplex.c\n"         \
-"\n"         \
-" makes a cellular complex from the given set\n"         \
-"\n"         \
-"Usage: 3dmakecomplex in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Makes a cellular complex from the given set, \n"         \
-"by performing the topological closure.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__list2pgm__c__ "  list2pgm.c\n"         \
-"\n"         \
-" converts from point list representation to pgm\n"         \
-"\n"         \
-"Usage: list2pgm in.list {in.pgm|r\n"         \
-"\n"         \
-"\n"         \
-"s cs ds} [scale] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Reads the file in.list. This file must have one of the following formats:\n"         \
-"  \n"         \
-"  e &lt;n&gt;       s &lt;n&gt;         b &lt;n&gt;         n &lt;n&gt;            B &lt;n&gt;            N &lt;n&gt;    \n"         \
-"  x1          x1 v1         x1 y1         x1 y1 v1         x1 y1 z1         x1 y1 z1 v1\n"         \
-"  x2    or    x2 v2   or    x2 y2   or    x2 y2 v2   or    x2 y2 z2   or    z2 x2 y2 v2\n"         \
-"  ...         ...           ...           ...              ...              ...\n"         \
-"  xn          xn vn         xn yn         xn yn vn         xn yn zn         zn xn yn vn\n"         \
-"\n"         \
-"The formats e, s, b, n, B, and N, correspond respectively\n"         \
-"to binary 1D, graylevel 1D, binary 2D, graylevel 2D, binary 3D and graylevel 3D images.\n"         \
-"If a file name in.pgm is given, then the points read in in.list are \n"         \
-"inserted (if possible) into the image read in in.pgm. Else, they are inserted in\n"         \
-"a new image, the dimensions of which are rs, cs, and d.\n"         \
-"\n"         \
-"The optional parameter  scale allows to scale the coordinates.\n"         \
-"\n"         \
-"Types supported: list 1D, 2D, 3D\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_CKSC3__c__ "  skel_CKSC3.c\n"         \
-"\n"         \
-" sequential 3D binary curvilinear skeleton\n"         \
-"\n"         \
-"Usage: skel_CKSC3 in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Sequentl 3D binary thinning or curvilinear skeleton. The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__seuilhistoglobal__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__meshwarp___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__diffimages__c__ "  diffimages.c\n"         \
-"\n"         \
-" pixelwise absolute value difference of 2 images\n"         \
-"\n"         \
-"Usage: diffimages in1.pgm in2.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = abs (in1[x] - in2[x]). \n"         \
-"Images must be of the same type and same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgm2curve__c__ "  pgm2curve.c\n"         \
-"\n"         \
-" extracts a curve from a binary image\n"         \
-"\n"         \
-"Usage: pgm2curve image.pgm connex [x y [z]] out.curve\n"         \
-"\n"         \
-"Description:\n"         \
-"Extracts a curve from a binary image. \n"         \
-"The parameter  connex is the connexity of the curve.\n"         \
-"It may be equal to 4 or 8 in 2D, and to 6, 18 or 26 in 3D.\n"         \
-"If given, the point (x, y, z) (2D) or (x, y, z) (3D) \n"         \
-"is the beginning of the curve, and must be an end point. \n"         \
-"The output is the text file  out.curve, with the following format:\n"         \
-"b nbpoints\n"         \
-"x1 y1\n"         \
-"x2 y2\n"         \
-"...\n"         \
-"or (3D): \n"         \
-"B nbpoints\n"         \
-"x1 y1 z1\n"         \
-"x2 y2 z2\n"         \
-"...\n"         \
-"\n"         \
-"The points of the curve may also be valued. This is must be indicated by \n"         \
-"a value of 40, 80, 60, 180 or 260 for the parameter  connex, instead\n"         \
-"of 4, 8, 6, 18 or 26 respectively. In this case,\n"         \
-"the output is the text file  out.curve, with the following format:\n"         \
-"n nbpoints\n"         \
-"x1 y1 v1\n"         \
-"x2 y2 v2\n"         \
-"...\n"         \
-"or (3D): \n"         \
-"N nbpoints\n"         \
-"x1 y1 z1 v1\n"         \
-"x2 y2 z2 v2\n"         \
-"...\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: convert geo\n"         \
-"  convert geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__segmentvol__c__ "  segmentvol.c\n"         \
-"\n"         \
-" segmentation by filtering components on a volume criterion\n"         \
-"\n"         \
-"Note: in the python front-end 'm' is mandatory, set 0 without maximization\n"         \
-"and 1 with maximization.\n"         \
-"\n"         \
-"Usage: segmentvol in.pgm connex vol out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Segmentation by selection of cross-section components, based on a \n"         \
-"volume criterion. \n"         \
-"Connexity = connex ; volume threshold = vol.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-"  connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_ACK3a__c__ "  skel_ACK3a.c\n"         \
-"\n"         \
-" parallel 3D binary curvilinear, asymetric skeleton based on thin 1D isthmus\n"         \
-"\n"         \
-"Usage: skel_ACK3a in.pgm nsteps [ndel [inhibit]] out.pgm\n"         \
-"\n"         \
-"Description: Parallel 3D binary thinning or curvilinear,\n"         \
-"asymetric skeleton based on thin 1D isthmus. The parameter  nsteps\n"         \
-"gives, if positive, the number of parallel thinning steps to be\n"         \
-"processed.  If the value given for  nsteps equals -1, the thinning\n"         \
-"is continued until stability.\n"         \
-"\n"         \
-"During the first  ndel steps (default value 0), detected curve points are marked: they are indicated by a value 127 (instead of 255) in the output image.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-" When  ndel is not set to 0, the output image may contain points with value 127.\n"         \
-"\n"         \
-" The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dynrecons__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__dilatplan__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__histo__c__ "  histo.c\n"         \
-"\n"         \
-" computes the histogram of an image or a region\n"         \
-"\n"         \
-"Usage: histo in.pgm [mask.pgm] out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Calculates the histogram of  im.pgm (masked by the binary image\n"         \
-" mask.pgm, if given) and saves it in file  out.list .\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: histo\n"         \
-"  histo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__histosieve__c__ "  histosieve.c\n"         \
-"\n"         \
-" eliminates points with values that are seldom in the histogram\n"         \
-"\n"         \
-"Usage: histosieve in.pgm val [out.pgm]\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"The points which value appear strictly less than  val times in the image are eliminated.\n"         \
-"\n"         \
-"If  out.pgm is not specified, then out.pgm = in.pgm.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: histo\n"         \
-" histo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__watershedMeyer3__c__ "  watershedMeyer3.c\n"         \
-"\n"         \
-" watershed transformation (Meyer's algorithm) with labelled markers and without separation lines\n"         \
-"\n"         \
-"Usage: watershedMeyer3 in mark {roi|null} connex out\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs the watershed transformation without separation lines, on the image in, taking the\n"         \
-"set of markers in mark, in the form of a label image where all the pixels\n"         \
-"sharing the same label (even if not connected) belong to the same marker.\n"         \
-"If this parameter is present, roi\n"         \
-"indicates the region of interest on which the operation is performed.\n"         \
-"The parameter connex gives the adjacency relation (4,8 in 2D; 6,18,26 in 3D) \n"         \
-"for the makers.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__meshregul__c__sav__ "  meshregul.c\n"         \
-"\n"         \
-" mesh smoothing\n"         \
-"\n"         \
-"Usage: meshregul in mode [param1 [param2]] out\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Mesh smoothing. \n"         \
-"The possible choices for parameter mode are:\n"         \
-" 0: Laplacian smoothing (param1 = number of iterations, default value 5)\n"         \
-" 1: Hamam method [HC06] (param1 = theta, default value 1.0)\n"         \
-" 2: Vollmer, Mencl and Mueller method [VMM] (param1 = alpha, param2 = beta, default values 0.1 and 0.6 resp.)\n"         \
-" 3: Hamam method [HC06], variant: matrix A used instead of AA (param1 = theta, default value 1.0)\n"         \
-" 4: Hamam method [HC06], variant: theta = infty (param1 = number of iterations, default value 5)\n"         \
-" 5: Hamam method [HC06], conjugate gradient algorithm (param1 = theta, default value 1.0)\n"         \
-"\n"         \
-"[HC06] Y. Hamam \"\", to appear, 2006\n"         \
-"\n"         \
-"Types supported: mesh 3d\n"         \
-"\n"         \
-"Category: mesh3d\n"         \
-"  mesh3d\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ptextensible__c__ "  ptextensible.c\n"         \
-"\n"         \
-" detects extensible points in a grayscale image\n"         \
-"\n"         \
-"Usage: ptextensible im.pgm {imcond.pgm|null} connex fileout.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Extensible point detection.\n"         \
-"The input image  im.pgm must be a \"thin\" grayscale image, as\n"         \
-"the output of the operator  hthin.\n"         \
-"The parameter  connex indicates the cconnectivity used for the minimal \n"         \
-"regions.\n"         \
-"The optional parameter  imcond.pgm is a binary image which indicates the points\n"         \
-"in the neighborhood of which the extensible points will be searched.\n"         \
-"\n"         \
-"Reference: \n"         \
-"M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lfopen3d_line__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__hfilling__c__ "  hfilling.c\n"         \
-"\n"         \
-" homotopic filling (pseudo closing) by a ball\n"         \
-"\n"         \
-"Usage: hfilling in.pgm r connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Homotopic filling (pseudo closing) by a ball of radius  r.\n"         \
-"\n"         \
-"Reference: \n"         \
-"[CB04] M. Couprie and G. Bertrand:\n"         \
-"Topology preserving alternating sequential filter for smoothing \n"         \
-"2D and 3D objects,  Journal of Electronic Imaging, Vol.&nbsp;13, No.&nbsp;4, pp.&nbsp;720-730, 2004.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho, topobin\n"         \
-"  morpho, topobin\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__2dflowskeleton__c__foret__ "  void Morsify(graphe * g, boolean * Vh, TYP_VSOM epsilon)\n"         \
-"     g (entrÃ©e) : un graphe pondÃ©rÃ© sur les sommets.\n"         \
-"     TODO\n"         \
-"     ne s'applique qu'aux graphes sans circuit\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_CK3__c__ "  skel_CK3.c\n"         \
-"\n"         \
-" parallel 3D binary curvilinear skeleton\n"         \
-"\n"         \
-"Usage: skel_CK3 in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 3D binary thinning or curvilinear skeleton. The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__recalagerigide_num__c__ "  recalagerigide_num.c\n"         \
-"\n"         \
-" rigid registration of two grayscale images\n"         \
-"\n"         \
-"Usage: recalagerigide_num in1 in2 seuil [init] out\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Rigid registration of two grayscale images. \n"         \
-"Let X and Y be two images, given respectively by  in1 and  in2.\n"         \
-"This procedure identifies the parameters of a rigid deformation R such that\n"         \
-"the \"distance\" between R(X) and Y is a local minimum.\n"         \
-"The distance D(Z,Y) between two images Z and Y is defined by:\n"         \
-"\n"         \
-"D(Z,Y) = sum { (Z[i] - Y[i])^2 ; for all i in support(Y) }\n"         \
-"\n"         \
-"The rigid deformation R is defined as the composition (in this order) \n"         \
-"of a zoom, a rotation, and a translation. \n"         \
-"\n"         \
-"In 2d, the parameters are:\n"         \
-" hx : parameter for the scaling in direction x\n"         \
-" hy : parameter for the scaling in direction y\n"         \
-" theta : angle (in degrees) of the rotation around (0,0)\n"         \
-" tx : parameter for the translation in direction x\n"         \
-" ty : parameter for the translation in direction y\n"         \
-"\n"         \
-"The output parameter  out is the name of a text file in which these \n"         \
-"values will be written (type \"e\" list format, see doc/formats.txt).\n"         \
-"\n"         \
-"The parameter  seuil makes it possible to eliminate outliers: \n"         \
-"points i such that (Z[i] - Y[i])^2 > seuil^2 are not taken into account.\n"         \
-"A value 255 for this parameter means no outlier elimination.\n"         \
-"\n"         \
-"The optional parameter  init makes it possible to give, \n"         \
-"in the same format as the output, an initial deformation which is \n"         \
-"\"close\" to the expected one. The default initialisation is the identity\n"         \
-"(parameters 0, 1, 1, 0, 0).\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__genkernel__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__egalise__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__fermetrous3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__pgm2GA__c__ "  pgm2GA.c\n"         \
-"\n"         \
-" Computes an edge-weighted graph from an image\n"         \
-"\n"         \
-"Usage: pgm2GA im.pgm param [alpha] out.ga \n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Computes a GA (an edge-weighted graph) from an image. The values of an\n"         \
-"edge linking two pixels {x,y} is computed according to the parameter\n"         \
-"param.\n"         \
-"\n"         \
-"If param = 0, the absolute difference of intensity between x and y is used.\n"         \
-"\n"         \
-"If param = 1, the maximum between the intensities of x and y is used.\n"         \
-"\n"         \
-"If param = 2, the minimum between the intensities of x and y is used.\n"         \
-"\n"         \
-"If param = 3, a Deriche-like gradient is used, the optional parameter\n"         \
-"alpha specifies the spatial extention of the filter (by default alpha\n"         \
-"is set to  1]),\n"         \
-"\n"         \
-"If im.pgm is a 2D (resp. 3D) image, then out.ga is a 2D (resp\n"         \
-"3D GA), that is a 2D 4-connected edge-weighted graph (resp. a 2D\n"         \
-"6-connected edge-weighted graph).\n"         \
-"\n"         \
-"\n"         \
-"Types supported: GA byte 2D, GA byte 3D, GA float 2D\n"         \
-"\n"         \
-"Category: \n"         \
-"  GA\n"         \
-"\n"         \
-" Jean Cousty\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__min__c__ "  min.c\n"         \
-"\n"         \
-" minimum of 2 images\n"         \
-"\n"         \
-"Usage: min in1.pgm in2.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = min{in1[x], in2[x]}. \n"         \
-"Images must be of the same type and same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dskelck__c__ "  3dskelck.c\n"         \
-"\n"         \
-" homotopic thinning based on critical kernels\n"         \
-"\n"         \
-"Usage: 3dskelck in.pgm mode niter [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Homotopic thinning of a 3d Khalimsky image.\n"         \
-"The maximum number of steps is given by niter.\n"         \
-"If the value given for  niter equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"The parameter  mode specifies the algorithm used for thinning.\n"         \
-"Possible choices are:\n"         \
-" 0: ultimate crucial thinning, symmetrical\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-" Input must be a complex with no point on the image border.\n"         \
-"\n"         \
-"References: \n"         \
-"\n"         \
-"[Ber07] G. Bertrand: \"On critical kernels\", Comptes-rendus de l'AcadÃ©mie des Sciences, sÃ©rie math., Vol. I, Nb. 345, pp. 363-367, 2007.\n"         \
-"\n"         \
-"[BC09] G. Bertrand and M. Couprie: \"On parallel thinning algorithms: minimal non-simple sets, P-simple points and critical kernels\", Journal of Mathematical Imaging and Vision, Vol. 35, Nb. 1, pp. 23-35, 2009.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skelpruning__c__ "  skelpruning.c\n"         \
-"\n"         \
-" pruning of \"short end branches\" in a curvilinear skeleton\n"         \
-"\n"         \
-"Usage: skelpruning in.skel length out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"The skeleton found in  is searched for \"small\" branches which satisfy the following criteria:\n"         \
-" Branch has exactly one end\n"         \
-" Branch length is less than or equal to  length parameter.\n"         \
-"\n"         \
-"Parameter  length is a number pixels.\n"         \
-"\n"         \
-"Matching arcs are written in  out.pgm.\n"         \
-"\n"         \
-"Types supported: skel 2d, skel 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2011\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgm2pov__c__ "  pgm2pov.c\n"         \
-"\n"         \
-" generates a povray file from a 3D image\n"         \
-"\n"         \
-"Usage: pgm2pov in.pgm mode out.pov\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"mode = \n"         \
-"   0 (none)\n"         \
-"   1 (between points)\n"         \
-"   2 (everywhere)\n"         \
-"   3 (6-links)\n"         \
-"   4 (26-links)\n"         \
-"   5 (cubes)\n"         \
-"   6 (triangles)\n"         \
-"   10-14: idem 0-4, khalimsky grid\n"         \
-"   15: colored khalimsky \n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lfclose3d_rect__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__identifyplane__c__ "  identifyplane.c\n"         \
-"\n"         \
-" identification of a best matching plane from a set of 3D points\n"         \
-"\n"         \
-"Usage: identifyplane in.list out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Identifies the parameters (a, b, c, d) of the equation of the 3D plane:\n"         \
-"ax+by+cz+d=0 that minimizes the least square error between this plane \n"         \
-"and the given points. Method: basic linear regression.\n"         \
-"\n"         \
-"The result is given as a file that contains a list of 5 numbers: a, b, c, d the parameters of the equation, and e the least square error.\n"         \
-"\n"         \
-"Types supported: list 3D\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__distgeo__c__ "  distgeo.c\n"         \
-"\n"         \
-" geodesic distance\n"         \
-"\n"         \
-"Usage: distgeo in.pgm mask.pgm mode out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Geodesic distance to the object X defined by the binary image  in.pgm ,\n"         \
-"in the object Y defined by the binary image  mask.pgm .\n"         \
-"\n"         \
-"The distance d used depends on the parameter  mode :\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"   morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lambdalthin__c__ "  lambdalthin.c\n"         \
-"\n"         \
-" grayscale filtered leveling\n"         \
-"\n"         \
-"Usage: lambdalthin in.pgm {imcond.pgm|null} connex niter h out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Filtered leveling for 2D grayscale images. \n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__gradinf__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__dilatbin3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__2dkhalimskize__c__ "  2dkhalimskize.c\n"         \
-"\n"         \
-" converts a 2D image into a 2D Khalimsky order\n"         \
-"\n"         \
-"Usage: 2dkhalimskize in.pgm {0|4|8|h|m|M|g|G|a} out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Converts a 2D image into a 2D Khalimsky order, or conversely.\n"         \
-"\n"         \
-"Modes 0, 4, 8 and h are for binary images. \n"         \
-"\n"         \
-"Modes m, M, g, G and a are for grayscale images. \n"         \
-"\n"         \
-"Mode = \n"         \
-"    0 : only maximal elements,\n"         \
-"    4 : emulates 4-connectivity, idem \"miss\", \n"         \
-"    8 : emulates 8-connectivity (\"hit\" transform followed by a kernel transform),   \n"         \
-"    h : \"hit\",\n"         \
-"    m : min, \n"         \
-"    M : max,\n"         \
-"    g : gradient 2, \n"         \
-"    G : gradient 4,\n"         \
-"    a : average,\n"         \
-"    R : reverse.\n"         \
-"\n"         \
-"In reverse mode (R), only the beta-terminal elements (squares) are selected.\n"         \
-"\n"         \
-"Types supported: byte 2d, long 2d, float 2d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__gradient_abs__cpp__ "\n"         \
-"    gradient_abs.cpp\n"         \
-"\n"         \
-"    Computes the absolute value of the gradient of the spline\n"         \
-"   approximation of the image.\n"         \
-"   \n"         \
-"   Usage: gradient_abs( (float_image)image) -> float_image\n"         \
-"   \n"         \
-"   Description: The an image can be considered as a continuous\n"         \
-"   field. This function approximates the image in all directions (x,\n"         \
-"   y, z), with a 1D spline. Than it calculates the absolute value of\n"         \
-"   the gradient for every point in form\n"         \
-"\n"         \
-"   g[[x,y,z]] = fabs([ pd_x g, pd_y g, pd_z g ])\n"         \
-"\n"         \
-"   here 'pd_x' stands for the partial derivative in the 'x' direction.\n"         \
-"\n"         \
-"   Types supported: float 2d, float 3d\n"         \
-"   \n"         \
-"   Category: signal, development\n"         \
-"    signal, development\n"         \
-"\n"         \
-"   References:\n"         \
-"   [1]  GNU Scientific Library \n"         \
-"    Laszlo Marak, 2009-2010\n"         \
-"\n"         \
-"\n"         \
-" \n"         \
-"\n"
-
-
-#define doc__vskel2graph___notfinished_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lferode_rect__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__isometry__c__ "  isometry.c\n"         \
-"\n"         \
-" basic isometries in 3D \n"         \
-"\n"         \
-"Usage: isometry in MODE out\n"         \
-"\n"         \
-"Description:\n"         \
-"Basic isometries in 2D and 3D.\n"         \
-"Available modes: xzy, yxz, yzx, zxy, zyx, (3D), and\n"         \
-"0: identity,\n"         \
-"1: rotation 90 degrees clockwise,\n"         \
-"2: rotation 180 degrees clockwise,\n"         \
-"3: rotation 270 degrees clockwise,\n"         \
-"4: symmetry / vertical axis,\n"         \
-"5: symmetry / horizontal axis.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__heightminima__c__ "  heightminima.c\n"         \
-"\n"         \
-" h-minima operator\n"         \
-"\n"         \
-"Usage: heightminima in.pgm connex height out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"h-minima with connexity connex and depth height.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__showpoint__c__ "  showpoint.c\n"         \
-"\n"         \
-" prints the value of a given point \n"         \
-"\n"         \
-"Usage: showpoint in.pgm x y z\n"         \
-"\n"         \
-"Description:\n"         \
-"The value of the point (x,y,z)\n"         \
-"is printed in the standard output stream.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lpetoporeg__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__voronoilabelling__c__ "  voronoilabelling.c\n"         \
-"\n"         \
-" voronoi labelling (and squared Euclidean distance transform)\n"         \
-"\n"         \
-"Usage: voronoilabelling in.pgm [dist.pgm] vor.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Types supported: byte 2d,  byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__shencastan__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lambdamedialaxis2__c__ "  lambdamedialaxis2.c\n"         \
-"\n"         \
-" discrete lambda-medial axis transform\n"         \
-"\n"         \
-"Usage: lambdamedialaxis2 in.pgm auxlambda lambda out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Experimental\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lfdilat3d_line__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__CMakeLists__txt__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__worms__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__ppm2bmp__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__gettree__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__hthickbin__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__nbtopo__c__ "  nbtopo.c\n"         \
-"\n"         \
-" connectivity numbers\n"         \
-"\n"         \
-"Usage: nbtopo filein.pgm connex {PP|P|M|MM} fileout.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each point p of the input grayscale image, compute the connectivity number T++,\n"         \
-"T+, T- or T-- according to the given option (resp. PP, P, M, MM).\n"         \
-"Refs: [BEC97, CBB01].\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dir__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__integermedialaxis__c__ "  integermedialaxis.c\n"         \
-"\n"         \
-" integer medial axis transform\n"         \
-"\n"         \
-"Usage: integermedialaxis in.pgm [gamma] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Integer medial axis, as defined in [HR05],\n"         \
-"of the binary image  X contained in  in.pgm.\n"         \
-"\n"         \
-"References:\n"         \
-"[HR05] \"Euclidean Skeletons of 3D Data Sets in Linear Time\n"         \
-"by the Integer Medial Axis Transform\",\n"         \
-"W.H. Hesselink and B.T.M. Roerdink,\n"         \
-"Computational Imaging and Vision, Vol. 30,\n"         \
-"Mathematical Morphology: 40 Years On, Springer, 2005, pp. 259-268\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__bmp2pgm__c__ "  bmp2pgm.c\n"         \
-"\n"         \
-" \n"         \
-"\n"         \
-"Usage: \n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__short2long__c__ "  short2long.c\n"         \
-"\n"         \
-" converts a \"short\" image to a \"int32_t\" image\n"         \
-"\n"         \
-"Usage: short2long in [out]\n"         \
-"\n"         \
-"Description: \n"         \
-"\n"         \
-"For each pixel x, out[x] = (int32_t)in[x].\n"         \
-"\n"         \
-"If the last argument  out is omitted, then out = in.\n"         \
-"\n"         \
-"Types supported: short 2d, short 3d.\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__volmaxima__c__ "  volmaxima.c\n"         \
-"\n"         \
-" volume-based filtering\n"         \
-"\n"         \
-"Usage: volmaxima in.pgm connex vol out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Volume-based filtering with connexity connex and volume vol.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__saliencyGA__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__maxflow__cpp__ "\n"         \
-"    maxflow.cpp\n"         \
-"\n"         \
-"    Calculates the optimal surface segmentation with the maximum\n"         \
-"   flow algorithm [1].\n"         \
-"   \n"         \
-"   Usage: maxflow( (char_image)source and sink, (float_image)constraint image, (int)iterations, (float)tau [, (int)number of threads=0]) -> float_image\n"         \
-"   \n"         \
-"   Description: In the input, you specify the constraint image\n"         \
-"   'g' and two subsets of the image 'S'==1 and 'P'==-1. The operator\n"         \
-"   will return a binary flow 'result', which is 0 or 1 almost\n"         \
-"   everywhere. The surface around the volume with value 1 will be the\n"         \
-"   optimum in the sense, that it will contain 'S', not contain 'P' and\n"         \
-"   and it's integral will be the smallest possible.\n"         \
-"\n"         \
-"   Generally, we choose the inverse of the gradient for 'g'. Sometimes\n"         \
-"   the inverse is weighted circularly, so gaps in the border are\n"         \
-"   interpolated with circles. \n"         \
-"\n"         \
-"   Usually the values, that are known to be in the object (which you\n"         \
-"   want to segment) are set to sink (value 1). You can set sink (value\n"         \
-"   -1) the points, which you know to be outside the object, but\n"         \
-"   generally the border is sufficient.\n"         \
-"   \n"         \
-"   Types supported: float 2d, float 3d, float 4d, ..., float xd\n"         \
-"   \n"         \
-"   Category: signal, development\n"         \
-"     signal, development\n"         \
-"   \n"         \
-"   References: [1] Appleton, B. and Talbot, H. (2006). Globally minimal\n"         \
-"   surfaces by continuous maximal ï¬ows. IEEE Transactions on Pattern\n"         \
-"   Analysis and Machine Intelligence, 28(1):106â118.\n"         \
-"\n"         \
-"    Laszlo Marak, 2009-2010\n"         \
-"\n"         \
-"\n"         \
-" \n"         \
-"\n"
-
-
-#define doc__segment__c__sav__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__erosbin3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__MSF__c__ "  MSF.c\n"         \
-"\n"         \
-" \n"         \
-"Compute a minimum spanning forest of a GA from a set of markers\n"         \
-"\n"         \
-"Usage: MSF GAin.ga marqueurs.pgm typeResul Result.?? \n"         \
-"\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Compute a minimum spanning forest of GAin.ga (a 4-connected 2D\n"         \
-"or 6-connected 3D edge-weighted graph) relative to the connected\n"         \
-"components of the non-zero pixels of marqueurs.pgm. If\n"         \
-"TypeResult = 0, then Result.?? is a GA whose non-zero edges form the\n"         \
-"induced MSF cut, otherwise Result.?? is a label image that represents\n"         \
-"the vertex partition induced by the MSF (the connected components of\n"         \
-"the MSF are marked with distinct labels).\n"         \
-"\n"         \
-"See [COUSTYetAl-PAMI2009] and [COUSTYetAl-PAMI2010] for more details.\n"         \
-"\n"         \
-"Types supported: GA byte 2D, GA byte 3D\n"         \
-"\n"         \
-"Category: \n"         \
-"  GA\n"         \
-"\n"         \
-" Jean Cousty\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__2dmakecomplex__c__ "  2dmakecomplex.c\n"         \
-"\n"         \
-" makes a cellular complex from the given set\n"         \
-"\n"         \
-"Usage: 2dmakecomplex in.pgm [i] out.pgm\n"         \
-"\n"         \
-"Note:  in python for the i option use function 'l2dclosebeta'\n"         \
-"\n"         \
-"Description:\n"         \
-"Makes a cellular complex from the given set, \n"         \
-"by performing the topological closure.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__addconst__c__ "  addconst.c\n"         \
-"\n"         \
-" adds a constant value to an image\n"         \
-"\n"         \
-"Usage: addconst in.pgm const [out.pgm]\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = in[x] + const. If out[x] \n"         \
-"exceeds 255, then out[x] is set to 255.\n"         \
-"\n"         \
-"If  out.pgm is not specified, then out.pgm = in.pgm.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__kern__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__skel_CKG__c__ "  skel_CKG.c\n"         \
-"\n"         \
-" parallel 2D and 3D binary guided thinning\n"         \
-"\n"         \
-"Usage: skel_CKG in.pgm prio.pgm val out.pgm\n"         \
-"\n"         \
-"Description: Parallel 2D and 3D binary guided thinning based on\n"         \
-"critical kernels. The parameter  in.pgm specifies the set\n"         \
-"(object) to be thinned. The parameter  prio.pgm specifies the priority\n"         \
-"function. The parameter  val is a threshold: any\n"         \
-"pixel having a priority greater than or equal to  val will be preserved\n"         \
-"from deletion.  If  val equals -1, then all points will be\n"         \
-"considered for deletion.\n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgm2bmp__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__labeltree__c__ "  labeltree.c\n"         \
-"\n"         \
-" branch distance\n"         \
-"\n"         \
-"Usage: labeltree in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Level of the branch section defined by his level in the tree. Returns the level\n"         \
-"max of the branches.\n"         \
-"\n"         \
-"The distance d used depends on the parameter  connex :\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: topo\n"         \
-"   topo\n"         \
-"\n"         \
-" Cédric Allène\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__crestrestoration__c__ "  crestrestoration.c\n"         \
-"\n"         \
-" crest restoration algorithm \n"         \
-"\n"         \
-"Usage: crestrestoration im.pgm {imcond.pgm|null} connex niter fileout.pgm [condout.pgm]\n"         \
-"\n"         \
-"Description:\n"         \
-"Crest restoration algorithm, as described in ref. CBB01.\n"         \
-"The input image  im.pgm must be a \"thin\" grayscale image, as\n"         \
-"the output of the operator  hthin.\n"         \
-"The parameter  connex indicates the connectivity used for the minimal \n"         \
-"regions.\n"         \
-"The parameter  niter gives the number of iterations.\n"         \
-"The optional parameter  imcond.pgm is a binary image (a set C) which indicates the points\n"         \
-"in the neighborhood of which the extensible points will be searched.\n"         \
-"The points which are modified by the algorithm will be dynamically added to C.\n"         \
-"The optional parameter  condout.pgm is an output file containing the final state of the \n"         \
-"set C.\n"         \
-"\n"         \
-"Reference: \n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__min1__c__ "  min1.c\n"         \
-"\n"         \
-" return the minimum of the pixel values of an image\n"         \
-"\n"         \
-"Usage: min1 in.pgm [out.list]\n"         \
-"\n"         \
-"Description:\n"         \
-"This function returns (in the list out.list) \n"         \
-"the minimum of the pixel values of the image  in.pgm .\n"         \
-"\n"         \
-"If the parameter  out.list is ommitted, the result is printed on the standard output.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__hitormiss__c__ "  hitormiss.c\n"         \
-"\n"         \
-" morphological hit or miss transformation for binay images\n"         \
-"\n"         \
-"Usage: hitormiss in.pgm e1.pgm e2.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let X be the input set, E1, E2 be the two structuring elements, the result Y is given by:\n"         \
-"Y = (X - E1) inter (Xb - E2)\n"         \
-"where '-' denotes the erosion operator, and 'Xb' denotes the complementary of X.  \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, long3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2003\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__bisector__c__ "  bisector.c\n"         \
-"\n"         \
-" compute the bisector function of a binary image\n"         \
-"\n"         \
-"Usage: bisector dist.pgm mask.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"The bisector function is computed for the points which are non-null in the binary image\n"         \
-" mask.pgm , from the exact quadratic euclidean distance map found in  dist.pgm .\n"         \
-"\n"         \
-" If the image  dist.pgm is not an exact quadratic euclidean distance map, \n"         \
-"then the result of this operator will make no sense. \n"         \
-"\n"         \
-"References: \n"         \
-"[CCZ07] M. Couprie, D. Coeurjolly and R. Zrour: \"Discrete bisector function and Euclidean skeleton in 2D and 3D\", Image and Vision Computing, Vol.&nbsp;25, No.&nbsp;10, pp.&nbsp;1543-1556, 2007.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d \n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-"\n"         \
-" Rita Zrour, Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lpemeyer3d___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__contours__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__mcube__c__ "  mcube.c\n"         \
-"\n"         \
-" topologically correct \"marching cubes\"-like algorithm\n"         \
-"\n"         \
-"Usage: mcube in.pgm threshold nregul obj_id format [connex] out\n"         \
-"\n"         \
-"Description:\n"         \
-"Generates a 3d mesh from the binary or grayscale image  in.pgm .\n"         \
-"\n"         \
-"The original image is first thresholded (parameter  threshold, values 0 and 1\n"         \
-"both fit for a binary image). Then the method described in [Lac96] is applied to\n"         \
-"generate the 3d mesh. The resulting mesh is then smoothed by  nregul steps of \n"         \
-"laplacian smoothing. The parameter  obj_id is used to tag the generated mesh.\n"         \
-"\n"         \
-"The parameter  format indicate the format of the output file \n"         \
-"(choices are POV, POVB, COL, MCM, AC, GL, VTK, RAW).\n"         \
-"The keyword POVB corresponds to a bare Povray mesh: \n"         \
-"a header and a footer must be catenated in order to make a full Povray scene. \n"         \
-"The keyword RAW is the exchange format for the \"mesh\" software: see http://mesh.berlios.de/\n"         \
-"\n"         \
-"The optional parameter  connex indicates the connexity used for the object.\n"         \
-"Possible values are 6 and 26 (default).\n"         \
-"\n"         \
-"[Lac96] J.-O. Lachaud, \"Topologically defined iso-surfaces\", DGCI'96, LNCS 1176 (245--256), Springer Verlag, 1996.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: mesh3d\n"         \
-"  mesh3d\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__maxdiameter__c__ "  maxdiameter.c\n"         \
-"\n"         \
-" maximal diameter of a binary image\n"         \
-"\n"         \
-"Usage: maxdiameter in connex out\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Find two points x, y in a set X (binary image in) such that \n"         \
-"d(x,y) is greater or equal to d(v,w) for any two points v, w in X.\n"         \
-"The distance d is the Euclidean distance.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Gu Jun\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ellipseincl__c__ "  ellipseincl.c\n"         \
-"\n"         \
-" ellipse identification and drawing from spare points\n"         \
-"\n"         \
-"Usage: ellipseincl in.pgm pts.list filled out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie and Yskandar Hamam\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__variance1__c__ "  variance1.c\n"         \
-"\n"         \
-" return the variance of the pixel values of an image\n"         \
-"\n"         \
-"Usage: variance1 in.pgm [mask.pgm] out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"This function returns (in the list out.list) \n"         \
-"the variance of the pixel values of the image  in.pgm .\n"         \
-"If the optional parameter  mask.pgm is given, then only the \n"         \
-"values which correspond to non-null points of mask are considered.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: signal stats\n"         \
-" signal stats\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__GAwatershedDouble__c__ "  GAwatershedDouble.c\n"         \
-"\n"         \
-" Compute the watershed of a 4-connected edge-weighted graph (a GA) where the weights are doubles.\n"         \
-"\n"         \
-"Usage: \n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Types supported: GA byte 2D \n"         \
-"\n"         \
-"Category: \n"         \
-"  \n"         \
-"\n"         \
-" Jean Cousty\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__reconseros3d___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__shortestpath__c__ "  shortestpath.c\n"         \
-"\n"         \
-" finds a shortest path from x to y in image \n"         \
-"\n"         \
-"Usage: shortestpath in.pgm connex mode S1 S2 [S3] D1 D2 [D3] out.lst\n"         \
-"\n"         \
-"Description:\n"         \
-"A weighted graph G = (V,E) is defined with V = set of pixels of  in.pgm \n"         \
-"and E = {(P,Q) in VxV ; P and Q are  connex- adjacent}. \n"         \
-"Let F(P) be the value of pixel P in the image  in.pgm. \n"         \
-"A weight W(P,Q) is assigned to each edge, according to the value of  mode:\n"         \
-"\n"         \
-" max : W(P,Q) = max{F(P),F(Q)} \n"         \
-" min : W(P,Q) = min{F(P),F(Q)} \n"         \
-" avg : W(P,Q) = (F(P) + F(Q)) / 2 \n"         \
-"\n"         \
-"This operator finds a shortest path from ( S1,  S2) to ( D1,  D2)\n"         \
-"in this graph. The result is given as a list of vertices (pixels) \n"         \
-"in  out.lst.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__selrect__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__eden__cxx__ "  eden.cxx\n"         \
-"\n"         \
-" growth and/or shrinking of an 2D binary image - Eden process\n"         \
-"\n"         \
-"Usage: eden in.pgm niter grow shrink topo out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Algorithm is as follows.\n"         \
-"\n"         \
-"For growth:\n"         \
-"   start from known set\n"         \
-"   take pixels from the border into a queue\n"         \
-"   choose randomly one such pixel\n"         \
-"   set it to 1\n"         \
-"   update queues\n"         \
-"   repeat\n"         \
-"\n"         \
-"For shrinking:\n"         \
-"   same thing but set to 0\n"         \
-"\n"         \
-"For adding boundary noise\n"         \
-"   alternate growth and shrinking\n"         \
-"\n"         \
-"With topological constraints\n"         \
-"   make sure the point to add or remove is simple\n"         \
-"\n"         \
-"Parameters:\n"         \
-"   niter (positive integer): number of iterations\n"         \
-"   grow (1/0): perform growing or not\n"         \
-"   shrink (1/0): perform shrinking or not\n"         \
-"   topo (26/6/8/4/0): connectivity for the object - 0: no topological constraint\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-" geo\n"         \
-"\n"         \
-" Hugues Talbot\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__deletewells__c__ "  deletewells.c\n"         \
-"\n"         \
-" deletes wells in a grayscale image \n"         \
-"\n"         \
-"Usage: deletewells filein.pgm [mask] connexmin fileout.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Deletes wells in a grayscale image. A point p is a well if T-(p) = 0\n"         \
-"(see ref. [BEC97]).\n"         \
-"\n"         \
-"References: \n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawcircle_notused_c__ "  drawellipse.c\n"         \
-"\n"         \
-" Draws an ellipse\n"         \
-"\n"         \
-"Usage: drawellipse in.pgm x1 y1 x2 y2 X1 Y1 X2 Y2 [filled] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws an  ellipse specified by four points, e.g. the extremities of the small axis \n"         \
-"(x1, y1, x2, y2) and the extremities of the big axis \n"         \
-"(X1, Y1, X2, Y2).\n"         \
-"The ellipse is surimposed to the contents of in.pgm.\n"         \
-"If the (optional) int32_t parameter  filled is set (1), then the ellipse is filled.\n"         \
-"Otherwise it is empty (default).\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: draw geo\n"         \
-"  draw geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dilatballnum__c__ "  dilatballnum.c\n"         \
-"\n"         \
-" morphological grayscale dilation by an Euclidean ball\n"         \
-"\n"         \
-"Usage: dilatballnum in.pgm r out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Morphological grayscale dilation by an Euclidean ball.\n"         \
-"The parameter  r must a positive number (int or float), \n"         \
-"the structuring element for this dilation is a ball (or a disc) of radius  r.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2006\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dthin__c__ "  3dthin.c\n"         \
-"\n"         \
-" homotopic thinning of a 3d Khalimsky image\n"         \
-"\n"         \
-"Usage: 3dthin in.pgm n out.pgm\n"         \
-"\n"         \
-"Description: Homotopic thinning of a 3d Khalimsky image.\n"         \
-"The maximum number of steps is given by n.\n"         \
-"If the value given for  n equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__scale__c__ "  scale.c\n"         \
-"\n"         \
-" product of an image by a scalar\n"         \
-"\n"         \
-"Usage: scale in.pgm const out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = in[x] * const. If the image is a byte image,\n"         \
-"and if out[x] exceeds 255, then out[x] is set to 255.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ptseparating__c__ "  ptseparating.c\n"         \
-"\n"         \
-" detects separating points in a 2D or 3D binary image\n"         \
-"\n"         \
-"Usage: ptseparating in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"A separating point is a white point x such that Tb_n[x] >= 2\n"         \
-"(n = 4,8 in 2D or n = 6,18,26 in 3D, as set by the parameter  connex)\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d \n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__label__c__ "  label.c\n"         \
-"\n"         \
-" labeling of some flat zones of a grayscale or a binary image\n"         \
-"\n"         \
-"Usage: label in.pgm connex {fgd|bgd|min|max|pla} out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The argument  connex selects the connectivity (4, 8 in 2D; 6, 18, 26 in 3D).\n"         \
-"The argument  selects the kind of flat zone\n"         \
-"to be labeled:\n"         \
-"  fgd selects foreground components for a binary image\n"         \
-"  bgd selects background components for a binary image\n"         \
-"  min selects regional minima\n"         \
-"  max selects regional maxima\n"         \
-"  pla selects all flat zones (plateaux).\n"         \
-"The output image  out.pgm has the type \"int32_t\".\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-"  connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ccv__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__t8pp__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lantuejoul__c__ "  lantuejoul.c\n"         \
-"\n"         \
-" Lantuejoul's skeleton\n"         \
-"\n"         \
-"Usage: lantuejoul in.pgm [dist] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let X be the set in  in.pgm .\n"         \
-"The result is union{Si(X), i in N} where\n"         \
-"Si(X) = erosball(X,i)  openball(erosball(X,i),1). \n"         \
-"Structuring elements are balls defined after a distance.\n"         \
-"The distance used depends on the optional parameter  dist (default is 0) :\n"         \
-" 0: approximate euclidean distance (truncated)\n"         \
-" 1: approximate quadratic euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-" The input image  in.pgm must be a binary image. No test is done.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie aoÃ»t 2009\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dilation__c__ "  dilation.c\n"         \
-"\n"         \
-" morphological dilation by a plane structuring element\n"         \
-"\n"         \
-"Usage: dilation in.pgm se.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The (plane) structuring element is given by the non-null values in  se.pgm, \n"         \
-"its origin (wrt the point (0,0) of  se.pgm ) is given by a comment line in the file se.pgm. \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"dilation cells ~/Pink/masks/carre5.pgm cells_dilat\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"  \n"         \
-"  cells\n"         \
-"      cells_dilat\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__genbini__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lfclose_line__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__skel_SCK3_pers__c__ "  skel_SCK3_pers.c\n"         \
-"\n"         \
-" topological persistence of 1D isthmuses, based on parallel 3D asymetric thinning\n"         \
-"\n"         \
-"Usage: skel_SCK3_pers in.pgm out.pgm\n"         \
-"\n"         \
-"Description: Topological persistence of 1D isthmuses, based on \n"         \
-"parallel 3D asymetric thinning.\n"         \
-"\n"         \
-"When a point x is detected as a 1D isthmus, a counter p(x) is\n"         \
-"associated to this point and initialized with value 1. This counter is\n"         \
-"incremented a each iteration as long as x is still an isthmus. When this point x is\n"         \
-"eventually deleted, the value of the counter is freezed.\n"         \
-"\n"         \
-" The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__alpha__c__ "  alpha.c\n"         \
-"\n"         \
-" computes the connecivity number alpha for each image voxel\n"         \
-"\n"         \
-"Usage: alpha in out\n"         \
-"\n"         \
-"Description: \n"         \
-"Computes the connecivity number alpha (as defined in ref. BEC97) for each image voxel.\n"         \
-"\n"         \
-"Types supported: byte 3D\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-"References:\n"         \
-"\n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"\n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__redt__c__ "  redt.c\n"         \
-"\n"         \
-" reverse euclidean distance transform\n"         \
-"\n"         \
-"Usage: redt in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Reverse euclidean distance transform, by the Coeurjolly's algorithm [1].\n"         \
-"The input  in.pgm must be a quadratic euclidean distance map, or \n"         \
-"an image of type int32_t where each non-null value correspond to the quadratic\n"         \
-"radius of a disc or ball. The output is a binary image.\n"         \
-"\n"         \
-"[1] D. Coeurjolly,\n"         \
-"\"d-Dimensional Reverse Euclidean Distance Transformation\n"         \
-"and Euclidean Medial Axis Extraction in Optimal Time\", \n"         \
-"DGCI 2003, LNCS 2886, pp. 327-337, 2003.\n"         \
-"\n"         \
-"Types supported: int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2004, Jean Cousty 2005 (3d)\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__2latex__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__normalize__c__ "  normalize.c\n"         \
-"\n"         \
-" normalization of grayscale values\n"         \
-"\n"         \
-"Usage: normalize in.pgm [[nmin nmax] out.pgm]\n"         \
-"\n"         \
-"Description:\n"         \
-"Grayscale of  in.pgm values are normalized to span the range of [nmin...nmax].\n"         \
-"The parameters  nmin and  nmax are optional.\n"         \
-"For byte and int32_t images, the default values are  nmin = 0 and  nmax = 255.\n"         \
-"For float images, the default values are  nmin = 0 and  nmax = 1.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__htkern3dbin__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__selectcomp__c__ "  selectcomp.c\n"         \
-"\n"         \
-" selects a connected component\n"         \
-"\n"         \
-"Usage: selectcomp in.pgm connex x y z out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The connected component of the binary image in.pgm\n"         \
-"(according to the connectivity connex)\n"         \
-"which contains the point (x,y,z)\n"         \
-"is preserved. All other points are deleted.\n"         \
-"Possible values for  connex are 4, 8 (2D), 6, 18, 26, 60, 260 (3D).\n"         \
-"Values 60 and 260 correspond to restrictions of 6 and 26 connectivities to the \n"         \
-"current xy plane.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__closing__c__ "  closing.c\n"         \
-"\n"         \
-" morphological closing by a plane structuring element\n"         \
-"\n"         \
-"Usage: closing in.pgm se.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Morphological closing by a plane structuring element.\n"         \
-"The (plane) structuring element is given by the non-null values in  se.pgm, \n"         \
-"its origin (wrt the point (0,0) of  se.pgm ) \n"         \
-"is given by a comment line in the file se.pgm. \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__directions__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__hthin__c__ "  hthin.c\n"         \
-"\n"         \
-" grayscale homotopic thinning\n"         \
-"\n"         \
-"Usage: hthin in.pgm {imcond.pgm|null} connex niter out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Grayscale homotopic thinning (refs. [BEC97, CBB01]).\n"         \
-"The parameter  connex gives the connectivity used for the minima;\n"         \
-"possible choices are 4, 8 in 2D and 6, 26 in 3D.\n"         \
-"Let F be the function corresponding to the input image  in.pgm.\n"         \
-"Let G be the function corresponding to the input image \n"         \
-" imcond.pgm, or the null function if the keyword  null is used.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat niter times:\n"         \
-"    L = {(p,d) such that p is destructible for F and d = delta-(p,F)}\n"         \
-"    While L not empty\n"         \
-"       extract a couple (p,d) from L\n"         \
-"       F(p) = max{ d, delta-(p,F), G(p) }    \n"         \
-"Result: F\n"         \
-"\n"         \
-"\n"         \
-"If  niter is set to -1, then the operator iterates until stability.\n"         \
-"\n"         \
-"References:\n"         \
-"\n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"\n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D.\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"hthin ur1 null 4 10 ur1_hthin\n"         \
-"minima ur1_hthin 4 ur1_hthin_m\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"      \n"         \
-"  \n"         \
-"  ur1\n"         \
-"      ur1_hthin\n"         \
-"      ur1_hthin_m\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__squel__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__float2byte__c__ "  float2byte.c\n"         \
-"\n"         \
-" converts a \"float\" image to a \"byte\" image\n"         \
-"\n"         \
-"Usage: float2byte in.pgm [mode] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Depending on the value given for the (optional) parameter mode:\n"         \
-"   mode = 0 (default) : for all x, out[x] = min(255, arrondi(in[x])).\n"         \
-"   mode = 1 : for all x, out[x] = arrondi(in[x]) modulo 256.\n"         \
-"   mode = 2 : scales values in the range 0-255.\n"         \
-"   mode = 4 : truncation of the square root in the range 0-255.\n"         \
-"   mode = 5 : truncation of the log in the range 0-255.\n"         \
-"\n"         \
-"Types supported: float 2d, float 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgm2skel2__c__ "  pgm2skel2.c\n"         \
-"\n"         \
-" decomposition of a curvilinear skeleton into isolated points,\n"         \
-"end points, curves and junctions\n"         \
-"\n"         \
-"Usage: pgm2skel in.pgm junc.pgm connex out.skel\n"         \
-"\n"         \
-"Description: \n"         \
-"The skeleton found in  in.pgm is decomposed into isolated points,\n"         \
-"end points, curves and junctions ; and its description is stored in \n"         \
-" out.skel .\n"         \
-"\n"         \
-"The parameter  connex sets the adjacency relation used for the object\n"         \
-"(4, 8 (2d) or 6, 18, 26 (3d)).\n"         \
-"\n"         \
-"The image given as parameter junc.pgm contains curve points that\n"         \
-"will artificially considered as junction points.\n"         \
-"\n"         \
-" Points at the border of the image will be ignored.\n"         \
-"\n"         \
-" IMPORTANT LIMITATION: \n"         \
-"different junctions in the original image must not be in direct\n"         \
-"contact with each other (i.e., connected) otherwise they will be\n"         \
-"considered as a single junction. To prevent this to occur, one can\n"         \
-"increase image resolution.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2009\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_CK3p__c__ "  skel_CK3p.c\n"         \
-"\n"         \
-" parallel 3D binary curvilinear skeleton based on 1D isthmuses\n"         \
-"\n"         \
-"Usage: skel_CK3p in.pgm pers [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 3D binary thinning or curvilinear skeleton based on 1D isthmuses, \n"         \
-"with a persistence parameter:  pers.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__nbvois__c__ "  nbvois.c\n"         \
-"\n"         \
-" number of neighbors for each object point\n"         \
-"\n"         \
-"Usage: nbvois in connex out\n"         \
-"\n"         \
-"Description:\n"         \
-"Let X be the set of object points of the binary image  in .\n"         \
-"For each point x of X,\n"         \
-" out (x) = card( gamma(x) inter X ). \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__watershedMeyer_time___notused_c__ "  watershedMeyer.c\n"         \
-"\n"         \
-" watershed transformation (Meyer's algorithm)\n"         \
-"\n"         \
-"Usage: watershedMeyer in mark   connex out\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs the watershed transformation on the image in, taking the\n"         \
-"set of markers in mark. \n"         \
-"If this parameter is present, bgmark\n"         \
-"is used as a set of markers for the background.\n"         \
-"If this parameter is present, roi\n"         \
-"indicates the region of interest on which the operation is performed.\n"         \
-"The parameter connex gives the adjacency relation (4,8 in 2D; 6,18,26 in 3D) \n"         \
-"for the makers.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ptseparatinggray__c__ "  ptseparatinggray.c\n"         \
-"\n"         \
-" detects separating points in a grayscale image\n"         \
-"\n"         \
-"Usage: ptseparatinggray in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"A separating point is a point p, which is separating (in the binary sense)\n"         \
-"for a section h of F, with h \n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__showheader__c__ "  showheader.c\n"         \
-"\n"         \
-" prints image information\n"         \
-"\n"         \
-"Usage: showheader in.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Prints all informations contained in the image file header: type, header, size and comments.\n"         \
-"\n"         \
-"Types supported: all pgm and ppm types\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__seuilhisto__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__jones__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__identifyparabola2__c__ "  identifyparabola2.c\n"         \
-"\n"         \
-" identification of a best matching parabola from a set of 2D points\n"         \
-"\n"         \
-"Usage: identifyparabola2 in.list out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Identifies the parameters (a,b) of the equation of the 2D parabola:\n"         \
-"ax^2+b=y that minimizes the least square error between this parabola \n"         \
-"and the given points. Method: basic linear regression.\n"         \
-"\n"         \
-"Types supported: list 1D, list 2D\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__tempNd__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__fits2pgm__c__ "  fits2pgm.c\n"         \
-"\n"         \
-" converts from fits format into pgm format\n"         \
-"\n"         \
-"Usage: fits2pgm in.fits out.pgm\n"         \
-"\n"         \
-"Description: Converts from fits format into pgm format.\n"         \
-"\n"         \
-"Parameters:\n"         \
-"  in.fits : source file in fits format\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__segbi___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__traceellipses__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__2elisp__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__areaopening__c__ "  areaopening.c\n"         \
-"\n"         \
-" area opening\n"         \
-"\n"         \
-"Usage: areaopening in.pgm connex area out.pgm\n"         \
-"\n"         \
-"Note:  in C main passes an argument 'area+1', whereas python passes the 'area'\n"         \
-"as argument (LuM)\n"         \
-"\n"         \
-"Description:\n"         \
-"Area opening with connexity connex and area area.\n"         \
-"Deletes the components of the upper cross-sections \n"         \
-"which have an area not higher than area.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skelcurv__c__ "  skelcurv.c\n"         \
-"\n"         \
-" curvilinear binary skeleton guided by a priority image\n"         \
-"\n"         \
-"Usage: skelcurv in.pgm prio connex [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Curvilinear binary skeleton guided by a priority image.\n"         \
-"The lowest values of the priority image correspond to the highest priority.\n"         \
-"\n"         \
-"The parameter  prio is either an image (byte or int32_t or float or double), or a numerical code\n"         \
-"indicating that a distance map will be used as a priority image; \n"         \
-"the possible choices are:\n"         \
-" 0: approximate euclidean distance\n"         \
-" 1: approximate quadratic euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-" 5: breadth-first and directional strategy\n"         \
-"\n"         \
-"The parameter  connex indicates the connectivity of the binary object.\n"         \
-"Possible choices are 4, 8 in 2d and 6, 26 in 3d.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Let X be the set corresponding to the input image  in.pgm.\n"         \
-"Let P be the function corresponding to the priority image.\n"         \
-"Let I be the set corresponding to the inhibit image, if given, or the empty\n"         \
-"set otherwise.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"C = null image\n"         \
-"Repeat until stability\n"         \
-"  choose a point x in X  I, simple for X, such that C[x] == 0 \n"         \
-"    and such that P[x] is minimal\n"         \
-"  X = X  {x}\n"         \
-"  for all y in gamma(x)\n"         \
-"    if T(y) > 1 then C[y] = 1\n"         \
-"Result: X\n"         \
-"\n"         \
-"\n"         \
-"where T(y) refers to the connectivity number of y, that is, \n"         \
-"(informally) the number of connected components of gamma(y) inter (X  {y}).\n"         \
-"\n"         \
-"References: \n"         \
-"[BC07] G. Bertrand and M. Couprie: \"Transformations topologiques discretes\", in G&eacute;om&eacute;trie discr&egrave;te et images num&eacute;riques, D. Coeurjolly and A. Montanvert and J.M. Chassery, pp.&nbsp;187-209, Herm&egrave;s, 2007.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__argmax__c__ "  argmax.c\n"         \
-"\n"         \
-" return the coordinates of a pixel having the maximal value\n"         \
-"\n"         \
-"Usage: argmax in.pgm [out.list]\n"         \
-"\n"         \
-"Description:\n"         \
-"This function returns (in the list out.list) \n"         \
-"coordinates of a pixel having the maximal value in the image  in.pgm .\n"         \
-"\n"         \
-"If the parameter  out.list is ommitted, the result is printed on the standard output.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__curvetangents__cxx__ "  curvetangents.c\n"         \
-"\n"         \
-" computes the tangents of a digital curve\n"         \
-"\n"         \
-"Usage: curvetangents curve.list [mode masksize] tangents.list\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Computes the tangents of a curve which is specified by the ordered list of its points. The output file is a list of normalized tangent vectors, all with origin 0.\n"         \
-"\n"         \
-"Types supported: curve 2D, curve 3D\n"         \
-"\n"         \
-"Category: geo\n"         \
-" geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-" Paulin Sanselme\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__seamcarving__c__ "  seamcarving.c\n"         \
-"\n"         \
-" applies the seam carving method to shrink an image\n"         \
-"\n"         \
-"Usage: seamcarving in.ppm energy.pgm w h out.ppm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawellipse__c__ "  drawellipse.c\n"         \
-"\n"         \
-" Draws an ellipse\n"         \
-"\n"         \
-"Usage: drawellipse in.pgm x1 y1 x2 y2 X1 Y1 X2 Y2 [filled] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws an  ellipse specified by four points, e.g. the extremities of the small axis \n"         \
-"(x1, y1, x2, y2) and the extremities of the big axis \n"         \
-"(X1, Y1, X2, Y2).\n"         \
-"The ellipse is surimposed to the contents of in.pgm.\n"         \
-"If the (optional) int32_t parameter  filled is set (1), then the ellipse is filled.\n"         \
-"Otherwise it is empty (default).\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: draw geo\n"         \
-"  draw geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dilat__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__meshaddnoise__c__ "  meshaddnoise.c\n"         \
-"\n"         \
-" adds gaussian noise to the positions of the vertices of a mesh\n"         \
-"\n"         \
-"Usage: meshaddnoise in alpha out\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Adds gaussian noise to the positions of the vertices of a mesh.\n"         \
-"The mean of the gaussian is 0.\n"         \
-"The standard deviation of the gaussian is given by alpha. \n"         \
-"Available input formats: mcm, ifs, vtk, ac.\n"         \
-"Available output formats: mcm, vtk.\n"         \
-"\n"         \
-"Types supported: mesh 3d\n"         \
-"\n"         \
-"Category: mesh3d\n"         \
-"  mesh3d\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__rankfilter__c__ "  rankfilter.c\n"         \
-"\n"         \
-" rank filter \n"         \
-"\n"         \
-"Usage: rankfilter in.pgm el.pgm r out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let F be the input image, G be the output image, and E the structuring\n"         \
-"element. Let n be the number of elements of E, and R be the product n.r,\n"         \
-"then for each pixel p, G[p] is the Rth element of the sorted list (by \n"         \
-"increasing order) of the pixel values in the set { F[q], q in E[p] }.\n"         \
-"\n"         \
-"Particular cases are the median filter (r = 0.5), the erosion (r = 0),\n"         \
-"and the dilation (r = 1).\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-" morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__genlut__c__ "  genlut.c\n"         \
-"\n"         \
-" generates a lookup table\n"         \
-"\n"         \
-"Usage: genlut ncol minhue maxhue minlum maxlum minsat maxsat  out.lut\n"         \
-"\n"         \
-"Description: Generates a lookup table with a continuous color gradient.\n"         \
-"\n"         \
-"A lookup table is represented by a special ppm image with 1 row. \n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dlabel__c__ "  3dlabel.c\n"         \
-"\n"         \
-" labels the theta-connected component of a 3D Khalimsky order\n"         \
-"\n"         \
-"Usage: 3dlabel in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Labels the theta-connected component of a 3D Khalimsky order.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dalpha__c__ "  3dalpha.c\n"         \
-"\n"         \
-" alpha-dilation of a 3d khalimsky order \n"         \
-"\n"         \
-"Usage: 3dalpha in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let X be the set of elements of the order  in.pgm, \n"         \
-"the result is the union of alpha(x) for all x in X.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__histstretch__c__ "  histstretch.c\n"         \
-"\n"         \
-" transforms the gray scale by stretching the histogram\n"         \
-"\n"         \
-"Usage: histstretch in.pgm vmin vmax p out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Eliminates the levels of the histogram strictly less than vmin or \n"         \
-"strictly greater than vmax, and also the extremal levels\n"         \
-"that have strictly less than N*(p/100) pixels \n"         \
-"(N being the total number of pixels). If p = 0, only the \n"         \
-"extremal levels with 0 pixels are eliminated.\n"         \
-"A linear histogram scaling is then performed.\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: histo\n"         \
-"  histo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__autocrop__c__ "  autocrop.c\n"         \
-"\n"         \
-" eliminates null regions at the periphery of an image\n"         \
-"\n"         \
-"Usage: autocrop in.pgm [threshold [out.pgm]]\n"         \
-"\n"         \
-"Description:\n"         \
-"Selects the minimum rectangle (cuboid in 3d) \n"         \
-"that contain all values of the image  in.pgm strictly above the  threshold (default 0).\n"         \
-"\n"         \
-"If  out.pgm is not specified, then out.pgm = in.pgm.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__points2spline__c__ "  points2spline.c\n"         \
-"\n"         \
-" converts a sequence of control points into a spline\n"         \
-"\n"         \
-"Usage: points2spline points.txt spline.txt\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Let S be the sequence of control points in points.txt. This program computes\n"         \
-"a parametric curve P defined by two (in 2D) or three (in 3D) splines \n"         \
-"that interpolates the points of the sequence S.\n"         \
-"\n"         \
-"If the last point equals the first point, then a closed spline is generated.\n"         \
-"\n"         \
-"The result is given in the form of the list of control points, followed by\n"         \
-"the set of coefficients for each spline segment. \n"         \
-"\n"         \
-"The input file  points.txt contains a list of points under the format:\n"         \
-"\n"         \
-"b nbpoints  \n"         \
-"x1 y1\n"         \
-"x2 y2\n"         \
-"x3 y3\n"         \
-"...\n"         \
-"\n"         \
-"or:\n"         \
-"\n"         \
-"B nbpoints  \n"         \
-"x1 y1 z1\n"         \
-"x2 y2 z2\n"         \
-"x3 y3 z3\n"         \
-"...\n"         \
-"\n"         \
-"The output file format is the following for 2D:\n"         \
-"\n"         \
-"c n+1 (where n+1 denotes the number of control points)\n"         \
-"x1 y1\n"         \
-"...\n"         \
-"xn+1 yn+1\n"         \
-"C0X1 C0Y1 C1X1 C1Y1 C2X1 C2Y1 C3X1 C3Y1\n"         \
-"...\n"         \
-"C0Xn C0Yn C1Xn C1Yn C2Xn C2Yn C3Xn C3Yn\n"         \
-"\n"         \
-"and in the 3D case:\n"         \
-"\n"         \
-"C n+1 (where n+1 denotes the number of control points)\n"         \
-"x1 y1 z1\n"         \
-"...\n"         \
-"xn+1 yn+1 zn+1\n"         \
-"C0X1 C0Y1 C0Z1 C1X1 C1Y1 C1Z1 C2X1 C2Y1 C2Z1 C3X1 C3Y1 C3Z1\n"         \
-"...\n"         \
-"C0Xn C0Yn C0Zn C1Xn C1Yn C1Zn C2Xn C2Yn C2Zn C3Xn C3Yn C3Zn\n"         \
-"\n"         \
-"The ith segment (starting from i=0) of the parametric curve P is then defined by:\n"         \
-"\n"         \
-"x(t) = C3Xi * t^3 + C2Xi * t^2 + C1Xi * t + C0Xi\n"         \
-"y(t) = C3Yi * t^3 + C2Yi * t^2 + C1Yi * t + C0Yi\n"         \
-"z(t) = C3Zi * t^3 + C2Zi * t^2 + C1Zi * t + C0Zi\n"         \
-"with t in [i,i+1]\n"         \
-"\n"         \
-"Types supported: list 2D, list 3D\n"         \
-"\n"         \
-"Category: draw geo\n"         \
-"  draw geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__animscenes__c__ "  animscenes.c\n"         \
-"\n"         \
-" generates intermediate scenes by interpolation\n"         \
-"\n"         \
-"Usage: animscenes prefix_in begin end prefix_out nbsamples\n"         \
-"\n"         \
-"Description:\n"         \
-"The input scenes must be stored in files with names of the form  \n"         \
-" prefix_inXXXX.3sc, where XXXX is an integer between  begin\n"         \
-"and  end. They must all contain the same number of objects, \n"         \
-"and object types must match from one scene to each other (order matters).\n"         \
-"\n"         \
-"Between the scenes of the series, a total number of  nbsamples scenes \n"         \
-"are generated by spline interpolation.\n"         \
-"\n"         \
-"Types supported: scene 3D\n"         \
-"\n"         \
-"Category: draw geo\n"         \
-"  draw geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__mult__c__ "  mult.c\n"         \
-"\n"         \
-" pixelwise multiplication of two images\n"         \
-"\n"         \
-"Usage: mult in1.pgm in2.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = in1[x] * in2[x]. If both images are byte images,\n"         \
-"and if out[x] exceeds 255, then out[x] is set to 255.\n"         \
-"Images must be of the same type and same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__linapprox__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__surfels_triang___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__exp__c__ "  exp.c\n"         \
-"\n"         \
-" pixelwise exponentiation\n"         \
-"\n"         \
-"Usage: exp in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = exp(in[x]).\n"         \
-"\n"         \
-"Types supported: float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__equal__c__ "  equal.c\n"         \
-"\n"         \
-" equality test\n"         \
-"\n"         \
-"Usage: equal in1.pgm in2.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"This function returns 1 (no error) if for each pixel x, in1[x] == in2[x]; \n"         \
-"otherwise it returns 0.\n"         \
-"Images must be of the same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__average__c__ "  average.c\n"         \
-"\n"         \
-" pixelwise (weighted) average of two images\n"         \
-"\n"         \
-"Usage: average in1.pgm in2.pgm [alpha] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The default value for the optional parameter  alpha is 0.5 . \n"         \
-"For each pixel x, out[x] = alpha * in1[x] + (1 - alpha) * in2[x]. \n"         \
-"If both images are byte images,\n"         \
-"and if out[x] exceeds 255, then out[x] is set to 255.\n"         \
-"Images must be of the same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__bruite__c__ "  bruite.c\n"         \
-"\n"         \
-" adds noise to an image\n"         \
-"\n"         \
-"Usage: bruite in.pgm n alpha p out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Adds a uniform or gaussian noise, of mean 0 and standard deviation alpha, \n"         \
-"to a proportion p of the pixels of the image in.pgm .\n"         \
-"\n"         \
-"  OPTIONS\n"         \
-"    n = 0  uniform noise\n"         \
-"    n = 1  gaussian noise\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: signal\n"         \
-"  signal\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__erosfast3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__histoazimuth__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__2dpardircollapse__c__ "  2dpardircollapse.c\n"         \
-"\n"         \
-" parallel directional constrained collapse\n"         \
-"\n"         \
-"Usage: 2dpardircollapse in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel directional constrained collapse.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ball___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__drawfieldlists__c__ "  drawfieldlists.c\n"         \
-"\n"         \
-" draw line segments that represent a vector field (represented by two lists)\n"         \
-"\n"         \
-"Usage: drawfieldlists in1.list in2.list in.pgm [len] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The files  in1.pgm,  in2.pgm represent a vector field, with the origins of vectors in  in1.pgm and their directions in  in2.pgm. This operator draws in the image  in.pgm a straight line segment of length  len (default 10) for each vector.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: draw\n"         \
-"  draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__erosball__c__ "  erosball.c\n"         \
-"\n"         \
-" morphological binary erosion by a ball\n"         \
-"\n"         \
-"Usage: erosball in.pgm r [dist] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Morphological binary erosion by a metric ball.\n"         \
-"This erosion is the dual of the dilatball operator, \n"         \
-"i.e. erosball(X) = inverse(dilatball(inverse(X))).\n"         \
-"The structuring element for this erosion is a ball (or a disc) of radius  r.\n"         \
-"The erosion is computed by thresholding a distance map.\n"         \
-"The distance used depends on the optional parameter  dist (default is 0) :\n"         \
-" 0: rounded euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-" The input image  in.pgm must be a binary image. No test is done.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"erosball cells 3 cells_erosball\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"  \n"         \
-"  cells\n"         \
-"      cells_erosball\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_CK3_pers__c__ "  skel_CK3_pers.c\n"         \
-"\n"         \
-" topological persistence of 1D isthmuses, based on parallel 3D asymetric thinning\n"         \
-"\n"         \
-"Usage: skel_CK3_pers in.pgm out.pgm\n"         \
-"\n"         \
-"Description: Topological persistence of 1D isthmuses, based on \n"         \
-"parallel 3D asymetric thinning.\n"         \
-"\n"         \
-"When a point x is detected as a 1D isthmus, a counter p(x) is\n"         \
-"associated to this point and initialized with value 1. This counter is\n"         \
-"incremented a each iteration as long as x is still an isthmus. When this point x is\n"         \
-"eventually deleted, the value of the counter is freezed.\n"         \
-"\n"         \
-" The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__delaunaymask__c__ "  delaunaymask.c\n"         \
-"\n"         \
-" delaunay triangulation\n"         \
-"\n"         \
-"\n"         \
-"\n"         \
-"Usage: delaunaymask in.list mask.pgm out.list\n"         \
-"\n"         \
-"\n"         \
-"Description:\n"         \
-"Reads a point list in file in.list under the following format:\n"         \
-"  \n"         \
-"    b &lt;n&gt;         n &lt;n&gt;    \n"         \
-"    x1 y1         x1 y1 v1\n"         \
-"    x2 y2   ou    x2 y2 v2\n"         \
-"    ...           ...\n"         \
-"    xn yn         xn yn vn\n"         \
-"  \n"         \
-"\n"         \
-"Computes a Delaunay triangulation and stores the resulting graph \n"         \
-"\n"         \
-"into file out.graph under the following format:\n"         \
-"\n"         \
-"    G &lt;n&gt;\n"         \
-"    x1 y1 v1 ec1 ns1 s11 s12 ... s1ns1\n"         \
-"    x2 y2 v2 ec2 ns2 s21 s22 ... s1ns2\n"         \
-"    ...\n"         \
-"    xn yn vn ecn nsn sn1 sn2 ... s1nsn\n"         \
-"\n"         \
-"  \n"         \
-"where xi, yi are the coordinates of the ith vertex, vi is the associated \n"         \
-"value (if given in the input file), eci is a int32_t which indicates \n"         \
-"whether the vertex i belongs to the convex hull, nsi denotes the number\n"         \
-"of adjacent vertices, and si1 si2 ... sins1 is the list of the indexes of\n"         \
-"the adjacent vertices (counted from 0).\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" algorithm in O(n^2)\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ppm2pgm__c__ "  ppm2pgm.c\n"         \
-"\n"         \
-" converts a color ppm image into 3 grayscale pgm images\n"         \
-"\n"         \
-"Usage: ppm2pgm in.ppm r.pgm g.pgm b.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Converts a color ppm image  in.ppm into 3 grayscale pgm images\n"         \
-"r.pgm, g.pgm and b.pgm which are the red, \n"         \
-"green and blue color planes of the original color image.\n"         \
-"\n"         \
-"Types supported: byte color 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__hthick3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__long2short__cpp__ "  long2byte.c\n"         \
-"\n"         \
-" converts a \"int32_t\" image to a \"ushort\" image\n"         \
-"\n"         \
-"Usage: long2byte in.pgm [mode] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Depending on the value given for the (optional) parameter mode:\n"         \
-"   mode = 0 (default) : for all x, out[x] = min(USHRT_MAX, in[x]).\n"         \
-"   mode = 1 : for all x, out[x] = in[x] modulo USHRT_MAX.\n"         \
-"   mode = 2 : scales values in the range 0-USHRT_MAX.\n"         \
-"   mode = 4 : truncation of the square root in the range 0-255.\n"         \
-"   mode = 5 : truncation of the log in the range 0-255.\n"         \
-"\n"         \
-"Types supported: short_image (any D)\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Laszlo Marak, 2011\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__seuilhistolocal__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__long2float__c__ "  long2float.c\n"         \
-"\n"         \
-" converts a \"long\" image to a \"float\" image\n"         \
-"\n"         \
-"Usage: long2float in [out]\n"         \
-"\n"         \
-"Description: For each pixel x, out[x] = (float)in[x]\n"         \
-"\n"         \
-"If the last argument  out is omitted, then out = in.\n"         \
-"\n"         \
-"Types supported: long 2d, long 3d.\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lambdakern___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__skelpar3d_others__cxx__ "  skelpar3d_others.cxx\n"         \
-"\n"         \
-" parallel 3D binary skeleton\n"         \
-"DirectionalSkeletonizer\n"         \
-"Usage: skelpar3d in.pgm algorithm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 3D binary thinning or skeleton. The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"The parameter  algorithm is a numerical code\n"         \
-"indicating which method will be used for the thinning.\n"         \
-"The possible choices are:\n"         \
-" 0: Palagyi (curvilinear, 6-subiterations directional, 1998)\n"         \
-" 1: Palagyi (curvilinear, sequential, 2006)\n"         \
-" 2: Palagyi (surface, parallel directional, 2002)\n"         \
-" 3: Palagyi (surface, fully parallel, 2008)\n"         \
-" 4: Raynal  (curvilinear, directional, 2010)\n"         \
-" 5: Raynal  (surface, directional, 2010)\n"         \
-" 6: Lohou-Bertrand  (curvilinear, symmetric, 2007)\n"         \
-" 7: Ma-Wan-Chang (curvilinear, 2 subfields, 2002)\n"         \
-" 8: Tsao-Fu (curvilinear, 6-subiterations directional, 1982)\n"         \
-" 9: Ma-Sonka (curvilinear, fully parallel, does not preserve topology 1996)\n"         \
-" 10: Ma-Wan (curvilinear (18/6) 6 subiterations, CVIU 2000)\n"         \
-" 11: Lohou-Bertrand (curvilinear 6 subiterations, DAM 2005)\n"         \
-" 12: Lohou-Bertrand (curvilinear 12 subiterations, DAM 2004)\n"         \
-" 13: ACK3a - see lskelpar3d.c\n"         \
-" 14: CKSC - see lskeletons.c\n"         \
-" 15: Ma-Wan-Lee (curvilinear, 4 subfields, 2002)\n"         \
-" 16: Nemeth-Kardos-Palagyi (curvilinear, 2 subfields, 2010, var. 1)\n"         \
-" 17: Nemeth-Kardos-Palagyi (curvilinear, 2 subfields, 2010, var. 2)\n"         \
-" 18: Nemeth-Kardos-Palagyi (curvilinear, 2 subfields, 2010, var. 3)\n"         \
-" 19: Nemeth-Kardos-Palagyi (curvilinear, 4 subfields, 2010, var. 1)\n"         \
-" 20: Nemeth-Kardos-Palagyi (curvilinear, 4 subfields, 2010, var. 2)\n"         \
-" 21: Nemeth-Kardos-Palagyi (curvilinear, 4 subfields, 2010, var. 3)\n"         \
-" 22: Nemeth-Kardos-Palagyi (curvilinear, 8 subfields, 2010, var. 1)\n"         \
-" 23: Nemeth-Kardos-Palagyi (curvilinear, 8 subfields, 2010, var. 2)\n"         \
-" 24: Nemeth-Kardos-Palagyi (curvilinear, 8 subfields, 2010, var. 3)\n"         \
-" 25: She et al. (curvilinear, symmetric, DICTA 2009)\n"         \
-" 26: Tsao-Fu (surface, 6-subiterations directional, 1981)\n"         \
-" 27: Tsao-Fu (curvilinear, 6-subiterations directional, 1981)\n"         \
-" 28: Nemeth-Kardos-Palagyi (curvilinear, 2 subfields, 2010, var. 0)\n"         \
-" 29: Nemeth-Kardos-Palagyi (curvilinear, 4 subfields, 2010, var. 0)\n"         \
-" 30: Nemeth-Kardos-Palagyi (curvilinear, 8 subfields, 2010, var. 0)\n"         \
-" 31: Lohou-Bertrand  (surface, symmetric, 2007)\n"         \
-" 32: Manzanera et al. (surface, symmetric, 1999)\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie, Benjamin Raynal, John Chaussard\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__radialrankmaxopening__c__ "  radialrankmaxopening.c\n"         \
-"\n"         \
-" radial rank-max opening by line\n"         \
-"\n"         \
-"Usage: radialrankmaxopening in.pgm length rank [angle in degrees] [dilatmask.pgm] out.pgm\n"         \
-"\n"         \
-"Description: Radial rank-max opening by line (or dilated\n"         \
-"line). Max between the rank-max openings (with parameter  rank) of\n"         \
-" in.pgm by a linear structuring element rotated by angle until 360\n"         \
-"degrees and dilated by dilatmask.pgm. The angle is normalized to an\n"         \
-"exact division of 360 by an integer.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" André Vital Saude, Michel Couprie jan 2005\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__any2complex__c__ "  any2complex.c\n"         \
-"\n"         \
-" converts a \"byte\", \"long\" of \"float\" image (or couple of images) to a \"fcomplex\" image\n"         \
-"\n"         \
-"Usage: any2complex re.pgm [im.pgm] out.pgm\n"         \
-"\n"         \
-"Description: \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, long 2d, long 3d, float 2d, float 3d.\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__genball__c__ "  genball.c\n"         \
-"\n"         \
-" generates a binary euclidean ball\n"         \
-"\n"         \
-"Usage: genball radius [dim] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws a binary euclidean ball in the new image  out.pgm.\n"         \
-"The parameter radius specifies the radius of the ball. \n"         \
-"The parameter dim specifies the dimension: 2 (default) or 3.\n"         \
-"The center of the ball is designated as the origin (for use as structuring element).\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: draw\n"         \
-"  draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__openingfunction__c__ "  openingfunction.c\n"         \
-"\n"         \
-" opening function\n"         \
-"\n"         \
-"Usage: openingfunction in.pgm [dist] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"This operator associates, to each point x of the input object X, \n"         \
-"the radius of the biggest ball included in X that includes x.\n"         \
-"The distance used depends on the optional parameter  dist (default is 0) :\n"         \
-" 0: Euclidean distance (truncated)\n"         \
-" 1: approximate quadratic Euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic Euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-" The input image  in.pgm must be a binary image. No test is done.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2009\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__frame__c__ "  frame.c\n"         \
-"\n"         \
-" generates an image with a white border and a black interior\n"         \
-"\n"         \
-"Usage: frame in.pgm [width] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The result out.pgm has the same size as in.pgm. Its border is set to 255, \n"         \
-"all other pixels are set to 0.\n"         \
-"\n"         \
-"If the optional parameter  width is given, then the border has thickness 'width'.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie 2000\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__minima__c__ "  minima.c\n"         \
-"\n"         \
-" regional minima \n"         \
-"\n"         \
-"Usage: in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description: \n"         \
-"Selects the regional minima of a grayscale image with connexity connex.\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d, byte 3d, int32_t 3d\n"         \
-"\n"         \
-"Category: connect, topogray\n"         \
-"  connect, topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__segmentarea__c__ "  segmentarea.c\n"         \
-"\n"         \
-" segmentation by filtering components on an area criterion\n"         \
-"\n"         \
-"Usage: segmentarea in.pgm connex area [m] out.pgm\n"         \
-"\n"         \
-"Note: in the python front-end 'm' is mandatory, set 0 without maximization\n"         \
-"and 1 with maximization.\n"         \
-"\n"         \
-"Description:\n"         \
-"Segmentation by selection of cross-section components, based on an area criterion. \n"         \
-"Connexity = connex ; area threshold = area.\n"         \
-"\n"         \
-"Segmentation is followed by a maximization if option m is set.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category:  connect\n"         \
-"  connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__circleincl__c__ "  circleincl.c\n"         \
-"\n"         \
-" circle identification and drawing from spare points\n"         \
-"\n"         \
-"Usage: circleincl in.pgm pts.list filled out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" John Chaussard\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__htkern__c__ "  htkern.c\n"         \
-"\n"         \
-" grayscale ultimate homotopic thinning\n"         \
-"\n"         \
-"Usage: htkern in.pgm {imcond.pgm|null} connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Grayscale ultimate homotopic thinning (refs. [BEC97, CBB01]).\n"         \
-"The parameter  connex gives the connectivity used for the minima;\n"         \
-"possible choices are 4, 8 in 2D and 6, 26 in 3D.\n"         \
-"Let F be the function corresponding to the input image  in.pgm.\n"         \
-"Let G be the function corresponding to the input image \n"         \
-" imcond.pgm, or the null function if the keyword  null is used.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat until stability:\n"         \
-"    select p destructible for F such that F(p) is minimal\n"         \
-"    F(p) = max{ delta-(p,F), G(p) }    \n"         \
-"Result: F\n"         \
-"\n"         \
-"\n"         \
-"References: \n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D.\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"htkern ur1 null 4 ur1_htkern\n"         \
-"minima ur1_htkern 4 ur1_htkern_m\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"      \n"         \
-"  \n"         \
-"  ur1\n"         \
-"      ur1_htkern\n"         \
-"      ur1_htkern_m\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__seuil2__c__ "  seuil2.c\n"         \
-"\n"         \
-" double threshold\n"         \
-"\n"         \
-"Usage: seuil2 in.pgm smin smax vmin vmax out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Every pixel   \n"         \
-"Every pixel >=  smax gets value  vmax \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__moments__c__ "  moments.c\n"         \
-"\n"         \
-" calcul des moments d'ordre 1 et 2 d'une image binaire (nuage de points) \n"         \
-"\n"         \
-"Usage: moments in.pgm out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dcollapse__c__ "  3dcollapse.c\n"         \
-"\n"         \
-" ultimate constrained collapse guided by a priority image\n"         \
-"\n"         \
-"Usage: 3dcollapse in.pgm prio [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Ultimate constrained collapse guided by a priority image.\n"         \
-"The lowest values of the priority image correspond to the highest priority.\n"         \
-"\n"         \
-"The parameter  prio is either an image (byte or int32_t), or a numerical code\n"         \
-"indicating that a distance map will be used as a priority image; \n"         \
-"the possible choices are:\n"         \
-" 0: approximate euclidean distance\n"         \
-" 1: approximate quadratic euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the elements of this image will be left unchanged. \n"         \
-"If the parameter  inhibit is given and is a number I,\n"         \
-"then the elements with priority greater than or equal to I will be left unchanged. \n"         \
-"\n"         \
-" The result makes sense only if the input image is a complex.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__temp2d___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__barycentre__c__ "  barycentre.c\n"         \
-"\n"         \
-" compute the center of gravity of each connected component\n"         \
-"\n"         \
-"Usage: barycentre in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description: \n"         \
-"Compute the center of gravity of each connected component.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__cadre__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__watershedMeyer2__c__ "  watershedMeyer2.c\n"         \
-"\n"         \
-" watershed transformation (Meyer's algorithm) with labelled markers  \n"         \
-"\n"         \
-"Usage: watershedMeyer2 in mark {roi|null} connex out\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs the watershed transformation on the image in, taking the\n"         \
-"set of markers in mark, in the form of a label image where all the pixels\n"         \
-"sharing the same label (even if not connected) belong to the same marker.\n"         \
-"If this parameter is present, roi\n"         \
-"indicates the region of interest on which the operation is performed.\n"         \
-"The parameter connex gives the adjacency relation (4,8 in 2D; 6,18,26 in 3D) \n"         \
-"for the makers.\n"         \
-"\n"         \
-"The result is a binary image.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ui_any_to_complex__c__ "\n"         \
-"    ui_any_to_complex.cpp\n"         \
-"\n"         \
-"    Creates a complex image from two images (one representing\n"         \
-"   the real, and the other the imaginary part of the complex image)\n"         \
-"   \n"         \
-"   Usage: !!!!!!!\n"         \
-"   \n"         \
-"   Description: The two images can be of any type, but they need to be of the same time.\n"         \
-"\n"         \
-"   NOTE: If you use complex images, than some information will\n"         \
-"   be lost, as the resulting image will be float-complex anyway. Also\n"         \
-"   if you use integers, some information may dissapear.\n"         \
-"\n"         \
-"    Laszlo Marak, 2011\n"         \
-"\n"         \
-"\n"         \
-" \n"         \
-"\n"
-
-
-#define doc__planarity__c__ "  planarity.c\n"         \
-"\n"         \
-" computes a planarity measure for each connected component\n"         \
-"\n"         \
-"Usage: planarity in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Labels each connected component with its planarity value.\n"         \
-"Argument  connex defines the connectivity.\n"         \
-"The result is a floating point image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__reformat__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__hk_tophat_lin_rotall__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__graph2pgm__c__ "  graph2pgm.c\n"         \
-"\n"         \
-" converts from graph representation to pgm\n"         \
-"\n"         \
-"Usage: graph2pgm in.graph {in.pgm|rs cs ds} out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Reads the file in.graph. Each vertex of this graph must have integer coordinates, and \n"         \
-"represents a pixel/voxel of a 2D/3D image.\n"         \
-"If a file name in.pgm is given, then the points read in in.graph are \n"         \
-"inserted (if possible) into the image read in in.pgm. Else, they are inserted in\n"         \
-"a new image, the dimensions of which are rs, cs, and ds.\n"         \
-"\n"         \
-"Types supported: graph\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__hma__c__ "\n"         \
-" Higher-resolution Medial Axis (HMA) extraction\n"         \
-"\n"         \
-"Usage: hma in.pgm [mode] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Higher-resolution Medial Axis (HMA) of the binary image  Xh, where Xh has\n"         \
-"been obtained by H(X), X being the original object and H, the H-transform.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Andre Vital Saude\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__bisector_talbot__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__3dbeta__c__ "  3dbeta.c\n"         \
-"\n"         \
-" beta-dilation of a 3d khalimsky order \n"         \
-"\n"         \
-"Usage: 3dbeta in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let X be the set of elements of the order  in.pgm, \n"         \
-"the result is the union of beta(x) for all x in X.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__div__c__ "  div.c\n"         \
-"\n"         \
-" pixelwise division of two images\n"         \
-"\n"         \
-"Usage: div in1.pgm in2.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x such that in2[x] != 0, out[x] = in1[x] / in2[x]. \n"         \
-"For each pixel x such that in2[x] = 0, out[x] = 0. \n"         \
-"Images must be of the same type and same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__findline__cxx__ "  findline.cxx\n"         \
-"\n"         \
-" find line into an image using bresenham definition\n"         \
-"w is the digital line size.\n"         \
-"\n"         \
-"Usage: findline in.fits {w}  out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"On commence pas netoyer l'image afin de retirer le bruit de fond et d'ameliorer le contraste.\n"         \
-"\n"         \
-"On determine ensuite les points sur le bord de l'image qui correspondent potentiellement Ã  une droite.\n"         \
-"\n"         \
-"On trace les droites de Bresenham entre les differents points des bords. Pour chacunes des droites on calcule\n"         \
-"le nombre de points non nul present sur la droite. La droites contenant les plus de points non nul doit correspondre\n"         \
-"Ã  la trace du satellite.\n"         \
-"\n"         \
-"L'image finale est une image noire, avec une droite blanche correspondant Ã  la trace du sattelite.\n"         \
-"\n"         \
-"\n"         \
-"Parameters:\n"         \
-"  in.fits : source file in fits format\n"         \
-"\n"         \
-"\n"         \
-" Juliette Charpentier\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lintophat__c__ "  lintophat.c\n"         \
-"\n"         \
-" max of morphological black top hats by linear structuring elements\n"         \
-"\n"         \
-"Usage: lintophat in.pgm length out.pgm\n"         \
-"\n"         \
-"Description: \n"         \
-"Max of morphological black top hats by linear structuring elements, \n"         \
-"in all possible discrete directions.\n"         \
-"Let F be the original image and E be a structuring element, the black\n"         \
-"top hat of F by E is defined by F - closing(F, E).\n"         \
-"The closing deletes dark structures that do not match the \n"         \
-"structuring element, thus the black top hat detects those dark structures.\n"         \
-"For a linear structuring element, the detected structures are those which\n"         \
-"are orthogonal to the se.\n"         \
-"The length if the linear structuring elements is given by  length.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Hildegard Koehler 2003\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__segmentnumi__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__skelend__c__ "  skelend.c\n"         \
-"\n"         \
-" homotopic skeleton of a 2d or 3d binary image with dynamic detection of end points\n"         \
-"\n"         \
-"Usage: skelend in.pgm connex [n] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Homotopic skeletonization by iterative removal of simple,\n"         \
-"non-end points. Breadth-first strategy.\n"         \
-"During the first  n iterations (default 0), the end points\n"         \
-"are removed as well.\n"         \
-"If  n = -1, the end points are always removed.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" This operator is very sensitive to small contour irregularities. \n"         \
-"See skelcurv for a more robust operator. Useful for reducing quasi-curvilinear objects.\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_MK3__c__ "  skel_MK3.c\n"         \
-"\n"         \
-" parallel 3D binary ultimate skeleton\n"         \
-"\n"         \
-"Usage: skel_MK3 in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 3D binary thinning or ultimate skeleton. The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__byte2float__c__ "  byte2float.c\n"         \
-"\n"         \
-" converts a \"byte\" image to a \"float\" image\n"         \
-"\n"         \
-"Usage: byte2float in [out]\n"         \
-"\n"         \
-"Description: \n"         \
-"\n"         \
-"For each pixel x, out[x] = (float)in[x]\n"         \
-"\n"         \
-"If the last argument  out is omitted, then out = in.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d.\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__complex_imaginary__c__ "  complex_imaginary.c\n"         \
-"\n"         \
-" pixelwise imaginary part of complex\n"         \
-"\n"         \
-"Usage: complex_imaginary in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Applies to complex images only.\n"         \
-"For each pixel p, out[p] = imaginary(in[p]), where \n"         \
-"imaginary(x+iy) = y\n"         \
-"\n"         \
-"Types supported: complex 2d, complex 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__genimage__c__ "  genimage.c\n"         \
-"\n"         \
-" generates a monocolor image of given size\n"         \
-"\n"         \
-"Usage: genimage {in.pgm|rs cs ds} col out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The size of the result image out.pgm is taken from image\n"         \
-"in.pgm, or given by the parameters rs, cs, ds. \n"         \
-"For a 2D image, the parameter ds (depth size) is set to 1.\n"         \
-"The color of the result image is given by the parameter col.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: arith, geo\n"         \
-"  arith, geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skelpar3d_others__c___ "  skelpar3d_others.c\n"         \
-"\n"         \
-" parallel 3D binary skeleton\n"         \
-"\n"         \
-"Usage: skelpar3d in.pgm algorithm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 3D binary thinning or skeleton. The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"The parameter  algorithm is a numerical code\n"         \
-"indicating which method will be used for the thinning.\n"         \
-"The possible choices are:\n"         \
-" 0: Palagyi (fully parallel, 2007)\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__watershedMeyer4D__c__ "  watershedMeyer4D.c\n"         \
-"\n"         \
-" watershed transformation (Meyer's algorithm)\n"         \
-"\n"         \
-"Usage: watershedMeyer4D prefix_in first last prefix_mark {prefix_bgmark|null} {prefix_roi|null} connex prefix_out\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs the watershed transformation on the 4D image made of the concatenation of the 3D images prefix_inxxxx.pgm (where nnnn is a four digit decimal integer and where first and last specify respectively the first and the last volume).The watershed is computed taking the\n"         \
-"set of markers in prefix_markxxxx.pgm. \n"         \
-"If this parameter is present, prefix_bgmarkxxxx.pgm\n"         \
-"is used as a set of markers for the background.\n"         \
-"If this parameter is present, prefix_roixxxx.pgm\n"         \
-"indicates the region of interest on which the operation is performed.\n"         \
-"The parameter connex gives the adjacency relation (8 in 4D) \n"         \
-"for the makers.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Jean Cousty - fevrier 2005\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__distsets__c__ "  distsets.c\n"         \
-"\n"         \
-" distance between sets\n"         \
-"\n"         \
-"Usage: distsets in1.pgm in1.pgm mode [cut] out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Computes the distance between the object X defined by the binary image\n"         \
-" in1.pgm and the object Y defined by the binary image  in2.pgm .\n"         \
-"\n"         \
-"Stores the result (a number) in the file  out.list .\n"         \
-"\n"         \
-"The used pointwise distance is the exact Euclidean distance (float).\n"         \
-"\n"         \
-"The definition of the set distance used depends on the parameter  mode :\n"         \
-" 0: Hausdorff\n"         \
-" 1: Baddeley, order 1\n"         \
-" 2: Baddeley, order 2\n"         \
-" 3: Dubuisson-Jain\n"         \
-"\n"         \
-"The optional parameter  cut is required only for Baddeley distances. \n"         \
-"\n"         \
-" The input images  in1.pgm and  in2.pgm must be binary images. No test is done.\n"         \
-"\n"         \
-"Types supported: byte 2d,  byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dsphere__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__3dcolor__c__ "  3dcolor.c\n"         \
-"\n"         \
-" Gives a specific color to points in a 3D khalimsky grid,\n"         \
-"according to their rank\n"         \
-"\n"         \
-"Usage: 3dcolor in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Gives a specific color to points in a 3D khalimsky grid,\n"         \
-"according to their rank\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pgm2ppm__c__ "  pgm2ppm.c\n"         \
-"\n"         \
-" constructs a ppm color image from 3 pgm grayscale image or from a pgm image and a lookup table\n"         \
-"\n"         \
-"Usage: pgm2ppm {r.pgm g.pgm b.pgm|in.pgm in.lut} out.ppm\n"         \
-"\n"         \
-"Description:\n"         \
-"1st mode (3 arguments): combines three grayscale images: r.pgm, g.pgm and\n"         \
-"b.pgm as the red, green and blue color planes of the color image out.ppm\n"         \
-"\n"         \
-"2nd mode (2 arguments): generates a color ppm image from the image in.pgm and the \n"         \
-"lookup table in.lut\n"         \
-"\n"         \
-"A lookup table is represented by a special ppm image with 1 row. \n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__selndg__c__ "  selndg.c\n"         \
-"\n"         \
-" selects pixels with values between two thresholds \n"         \
-"\n"         \
-"Usage: selndg in.pgm inf sup out.ppm\n"         \
-"\n"         \
-"Description: \n"         \
-"Selects pixels x such that  inf  \n"         \
-"If the input image is of type byte, the output is a binary image.\n"         \
-"If the input image is of type long, the output is also a long image\n"         \
-"where all pixels whose values are not in the interval, are put to 0.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, long 2d, long 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__relief__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__asftndg__c__ "  asftndg.c\n"         \
-"\n"         \
-" alternate sequential filter controled by topology\n"         \
-"\n"         \
-"Usage: asftndg in.pgm {c.pgm cc.pgm|null null} connex rmax out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Alternate sequential filter controled by topology for multilevel images.\n"         \
-"Disc- or Ball-shaped structuring elements of increasing radius,\n"         \
-"ranging from 1 to rmax,\n"         \
-"are generated. Let D1...Dn be these structuring elements, sorted by increasing radius.\n"         \
-"Let I(0) = in.pgm, the ith intermediate result I(i) is obtained by the \n"         \
-"homotopic pseudo-closing of the homotopic pseudo-opening of I(i-1) by the structuring element Di. \n"         \
-"Two images  c.pgm and  cc.pgm can be given to serve as constraints. \n"         \
-"The image  c.pgm must be 0 except for the points x that are to be preserved,\n"         \
-"which can be set to 255 or to I[x].\n"         \
-"The image  cc.pgm must be 255 except for the points x that are to be preserved,\n"         \
-"which can be set to 0 or to I[x].\n"         \
-"The result out.pgm contains the final result I(n).\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho, topogray\n"         \
-"  morpho, topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__samplespline__c__ "  samplespline.c\n"         \
-"\n"         \
-" samples a cubic spline according to its curvilinear abcissa\n"         \
-"\n"         \
-"Usage: samplespline in.txt nsamples out.txt\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"This program computes a regular sampling of the spline given in in.txt.\n"         \
-"The result is a list of nsamples points, which are stored in out.txt.\n"         \
-"\n"         \
-"Types supported: list 2D, list 3D\n"         \
-"\n"         \
-"Category: draw geo\n"         \
-"  draw geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dilatfast3d___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__seltopo__c__ "  seltopo.c\n"         \
-"\n"         \
-" selects points according to a local topological criterion \n"         \
-"\n"         \
-"Usage: seltopo in connex t- t+ tb- tb+ out\n"         \
-"\n"         \
-"Description:\n"         \
-"Let X be the set of points of the binary image  in, let x be a point.\n"         \
-"Let t(x) and tb(x) be the two connectivity numbers for x.\n"         \
-"The result  out is the set of points:\n"         \
-"{ x in X, t- \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__projy___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__skelvertex__c__ "  skelvertex.c\n"         \
-"\n"         \
-" selection of a specified vertex in a curvilinear skeleton\n"         \
-"\n"         \
-"Usage: skelvertex in.skel vertex_id out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"In the output image  out.pgm, only the pixels/voxels of the skeleton element\n"         \
-"corresponding to  vertex_id are present.\n"         \
-"\n"         \
-"Types supported: skel 2d, skel 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2009\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__volumelignes__c__ "  volumelignes.c\n"         \
-"\n"         \
-" enhances linear structures in a grayscale image\n"         \
-"\n"         \
-"Usage: volumelignes skel.pgm orig.pgm connex radius out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Enhances linear structures in a grayscale image.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Let F be the original image (\"orig.pgm\")\n"         \
-"Let O be the final result (\"out.pgm\")\n"         \
-"Let r be the value of parameter \"radius\"\n"         \
-"Compute k iterations of homotopic thinning, result S (\"skel.pgm\")\n"         \
-"For each point x of S which is separating\n"         \
-"  O(x) = volume((F-S).Br(x)) \n"         \
-"  where Br(x) is the disc centered on x with radius r\n"         \
-"EndFor\n"         \
-"\n"         \
-"\n"         \
-"References: \n"         \
-"\"Topological operators for the detection of\n"         \
-"curvilinar structures in grayscale images\", in preparation, 2003.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__deframe__c__ "  deframe.c\n"         \
-"\n"         \
-" suppress the frame from an image\n"         \
-"\n"         \
-"Usage: deframe in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"suppress the frame from an image.\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d, float 2d, byte 3d, int32_t 3d, float 3d.\n"         \
-"\n"         \
-"Category: convert, geo\n"         \
-"  convert, geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__rotate__c__ "  rotate.c\n"         \
-"\n"         \
-" rotation of an image\n"         \
-"\n"         \
-"Usage: rotate in.pgm theta [x y] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"rotates the image  in.pgm of the angle  theta (in degrees).\n"         \
-"Method: interpolation.\n"         \
-"If  x and  y are given, then the center of the rotation is the point \n"         \
-"(x,y) and the image size is left unchanged (hence parts of object \n"         \
-"may be lost). \n"         \
-"Otherwise, the center of the rotation is the point (0,0) and the resulting \n"         \
-"image size is computed such that no loss of information occur.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__medianfilter__c__ "  medianfilter.c\n"         \
-"\n"         \
-" median filter \n"         \
-"\n"         \
-"Usage: medianfilter in.pgm el.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let F be the input image, G be the output image, and E the structuring\n"         \
-"element. \n"         \
-"then for each pixel p, G[p] is the median element of the sorted list (by \n"         \
-"increasing order) of the pixel values in the set { F[q], q in E[p] }.\n"         \
-"\n"         \
-"The median filter is a particular case of rank filter (see rankfilter.c), \n"         \
-"with rank = 0.5 .\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-" morpho\n"         \
-"\n"         \
-" Michel Couprie 1997\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__double2byte__c__ "  double2byte.c\n"         \
-"\n"         \
-" converts a \"double\" image to a \"byte\" image\n"         \
-"\n"         \
-"Usage: double2byte in.pgm [mode] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Depending on the value given for the (optional) parameter mode:\n"         \
-"   mode = 0 (default) : for all x, out[x] = min(255, arrondi(in[x])).\n"         \
-"   mode = 1 : for all x, out[x] = arrondi(in[x]) modulo 256.\n"         \
-"   mode = 2 : scales values in the range 0-255.\n"         \
-"   mode = 4 : truncation of the square root in the range 0-255.\n"         \
-"   mode = 5 : truncation of the log in the range 0-255.\n"         \
-"\n"         \
-"Types supported: double 2d, double 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawrect__c__ "  drawrect.c\n"         \
-"\n"         \
-" Draws a rectangle with sides parallel to the main axes\n"         \
-"\n"         \
-"Usage: drawrect in.pgm x1 y1 z1 x2 y2 z2 out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws a rectangle (a box in 3D) with sides parallel to the main axes. \n"         \
-"Two diagonally opposed corners are specified by \n"         \
-"x1, y1, z1 and x2, y2, z2.\n"         \
-"The rectangle is surimposed to the contents of in.pgm.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: draw\n"         \
-"  draw\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__curvatures__c__ "  curvatures.c\n"         \
-"\n"         \
-" compute the curvatures of a natural cubic spline\n"         \
-"\n"         \
-"Usage: curvatures spline.txt n out.txt\n"         \
-"\n"         \
-"Description:\n"         \
-"Samples the spline in  spline.txt and compute the curvature at each sample point.\n"         \
-"The file  spline.txt contains a 2D or 3D spline under the format:\n"         \
-"s nbpoints  \n"         \
-"x1 y1\n"         \
-"x2 y2\n"         \
-"x3 y3\n"         \
-"...\n"         \
-"or:\n"         \
-"S nbpoints  \n"         \
-"x1 y1 z1\n"         \
-"x2 y2 z2\n"         \
-"x3 y3 z3\n"         \
-"...\n"         \
-"\n"         \
-"Types supported: 2D, 3D splines\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_EK3__c__ "  skel_EK3.c\n"         \
-"\n"         \
-" parallel 3D binary curvilinear skeleton based on ends\n"         \
-"\n"         \
-"Usage: skel_EK3 in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 3D binary thinning or curvilinear skeleton based on ends. \n"         \
-"The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__mask__c__ "  mask.c\n"         \
-"\n"         \
-" applies a binary mask to an image\n"         \
-"\n"         \
-"Usage: mask in.pgm mask.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, if mask[x] == 0 then out[x] = 0 else out[x] = in[x]\n"         \
-"Images must be of the same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2D-3D, long 2D-3D, float 2D-3D, complex 2D-3D\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__split__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__translate__c__ "  translate.c\n"         \
-"\n"         \
-" image translation \n"         \
-"\n"         \
-"Usage: in.pgm ox oy oz [mode] out.ppm\n"         \
-"\n"         \
-"Description:\n"         \
-"Translates the image by the offsets  ox,  oy,  oz in the directions\n"         \
-"x, y, z respectively. Offsets may be negative or positive integers.\n"         \
-"If  mode is 0, the points that get out of the image frame are lost. \n"         \
-"If  mode is 1, a torical space is simulated in all dimensions. \n"         \
-"Default mode is 0.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__temp3d___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__pgm2ps__c__ "  pgm2ps.c\n"         \
-"\n"         \
-" converts from pgm to ps for illustrating small image configurations\n"         \
-"\n"         \
-"Usage: pgm2ps in.pgm mode {label.pgm|null} {marker.pgm|null} coord maxval out.ps\n"         \
-"\n"         \
-"Description:\n"         \
-"Produces a Postscript file from a binary or grayscale image.\n"         \
-"If mode = \n"         \
-"     b: binary image\n"         \
-"     c: grayscale image (levels not printed)\n"         \
-"     n: grayscale image (levels printed as numbers on a colored background)\n"         \
-"     m: grayscale image (levels printed as numbers on a colored background)\n"         \
-"     d: grayscale image (idem n - levels are square-rooted)\n"         \
-"     i: grayscale image (levels printed as numbers on an inverted colored background)\n"         \
-"     p: grayscale image (levels printed as numbers)\n"         \
-"     a: grayscale image (levels printed as letters: a=1, b=2...)\n"         \
-"     g: grayscale image (levels showed as colored items)\n"         \
-"     v: vector image\n"         \
-"     B: binary khalimsky grid\n"         \
-"     N: grayscale khalimsky grid (levels printed as numbers)\n"         \
-"     G: grayscale khalimsky grid (levels showed as colored items)\n"         \
-"     C: binary khalimsky grid (dual of B)\n"         \
-"     M: grayscale khalimsky grid (dual of N)\n"         \
-"     H: grayscale khalimsky grid (dual of G)\n"         \
-"\n"         \
-"If an image  label.pgm is present and the mode is n, the level number will be replaced by a letter for each pixel not null in the label image.\n"         \
-"\n"         \
-"If an image  label.pgm is present and the mode is m, the printed number will\n"         \
-"taken in the image  label.pgm while the color will be taken from  in.pgm .\n"         \
-"\n"         \
-"If an image  marker.pgm is present, a circle will be drawn on each point not null in the marker image.\n"         \
-"\n"         \
-"The parameter  coord is a int32_t (0 or 1) which commands the inclusion of axis coordinates in the\n"         \
-"figure. \n"         \
-"\n"         \
-"The parameter  maxval is an integer which indicates the maximum grayscale value of the figure\n"         \
-"(not necessarily the maximum value of the input image).\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel2graph__c__ "  skel2graph.c\n"         \
-"\n"         \
-" generation of a graph from a curvilinear skeleton\n"         \
-"\n"         \
-"Usage: skel2graph in.skel [mode [param]] out.graph\n"         \
-"\n"         \
-"Description:\n"         \
-"Generation of a graph from a curvilinear skeleton.\n"         \
-"\n"         \
-"The parameter  mode has the following meaning (default is 0):\n"         \
-"\n"         \
-" 0: vertices of the graphs are elements (ends, curves, junctions, isolated points) of the skeleton\n"         \
-"\n"         \
-" 1: vertices of the graph are only ends, isolated points and junctions of the skeleton\n"         \
-"\n"         \
-" 2: each curve of the skeleton (not including its ends) is represented by N edges and N-1 vertices of the graph, where N is set to  param\n"         \
-"\n"         \
-" 3: each curve of the skeleton (not including its end) is represented by N edges and N-1 vertices of the graph, where N is set to max(1, trunc(len /  param)), where len is the number of points of the curve.\n"         \
-"\n"         \
-"Types supported: 2Dskel, 3Dskel\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2009\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skeleucl__c__ "  skeleucl.c\n"         \
-"\n"         \
-" Euclidean binary skeleton\n"         \
-"\n"         \
-"Usage: skeleucl in.pgm connex [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Euclidean binary skeleton.\n"         \
-"\n"         \
-"The parameter  connex indicates the connectivity of the binary object.\n"         \
-"Possible choices are 4, 8 in 2d and 6, 26 in 3d.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image (constraint set) will be left unchanged. \n"         \
-"\n"         \
-"This operator is usually used with a constraint set (parameter  inhibit) that is a subset of the exact Euclidean medial axis (see operator medialaxis). \n"         \
-"\n"         \
-"Here is an example using the whole medial axis as constraint set:\n"         \
-"\n"         \
-"\n"         \
-"medialaxis test.pgm 3 _1\n"         \
-"threshold _1 1 _2\n"         \
-"skeleucl test.pgm 8 _2 result.pgm\n"         \
-"\n"         \
-"\n"         \
-"Intersesting subsets are obtained by filtering the medial axis, either based on the ball radiuses, or based on the bisector angle (see operator bisector). Below is a script showing how to proceed:\n"         \
-"\n"         \
-"\n"         \
-"#!/bin/sh\n"         \
-"USAGE=\"Usage: $0 in seuilR (in [1..infnty[) seuilA (in [0.001..pi]) out\"\n"         \
-"if [ $# -ne 4 ]\n"         \
-"then\n"         \
-"	echo $USAGE\n"         \
-"        exit\n"         \
-"fi\n"         \
-"medialaxis $1 3 /tmp/skel2_tmp_m\n"         \
-"threshold /tmp/skel2_tmp_m 1 /tmp/skel2_tmp_m1\n"         \
-"skeleucl $1 8 /tmp/skel2_tmp_m1 /tmp/skel2_tmp_s\n"         \
-"threshold /tmp/skel2_tmp_m $2 /tmp/skel2_tmp_ms\n"         \
-"distc $1 3 /tmp/skel2_tmp_d\n"         \
-"bisector /tmp/skel2_tmp_d /tmp/skel2_tmp_ms /tmp/skel2_tmp_a\n"         \
-"threshold /tmp/skel2_tmp_a $3 /tmp/skel2_tmp_i\n"         \
-"skeleton /tmp/skel2_tmp_s /tmp/skel2_tmp_d 8 /tmp/skel2_tmp_i $4\n"         \
-"rm -f /tmp/skel2_tmp_*\n"         \
-"\n"         \
-"\n"         \
-"References: \n"         \
-"[CCZ07] M. Couprie, D. Coeurjolly and R. Zrour: \"Discrete bisector function and Euclidean skeleton in 2D and 3D\", Image and Vision Computing, Vol.&nbsp;25, No.&nbsp;10, pp.&nbsp;1543-1556, 2007.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__areaselnb__c__ "  areaselnb.c\n"         \
-"\n"         \
-" area based segmentation by selection of a given number or components\n"         \
-"\n"         \
-"Usage: areaselnb in.pgm connex nb out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Segmentation by selection of a given number or components, based on an area criterion. \n"         \
-"Connexity = connex ; desired number of components = nb.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__eros__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__desfilssombres3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__mcm2ac__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__encadre__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__lambdathin__c__ "  lambdathin.c\n"         \
-"\n"         \
-" grayscale homotopic and filtered thinning\n"         \
-"\n"         \
-"Usage: lambdathin in.pgm {imcond.pgm|null} connex niter h out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Homotopic thinning for 2D grayscale images. \n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__pow__c__ "  pow.c\n"         \
-"\n"         \
-" raises the value of each pixel to the pth power\n"         \
-"\n"         \
-"Usage: pow in.pgm p out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = in[x]^p. If the image is a byte image,\n"         \
-"and if out[x] exceeds 255, then out[x] is set to 255.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__closeball__c__ "  closeball.c\n"         \
-"\n"         \
-" morphological binary closing by a ball\n"         \
-"\n"         \
-"Usage: closeball in.pgm r [dist] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The closing consists in a dilation (dilatball) followed by an erosion (erosball).\n"         \
-"The structuring element for this closing is a ball (or a disc) of radius  r.\n"         \
-"The erosion and dilation are computed by thresholding a distance map.\n"         \
-"The distance used depends on the optional parameter  dist (default is 0) :\n"         \
-" 0: rounded euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-" The input image  in.pgm must be a binary image. No test is done.\n"         \
-"\n"         \
-"Types supported: binary byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"closeball cells 3 cells_closeball\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"  \n"         \
-"  cells\n"         \
-"      cells_closeball\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__randimage__c__ "  randimage.c\n"         \
-"\n"         \
-" random image generation\n"         \
-"\n"         \
-"Usage: randimage [in.pgm | rowsize colsize depth] valmax [seed] out.pgm\n"         \
-"\n"         \
-"Description: Generates an image with pixel values uniformly randomly\n"         \
-"distributed between 0 and  valmax (included). \n"         \
-"If given, the parameter  seed is used to \n"         \
-"initialize the random generator, otherwise the clock is used instead.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D, int32_t 2D, int32_t 3D\n"         \
-"\n"         \
-"Category: signal\n"         \
-"  signal\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skelsurf__c__ "  skelsurf.c\n"         \
-"\n"         \
-" surfacic binary skeleton guided by a priority image\n"         \
-"\n"         \
-"Usage: skelsurf in.pgm prio connex [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Surfacic binary skeleton guided by a priority image.\n"         \
-"The lowest values of the priority image correspond to the highest priority.\n"         \
-"\n"         \
-"The parameter  prio is either an image (byte or int32_t), or a numerical code\n"         \
-"indicating that a distance map will be used as a priority image; \n"         \
-"the possible choices are:\n"         \
-" 0: approximate euclidean distance\n"         \
-" 1: approximate quadratic euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-"The parameter  connex indicates the connectivity of the binary object.\n"         \
-"Possible choices are 6, 26.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Let X be the set corresponding to the input image  in.pgm.\n"         \
-"Let P be the function corresponding to the priority image.\n"         \
-"Let I be the set corresponding to the inhibit image, if given, or the empty\n"         \
-"set otherwise.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"C = {y in F | Tb(y) > 1}\n"         \
-"Repeat until stability\n"         \
-"  choose a point x in X, simple for X, such that C[x] == 0 \n"         \
-"    and such that P[x] is minimal\n"         \
-"  X = X  {x}\n"         \
-"  for all y in gamma(x)\n"         \
-"    if Tb(y) > 1 then C[y] = 1\n"         \
-"Result: X\n"         \
-"\n"         \
-"\n"         \
-"where Tb(y) refers to the second connectivity number of y, that is, \n"         \
-"(informally) the number of connected components of gamma(y) inter complement(X).\n"         \
-"\n"         \
-"References: \n"         \
-"[BC07] G. Bertrand and M. Couprie: \"Transformations topologiques discretes\", in G&eacute;om&eacute;trie discr&egrave;te et images num&eacute;riques, D. Coeurjolly and A. Montanvert and J.M. Chassery, pp.&nbsp;187-209, Herm&egrave;s, 2007.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ultimateerosion__c__ "  ultimateerosion.c\n"         \
-"\n"         \
-" ultimate erosion\n"         \
-"\n"         \
-"Usage: ultimateerosion in.pgm [dist] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let X be the set in  in.pgm .\n"         \
-"The result is union{Ui(X), i in N} where\n"         \
-"Ui(X) = erosball(X,i)  reconsgeo(erosball(X,i+1), erosball(X,i)). \n"         \
-"Structuring elements are balls defined after a distance.\n"         \
-"The distance used depends on the optional parameter  dist (default is 0) :\n"         \
-" 0: approximate euclidean distance (truncated)\n"         \
-" 1: approximate quadratic euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-" The input image  in.pgm must be a binary image. No test is done.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie aoÃ»t 2009\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__profil__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__long2byte__c__ "  long2byte.c\n"         \
-"\n"         \
-" converts a \"int32_t\" image to a \"byte\" image\n"         \
-"\n"         \
-"Usage: long2byte in.pgm [mode] [n] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Depending on the value given for the (optional) parameter mode:\n"         \
-"   mode = 0 (default) : for all x, out[x] = min(255, in[x]).\n"         \
-"   mode = 1 : for all x, out[x] = in[x] modulo 256.\n"         \
-"   mode = 2 : scales values in the range 0-255.\n"         \
-"   mode = 3 : sorts the values by decreasing number of occurence in the image.\n"         \
-"Replaces the values by their order.\n"         \
-"Only the n (default 255) first values are kept.\n"         \
-"Useful for label images.\n"         \
-"   mode = 4 : truncation of the square root in the range 0-255.\n"         \
-"   mode = 5 : truncation of the log in the range 0-255.\n"         \
-"\n"         \
-"Types supported: int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-"  convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__despics3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__mcube_tmp__c__ "  mcube.c\n"         \
-"\n"         \
-" topologically correct \"marching cubes\"-like algorithm\n"         \
-"\n"         \
-"Usage: mcube in.pgm threshold nregul obj_id format [connex] out\n"         \
-"\n"         \
-"Description:\n"         \
-"Generates a 3d mesh from the binary or grayscale image  in.pgm .\n"         \
-"\n"         \
-"The original image is first thresholded (parameter  threshold, values 0 and 1\n"         \
-"both fit for a binary image). Then the method described in [Lac96] is applied to\n"         \
-"generate the 3d mesh. The resulting mesh is then smoothed by  nregul steps of \n"         \
-"laplacian smoothing. The parameter  obj_id is used to tag the generated mesh.\n"         \
-"\n"         \
-"The parameter  format indicate the format of the output file \n"         \
-"(choices are POV, POVB, COL, MCM, AC, GL, VTK, RAW).\n"         \
-"The keyword POVB corresponds to a bare Povray mesh: \n"         \
-"a header and a footer must be catenated in order to make a full Povray scene. \n"         \
-"The keyword RAW is the exchange format for the \"mesh\" software: see http://mesh.berlios.de/\n"         \
-"\n"         \
-"The optional parameter  connex indicates the connexity used for the object.\n"         \
-"Possible values are 6 and 26 (default).\n"         \
-"\n"         \
-"[Lac96] J.-O. Lachaud, \"Topologically defined iso-surfaces\", DGCI'96, LNCS 1176 (245--256), Springer Verlag, 1996.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: mesh3d\n"         \
-"  mesh3d\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lferode3d_line__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__despuits__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__skel_CKG_map__c__ "  skel_CKG_map.c\n"         \
-"\n"         \
-" topogical map from parallel 2D and 3D binary guided thinning\n"         \
-"\n"         \
-"Usage: skel_CKG_map prio.pgm in.pgm out.pgm\n"         \
-"\n"         \
-"Description: Topological map from parallel 2D and 3D \n"         \
-"binary guided thinning based on critical kernels. \n"         \
-"The parameter  in.pgm specifies the set\n"         \
-"(object) to be thinned. The parameter  prio.pgm specifies the priority\n"         \
-"function. \n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, long 2d, long 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ellipsefit__c__ "  ellipsefit.c\n"         \
-"\n"         \
-" ellipse identification and drawing from spare points\n"         \
-"\n"         \
-"Usage: ellipsefit in.pgm pts.list filled out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Identifies the ellipse E which minimizes the sum of the (approximate) distances\n"         \
-"between the points in  pts.list and E. \n"         \
-"If  filled (int32_t) is set, then a filled ellipse is drawn.\n"         \
-"\n"         \
-"Ref: \n"         \
-"Andrew W. Fitzgibbon, Maurizio Pilu, and Robert B. Fisher\n"         \
-"Direct least-squares fitting of ellipses,\n"         \
-"IEEE Transactions on Pattern Analysis and Machine Intelligence, 21(5), 476--480, May 1999\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__genfield__c__ "  genfield.c\n"         \
-"\n"         \
-" generates a null vector field of given size\n"         \
-"\n"         \
-"Usage: genfield {in.pgm|rs cs ds} out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The size of the result field out.pgm is taken from image\n"         \
-"in.pgm, or given by the parameters rs, cs, ds. \n"         \
-"\n"         \
-"Types supported: float 2d, float 3d\n"         \
-"\n"         \
-"Category: arith, geo\n"         \
-"  arith, geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__hcutting__c__ "  hcutting.c\n"         \
-"\n"         \
-" homotopic cutting (pseudo opening) by a ball\n"         \
-"\n"         \
-"Usage: hcutting in.pgm r connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Homotopic cutting (pseudo opening) by a ball of radius  r.\n"         \
-"\n"         \
-"Reference: \n"         \
-"[CB04] M. Couprie and G. Bertrand:\n"         \
-"Topology preserving alternating sequential filter for smoothing \n"         \
-"2D and 3D objects,  Journal of Electronic Imaging, Vol.&nbsp;13, No.&nbsp;4, pp.&nbsp;720-730, 2004.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho, topobin\n"         \
-"  morpho, topobin\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__entropy__c__ "  entropy.c\n"         \
-"\n"         \
-" computes the Shannon entropy of an image or a region\n"         \
-"\n"         \
-"Usage: entropy in.pgm [mask.pgm] out.list\n"         \
-"\n"         \
-"Description:\n"         \
-"Calculates the Shannon entropy of  im.pgm (masked by the binary image\n"         \
-" mask.pgm, if given) and saves it in file  out.list .\n"         \
-"\n"         \
-"Let H(i), i = 0...B-1, denote the histogram of  im.pgm, where B is the number of bins.\n"         \
-"Let P(i) be the frequency of the level i in the image, that is, P(i) = H(i)/N, where N is the number of pixels of  im.pgm .\n"         \
-"Then, the Shannon entropy of  im.pgm is defined by: E = - SUM P(i) log_2 P(i), for all i in {0...B-1}.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: signal\n"         \
-"  signal\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__matchrect__c__ "  matchrect.c\n"         \
-"\n"         \
-" matches (rounded) rectangles to the contours of objects\n"         \
-"\n"         \
-"Usage: matchrect in.pgm connex [rounded|axis] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Matches (rounded) rectangles to the contours of objects.\n"         \
-"Objects are connected components according to the connectivity\n"         \
-"given by  connex .\n"         \
-"Option  rounded is used to match rounded rectangles.\n"         \
-"Option  axis is used to output only the big axis of the matched rectangle.\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category:  geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dborder__c__ "  3dborder.c\n"         \
-"\n"         \
-" extracts the border of an object in H3\n"         \
-"\n"         \
-"Usage: 3dborder in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Extracts the border of an object in H3. The (internal) border is defined as the set \n"         \
-"of the object points which have at least one neighboring background point. \n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topo \n"         \
-"  topo \n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__erosfast__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__ptselectgray__c__ "  ptselectgray.c\n"         \
-"\n"         \
-" detects points in a 2D or 3D grayscale image corresponding to a given criterion \n"         \
-"\n"         \
-"Usage: ptselectgray in.pgm connex mint+ maxt+ mint-- maxt-- out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Select all points p such that the condition:\n"         \
-"mint+ \n"         \
-"is satisfied.\n"         \
-"\n"         \
-"The parameter  connex gives the connectivity used for the minima;\n"         \
-"possible choices are 4, 8 in 2D and 6, 26 in 3D.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d \n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Nicolas Combaret 2006\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__segmentheight__c__ "  segmentheight.c\n"         \
-"\n"         \
-" segmentation based on a height criterion\n"         \
-"\n"         \
-"Usage: segmentheight in.pgm connex height [r] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Height segmentation with connexity connex and depth height, \n"         \
-"followed by a reconstruction (2D only) if option r is set (see reference: to appear)\n"         \
-"or a maximization if option m is set.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__2dinvariants__c__ "  2dinvariants.c\n"         \
-"\n"         \
-" computes the numbers of connected components,\n"         \
-"cavities and tunnels of a 2D Khalimsky order\n"         \
-"\n"         \
-"Usage: 2dinvariants in.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Computes the numbers of connected components\n"         \
-"and holes of a 2D Khalimsky order\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__quasishear__c__ "  quasishear.c\n"         \
-"\n"         \
-" quasi shear rotation\n"         \
-"\n"         \
-"Usage: quasishear in.pgm theta [x y] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"rotates the image of the angle  theta (in degrees).\n"         \
-"If a point (x,y) is given, then the result is croped to the original\n"         \
-"image size, otherwise a new image with sufficient size is created.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skeletonlab__c__ "  skeletonlab.c\n"         \
-"\n"         \
-" ultimate binary skeleton on label image guided by a priority image (see [BC07])\n"         \
-"\n"         \
-"Usage: skeletonlab in.pgm prio connex [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Ultimate binary skeleton on label image guided by a priority image.\n"         \
-"For simple point testing, each label is treated as if all other labels are turned to 0 (background).\n"         \
-"For computing distance maps, all labels are turned to 1 (foregroung).\n"         \
-"The lowest values of the priority image correspond to the highest priority.\n"         \
-"\n"         \
-"The parameter  prio is either an image (byte, int32_t, float or double), or a numerical code\n"         \
-"indicating that a distance map will be used as a priority image; \n"         \
-"the possible choices are:\n"         \
-" 0: approximate euclidean distance\n"         \
-" 1: approximate quadratic euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-"The parameter  connex indicates the connectivity of the binary object.\n"         \
-"Possible choices are 4, 8 in 2d and 6, 26 in 3d.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is an integer different from -1,\n"         \
-"then the points which correspond to this priority value will be left unchanged. \n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Let X be the set corresponding to the input image  in.pgm.\n"         \
-"Let P be the function corresponding to the priority image.\n"         \
-"Let I be the set corresponding to the inhibit image, if given, or the empty\n"         \
-"set otherwise.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat until stability\n"         \
-"    Select a point x in X  I such that P[x] is minimal\n"         \
-"    If x is simple for X then\n"         \
-"        X = X  {x}\n"         \
-"Result: X\n"         \
-"\n"         \
-"\n"         \
-"Reference: \n"         \
-"[BC07] G. Bertrand and M. Couprie: \"Transformations topologiques discretes\", in G&eacute;om&eacute;trie discr&egrave;te et images num&eacute;riques, D. Coeurjolly and A. Montanvert and J.M. Chassery, pp.&nbsp;187-209, Herm&egrave;s, 2007.\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__setvoxdim__c__ "  setvoxdim.c\n"         \
-"\n"         \
-" adds voxel dimensions to file header\n"         \
-"\n"         \
-"Usage: setvoxdim image xdim ydim zdim\n"         \
-"\n"         \
-"Description: Adds voxel dimensions ( xdim  ydim  zdim ) \n"         \
-"to file header.\n"         \
-"\n"         \
-"Types supported: byte 3d, int32_t 3d\n"         \
-"\n"         \
-"Category: convert\n"         \
-" convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_AK2__c__ "  skel_AK2.c\n"         \
-"\n"         \
-" parallel 2D binary curvilinear skeleton\n"         \
-"\n"         \
-"Usage: skel_AK2 in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 2D binary thinning or curvilinear skeleton. The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"References:\n"         \
-"[BC08] Gilles Bertrand and Michel Couprie, Two-dimensional thinning algorithms based on critical kernels. Journal of Mathematical Imaging and Vision, 31(1). 2008. pp.35â56.\n"         \
-"http://igm.univ-mlv.fr/LIGM/internal_report/pdf/2006_02.v2.pdf\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__delcomp___notused_c__ "  delcomp.c\n"         \
-"\n"         \
-" deletes a connected component\n"         \
-"\n"         \
-"Usage: delcomp in.pgm x y z v out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The connected component of the binary image in.pgm\n"         \
-"which contains the point (x,y,z)\n"         \
-"is deleted.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect, topobin\n"         \
-"  connect, topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__hthinbin__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__pgm2closedcurve__c__ "  pgm2closedcurve.c\n"         \
-"\n"         \
-" extracts a curve from a binary image\n"         \
-"\n"         \
-"Usage: pgm2closedcurve image.pgm connex [x y [z]] out.curve\n"         \
-"\n"         \
-"Description:\n"         \
-"Extracts a closed curve from a binary image, that is, a curve with the\n"         \
-"same starting and ending point.\n"         \
-"The parameter  connex is the connexity of the curve.\n"         \
-"It may be equal to 4 or 8 in 2D, and to 6, 18 or 26 in 3D.\n"         \
-"If given, the point (x, y, z) (2D) or (x, y, z) (3D) \n"         \
-"is taken as the starting point of the curve, and must be a curve point. \n"         \
-"The output is the text file  out.curve, with the following format:\n"         \
-"b nbpoints\n"         \
-"x1 y1\n"         \
-"x2 y2\n"         \
-"...\n"         \
-"or (3D): \n"         \
-"B nbpoints\n"         \
-"x1 y1 z1\n"         \
-"x2 y2 z2\n"         \
-"...\n"         \
-"\n"         \
-"The points of the curve may also be valued. This is must be indicated by \n"         \
-"a value of 40, 80, 60, 180 or 260 for the parameter  connex, instead\n"         \
-"of 4, 8, 6, 18 or 26 respectively. In this case,\n"         \
-"the output is the text file  out.curve, with the following format:\n"         \
-"n nbpoints\n"         \
-"x1 y1 v1\n"         \
-"x2 y2 v2\n"         \
-"...\n"         \
-"or (3D): \n"         \
-"N nbpoints\n"         \
-"x1 y1 z1 v1\n"         \
-"x2 y2 z2 v2\n"         \
-"...\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: convert geo\n"         \
-"  convert geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__2dthin__c__ "  2dthin.c\n"         \
-"\n"         \
-" homotopic thinning of a 2d Khalimsky image\n"         \
-"\n"         \
-"Usage: 2dthin in.pgm n out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Homotopic thinning of a 2d Khalimsky image.\n"         \
-"The maximum number of steps is given by n.\n"         \
-"If the value given for  n equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__hthinpar__c__ "  hthinpar.c\n"         \
-"\n"         \
-" parallel grayscale homotopic thinning\n"         \
-"\n"         \
-"Usage: hthinpar in.pgm {imcond.pgm|null} connex niter out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel grayscale homotopic thinning (refs. [BEC97, CBB01]).\n"         \
-"The parameter  connex gives the connectivity used for the minima;\n"         \
-"possible choices are 4, 8 in 2D and 6, 26 in 3D.\n"         \
-"Let F be the function corresponding to the input image  in.pgm.\n"         \
-"Let G be the function corresponding to the input image \n"         \
-" imcond.pgm, or the null function if the keyword  null is used.\n"         \
-"\n"         \
-"If  niter is set to -1, then the operator iterates until stability.\n"         \
-"\n"         \
-"References:\n"         \
-"\n"         \
-"to appear\n"         \
-"\n"         \
-"Types supported: byte 2D.\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Nivando Bezerra\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lambdamedialaxis__c__ "  lambdamedialaxis.c\n"         \
-"\n"         \
-" discrete lambda-medial axis transform\n"         \
-"\n"         \
-"Usage: lambdamedialaxis in.pgm [lambda] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Discrete lambda-medial axis, as defined in [CCT09], \n"         \
-"of the binary image  X contained in  in.pgm.\n"         \
-"\n"         \
-"By default, the output is a float image representing the function x->lambda(x).\n"         \
-"\n"         \
-"If the parameter  lambda is given (bash interface only, not python), the output is a binary image obtained by thresholding the aforementioned function at the value  lambda .\n"         \
-"\n"         \
-"References: \n"         \
-"[CCT09] John Chaussard, Michel Couprie, and Hugues Talbot. A discrete lambda-medial axis. 15th Discrete Geometry for Computer Imagery (DGCI'09). Lecture Notes in Computer Science.   2009.  pp. 1â12. To appear.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__herosball__c__ "  herosball.c\n"         \
-"\n"         \
-" topologically controlled erosion\n"         \
-"\n"         \
-"Usage: herosball in.pgm radius dist connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs a topologically controlled erosion, that is, a homotopic thinning \n"         \
-"constrained by the erosion of the input object.\n"         \
-"\n"         \
-"The parameter  radius gives the radius of the ball which is \n"         \
-"used as structuring element for the erosion.\n"         \
-"\n"         \
-"The parameter  dist is a numerical code\n"         \
-"indicating the distance which is used to compute the erosion.\n"         \
-"The possible choices are:\n"         \
-" 0: approximate euclidean distance\n"         \
-" 1: approximate quadratic euclidean distance\n"         \
-" 2: chamfer distance\n"         \
-" 3: exact quadratic euclidean distance\n"         \
-" 4: 4-distance in 2d\n"         \
-" 8: 8-distance in 2d\n"         \
-" 6: 6-distance in 3d\n"         \
-" 18: 18-distance in 3d\n"         \
-" 26: 26-distance in 3d\n"         \
-"\n"         \
-"The parameter  connex indicates the connectivity of the binary object.\n"         \
-"Possible choices are 4, 8 in 2d and 6, 26 in 3d.\n"         \
-"\n"         \
-"Let X be the set corresponding to the input image  in.pgm, and let\n"         \
-"Xbar denote its complementary set. The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"I = erosball(X, dist, r)\n"         \
-"Repeat:\n"         \
-"    Select a point x in X  I such that dist(x,Xbar) is minimal\n"         \
-"    If x is simple for X then\n"         \
-"        X = X  {x}\n"         \
-"	I = I union {x}\n"         \
-"Until X == I\n"         \
-"Result: X\n"         \
-"\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__deletepeaks__c__ "  deletepeaks.c\n"         \
-"\n"         \
-" deletes peaks in a grayscale image \n"         \
-"\n"         \
-"Usage: deletepeaks filein.pgm [mask] connexmin fileout.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Deletes peaks in a grayscale image. A point p is a peak if T+(p) = 0\n"         \
-"(see ref. [BEC97]).\n"         \
-"\n"         \
-"References: \n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__ptisolated__c__ "  ptisolated.c\n"         \
-"\n"         \
-" detects isolated points in a binary image\n"         \
-"\n"         \
-"Usage: ptisolated in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"An isolated point is a white point, all the n-neighbours of which are black\n"         \
-"(n = 4, 8 (2d) or 6, 18, 26 (3d), as set by the parameter  connex)\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__squelval__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__propgeo__c__ "  propgeo.c\n"         \
-"\n"         \
-" geodesic propagation of image values\n"         \
-"\n"         \
-"Usage: propgeo in.pgm mask.pgm connex mode out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Propagates certain values of the original image in.pgm, \n"         \
-"geodesicaly wrt the connected components of the binary image mask.pgm.\n"         \
-"The connexity is specified by the parameter connex.\n"         \
-"The mode is one of the following ones:\n"         \
-" 0 | min   : propagates the minimal value of the component\n"         \
-" 1 | max   : propagates the maximal value of the component\n"         \
-" 2 | moy   : propagates the mean grayscale value of the component\n"         \
-" 3 | min1  : selects one point the value of which is equal to the min\n"         \
-" 4 | max1  : selects one point the value of which is equal to the max\n"         \
-" 5 | moy1  : selects one point the value of which is nearest to the mean\n"         \
-" 6 | minb  : propagates the minimal value of the external border of the component\n"         \
-" 7 | maxb  : propagates the maximal value of the external border of the component\n"         \
-" 8 | moyb  : propagates the mean value of the external border of the component\n"         \
-" 9 | randb : fills the component with random values, with a normal distribution centered around the value computed as for moyb\n"         \
-"\n"         \
-"Only modes min, max and moy are available for int32_t images.\n"         \
-"\n"         \
-"Types supported: byte 2d, int32_t 2d byte 3d, int32_t 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skelpar__c__ "  skelpar.c\n"         \
-"\n"         \
-" parallel binary skeleton\n"         \
-"\n"         \
-"Usage: skelpar in.pgm algorithm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel binary thinning or skeleton. The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"The parameter  algorithm is a numerical code\n"         \
-"indicating which method will be used for the thinning.\n"         \
-"The possible choices are:\n"         \
-" 0: Pavlidis 1981\n"         \
-" 1: Eckhardt and Maderlechner 1993\n"         \
-" 2: Couprie and Bertrand, ultimate (MK2)\n"         \
-" 3: Couprie and Bertrand, curvilinear\n"         \
-" 4: Couprie and Bertrand, curvilinear with reconstruction property (AK2)\n"         \
-" 5: Rutovitz 1966 [DOES NOT PRESERVE TOPOLOGY]\n"         \
-" 6: Zhang and Wang 1988 [DOES NOT PRESERVE TOPOLOGY]\n"         \
-" 7: Han, La and Rhee\n"         \
-" 8: Guo and Hall 1992 (1)\n"         \
-" 9: Guo and Hall 1992 (2)\n"         \
-" 10: Guo and Hall 1992 (3)\n"         \
-" 11: Chin and Wan and Stover and Iverson 1987\n"         \
-" 12: Jang and Chin 1992 [DOES NOT PRESERVE TOPOLOGY]\n"         \
-" 13: Jang and Chin (correction mc)\n"         \
-" 14: MNS preservation\n"         \
-" 15: Jang and Chin 1993 (reconstruction)\n"         \
-" 16: Choy, Choy and Siu 1995 [DOES NOT PRESERVE TOPOLOGY]\n"         \
-" 17: Bernard and Manzanera 1999\n"         \
-" 18: Holt et al. 1987\n"         \
-" 19: Hall 1989\n"         \
-" 20: Wu and Tsai 1992 [DOES NOT PRESERVE TOPOLOGY]\n"         \
-" 21: Manzanera and Bernard (variant by GB)\n"         \
-" 22: Couprie and Bertrand, ultimate asymmetrical with medial axis (NK2)\n"         \
-" 23: Bertrand curvilinear with reconstruction, asymmetrical\n"         \
-" 24: Bertrand curvilinear with reconstruction, symmetrical\n"         \
-" 25: Rosenfeld directionnel\n"         \
-" 26: Nemeth et Palagyi, 2009 (1)\n"         \
-" 27: Nemeth et Palagyi, 2009 (2)\n"         \
-" 28: Nemeth et Palagyi, 2009 (3)\n"         \
-" 29: Couprie and Bertrand, ultimate, asymmetrical (NK2)\n"         \
-" 30: Couprie and Bertrand, ultimate, symmetrical (MK2b)\n"         \
-" 31: Couprie and Bertrand, curvilinear, symmetrical, based on 1D isthmuses (CK2)\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged.\n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"References:\n"         \
-"[BC08] Gilles Bertrand and Michel Couprie, Two-dimensional thinning algorithms based on critical kernels. Journal of Mathematical Imaging and Vision, 31(1). 2008. pp.35â56.\n"         \
-"http://igm.univ-mlv.fr/LIGM/internal_report/pdf/2006_02.v2.pdf\n"         \
-"\n"         \
-"[COU05] M. Couprie, Note on fifteen 2D parallel thinning algorithms,\n"         \
-"IGM2006-01}, Universit de Marne-la-Vall 2006,\n"         \
-"http://igm.univ-mlv.fr/LabInfo/rapportsInternes/2006/01.pdf\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lvkernu__c__ "  lvkernu.c\n"         \
-"\n"         \
-" grayscale ultimate leveling thickening\n"         \
-"\n"         \
-"Usage: lvkernu in.pgm {imcond.pgm|null} connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Grayscale ultimate leveling thickening (refs. [BEC97, CBB01]).\n"         \
-"The parameter  connex gives the connectivity used for the minima;\n"         \
-"possible choices are 4, 8 in 2D and 6, 26 in 3D.\n"         \
-"Let F be the function corresponding to the input image  in.pgm.\n"         \
-"Let G be the function corresponding to the input image \n"         \
-" imcond.pgm, or the blanck function (constant 255) if the keyword  null is used.\n"         \
-"The algorithm is the following:\n"         \
-"\n"         \
-"\n"         \
-"Repeat until stability:\n"         \
-"    select p such that T++(p,F) = 1 and such that F(p) is maximal\n"         \
-"    F(p) = min{ delta+(p,F), G(p) }    \n"         \
-"Result: F\n"         \
-"\n"         \
-"\n"         \
-"References: \n"         \
-"[BEC97] G. Bertrand, J. C. Everat and M. Couprie: \"Image segmentation through operators based upon topology\",  Journal of Electronic Imaging, Vol.&nbsp;6, No.&nbsp;4, pp.&nbsp;395-405, 1997.\n"         \
-"[CBB01] M. Couprie, F.N. Bezerra, Gilles Bertrand: \"Topological operators for\n"         \
-"grayscale image processing\",  Journal of Electronic Imaging, Vol.&nbsp;10, No.&nbsp;4, pp.&nbsp;1003-1015, 2001.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D.\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__surrect__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__boxmin__c__ "  boxmin.c\n"         \
-"\n"         \
-" minimal box including a given set of points\n"         \
-"\n"         \
-"Usage: boxmin in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The result out.pgm has the same size as in.pgm. \n"         \
-"It contains the minimal box including the set of points in  in.pgm \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__extractplane__c__ "  extractplane.c\n"         \
-"\n"         \
-" extracts a plane normal to one of the directions x,y,z from a 3D image\n"         \
-"\n"         \
-"Usage: extractplane in.pgm n plane out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The original 3D image is in.pgm. The parameter n is an integer.\n"         \
-"The parameter plane is set to xy, yx, \n"         \
-"xz, zx, yz, zy.\n"         \
-"The order of the letters x, y, z is meaningfull: for example, zy means that \n"         \
-"each row of the output image will correspond to a z-line of the original image, \n"         \
-"each column of the output image will correspond to a y-line of the original image.\n"         \
-"The output image out.pgm contains the nth plane of the given form extracted\n"         \
-"from in.pgm.\n"         \
-"\n"         \
-"Types supported: byte 3d, long 3d, float 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__geodilat__c__ "  geodilat.c\n"         \
-"\n"         \
-" geodesic (grayscale or binary) dilation\n"         \
-"\n"         \
-"Usage: geodilat g.pgm f.pgm connex niter out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Geodesic dilation of g.pgm under f.pgm.\n"         \
-"Let G and F be the two input images. If G is not under F, then G is replaced initially by min(G,F).\n"         \
-"The structuring element is specified by the value of the parameter connex, \n"         \
-"which can be one of the following ones: 4, 8 in 2d, or 6, 18, 26 in 3d.\n"         \
-"The parameter  niter sets the number of iterations. If  niter = -1,\n"         \
-"then the iterations continue until stability.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d.\n"         \
-"\n"         \
-"Category: connect, morpho\n"         \
-"  connect, morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__detectcercles__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__projsphere__c__ "  projsphere.c\n"         \
-"\n"         \
-" projection on a sphere\n"         \
-"\n"         \
-"Usage: projsphere in.pgm out.pgm\n"         \
-"\n"         \
-"Description: Projection on a sphere.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__drawsplinesorient__c__ "  drawsplinesorient.c\n"         \
-"\n"         \
-" draw spline orientations in a vector field (multiple spline version)\n"         \
-"\n"         \
-"Usage: drawsplinesorient in.pgm in.splines out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws spline orientations in a vector field. \n"         \
-"The spline is specified by its control points in a text file.\n"         \
-"The parameter  in.pgm gives a vector field into which the spline is to be drawn.\n"         \
-"\n"         \
-"The file  splines.txt contains a list of splines under the format:\n"         \
-"d nb_splines\n"         \
-"nb_points_spline_1  x11 y11  x12 y12 ...\n"         \
-"nb_points_spline_2  x21 y21  x22 y22 ...\n"         \
-"nb_points_spline_3  x31 y31  x32 y32 ...\n"         \
-"...\n"         \
-"or, in 3D:\n"         \
-"D nb_splines\n"         \
-"nb_points_spline_1  x11 y11 z11  x12 y12 z12 ...\n"         \
-"nb_points_spline_2  x21 y21 z21  x22 y22 z22 ...\n"         \
-"nb_points_spline_3  x31 y31 z31  x32 y32 z32 ...\n"         \
-"...\n"         \
-"\n"         \
-"Types supported: spline 2D, spline 3D\n"         \
-"\n"         \
-"Category: draw geo\n"         \
-"  draw geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__3dpardircollapse__c__ "  3dpardircollapse.c\n"         \
-"\n"         \
-" parallel directional constrained collapse\n"         \
-"\n"         \
-"Usage: 3dpardircollapse in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel directional constrained collapse.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__bmp2ppm__c__ "  bmp2ppm.c\n"         \
-"\n"         \
-" \n"         \
-"\n"         \
-"Usage: \n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: \n"         \
-"  \n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__point__c__ "  point.c\n"         \
-"\n"         \
-" modifies the value of a given point \n"         \
-"\n"         \
-"Usage: point in.pgm x y z v out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The value of the point (x,y,z)\n"         \
-"is changed to v.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dror__cxx__ "  im2line.c\n"         \
-"\n"         \
-" find line into an image using bresenham definition\n"         \
-"\n"         \
-"Usage:test4.pgm  testfind.pgm\n"         \
-"test4.pgm  testfind.pgm\n"         \
-"test4.pgm  testfind.pgm\n"         \
-" im2line in.fits {w}  out.pgmtest4.pgm  testfind.pgm\n"         \
-"\n"         \
-"\n"         \
-"Description:\n"         \
-"On commence pas netoyer l'image afin de retirer le bruit de fond et d'ameliorer le contraste.\n"         \
-"\n"         \
-"On determine ensuite les points sur le bord de l'image qui correspondent potentiellement Ã  une droite.\n"         \
-"\n"         \
-"Parralellement, on crÃ©e un arbre...\n"         \
-"\n"         \
-"On trace les droites de Bresenham entre les differents points des bords. Pour chacunes des droites on calcule\n"         \
-"le nombre de points non nul present dans le plan sous la droite via l'arbre, puis le nombre de points non nuls pour une droite parralelle.\n"         \
-"On soustrait ces 2 nombres, on obtient ainsi le nombre de pixel non nul contenu dans l'espace entre les 2 plans.\n"         \
-"La droites contenant les plus de points non nul doit correspondre Ã  la trace du satellite.\n"         \
-"\n"         \
-"L'image finale est une image noire, avec une droite blanche correspondant Ã  la trace du sattelite.\n"         \
-"\n"         \
-"Parameters:\n"         \
-"  in.fits : source file in fits format\n"         \
-"\n"         \
-"\n"         \
-" Juliette Charpentier\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__convol3__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__sym__c__ "  sym.c\n"         \
-"\n"         \
-" symmetry (vertical, horizontal, central in 2D; x, y, z in 3D) \n"         \
-"\n"         \
-"Usage: sym in.pgm type out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Symmetry (vertical, horizontal, central in 2D; x, y, z in 3D).\n"         \
-"The parameter type is set to v or y (vertical), \n"         \
-"h or x (horizontal), or c (central) for 2D images, \n"         \
-"or to x, y or z for 3D images.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d.\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__extrude__c__ "  extrude.c\n"         \
-"\n"         \
-" catenates a sequence of 2d (resp. 1d) images, made of the repetition of the same image, into a 3d (resp. 2d) image\n"         \
-"\n"         \
-"Usage: extrude in.pgm nbrep [xdim ydim zdim] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Catenates a sequence of 2d (resp. 1d) images, made of the repetition of the same image, into a 3d (resp. 2d) image.\n"         \
-"\n"         \
-"Types supported: byte 1d, 2d\n"         \
-"\n"         \
-"Category:  convert\n"         \
-"   convert\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lfopen_rect__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__GA2khalimsky__c__ "  GA2khalimsky.c\n"         \
-"\n"         \
-" Convert a 4-connected edge-weighted graph (a GA) into its\n"         \
-"representation in the Khalimsky grid\n"         \
-"\n"         \
-"Usage: GA2khalimsky GA.pgm type out.pgm \n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Convert a 4-connected (6-connected, in 3D) edge-weighted graph\n"         \
-"(graph.ga) into its Khalimsky grid representation (depending on\n"         \
-"the parameter type), stored as a pgm image\n"         \
-"(out.pgm). The vertices of the graph are associated to the\n"         \
-"square of the Khalimsky grid, and the edges of the graphs are\n"         \
-"associated to the line segments.\n"         \
-"\n"         \
-"If type = 0, then the closure of the set of weighted-edges is used\n"         \
-"(usefull for representing contours).  \n"         \
-"\n"         \
-"If type = 1, then the dual of the closure of the set of weighted edges\n"         \
-"is used (usefull for representing regions).\n"         \
-"\n"         \
-"\n"         \
-"Types supported: ga 2d, ga 3d\n"         \
-"\n"         \
-"Category: GA\n"         \
-" GA\n"         \
-"\n"         \
-" Jean Cousty\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lfopen_line__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__section__c__ "  section.c\n"         \
-"\n"         \
-" computes a 2d cross section from a 3d image\n"         \
-"\n"         \
-"Usage: section in.pgm x0 y0 z0 x1 y1 z1 x2 y2 z2 out.pgm\n"         \
-"\n"         \
-"Description: \n"         \
-"The points P0 (  x0,  y0,  z0 ), P1 (  x1,  y1,  z1 ) and\n"         \
-"P2 (  x2,  y2,  z2 ) form a basis for a plane in the 3d space. \n"         \
-"The intersection of this plane with the domain of the 3d image  in.pgm\n"         \
-"form the domain of the 2d image  out.pgm .\n"         \
-"The grayscale values of  out.pgm are obtained by trilinear interpolation from\n"         \
-"the grayscale values of  in.pgm .\n"         \
-"The coordinates of the basis for the plane are expressed in \"real world\" dimensions.\n"         \
-"\n"         \
-"Types supported: byte 3d, int32_t 3d\n"         \
-"\n"         \
-"Category: geo\n"         \
-"  geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__max__c__ "  max.c\n"         \
-"\n"         \
-" maximum of 2 images\n"         \
-"\n"         \
-"Usage: max in1.pgm in2.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"For each pixel x, out[x] = max{in1[x], in2[x]}. \n"         \
-"Images must be of the same type and same dimensions.\n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__tracevect__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__skelsmoothing__c__ "  skelsmoothing.c\n"         \
-"\n"         \
-" computes a smmothed version of a curvilinear skeleton\n"         \
-"\n"         \
-"Usage: skelsmoothing in.skel mode param out.skel\n"         \
-"\n"         \
-"Description:\n"         \
-"Computes a smmothed version of a curvilinear skeleton.\n"         \
-"\n"         \
-"The parameter  mode specifies the smoothing method:\n"         \
-" 0: straight lines segments\n"         \
-" 1: splines\n"         \
-"\n"         \
-"Types supported: 2Dskel, 3Dskel\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2011\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__GAwatershed__c__ "  GAwatershed.c\n"         \
-"\n"         \
-" Compute the watershed of a 4-connected edge-weighted graph (a GA)\n"         \
-"\n"         \
-"Usage: GAwatershed in.ga out.pgm [type]\n"         \
-"\n"         \
-"Description:\n"         \
-"\n"         \
-"Compute the watershed of a 4-connected edge-weighted graph (a GA).\n"         \
-"\n"         \
-"If type = 0, then outputs a watershed by an M-border algorithm. The\n"         \
-"file out.pgm is a GA.\n"         \
-"\n"         \
-"If type = 1, then outputs a watershed by a non-recursive algorithm\n"         \
-"based on streams. The file out.pgm is a GA (this is the default) (not\n"         \
-"available for floats).\n"         \
-"\n"         \
-"If type = 2 outputs a watershed by a recursive algorithm based on\n"         \
-"streams. The file out.pgm is a GA (not available for floats).\n"         \
-"\n"         \
-"If type = 3 outputs an M-border watershed. The file out.pgm is a GA\n"         \
-"(not available for floats).\n"         \
-"\n"         \
-"If type = 4 outputs a flow mapping. The file out.pgm is a long integer\n"         \
-"image that represents a labeled partition induced by a watershed cut\n"         \
-"of the input GA (not available for floats).\n"         \
-"\n"         \
-"\n"         \
-"\n"         \
-"Types supported: GA byte 2D, GA float 2D\n"         \
-"\n"         \
-"Category: GA\n"         \
-"  GA\n"         \
-"\n"         \
-" Jean Cousty\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__correctbias__c__ "  correctbias.c\n"         \
-"\n"         \
-" correction of a luminosity bias expressed by a linear function\n"         \
-"\n"         \
-"Usage: correctbias in.pgm factor type [xc yc] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let  a be the value of parameter  factor.\n"         \
-"The bias  type can be:\n"         \
-" 0 radial (center  xc,  yc), linear (add -ax to the value of the element of abcissa x).\n"         \
-" 1 radial (center  xc,  yc), parabolic (add -a^2 x to the value of the element of abcissa x).\n"         \
-"\n"         \
-"Types supported: byte 2D\n"         \
-"\n"         \
-"Category: arith\n"         \
-" arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__surfacerestoration__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__opening__c__ "  opening.c\n"         \
-"\n"         \
-" morphological opening by a plane structuring element\n"         \
-"\n"         \
-"Usage: opening in.pgm se.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Morphological opening by a plane structuring element.\n"         \
-"The (plane) structuring element is given by the non-null values in  se.pgm, \n"         \
-"its origin (wrt the point (0,0) of  se.pgm ) \n"         \
-"is given by a comment line in the file se.pgm. \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__segment3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__skel_MK2__c__ "  skel_MK2.c\n"         \
-"\n"         \
-" parallel 2D binary ultimate skeleton, symmetrical\n"         \
-"\n"         \
-"Usage: skel_MK2 in.pgm nsteps [inhibit] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Parallel 2D binary thinning or ultimate skeleton (symmetrical). The parameter  nsteps gives,\n"         \
-"if positive, the number of parallel thinning steps to be processed.\n"         \
-"If the value given for  nsteps equals -1, the thinning is continued\n"         \
-"until stability.\n"         \
-"\n"         \
-"If the parameter  inhibit is given and is a binary image name,\n"         \
-"then the points of this image will be left unchanged. \n"         \
-"\n"         \
-"Warning: The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"References:\n"         \
-"[BC08] Gilles Bertrand and Michel Couprie, Two-dimensional thinning algorithms based on critical kernels. Journal of Mathematical Imaging and Vision, 31(1). 2008. pp.35â56.\n"         \
-"http://igm.univ-mlv.fr/LIGM/internal_report/pdf/2006_02.v2.pdf\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__moyenne__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__drawspline__c__ "  drawspline.c\n"         \
-"\n"         \
-" draw a spline which is specified by its control points\n"         \
-"\n"         \
-"Usage: drawspline in.pgm spline.txt [len] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Draws a spline which is specified by its control points.\n"         \
-"The control points are read in the text file  spline.txt .\n"         \
-"The parameter  in.pgm gives an image into which the spline is to be drawn.\n"         \
-"The file format for  spline.txt is the following for 2D:\n"         \
-"\n"         \
-"c n+1 (where n+1 denotes the number of control points)\n"         \
-"x1 y1\n"         \
-"...\n"         \
-"xn+1 yn+1\n"         \
-"C0X1 C0Y1 C1X1 C1Y1 C2X1 C2Y1 C3X1 C3Y1\n"         \
-"...\n"         \
-"C0Xn C0Yn C1Xn C1Yn C2Xn C2Yn C3Xn C3Yn\n"         \
-"\n"         \
-"and in the 3D case:\n"         \
-"\n"         \
-"C n+1 (where n+1 denotes the number of control points)\n"         \
-"x1 y1 z1\n"         \
-"...\n"         \
-"xn+1 yn+1 zn+1\n"         \
-"C0X1 C0Y1 C0Z1 C1X1 C1Y1 C1Z1 C2X1 C2Y1 C2Z1 C3X1 C3Y1 C3Z1\n"         \
-"...\n"         \
-"C0Xn C0Yn C0Zn C1Xn C1Yn C1Zn C2Xn C2Yn C2Zn C3Xn C3Yn C3Zn\n"         \
-"\n"         \
-"If parameter  len is given and non-zero, the spline is extended on both sides by straight line segments of length  len. \n"         \
-"\n"         \
-"Types supported: byte 2D, byte 3D\n"         \
-"\n"         \
-"Category: draw geo\n"         \
-"  draw geo\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__temp3dthin___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__asfr__c__ "  asfr.c\n"         \
-"\n"         \
-" alternate sequential filter by reconstruction\n"         \
-"\n"         \
-"Usage: asfr in.pgm [rmin] rmax out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Alternate sequential filter by reconstruction. \n"         \
-"Disc-shaped structuring elements of increasing radius,\n"         \
-"ranging from 1 (or rmin if this parameter is specified) to rmax,\n"         \
-"are generated. Let D1...Dn be these structuring elements, sorted by increasing radius.\n"         \
-"Let I0 = in.pgm, the ith intermediate result Ii is obtained by the closure \n"         \
-"by reconstruction of Ii-1 by the structuring element Di. \n"         \
-"The result out.pgm contains the final result In.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__wshedkhalimsky__c__ "  wshedkhalimsky.c\n"         \
-"\n"         \
-" watershed transformation in Khalimsky space (inter pixel watershed)\n"         \
-"\n"         \
-"Usage: watershed in mark {bgmark|null} {roi|null} out\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs the watershed transformation on the image in.pgm, taking the\n"         \
-"set of markers in mark.pgm. \n"         \
-"If this parameter is present, bgmark.pgm\n"         \
-"is used as a set of markers for the background.\n"         \
-"If this parameter is present, roi\n"         \
-"indicates the region of interest on which the operation is performed.\n"         \
-"All images must be previously transformed in the khalimsky space with a max strategy.\n"         \
-"The output image is in khalimsky space too.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: connect orders\n"         \
-" connect orders\n"         \
-"\n"         \
-" Michel Couprie & Christophe Doublier\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__asfbin__c__ "  asfbin.c\n"         \
-"\n"         \
-" alternate sequential filter for binary images\n"         \
-"\n"         \
-"Usage: asfbin in.pgm [rmin] rmax out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Alternate sequential filter for binary images. \n"         \
-"\n"         \
-"Disc-shaped structuring elements of increasing radius,\n"         \
-"ranging from 1 (or rmin if this parameter is specified) to rmax,\n"         \
-"are generated. \n"         \
-"\n"         \
-"Let D1...Dn be these structuring elements, sorted by increasing radius.\n"         \
-"Let F0 = in.pgm, the ith intermediate result Fi is obtained by the closing of\n"         \
-"the opening of Fi-1 by the structuring element Di. \n"         \
-"The result out.pgm contains the final result Fn.\n"         \
-"Giving a value 0 for the optional parameter rmin has the effect of beginning \n"         \
-"by a closing instead of an opening.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__dilatbin__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__erosbin__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__proj3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__3dplane__c__ "  3dplane.c\n"         \
-"\n"         \
-" Builds the discretization of a plane in the 3d Khalimsky space.\n"         \
-"\n"         \
-"Usage: 3dplane in.pgm a b c d out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"  Draws into the Khalimsky volume  k, the discretization of the plane\n"         \
-"  defined by the equation:  a x +  b y +  c z +  d = 0\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: orders\n"         \
-"  orders\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__erosballnum__c__ "  erosballnum.c\n"         \
-"\n"         \
-" morphological grayscale erosion by an Euclidean ball\n"         \
-"\n"         \
-"Usage: erosballnum in.pgm r out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Morphological grayscale erosion by an Euclidean ball.\n"         \
-"The parameter  r must a positive number (int or float), \n"         \
-"the structuring element for this erosion is a ball (or a disc) of radius  r.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2006\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__reconsdilat3d__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__ptcurve__c__ "  ptcurve.c\n"         \
-"\n"         \
-" detects curve points in a binary image\n"         \
-"\n"         \
-"Usage: ptcurve in.pgm connex out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"An curve point is a white point, which has exactly 2 white n-neighbours \n"         \
-"that are not n-neighbours to each other. In other words, Tn = 2 and \n"         \
-"each neighboring n-connected component is made of exactly one point\n"         \
-"(n = 4, 8 (2d) or 6, 18, 26 (3d), as set by the parameter  connex)\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lfdilat_rect__c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__erosion__c__ "  erosion.c\n"         \
-"\n"         \
-" morphological erosion by a plane structuring element\n"         \
-"\n"         \
-"Usage: erosion in.pgm se.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"The (plane) structuring element is given by the non-null values in  se.pgm, \n"         \
-"its origin (wrt the point (0,0) of  se.pgm ) is given by a comment line in the file se.pgm. \n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d, int32_t 2d, int32_t 3d, float 2d, float 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie 2002\n"         \
-"\n"         \
-"Example:\n"         \
-"\n"         \
-"erosion cells ~/Pink/masks/carre5.pgm cells_eros\n"         \
-"\n"         \
-"\n"         \
-"  \n"         \
-"      \n"         \
-"  \n"         \
-"  cells\n"         \
-"      cells_eros\n"         \
-"  \n"         \
-"\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__files_to_copy__c__ "  files_to_copy Draft\n"         \
-"\n"         \
-" html pink_euroscipy_web.jpeg \"EuroSciPy 2011 poster\"\n"         \
-" html pink_euroscipy_web.pdf \"EuroSciPy 2011 poster\"\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__radialopening__c__ "  radialopening.c\n"         \
-"\n"         \
-" radial opening by line\n"         \
-"\n"         \
-"Usage: radialopening in.pgm length [angle in degrees] [dilatmask.pgm] out.pgm\n"         \
-"\n"         \
-"Description: \n"         \
-"Radial opening by line (or dilated line). Max between the openings of\n"         \
-"in.pgm by a linear structuring element rotated by angle until 360 degrees\n"         \
-"and dilated by dilatmask.pgm. The angle is normalized to an exact division\n"         \
-"of 360 by an integer.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" André Vital Saude jan 2005\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel_ACK3_pers__c__ "  skel_ACK3c.c\n"         \
-"\n"         \
-" topological persistence of 1D isthmuses, based on parallel 3D asymetric thinning\n"         \
-"\n"         \
-"Usage: skel_ACK3c in.pgm out.pgm\n"         \
-"\n"         \
-"Description: Topological persistence of 1D isthmuses, based on \n"         \
-"parallel 3D asymetric thinning.\n"         \
-"\n"         \
-"When a point x is detected as a 1D isthmus, a counter p(x) is\n"         \
-"associated to this point and initialized with value 1. This counter is\n"         \
-"incremented a each iteration as long as x is still an isthmus. When this point x is\n"         \
-"eventually deleted, the value of the counter is freezed.\n"         \
-"\n"         \
-" The object must not have any point on the frame of the image.\n"         \
-"\n"         \
-"Types supported: byte 3d\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__tlf__c__ "  tlf.c\n"         \
-"\n"         \
-" topological lower filter\n"         \
-"\n"         \
-"Usage: tlf in.pgm connexmin r out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Topological lower filter. Performs the homotopic thickening controlled by\n"         \
-"a radius r, followed by a well deletion, and a homotopic reconstruction over\n"         \
-"the original image.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__lambdamedialaxisauto__c__ "  lambdamedialaxis.c\n"         \
-"\n"         \
-" discrete lambda-medial axis transform\n"         \
-"\n"         \
-"Usage: lambdamedialaxis in.pgm [lambda] out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Discrete lambda-medial axis, as defined in [CCT09], \n"         \
-"of the binary image  X contained in  in.pgm.\n"         \
-"\n"         \
-"By default, the output is a float image representing the function x->lambda(x).\n"         \
-"\n"         \
-"If the parameter  lambda is given (bash interface only, not python), the output is a binary image obtained by thresholding the aforementioned function at the value  lambda .\n"         \
-"\n"         \
-"If the parameter  lambda is given and set to 0, the output is a binary image obtained by thresholding the aforementioned function at the automaticaly defined (k-means) value  lambda . \n"         \
-"\n"         \
-" References: \n"         \
-"[CCT09] John Chaussard, Michel Couprie, and Hugues Talbot. A discrete lambda-medial axis. 15th Discrete Geometry for Computer Imagery (DGCI'09). Lecture Notes in Computer Science.   2009.  pp. 1â12. To appear.\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__fusreg___notused_c__ "WRITE ME!!!\n"         \
-"\n"
-
-
-#define doc__watershedMeyer2lab__c__ "  watershedMeyer2lab.c\n"         \
-"\n"         \
-" watershed transformation (Meyer's algorithm) with labelled markers  \n"         \
-"\n"         \
-"Usage: watershedMeyer2lab marker image {roi|null} connex [mode] out\n"         \
-"\n"         \
-"Description:\n"         \
-"Performs the watershed transformation on the image image, taking the\n"         \
-"set of markers in marker, in the form of a label image where all the pixels\n"         \
-"sharing the same label (even if not connected) belong to the same marker.\n"         \
-"If this parameter is present, roi\n"         \
-"indicates the region of interest on which the operation is performed.\n"         \
-"The parameter connex gives the adjacency relation (4,8 in 2D; 6,18,26 in 3D) \n"         \
-"for the makers.\n"         \
-"\n"         \
-"The result is a label image. If the original markers are labelled by\n"         \
-"numbers 1,...,n then the regions (catchment basins) of the result will\n"         \
-"be labelled with the same numbers.\n"         \
-"\n"         \
-"If the optional parameter mode is 0 (default value), then the\n"         \
-"separation (watershed) will be labelled with n+1. Otherwise, a\n"         \
-"separating point that is neighbour of exactly two regions i and j will be\n"         \
-"labelled by j*(n+1)+i, with i\n"         \
-"of more than two regions be labelled by n+1.\n"         \
-"Thus, from any label L > n+1, one can recover the labels of the two\n"         \
-"regions i,j in contact by doing: i = L%(n+1); j = L/(n+1).\n"         \
-"\n"         \
-"Types supported: byte 2d, byte 3d\n"         \
-"\n"         \
-"Category: connect\n"         \
-" connect\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__skel2pov__c__ "  skel2pov.c\n"         \
-"\n"         \
-" generation of a 3d illustration from a curvilinear skeleton\n"         \
-"\n"         \
-"Usage: skel2pov in.skel out.pov\n"         \
-"\n"         \
-"Description:\n"         \
-"Generation of a 3d illustration from a curvilinear skeleton.\n"         \
-"\n"         \
-"Types supported: 2Dskel, 3Dskel\n"         \
-"\n"         \
-"Category: topobin\n"         \
-"  topobin\n"         \
-"\n"         \
-" Michel Couprie 2004\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__crestsegment__c__ "  crestsegment.c\n"         \
-"\n"         \
-" measures the height of crests in a thinned grayscale image\n"         \
-"\n"         \
-"Usage: crestsegment skel.pgm connex niter base incr out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Let F be the input image (parameter skel.pgm), and\n"         \
-"let R be the output image (parameter out.pgm).\n"         \
-"\n"         \
-"TO BE WRITTEN\n"         \
-"\n"         \
-"Reference: \n"         \
-"\"Topological operators for the detection of\n"         \
-"curvilinar structures in grayscale images\", in preparation, 2003.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: topogray\n"         \
-"  topogray\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__complex_modulus__c__ "  complex_modulus.c\n"         \
-"\n"         \
-" pixelwise modulus of complex\n"         \
-"\n"         \
-"Usage: complex_modulus in.pgm out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Applies to complex images only.\n"         \
-"For each pixel p, out[p] = modulus(in[p]), where \n"         \
-"modulus(x+iy) = sqrt(x^2 + y^2).\n"         \
-"\n"         \
-"Types supported: complex 2d, complex 3d\n"         \
-"\n"         \
-"Category: arith\n"         \
-"  arith\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"
-
-
-#define doc__asflin__c__ "  asflin.c\n"         \
-"\n"         \
-" alternate sequential filter by linear structuring elements\n"         \
-"\n"         \
-"Usage: asflin in.pgm {x|y|z} [rmin] rmax out.pgm\n"         \
-"\n"         \
-"Description:\n"         \
-"Alternate sequential filter by linear structuring elements for grayscale images.\n"         \
-"Linear structuring elements in direction x, y or z of increasing radius,\n"         \
-"ranging from 1 (or rmin if this parameter is specified) to rmax,\n"         \
-"are generated. Let D1...Dn be these structuring elements, sorted by increasing radius.\n"         \
-"Let I0 = in.pgm, the ith intermediate result Ii is obtained by the closing of\n"         \
-"the opening of Ii-1 by the structuring element Di. \n"         \
-"The result out.pgm contains the final result In.\n"         \
-"Giving a value 0 for the optional parameter rmin has the effect of beginning \n"         \
-"by a closing instead of an opening.\n"         \
-"\n"         \
-"Types supported: byte 2d\n"         \
-"\n"         \
-"Category: morpho\n"         \
-"  morpho\n"         \
-"\n"         \
-" Michel Couprie\n"         \
-"\n"         \
-"\n"         \
-"\n"
-
-
-#endif /* PINK__PYTHON__DOCUMENTER__HPP__ */
-// LuM end of file
diff -r 8b1af7363833 include/ui_graph.hpp~
--- a/include/ui_graph.hpp~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,79 +0,0 @@
-/*
-  This software is licensed under 
-  CeCILL FREE SOFTWARE LICENSE AGREEMENT
-
-  This software comes in hope that it will be useful but 
-  without any warranty to the extent permitted by applicable law.
-  
-  (C) UjoImro, 2012 <ujoimro@gmail.com>
-  ProCarPlan s.r.o.
-*/
-
-// Pink Graph C++ Wrapper
-
-// LuM end of file
-
-#ifndef GRAPH__HPP__
-#define GRAPH__HPP__
-
-#include <string>
-#include <boost/python.hpp>
-#include <boost/smart_ptr.hpp>
-
-#include "mcgraphe.h"
-#include "lskel2graph.h"
-#include "ui_skeleton.hpp"
-
-
-namespace pink {
-
-    template <class T0>
-    class graph_t
-    {
-
-    private:
-        typedef T0 tag;
-        boost::shared_ptr<graphe> m_graph;        
-        
-    public:
-
-        operator graphe* () { return this->m_grapth.get(); }
-        
-        graph_t( graphe * m_graph ) : m_graph( m_graph, ::TermineGraphe ) { }
-
-        graph_t( std::string filename ) {
-            graphe * tmp_graph;
-            tmp_graph = ReadGraphe( filename.c_str() );
-            // assert here
-            m_graph.reset( tmp_graph, ::TermineGraphe );            
-        }
-        
-        graph_t( ) { pink_error("You should not be calling me."); }
-        
-        ~graph_t ( ) { }
-        
-        void writegraph( std::string filename ) {
-            SaveGraphe( m_graph.get(), filename.c_str() );
-        }
-        
-    }; // class graph_t
-
-
-    template <class T0>
-    pink::graph_t<T0>
-    skel2graph( pink::skel_t<T0> & skel, int32_t mode )
-    {
-        graphe * tmp = lskel2graph( skel, mode );
-        assert( tmp != NULL );        
-        pink::graph_t<T0> result(tmp);
-
-        return result;        
-    } // skel2graph
-    
-    
-} /* namespace pink */
-
-
-#endif /* GRAPH__HPP__ */
-
-// LuM end of file
diff -r 8b1af7363833 log
--- a/log	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,3158 +0,0 @@
-------------------------------------------------------------------------
-r768 | marakl | 2012-07-23 22:08:24 +0200 (Mon, 23 Jul 2012) | 1 line
-
-even more python3 tuning
-------------------------------------------------------------------------
-r767 | marakl | 2012-07-23 19:31:26 +0200 (Mon, 23 Jul 2012) | 1 line
-
-even a little more tuning for the python3 build on Windows(tm)
-------------------------------------------------------------------------
-r766 | marakl | 2012-07-23 12:05:53 +0200 (Mon, 23 Jul 2012) | 1 line
-
-python3 harmonization
-------------------------------------------------------------------------
-r765 | marakl | 2012-07-23 10:23:10 +0200 (Mon, 23 Jul 2012) | 1 line
-
-python_documenter adjusted for python3
-------------------------------------------------------------------------
-r764 | coupriem | 2012-07-23 09:16:42 +0200 (Mon, 23 Jul 2012) | 1 line
-
-adding seamcarving.c
-------------------------------------------------------------------------
-r763 | marakl | 2012-07-20 18:01:52 +0200 (Fri, 20 Jul 2012) | 1 line
-
-little variable name adjustment
-------------------------------------------------------------------------
-r762 | marakl | 2012-07-20 17:45:32 +0200 (Fri, 20 Jul 2012) | 1 line
-
-round replaced with pink_round for the Windows(tm) build compatibility
-------------------------------------------------------------------------
-r761 | marakl | 2012-07-20 08:54:14 +0200 (Fri, 20 Jul 2012) | 1 line
-
-python 3.2 adjustments and config files for Windows(tm) CMake added
-------------------------------------------------------------------------
-r760 | marakl | 2012-07-19 15:03:13 +0200 (Thu, 19 Jul 2012) | 1 line
-
-Adjusted the Python wrapper for the new graph function
-------------------------------------------------------------------------
-r759 | coupriem | 2012-07-19 13:58:50 +0200 (Thu, 19 Jul 2012) | 1 line
-
-adding new modes for skel2graph
-------------------------------------------------------------------------
-r758 | marakl | 2012-07-19 13:51:12 +0200 (Thu, 19 Jul 2012) | 1 line
-
-CMakeLists.txt adjusted for the Linux builds.
-------------------------------------------------------------------------
-r757 | marakl | 2012-07-19 11:46:42 +0200 (Thu, 19 Jul 2012) | 36 lines
-
-changeset:   760:c6bb4b039280
-tag:         tip
-user:        ujoimro
-date:        Wed Jul 18 23:10:46 2012 +0200
-summary:     Windows(tm) version ready
-
-changeset:   759:4c08289133be
-user:        ujoimro
-date:        Fri Jul 13 21:49:21 2012 +0200
-summary:     package generation works for Windows(tm) too (using NSIS),
-but the installer still wants to copy all the files to the same program
-files/ directory. It has to be copied to the Python package pack
-
-changeset:   758:2881ea676e79
-user:        ujoimro
-date:        Thu Jul 12 11:55:54 2012 +0200
-summary:     this version compiles on Windows(tm). It includes the
-development, the libtiff, the boost, the lapack libraries. The only
-feature deactivated is the imview socketer. That does not compile
-because it is using mkfifo. I am considering replacing it with some
-boost feature.
-
-changeset:   757:141fc2ce33f0
-user:        ujoimro
-date:        Sat Jul 07 22:40:56 2012 +0200
-summary:     compilation bat file for Windows(tm) added.
-
-changeset:   756:fa88be0fdcaf
-user:        ujoimro
-date:        Sat Jul 07 22:31:56 2012 +0200
-summary:     Windows(tm) harmonization, compiles, but does not build. I
-am fixing the libboost_python libraries. For some reason it wants to
-link with boost_python instead of libboost_python. This must come from
-cmake boost detection.
-
-
-------------------------------------------------------------------------
-r756 | marakl | 2012-06-29 19:51:00 +0200 (Fri, 29 Jun 2012) | 1 line
-
-numpy wrapper unittest. The coordinates are mixed. I filled the bug https://www.pinkhq.com/redmine/issues/42
-------------------------------------------------------------------------
-r755 | marakl | 2012-06-29 17:49:46 +0200 (Fri, 29 Jun 2012) | 1 line
-
-as python-vtk is in debian/ubuntu, I think we can make it a dependency
-------------------------------------------------------------------------
-r754 | marakl | 2012-06-29 16:31:23 +0200 (Fri, 29 Jun 2012) | 1 line
-
-package dependencies adjusted part1
-------------------------------------------------------------------------
-r753 | marakl | 2012-06-27 19:38:38 +0200 (Wed, 27 Jun 2012) | 1 line
-
-a forgotten include
-------------------------------------------------------------------------
-r752 | marakl | 2012-06-27 15:56:35 +0200 (Wed, 27 Jun 2012) | 1 line
-
-compilation adjustments. Pink should now compile with numpy in devel mode
-------------------------------------------------------------------------
-r751 | marakl | 2012-06-27 15:03:34 +0200 (Wed, 27 Jun 2012) | 1 line
-
-cmake changes. Now pink should compile without python and with numpy
-------------------------------------------------------------------------
-r750 | marakl | 2012-06-27 13:02:21 +0200 (Wed, 27 Jun 2012) | 1 line
-
-python numpy conversion alpha
-------------------------------------------------------------------------
-r749 | marakl | 2012-06-25 18:13:59 +0200 (Mon, 25 Jun 2012) | 1 line
-
-configuration and package generation
-------------------------------------------------------------------------
-r748 | talboth | 2012-06-25 12:42:52 +0200 (Mon, 25 Jun 2012) | 1 line
-
-tested
-------------------------------------------------------------------------
-r747 | talboth | 2012-06-25 04:28:25 +0200 (Mon, 25 Jun 2012) | 1 line
-
-experimental
-------------------------------------------------------------------------
-r746 | talboth | 2012-06-22 12:13:04 +0200 (Fri, 22 Jun 2012) | 1 line
-
-trivial changes
-------------------------------------------------------------------------
-r745 | talboth | 2012-06-22 04:38:01 +0200 (Fri, 22 Jun 2012) | 1 line
-
-doc
-------------------------------------------------------------------------
-r744 | talboth | 2012-06-22 04:28:23 +0200 (Fri, 22 Jun 2012) | 1 line
-
-numpy conversion, may even be working
-------------------------------------------------------------------------
-r743 | marakl | 2012-06-18 18:55:48 +0200 (Mon, 18 Jun 2012) | 1 line
-
-fedora 17 tuning
-------------------------------------------------------------------------
-r742 | marakl | 2012-06-18 17:56:56 +0200 (Mon, 18 Jun 2012) | 1 line
-
-fedora 17 tuning
-------------------------------------------------------------------------
-r741 | marakl | 2012-06-18 15:46:54 +0200 (Mon, 18 Jun 2012) | 1 line
-
-fedora core 17 authorization
-------------------------------------------------------------------------
-r740 | marakl | 2012-06-16 10:17:22 +0200 (Sat, 16 Jun 2012) | 1 line
-
-debian4 compatibility
-------------------------------------------------------------------------
-r739 | marakl | 2012-06-15 23:47:11 +0200 (Fri, 15 Jun 2012) | 1 line
-
-cmake modifications for debian4
-------------------------------------------------------------------------
-r738 | marakl | 2012-06-01 13:23:42 +0200 (Fri, 01 Jun 2012) | 1 line
-
-tutorial for Pink graphs added tutorial/python/MC-TP6/solution/mc-tp6-2_python_only.py
-------------------------------------------------------------------------
-r737 | marakl | 2012-05-31 15:46:47 +0200 (Thu, 31 May 2012) | 1 line
-
-unit tests added for skeleton_T
-------------------------------------------------------------------------
-r736 | marakl | 2012-05-28 18:01:39 +0200 (Mon, 28 May 2012) | 1 line
-
-some unittests forgotten
-------------------------------------------------------------------------
-r735 | marakl | 2012-05-28 17:51:06 +0200 (Mon, 28 May 2012) | 1 line
-
-some tests disabled for debian6 compatibility
-------------------------------------------------------------------------
-r734 | marakl | 2012-05-28 17:13:04 +0200 (Mon, 28 May 2012) | 1 line
-
-cmake changes to accomodate unit testing
-------------------------------------------------------------------------
-r733 | marakl | 2012-05-28 15:44:50 +0200 (Mon, 28 May 2012) | 1 line
-
-a file forgotten (src/lib/lskel2graph.c)
-------------------------------------------------------------------------
-r732 | marakl | 2012-05-28 13:54:38 +0200 (Mon, 28 May 2012) | 1 line
-
-This version has the image.copy method replaced with image.clone(), which works according to the clone convention both in c++ and in python. It has graphs running in python. No general conversion yet. Also this version introduces an extensive unit test module. Now with 104 unit tests. The report is generated in junit xml format.
-------------------------------------------------------------------------
-r731 | marakl | 2012-05-27 12:30:09 +0200 (Sun, 27 May 2012) | 1 line
-
-pink skel* class wrapped as python.skeleton_t
-------------------------------------------------------------------------
-r730 | marakl | 2012-05-20 19:07:38 +0200 (Sun, 20 May 2012) | 1 line
-
-package generation tuned
-------------------------------------------------------------------------
-r729 | marakl | 2012-05-20 08:55:30 +0200 (Sun, 20 May 2012) | 1 line
-
-debian package generation fixed. but it only works with revent cmakes
-------------------------------------------------------------------------
-r728 | marakl | 2012-05-14 14:50:57 +0200 (Mon, 14 May 2012) | 1 line
-
-documentation search engine both js and php
-------------------------------------------------------------------------
-r727 | marakl | 2012-05-13 16:02:57 +0200 (Sun, 13 May 2012) | 1 line
-
-documentation corrected
-------------------------------------------------------------------------
-r726 | talboth | 2012-04-24 15:16:23 +0200 (Tue, 24 Apr 2012) | 1 line
-
-added tiff saving capability
-------------------------------------------------------------------------
-r725 | talboth | 2012-03-04 20:33:34 +0100 (Sun, 04 Mar 2012) | 1 line
-
-closebin ok apparently
-------------------------------------------------------------------------
-r724 | talboth | 2012-03-04 18:47:50 +0100 (Sun, 04 Mar 2012) | 1 line
-
-openbun coming along and even tested
-------------------------------------------------------------------------
-r723 | talboth | 2012-03-04 18:47:04 +0100 (Sun, 04 Mar 2012) | 1 line
-
-openbun coming along
-------------------------------------------------------------------------
-r722 | talboth | 2012-03-04 15:51:21 +0100 (Sun, 04 Mar 2012) | 1 line
-
-what now
-------------------------------------------------------------------------
-r721 | talboth | 2012-03-04 15:41:57 +0100 (Sun, 04 Mar 2012) | 1 line
-
-less stupid
-------------------------------------------------------------------------
-r720 | talboth | 2012-03-04 15:40:34 +0100 (Sun, 04 Mar 2012) | 1 line
-
-stupid stupid
-------------------------------------------------------------------------
-r719 | talboth | 2012-03-04 15:24:33 +0100 (Sun, 04 Mar 2012) | 1 line
-
-change of name for consistency
-------------------------------------------------------------------------
-r718 | talboth | 2012-03-04 15:19:43 +0100 (Sun, 04 Mar 2012) | 1 line
-
-generic version of openbun coming along
-------------------------------------------------------------------------
-r717 | talboth | 2012-03-04 09:59:50 +0100 (Sun, 04 Mar 2012) | 1 line
-
-runs on 10.7
-------------------------------------------------------------------------
-r716 | charpeju | 2012-03-03 12:28:19 +0100 (Sat, 03 Mar 2012) | 1 line
-
-warnings
-------------------------------------------------------------------------
-r715 | charpeju | 2012-03-03 12:23:02 +0100 (Sat, 03 Mar 2012) | 1 line
-
-fast open ok
-------------------------------------------------------------------------
-r714 | charpeju | 2012-03-03 11:49:16 +0100 (Sat, 03 Mar 2012) | 1 line
-
-fastclosing
-------------------------------------------------------------------------
-r713 | charpeju | 2012-03-03 10:47:32 +0100 (Sat, 03 Mar 2012) | 1 line
-
-pas besoin
-------------------------------------------------------------------------
-r712 | charpeju | 2012-03-03 10:47:11 +0100 (Sat, 03 Mar 2012) | 1 line
-
-poly erosion
-------------------------------------------------------------------------
-r711 | charpeju | 2012-03-02 23:01:50 +0100 (Fri, 02 Mar 2012) | 1 line
-
-betise en moins
-------------------------------------------------------------------------
-r710 | charpeju | 2012-03-02 23:01:29 +0100 (Fri, 02 Mar 2012) | 1 line
-
-bad idea
-------------------------------------------------------------------------
-r709 | charpeju | 2012-03-02 22:46:17 +0100 (Fri, 02 Mar 2012) | 1 line
-
-missing files
-------------------------------------------------------------------------
-r708 | charpeju | 2012-03-02 19:29:23 +0100 (Fri, 02 Mar 2012) | 1 line
-
-marchotte
-------------------------------------------------------------------------
-r707 | charpeju | 2012-02-27 17:29:50 +0100 (Mon, 27 Feb 2012) | 1 line
-
-fast dilations and erosions, openings and closings
-------------------------------------------------------------------------
-r706 | coupriem | 2012-02-25 02:35:11 +0100 (Sat, 25 Feb 2012) | 1 line
-
-updating lskelpar3d_others.c
-------------------------------------------------------------------------
-r705 | coupriem | 2012-02-22 09:03:28 +0100 (Wed, 22 Feb 2012) | 1 line
-
-updating lskelpar3d_others
-------------------------------------------------------------------------
-r704 | coupriem | 2012-02-17 07:11:16 +0100 (Fri, 17 Feb 2012) | 1 line
-
-update 3D skeletons
-------------------------------------------------------------------------
-r703 | coupriem | 2012-02-06 06:02:06 +0100 (Mon, 06 Feb 2012) | 1 line
-
-updating lskeletons.c
-------------------------------------------------------------------------
-r702 | coupriem | 2012-02-03 06:17:40 +0100 (Fri, 03 Feb 2012) | 1 line
-
-updating src/lib/lskeletons.c
-------------------------------------------------------------------------
-r701 | coupriem | 2012-02-01 11:07:50 +0100 (Wed, 01 Feb 2012) | 1 line
-
-updating src/lib/lskeletons.c scripts/mesh2pgm
-------------------------------------------------------------------------
-r700 | coupriem | 2012-01-31 11:38:47 +0100 (Tue, 31 Jan 2012) | 1 line
-
-updating src/com/pgm2raw.c
-------------------------------------------------------------------------
-r699 | coupriem | 2012-01-30 17:30:32 +0100 (Mon, 30 Jan 2012) | 1 line
-
-adding src/com/skel_CKSC3.c
-------------------------------------------------------------------------
-r698 | coupriem | 2012-01-27 09:05:25 +0100 (Fri, 27 Jan 2012) | 1 line
-
-updating ltangents.cxx curve2segments.cxx lskelpar.c mcskel3d.c
-------------------------------------------------------------------------
-r697 | coupriem | 2012-01-27 08:37:44 +0100 (Fri, 27 Jan 2012) | 1 line
-
-updating lskeletons.c, adding skel_ASK3b.c
-------------------------------------------------------------------------
-r696 | coupriem | 2012-01-27 08:34:46 +0100 (Fri, 27 Jan 2012) | 1 line
-
-updating src/com/skelpar3d_others.cxx src/lib/lskelpar3d_others.c
-------------------------------------------------------------------------
-r695 | coupriem | 2012-01-24 11:37:14 +0100 (Tue, 24 Jan 2012) | 1 line
-
-updating lskeletons.c
-------------------------------------------------------------------------
-r694 | coupriem | 2012-01-13 06:15:32 +0100 (Fri, 13 Jan 2012) | 1 line
-
-updates in src/lib/lskelpar.c src/lib/lskelpar.c
-------------------------------------------------------------------------
-r693 | marakl | 2012-01-12 22:25:49 +0100 (Thu, 12 Jan 2012) | 1 line
-
-corrected a bug of incompatibility with boost 1.48
-------------------------------------------------------------------------
-r692 | talboth | 2012-01-12 20:25:35 +0100 (Thu, 12 Jan 2012) | 1 line
-
-better solution
-------------------------------------------------------------------------
-r691 | talboth | 2012-01-12 20:05:25 +0100 (Thu, 12 Jan 2012) | 1 line
-
-better solution
-------------------------------------------------------------------------
-r690 | talboth | 2012-01-12 20:04:37 +0100 (Thu, 12 Jan 2012) | 1 line
-
-better solution
-------------------------------------------------------------------------
-r689 | talboth | 2012-01-12 20:04:08 +0100 (Thu, 12 Jan 2012) | 1 line
-
-better solution
-------------------------------------------------------------------------
-r688 | talboth | 2012-01-12 20:03:04 +0100 (Thu, 12 Jan 2012) | 1 line
-
-better solution
-------------------------------------------------------------------------
-r687 | talboth | 2012-01-12 20:02:03 +0100 (Thu, 12 Jan 2012) | 1 line
-
-better solution
-------------------------------------------------------------------------
-r686 | talboth | 2012-01-12 19:43:46 +0100 (Thu, 12 Jan 2012) | 1 line
-
-updated solution
-------------------------------------------------------------------------
-r685 | coupriem | 2012-01-09 06:14:34 +0100 (Mon, 09 Jan 2012) | 1 line
-
-updating src/lib/lskelpar3d_others.c
-------------------------------------------------------------------------
-r684 | coupriem | 2012-01-03 20:12:39 +0100 (Tue, 03 Jan 2012) | 1 line
-
-updating lskelpar3d_others.c
-------------------------------------------------------------------------
-r683 | coupriem | 2011-12-22 06:21:56 +0100 (Thu, 22 Dec 2011) | 1 line
-
-adding src/com/hthinpar.c src/com/enframe3d.c
-------------------------------------------------------------------------
-r682 | coupriem | 2011-12-19 15:21:40 +0100 (Mon, 19 Dec 2011) | 1 line
-
-modifications in lskelpar.c
-------------------------------------------------------------------------
-r681 | coupriem | 2011-12-14 11:09:34 +0100 (Wed, 14 Dec 2011) | 1 line
-
-adding src/com/skel_ACK3b.c
-------------------------------------------------------------------------
-r680 | talboth | 2011-12-12 14:17:52 +0100 (Mon, 12 Dec 2011) | 1 line
-
-plein de fonctions rapides
-------------------------------------------------------------------------
-r679 | coupriem | 2011-12-04 10:18:08 +0100 (Sun, 04 Dec 2011) | 1 line
-
-fix bug in leden.cxx (suite)
-------------------------------------------------------------------------
-r678 | coupriem | 2011-12-04 10:11:41 +0100 (Sun, 04 Dec 2011) | 1 line
-
-fix bug in leden.cxx
-------------------------------------------------------------------------
-r677 | coupriem | 2011-12-03 16:48:49 +0100 (Sat, 03 Dec 2011) | 1 line
-
-fixing bug in skelend for 2D
-------------------------------------------------------------------------
-r676 | talboth | 2011-12-02 11:17:10 +0100 (Fri, 02 Dec 2011) | 1 line
-
-Thanks to Estelle
-------------------------------------------------------------------------
-r675 | coupriem | 2011-11-30 13:24:49 +0100 (Wed, 30 Nov 2011) | 1 line
-
-updating src/lib/lskeletons.c
-------------------------------------------------------------------------
-r674 | coupriem | 2011-11-03 08:20:28 +0100 (Thu, 03 Nov 2011) | 1 line
-
-fix bug in mcskel3d
-------------------------------------------------------------------------
-r673 | coupriem | 2011-11-03 06:21:58 +0100 (Thu, 03 Nov 2011) | 1 line
-
-correction li64.make
-------------------------------------------------------------------------
-r672 | marakl | 2011-11-01 18:13:20 +0100 (Tue, 01 Nov 2011) | 1 line
-
-now it compiles again, but must be taken with caution
-------------------------------------------------------------------------
-r671 | coupriem | 2011-10-28 17:01:49 +0200 (Fri, 28 Oct 2011) | 1 line
-
-adding 3dskelck.c mcskel3d mcskel2d mcskel2d3d
-------------------------------------------------------------------------
-r670 | coupriem | 2011-10-26 07:19:51 +0200 (Wed, 26 Oct 2011) | 1 line
-
-adding lambdamedialaxis*auto*
-------------------------------------------------------------------------
-r669 | coupriem | 2011-10-15 20:27:53 +0200 (Sat, 15 Oct 2011) | 1 line
-
-restoring disque9.pgm
-------------------------------------------------------------------------
-r668 | coupriem | 2011-10-15 20:27:04 +0200 (Sat, 15 Oct 2011) | 1 line
-
-deleting disque9.pgm
-------------------------------------------------------------------------
-r667 | coupriem | 2011-10-15 20:20:05 +0200 (Sat, 15 Oct 2011) | 1 line
-
-restoring disque9.pgm
-------------------------------------------------------------------------
-r666 | coupriem | 2011-10-14 14:58:14 +0200 (Fri, 14 Oct 2011) | 1 line
-
-changes in lambdamedialaxis2*
-------------------------------------------------------------------------
-r665 | marakl | 2011-10-12 17:16:13 +0200 (Wed, 12 Oct 2011) | 1 line
-
-doc__powerwshedval__c__ not yet created (or added), so the documentation does not exist
-------------------------------------------------------------------------
-r664 | marakl | 2011-10-12 17:06:12 +0200 (Wed, 12 Oct 2011) | 1 line
-
-some changes regarding maxflows
-------------------------------------------------------------------------
-r663 | coupriem | 2011-10-12 10:40:09 +0200 (Wed, 12 Oct 2011) | 1 line
-
-modifications in lseltopo and fix bug in lskeletons
-------------------------------------------------------------------------
-r662 | coupriem | 2011-10-11 16:03:50 +0200 (Tue, 11 Oct 2011) | 1 line
-
-adding src/com/skeletonlab.c
-------------------------------------------------------------------------
-r661 | talboth | 2011-10-11 02:00:52 +0200 (Tue, 11 Oct 2011) | 1 line
-
-launches, but crashes
-------------------------------------------------------------------------
-r660 | talboth | 2011-10-08 03:26:14 +0200 (Sat, 08 Oct 2011) | 1 line
-
-powerwatershed compiles
-------------------------------------------------------------------------
-r659 | talboth | 2011-10-08 02:03:11 +0200 (Sat, 08 Oct 2011) | 1 line
-
-should compile OK
-------------------------------------------------------------------------
-r658 | talboth | 2011-10-07 01:42:22 +0200 (Fri, 07 Oct 2011) | 1 line
-
-Camille's power watershed coming in, not tested yet
-------------------------------------------------------------------------
-r657 | marakl | 2011-10-05 14:04:06 +0200 (Wed, 05 Oct 2011) | 1 line
-
-error message
-------------------------------------------------------------------------
-r656 | talboth | 2011-10-05 03:44:19 +0200 (Wed, 05 Oct 2011) | 1 line
-
-does not compile
-------------------------------------------------------------------------
-r655 | coupriem | 2011-09-30 08:32:33 +0200 (Fri, 30 Sep 2011) | 1 line
-
-adding src/com/relabel.c src/com/skelendlab.c and small updates
-------------------------------------------------------------------------
-r654 | marakl | 2011-09-29 13:38:25 +0200 (Thu, 29 Sep 2011) | 1 line
-
-flow opencl 2d and 3d
-------------------------------------------------------------------------
-r653 | marakl | 2011-09-26 17:13:16 +0200 (Mon, 26 Sep 2011) | 1 line
-
-some files are no longer needed. sqlite is being corrected
-------------------------------------------------------------------------
-r652 | marakl | 2011-09-26 17:05:24 +0200 (Mon, 26 Sep 2011) | 1 line
-
-some files are no longer needed
-------------------------------------------------------------------------
-r651 | marakl | 2011-09-26 17:04:36 +0200 (Mon, 26 Sep 2011) | 1 line
-
-new files
-------------------------------------------------------------------------
-r650 | marakl | 2011-09-26 17:03:27 +0200 (Mon, 26 Sep 2011) | 1 line
-
-rewrite and reorganization of some header files and tests
-------------------------------------------------------------------------
-r649 | marakl | 2011-09-22 12:45:55 +0200 (Thu, 22 Sep 2011) | 1 line
-
-numa allocator corrected for memtests. It's also cross platformish
-------------------------------------------------------------------------
-r648 | marakl | 2011-09-14 20:32:27 +0200 (Wed, 14 Sep 2011) | 1 line
-
-numa array tuned
-------------------------------------------------------------------------
-r647 | marakl | 2011-09-14 17:07:32 +0200 (Wed, 14 Sep 2011) | 1 line
-
-type rearrangement
-------------------------------------------------------------------------
-r646 | marakl | 2011-09-13 20:11:23 +0200 (Tue, 13 Sep 2011) | 1 line
-
-barispeed function
-------------------------------------------------------------------------
-r645 | marakl | 2011-09-13 16:09:33 +0200 (Tue, 13 Sep 2011) | 1 line
-
-glinemm tune
-------------------------------------------------------------------------
-r644 | marakl | 2011-09-13 16:05:18 +0200 (Tue, 13 Sep 2011) | 1 line
-
-findline tune
-------------------------------------------------------------------------
-r643 | marakl | 2011-09-13 16:01:55 +0200 (Tue, 13 Sep 2011) | 1 line
-
-findline tune
-------------------------------------------------------------------------
-r642 | marakl | 2011-09-13 15:58:15 +0200 (Tue, 13 Sep 2011) | 1 line
-
-flow windows tune
-------------------------------------------------------------------------
-r641 | marakl | 2011-09-13 15:55:08 +0200 (Tue, 13 Sep 2011) | 1 line
-
-flow windows tune
-------------------------------------------------------------------------
-r640 | marakl | 2011-09-13 15:52:30 +0200 (Tue, 13 Sep 2011) | 1 line
-
-flow windows tune
-------------------------------------------------------------------------
-r639 | marakl | 2011-09-13 15:45:52 +0200 (Tue, 13 Sep 2011) | 1 line
-
-ungerflow tune
-------------------------------------------------------------------------
-r638 | marakl | 2011-09-13 15:41:26 +0200 (Tue, 13 Sep 2011) | 1 line
-
-now function changed to cross-platform
-------------------------------------------------------------------------
-r637 | marakl | 2011-09-13 15:39:59 +0200 (Tue, 13 Sep 2011) | 1 line
-
-now function changed to cross-platform
-------------------------------------------------------------------------
-r636 | marakl | 2011-09-13 15:37:24 +0200 (Tue, 13 Sep 2011) | 1 line
-
-now function changed to cross-platform
-------------------------------------------------------------------------
-r635 | marakl | 2011-09-12 21:26:13 +0200 (Mon, 12 Sep 2011) | 1 line
-
-windows corrections
-------------------------------------------------------------------------
-r634 | marakl | 2011-09-12 20:42:32 +0200 (Mon, 12 Sep 2011) | 1 line
-
-building errors on 32-bit systems
-------------------------------------------------------------------------
-r633 | marakl | 2011-09-12 20:22:36 +0200 (Mon, 12 Sep 2011) | 1 line
-
-crop function added UI_WRAP_MALLOC added along with some other functions
-------------------------------------------------------------------------
-r632 | talboth | 2011-09-09 16:01:10 +0200 (Fri, 09 Sep 2011) | 1 line
-
-Render Picker
-------------------------------------------------------------------------
-r631 | talboth | 2011-09-08 19:46:35 +0200 (Thu, 08 Sep 2011) | 1 line
-
-bugs
-------------------------------------------------------------------------
-r630 | talboth | 2011-09-08 17:46:21 +0200 (Thu, 08 Sep 2011) | 1 line
-
-sorry, not a good solution
-------------------------------------------------------------------------
-r629 | coupriem | 2011-09-07 16:53:53 +0200 (Wed, 07 Sep 2011) | 1 line
-
-correcting masks/carre5.pgm
-------------------------------------------------------------------------
-r628 | najmanl | 2011-09-07 16:08:55 +0200 (Wed, 07 Sep 2011) | 1 line
-
-straight line size 3x3
-------------------------------------------------------------------------
-r627 | najmanl | 2011-09-07 15:55:17 +0200 (Wed, 07 Sep 2011) | 1 line
-
-straight line size 3x3
-------------------------------------------------------------------------
-r626 | marakl | 2011-09-05 15:31:51 +0200 (Mon, 05 Sep 2011) | 1 line
-
-no numa is mandatory in this revision
-------------------------------------------------------------------------
-r625 | marakl | 2011-09-05 15:02:15 +0200 (Mon, 05 Sep 2011) | 1 line
-
-numa.h should not be a default dependency
-------------------------------------------------------------------------
-r624 | marakl | 2011-08-30 13:37:38 +0200 (Tue, 30 Aug 2011) | 1 line
-
-fmm wrapped in python and amira export extended to 3D int32 images
-------------------------------------------------------------------------
-r623 | marakl | 2011-08-29 13:24:33 +0200 (Mon, 29 Aug 2011) | 1 line
-
-some last minor changes in the poster 
-------------------------------------------------------------------------
-r622 | marakl | 2011-08-29 13:03:01 +0200 (Mon, 29 Aug 2011) | 1 line
-
-poster tuned
-------------------------------------------------------------------------
-r621 | marakl | 2011-08-29 12:35:19 +0200 (Mon, 29 Aug 2011) | 1 line
-
-pdf poster added
-------------------------------------------------------------------------
-r620 | marakl | 2011-08-29 12:31:41 +0200 (Mon, 29 Aug 2011) | 1 line
-
-EuroSciPy 2011 poster added to the documentation
-------------------------------------------------------------------------
-r619 | coupriem | 2011-08-26 06:07:50 +0200 (Fri, 26 Aug 2011) | 1 line
-
-adding src/com/skelsmoothing.c
-------------------------------------------------------------------------
-r618 | coupriem | 2011-08-25 20:31:34 +0200 (Thu, 25 Aug 2011) | 1 line
-
-minor adds
-------------------------------------------------------------------------
-r617 | marakl | 2011-08-11 22:34:24 +0200 (Thu, 11 Aug 2011) | 1 line
-
-memtest
-------------------------------------------------------------------------
-r616 | marakl | 2011-08-10 15:26:24 +0200 (Wed, 10 Aug 2011) | 1 line
-
-specializing the opencl inclusion
-------------------------------------------------------------------------
-r615 | marakl | 2011-08-06 23:28:01 +0200 (Sat, 06 Aug 2011) | 1 line
-
-memtest polish
-------------------------------------------------------------------------
-r614 | marakl | 2011-08-06 23:19:40 +0200 (Sat, 06 Aug 2011) | 1 line
-
-memtest polish
-------------------------------------------------------------------------
-r613 | marakl | 2011-08-06 23:08:45 +0200 (Sat, 06 Aug 2011) | 1 line
-
-memtest polish
-------------------------------------------------------------------------
-r612 | marakl | 2011-08-06 22:52:25 +0200 (Sat, 06 Aug 2011) | 1 line
-
-memtest polish
-------------------------------------------------------------------------
-r611 | marakl | 2011-08-06 22:51:25 +0200 (Sat, 06 Aug 2011) | 1 line
-
-memtest polish
-------------------------------------------------------------------------
-r610 | marakl | 2011-08-06 22:25:18 +0200 (Sat, 06 Aug 2011) | 1 line
-
-memtest polish
-------------------------------------------------------------------------
-r609 | marakl | 2011-08-06 21:57:52 +0200 (Sat, 06 Aug 2011) | 1 line
-
-memtest polish
-------------------------------------------------------------------------
-r608 | marakl | 2011-08-06 21:05:14 +0200 (Sat, 06 Aug 2011) | 1 line
-
-numa memory speedtest
-------------------------------------------------------------------------
-r607 | marakl | 2011-08-05 01:26:06 +0200 (Fri, 05 Aug 2011) | 1 line
-
-some leeks filled up
-------------------------------------------------------------------------
-r606 | marakl | 2011-08-04 18:38:41 +0200 (Thu, 04 Aug 2011) | 1 line
-
-in this version simd flow knows hyper-threading
-------------------------------------------------------------------------
-r605 | marakl | 2011-08-04 16:05:08 +0200 (Thu, 04 Aug 2011) | 1 line
-
-numa option created and flow functions either moved under standard functions or under the numa options; also opencl no longer depend on the development option
-------------------------------------------------------------------------
-r604 | coupriem | 2011-08-04 10:27:05 +0200 (Thu, 04 Aug 2011) | 1 line
-
-several updates
-------------------------------------------------------------------------
-r603 | marakl | 2011-08-03 21:38:46 +0200 (Wed, 03 Aug 2011) | 1 line
-
-minor updates
-------------------------------------------------------------------------
-r602 | marakl | 2011-08-03 21:19:04 +0200 (Wed, 03 Aug 2011) | 1 line
-
-queueless simd version now runs considerably fast
-------------------------------------------------------------------------
-r601 | marakl | 2011-08-03 19:34:29 +0200 (Wed, 03 Aug 2011) | 1 line
-
-maxflows in the source code. I envisage mooving them to the std repo and there is one more idea in my head
-------------------------------------------------------------------------
-r600 | marakl | 2011-08-02 20:37:48 +0200 (Tue, 02 Aug 2011) | 1 line
-
-distributed flow polishing
-------------------------------------------------------------------------
-r599 | marakl | 2011-08-02 19:19:47 +0200 (Tue, 02 Aug 2011) | 1 line
-
-ui_flow distributed cleaned up
-------------------------------------------------------------------------
-r598 | marakl | 2011-08-02 17:43:54 +0200 (Tue, 02 Aug 2011) | 1 line
-
-there was a typo in the license header
-------------------------------------------------------------------------
-r597 | marakl | 2011-08-02 16:59:58 +0200 (Tue, 02 Aug 2011) | 1 line
-
-maxflow opencl polished
-------------------------------------------------------------------------
-r596 | marakl | 2011-07-30 00:19:24 +0200 (Sat, 30 Jul 2011) | 1 line
-
-liberator introduced. The images are now appropriately liberated by delete of free. The garbage collection has also been improved. Also readimage now contains no data copy, the xvimage is embedded in ujimage. Reading bands of images is still an open question
-------------------------------------------------------------------------
-r595 | coupriem | 2011-07-27 11:27:26 +0200 (Wed, 27 Jul 2011) | 1 line
-
-updating src/lib/lskelcurv.c
-------------------------------------------------------------------------
-r594 | sanselmp | 2011-07-25 16:42:23 +0200 (Mon, 25 Jul 2011) | 1 line
-
-modif project_contact.c
-------------------------------------------------------------------------
-r593 | coupriem | 2011-07-25 14:28:54 +0200 (Mon, 25 Jul 2011) | 1 line
-
-fix another bug in mcsplines
-------------------------------------------------------------------------
-r592 | coupriem | 2011-07-25 13:30:10 +0200 (Mon, 25 Jul 2011) | 1 line
-
-fix bug in mcsplines
-------------------------------------------------------------------------
-r591 | sanselmp | 2011-07-22 16:10:30 +0200 (Fri, 22 Jul 2011) | 1 line
-
-ajout project_contact.c
-------------------------------------------------------------------------
-r590 | miraucoo | 2011-07-20 18:20:50 +0200 (Wed, 20 Jul 2011) | 1 line
-
-oueeh ma premiere fonction en python
-------------------------------------------------------------------------
-r589 | coupriem | 2011-07-20 15:15:19 +0200 (Wed, 20 Jul 2011) | 1 line
-
-modif lskelcurv.c
-------------------------------------------------------------------------
-r588 | charpeju | 2011-07-20 15:01:35 +0200 (Wed, 20 Jul 2011) | 1 line
-
-mise a jour de findline
-------------------------------------------------------------------------
-r587 | talboth | 2011-07-20 12:02:17 +0200 (Wed, 20 Jul 2011) | 1 line
-
-fixed pb with counting number of CPU
-------------------------------------------------------------------------
-r586 | coupriem | 2011-07-20 06:21:10 +0200 (Wed, 20 Jul 2011) | 1 line
-
-lskelcurv et ltangents
-------------------------------------------------------------------------
-r585 | marakl | 2011-07-19 14:12:03 +0200 (Tue, 19 Jul 2011) | 1 line
-
-hardware concurrency not found in macosx snow leopard
-------------------------------------------------------------------------
-r584 | coupriem | 2011-07-19 06:12:25 +0200 (Tue, 19 Jul 2011) | 1 line
-
-adding tcl/labelrender
-------------------------------------------------------------------------
-r583 | charpeju | 2011-07-18 16:14:13 +0200 (Mon, 18 Jul 2011) | 1 line
-
-ptet bien quoui
-------------------------------------------------------------------------
-r582 | charpeju | 2011-07-18 16:13:59 +0200 (Mon, 18 Jul 2011) | 1 line
-
-ptet bien quoui
-------------------------------------------------------------------------
-r581 | charpeju | 2011-07-18 16:12:47 +0200 (Mon, 18 Jul 2011) | 1 line
-
-tres radical
-------------------------------------------------------------------------
-r580 | charpeju | 2011-07-18 16:11:56 +0200 (Mon, 18 Jul 2011) | 1 line
-
-radical
-------------------------------------------------------------------------
-r579 | coupriem | 2011-07-16 09:15:26 +0200 (Sat, 16 Jul 2011) | 1 line
-
-adding src/com/curve2segments.cxx
-------------------------------------------------------------------------
-r578 | marakl | 2011-07-15 15:26:37 +0200 (Fri, 15 Jul 2011) | 1 line
-
-polishing jamroot
-------------------------------------------------------------------------
-r577 | marakl | 2011-07-15 15:06:04 +0200 (Fri, 15 Jul 2011) | 1 line
-
-jamroot tuning
-------------------------------------------------------------------------
-r576 | marakl | 2011-07-15 13:55:20 +0200 (Fri, 15 Jul 2011) | 1 line
-
-Jamroot still kicked a little more
-------------------------------------------------------------------------
-r575 | marakl | 2011-07-15 13:35:30 +0200 (Fri, 15 Jul 2011) | 1 line
-
-This Jamroot file is the one which builds.
-------------------------------------------------------------------------
-r574 | coupriem | 2011-07-15 07:28:49 +0200 (Fri, 15 Jul 2011) | 1 line
-
-splines and curves
-------------------------------------------------------------------------
-r573 | marakl | 2011-07-13 18:57:40 +0200 (Wed, 13 Jul 2011) | 1 line
-
-maxflow opencl function has become optional
-------------------------------------------------------------------------
-r572 | coupriem | 2011-07-13 16:02:09 +0200 (Wed, 13 Jul 2011) | 1 line
-
-modifs splines
-------------------------------------------------------------------------
-r571 | coupriem | 2011-07-10 07:21:49 +0200 (Sun, 10 Jul 2011) | 1 line
-
-fix bug in lskelcurv.c
-------------------------------------------------------------------------
-r570 | coupriem | 2011-07-08 16:04:49 +0200 (Fri, 08 Jul 2011) | 1 line
-
-changes in lskelcurv.c
-------------------------------------------------------------------------
-r569 | coupriem | 2011-07-08 06:00:47 +0200 (Fri, 08 Jul 2011) | 1 line
-
-changes in mcplines.c
-------------------------------------------------------------------------
-r568 | marakl | 2011-07-06 18:48:52 +0200 (Wed, 06 Jul 2011) | 1 line
-
-windows tune
-------------------------------------------------------------------------
-r567 | marakl | 2011-07-06 18:40:18 +0200 (Wed, 06 Jul 2011) | 1 line
-
-windows installer tune
-------------------------------------------------------------------------
-r566 | marakl | 2011-07-06 17:01:13 +0200 (Wed, 06 Jul 2011) | 1 line
-
-minor changes to mfc opencl and wrapped a skeleton function
-------------------------------------------------------------------------
-r565 | coupriem | 2011-07-06 07:59:53 +0200 (Wed, 06 Jul 2011) | 1 line
-
-cor. lskelcurv.c
-------------------------------------------------------------------------
-r564 | coupriem | 2011-07-06 06:25:27 +0200 (Wed, 06 Jul 2011) | 1 line
-
-lskelcurv and mcsplines
-------------------------------------------------------------------------
-r563 | coupriem | 2011-07-05 10:43:12 +0200 (Tue, 05 Jul 2011) | 1 line
-
-more tests (splines, etc)
-------------------------------------------------------------------------
-r562 | marakl | 2011-07-01 11:09:39 +0200 (Fri, 01 Jul 2011) | 1 line
-
-thin wrong name + screenshot 
-------------------------------------------------------------------------
-r561 | coustyj | 2011-06-30 17:25:02 +0200 (Thu, 30 Jun 2011) | 1 line
-
-JC : quelques fonctions supplementaires sur les GA sont documentees
-------------------------------------------------------------------------
-r560 | coustyj | 2011-06-30 17:02:51 +0200 (Thu, 30 Jun 2011) | 1 line
-
-JC : quelques fonctions supplementaires sur les GA sont documentees
-------------------------------------------------------------------------
-r559 | marakl | 2011-06-30 15:54:45 +0200 (Thu, 30 Jun 2011) | 1 line
-
-screenshots, they should be put to the doxygen on a separate page
-------------------------------------------------------------------------
-r558 | marakl | 2011-06-30 02:44:02 +0200 (Thu, 30 Jun 2011) | 1 line
-
-download page adjusted
-------------------------------------------------------------------------
-r557 | marakl | 2011-06-30 02:19:18 +0200 (Thu, 30 Jun 2011) | 1 line
-
-first functional python installer
-------------------------------------------------------------------------
-r556 | marakl | 2011-06-30 01:55:46 +0200 (Thu, 30 Jun 2011) | 1 line
-
-setup.py for creating a windows installer. Visual Studio runtime redistributable package also needed
-------------------------------------------------------------------------
-r555 | sanselmp | 2011-06-29 17:33:12 +0200 (Wed, 29 Jun 2011) | 1 line
-
-correction lskelcurve.c et ltangents.cxx
-------------------------------------------------------------------------
-r554 | marakl | 2011-06-29 17:05:12 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r553 | marakl | 2011-06-29 17:01:47 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r552 | coupriem | 2011-06-29 16:45:43 +0200 (Wed, 29 Jun 2011) | 1 line
-
-cor. bug mcimage.c (writergbascimage)
-------------------------------------------------------------------------
-r551 | marakl | 2011-06-29 16:24:06 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r550 | marakl | 2011-06-29 16:20:40 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r549 | marakl | 2011-06-29 16:13:28 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r548 | marakl | 2011-06-29 16:09:15 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r547 | marakl | 2011-06-29 16:08:22 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r546 | marakl | 2011-06-29 16:06:29 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r545 | marakl | 2011-06-29 16:04:52 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r544 | marakl | 2011-06-29 16:04:19 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r543 | marakl | 2011-06-29 15:57:24 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r542 | marakl | 2011-06-29 15:55:11 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r541 | marakl | 2011-06-29 15:53:27 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r540 | marakl | 2011-06-29 15:47:45 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r539 | marakl | 2011-06-29 15:42:44 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r538 | marakl | 2011-06-29 14:22:55 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r537 | marakl | 2011-06-29 14:11:17 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r536 | marakl | 2011-06-29 14:08:18 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r535 | marakl | 2011-06-29 14:04:34 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r534 | marakl | 2011-06-29 14:00:51 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r533 | marakl | 2011-06-29 13:39:53 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r532 | marakl | 2011-06-29 13:33:00 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r531 | marakl | 2011-06-29 13:31:34 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r530 | marakl | 2011-06-29 13:30:01 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r529 | marakl | 2011-06-29 13:24:08 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r528 | marakl | 2011-06-29 13:18:09 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r527 | marakl | 2011-06-29 12:56:08 +0200 (Wed, 29 Jun 2011) | 1 line
-
-towards conforming with msvc
-------------------------------------------------------------------------
-r526 | sanselmp | 2011-06-28 14:31:57 +0200 (Tue, 28 Jun 2011) | 1 line
-
-modifs lskelfilter5
-------------------------------------------------------------------------
-r525 | charpeju | 2011-06-27 15:29:58 +0200 (Mon, 27 Jun 2011) | 1 line
-
-ajout des fonction liar
-------------------------------------------------------------------------
-r524 | coupriem | 2011-06-27 09:20:47 +0200 (Mon, 27 Jun 2011) | 1 line
-
-fixing scripts/closeballlab
-------------------------------------------------------------------------
-r523 | coupriem | 2011-06-27 06:16:08 +0200 (Mon, 27 Jun 2011) | 1 line
-
-adding scripts/closeballlab
-------------------------------------------------------------------------
-r522 | coupriem | 2011-06-26 08:03:06 +0200 (Sun, 26 Jun 2011) | 1 line
-
-adding private directory for non-released things
-------------------------------------------------------------------------
-r521 | miraucoo | 2011-06-24 16:43:40 +0200 (Fri, 24 Jun 2011) | 1 line
-
-truc super
-------------------------------------------------------------------------
-r520 | sanselmp | 2011-06-24 09:52:13 +0200 (Fri, 24 Jun 2011) | 1 line
-
-modif lskelfilter.c
-------------------------------------------------------------------------
-r519 | marakl | 2011-06-23 00:27:33 +0200 (Thu, 23 Jun 2011) | 1 line
-
-minor bug corrected concerning the conversion of image types
-------------------------------------------------------------------------
-r518 | sanselmp | 2011-06-22 14:47:54 +0200 (Wed, 22 Jun 2011) | 1 line
-
-modif lskelfilter
-------------------------------------------------------------------------
-r517 | coupriem | 2011-06-22 14:30:17 +0200 (Wed, 22 Jun 2011) | 1 line
-
-changes in lskelcurv.c and others...
-------------------------------------------------------------------------
-r516 | marakl | 2011-06-22 10:34:20 +0200 (Wed, 22 Jun 2011) | 1 line
-
-a minor bug of compilation.
-------------------------------------------------------------------------
-r515 | marakl | 2011-06-21 14:46:09 +0200 (Tue, 21 Jun 2011) | 1 line
-
-maxflow opencl implementation. It saturates my GPU 90%
-------------------------------------------------------------------------
-r514 | marakl | 2011-06-21 14:45:54 +0200 (Tue, 21 Jun 2011) | 1 line
-
-maxflow opencl implementation. It saturates my GPU 90%
-------------------------------------------------------------------------
-r513 | marakl | 2011-06-21 14:02:54 +0200 (Tue, 21 Jun 2011) | 1 line
-
-pydevel.cpp corrected to compile in normal mode without numa
-------------------------------------------------------------------------
-r512 | coupriem | 2011-06-19 20:17:26 +0200 (Sun, 19 Jun 2011) | 1 line
-
-minor updates in comments
-------------------------------------------------------------------------
-r511 | marakl | 2011-06-17 15:03:06 +0200 (Fri, 17 Jun 2011) | 1 line
-
-minimal changes on distributed flow
-------------------------------------------------------------------------
-r510 | marakl | 2011-06-17 14:55:13 +0200 (Fri, 17 Jun 2011) | 1 line
-
-pydevel reverted
-------------------------------------------------------------------------
-r509 | marakl | 2011-06-17 14:08:50 +0200 (Fri, 17 Jun 2011) | 1 line
-
-maxflow distributed works and scales better then traditional maxflow
-------------------------------------------------------------------------
-r508 | sanselmp | 2011-06-17 11:38:17 +0200 (Fri, 17 Jun 2011) | 1 line
-
-ajout mctopo3d_toplab
-------------------------------------------------------------------------
-r507 | charpeju | 2011-06-16 15:04:17 +0200 (Thu, 16 Jun 2011) | 1 line
-
-ajout des fonction liar dans python
-------------------------------------------------------------------------
-r506 | marakl | 2011-06-16 01:15:26 +0200 (Thu, 16 Jun 2011) | 1 line
-
-development compiles, distributed flow and maxflow added and tested on 2d images
-------------------------------------------------------------------------
-r505 | sanselmp | 2011-06-15 14:58:34 +0200 (Wed, 15 Jun 2011) | 1 line
-
-ajouts: table du triangle de pascal, methode de calcul de tangentes discretes, application a la squelettisation
-------------------------------------------------------------------------
-r504 | charpeju | 2011-06-14 13:28:37 +0200 (Tue, 14 Jun 2011) | 1 line
-
-ajout fonctions fseries
-------------------------------------------------------------------------
-r503 | charpeju | 2011-06-14 13:12:26 +0200 (Tue, 14 Jun 2011) | 1 line
-
-ajout fonctions fseries
-------------------------------------------------------------------------
-r502 | charpeju | 2011-06-14 11:40:50 +0200 (Tue, 14 Jun 2011) | 1 line
-
-ajout fonctions fseries
-------------------------------------------------------------------------
-r501 | marakl | 2011-06-09 23:52:33 +0200 (Thu, 09 Jun 2011) | 1 line
-
-one more file missing src/com/long2short.cpp
-------------------------------------------------------------------------
-r500 | marakl | 2011-06-09 23:39:32 +0200 (Thu, 09 Jun 2011) | 1 line
-
-fits converter corriged for the case when there is no fits library
-------------------------------------------------------------------------
-r499 | marakl | 2011-06-09 23:28:05 +0200 (Thu, 09 Jun 2011) | 1 line
-
-the following files have been created during the configuration and are not needed CMakeFiles/cmake.check_cache  CMakeFiles CMakeCache.txt
-------------------------------------------------------------------------
-r498 | marakl | 2011-06-09 23:26:20 +0200 (Thu, 09 Jun 2011) | 1 line
-
-I forgot to add some files
-------------------------------------------------------------------------
-r497 | charpeju | 2011-06-09 17:28:17 +0200 (Thu, 09 Jun 2011) | 1 line
-
-ajout fonctions fseries
-------------------------------------------------------------------------
-r496 | charpeju | 2011-06-09 12:33:19 +0200 (Thu, 09 Jun 2011) | 1 line
-
-code de Juju ter
-------------------------------------------------------------------------
-r495 | charpeju | 2011-06-09 12:32:44 +0200 (Thu, 09 Jun 2011) | 1 line
-
-test image not needed here
-------------------------------------------------------------------------
-r494 | charpeju | 2011-06-09 12:32:24 +0200 (Thu, 09 Jun 2011) | 1 line
-
-code de Juju suite
-------------------------------------------------------------------------
-r493 | charpeju | 2011-06-09 12:30:33 +0200 (Thu, 09 Jun 2011) | 1 line
-
-code de Juju
-------------------------------------------------------------------------
-r492 | charpeju | 2011-06-09 12:29:07 +0200 (Thu, 09 Jun 2011) | 1 line
-
-new templated fseries code
-------------------------------------------------------------------------
-r491 | charpeju | 2011-06-09 10:59:13 +0200 (Thu, 09 Jun 2011) | 1 line
-
-tout en c++
-------------------------------------------------------------------------
-r490 | charpeju | 2011-06-09 10:53:46 +0200 (Thu, 09 Jun 2011) | 1 line
-
-on convertit tout en c++, on a pas fini
-------------------------------------------------------------------------
-r489 | charpeju | 2011-06-09 10:50:18 +0200 (Thu, 09 Jun 2011) | 1 line
-
-on a pas peur
-------------------------------------------------------------------------
-r488 | charpeju | 2011-06-09 10:29:48 +0200 (Thu, 09 Jun 2011) | 1 line
-
-oula
-------------------------------------------------------------------------
-r487 | coustyj | 2011-06-06 17:58:28 +0200 (Mon, 06 Jun 2011) | 1 line
-
-JC quelques documentations supplementaires sur les GA
-------------------------------------------------------------------------
-r486 | charpeju | 2011-06-06 14:45:22 +0200 (Mon, 06 Jun 2011) | 1 line
-
-add of the liar fonction
-------------------------------------------------------------------------
-r485 | marakl | 2011-06-05 01:15:36 +0200 (Sun, 05 Jun 2011) | 1 line
-
-in this commit I have made several changes and reorganization: firstly, the python front end is broken up into five parts. each of the parts can be compiled independently, so the parallel compilation should speed up. I have also replaced pink.h with minimum necessary header files, so during the development, only the part, which gets a direct hit will be recompiled. secondly I have completed the conversion functions, which should now be able to convert from and to short images
-------------------------------------------------------------------------
-r484 | talboth | 2011-06-03 15:08:41 +0200 (Fri, 03 Jun 2011) | 1 line
-
-fseries
-------------------------------------------------------------------------
-r483 | talboth | 2011-06-02 15:20:02 +0200 (Thu, 02 Jun 2011) | 1 line
-
-anyawy
-------------------------------------------------------------------------
-r482 | charpeju | 2011-06-01 15:23:41 +0200 (Wed, 01 Jun 2011) | 1 line
-
-ajout de certaines fonctions de liar
-------------------------------------------------------------------------
-r481 | coupriem | 2011-05-30 14:39:53 +0200 (Mon, 30 May 2011) | 1 line
-
-modification in attribute.c
-------------------------------------------------------------------------
-r480 | marakl | 2011-05-28 09:18:58 +0200 (Sat, 28 May 2011) | 1 line
-
-mailing list and bugtracker
-------------------------------------------------------------------------
-r479 | coupriem | 2011-05-27 16:03:33 +0200 (Fri, 27 May 2011) | 1 line
-
-fixed small bug in allocimage()
-------------------------------------------------------------------------
-r478 | marakl | 2011-05-26 18:42:43 +0200 (Thu, 26 May 2011) | 1 line
-
-some minor trouble with pygradmorph
-------------------------------------------------------------------------
-r477 | marakl | 2011-05-26 18:16:45 +0200 (Thu, 26 May 2011) | 1 line
-
-dilation, erosion, opening and closing now also accepts int images
-------------------------------------------------------------------------
-r476 | marakl | 2011-05-26 16:58:16 +0200 (Thu, 26 May 2011) | 1 line
-
-corrected a bug conserning reading short images in Python
-------------------------------------------------------------------------
-r475 | marakl | 2011-05-22 22:43:56 +0200 (Sun, 22 May 2011) | 1 line
-
-documentation changes
-------------------------------------------------------------------------
-r474 | marakl | 2011-05-22 21:22:12 +0200 (Sun, 22 May 2011) | 1 line
-
-2D images are not recognized if 3x1x1x1 is the size
-------------------------------------------------------------------------
-r473 | marakl | 2011-05-22 21:18:48 +0200 (Sun, 22 May 2011) | 1 line
-
-two bugs corrected
-------------------------------------------------------------------------
-r472 | coupriem | 2011-05-19 15:07:17 +0200 (Thu, 19 May 2011) | 1 line
-
-updated curvetangents and ltangents
-------------------------------------------------------------------------
-r471 | marakl | 2011-05-18 20:13:56 +0200 (Wed, 18 May 2011) | 1 line
-
-download page corrected
-------------------------------------------------------------------------
-r470 | charpeju | 2011-05-18 15:40:45 +0200 (Wed, 18 May 2011) | 1 line
-
-multi FITS reader
-------------------------------------------------------------------------
-r469 | marakl | 2011-05-18 09:57:16 +0200 (Wed, 18 May 2011) | 1 line
-
-download page changes
-------------------------------------------------------------------------
-r468 | marakl | 2011-05-17 20:07:14 +0200 (Tue, 17 May 2011) | 1 line
-
-the download page forgotten from the manual
-------------------------------------------------------------------------
-r467 | coupriem | 2011-05-17 16:09:17 +0200 (Tue, 17 May 2011) | 1 line
-
-dilation, erosion, opening, closing of float images
-------------------------------------------------------------------------
-r466 | marakl | 2011-05-12 16:24:30 +0200 (Thu, 12 May 2011) | 1 line
-
-almost no change to uiFlow
-------------------------------------------------------------------------
-r465 | talboth | 2011-05-11 12:41:13 +0200 (Wed, 11 May 2011) | 1 line
-
-Problems with FITSIO and conflicts with Coordinates structure
-------------------------------------------------------------------------
-r464 | talboth | 2011-05-11 12:28:21 +0200 (Wed, 11 May 2011) | 1 line
-
-conflict in Coordinates
-------------------------------------------------------------------------
-r463 | najmanl | 2011-05-10 14:05:19 +0200 (Tue, 10 May 2011) | 1 line
-
-saliencyGA scale
-------------------------------------------------------------------------
-r462 | coupriem | 2011-04-25 21:43:26 +0200 (Mon, 25 Apr 2011) | 1 line
-
-updating l?dcollapse
-------------------------------------------------------------------------
-r461 | marakl | 2011-04-25 14:00:47 +0200 (Mon, 25 Apr 2011) | 1 line
-
-syntax errors
-------------------------------------------------------------------------
-r460 | coupriem | 2011-04-18 07:45:03 +0200 (Mon, 18 Apr 2011) | 1 line
-
-lecture/Ã©criture ppm (mcimage)
-------------------------------------------------------------------------
-r459 | charpeju | 2011-04-14 18:34:09 +0200 (Thu, 14 Apr 2011) | 1 line
-
-comme ca on a rien perdu
-------------------------------------------------------------------------
-r458 | talboth | 2011-04-14 18:31:07 +0200 (Thu, 14 Apr 2011) | 1 line
-
-alors
-------------------------------------------------------------------------
-r457 | marakl | 2011-04-14 16:37:49 +0200 (Thu, 14 Apr 2011) | 1 line
-
-multi-band tiff images are now read as list of images in python
-------------------------------------------------------------------------
-r456 | talboth | 2011-04-14 11:26:45 +0200 (Thu, 14 Apr 2011) | 1 line
-
-TIFF disabled for command-line
-------------------------------------------------------------------------
-r455 | talboth | 2011-04-14 10:54:59 +0200 (Thu, 14 Apr 2011) | 1 line
-
-reading TIFF images
-------------------------------------------------------------------------
-r454 | coupriem | 2011-04-13 16:03:06 +0200 (Wed, 13 Apr 2011) | 1 line
-
-adding src/com/genball.c src/com/skel_CKG.c src/com/skel_CKG_map.c
-------------------------------------------------------------------------
-r453 | talboth | 2011-04-12 15:54:57 +0200 (Tue, 12 Apr 2011) | 1 line
-
-small bugs
-------------------------------------------------------------------------
-r452 | coupriem | 2011-04-12 07:55:28 +0200 (Tue, 12 Apr 2011) | 1 line
-
-adding src/com/skel_PSG.c
-------------------------------------------------------------------------
-r451 | coupriem | 2011-04-11 14:29:21 +0200 (Mon, 11 Apr 2011) | 1 line
-
-adding scripts skelfilter?d and skel_AMK.c
-------------------------------------------------------------------------
-r450 | marakl | 2011-04-07 00:09:20 +0200 (Thu, 07 Apr 2011) | 1 line
-
-cde package addresses
-------------------------------------------------------------------------
-r449 | marakl | 2011-04-07 00:01:31 +0200 (Thu, 07 Apr 2011) | 1 line
-
-cde package
-------------------------------------------------------------------------
-r448 | marakl | 2011-04-06 20:40:20 +0200 (Wed, 06 Apr 2011) | 1 line
-
-cde package generation
-------------------------------------------------------------------------
-r447 | marakl | 2011-04-06 20:33:21 +0200 (Wed, 06 Apr 2011) | 1 line
-
-whatershed bug corrected. it was a test in the tutorial. Don't forget, watershed changes the marker image. This is not good; correct it later.
-------------------------------------------------------------------------
-r446 | marakl | 2011-04-06 20:16:34 +0200 (Wed, 06 Apr 2011) | 1 line
-
-there is a bug in watershed
-------------------------------------------------------------------------
-r445 | marakl | 2011-04-06 19:28:36 +0200 (Wed, 06 Apr 2011) | 1 line
-
-tp-s tested for edf, starting the package generation
-------------------------------------------------------------------------
-r444 | marakl | 2011-04-06 18:35:20 +0200 (Wed, 06 Apr 2011) | 1 line
-
-fft (mc-tp5-3.py) and the necessary framework created and tested
-------------------------------------------------------------------------
-r443 | marakl | 2011-04-05 14:14:18 +0200 (Tue, 05 Apr 2011) | 1 line
-
-forgot to add
-------------------------------------------------------------------------
-r442 | coupriem | 2011-04-05 10:58:35 +0200 (Tue, 05 Apr 2011) | 1 line
-
-adding formation_EDF.txt
-------------------------------------------------------------------------
-r441 | marakl | 2011-04-05 09:56:56 +0200 (Tue, 05 Apr 2011) | 1 line
-
-before diskussion
-------------------------------------------------------------------------
-r440 | marakl | 2011-04-04 21:37:43 +0200 (Mon, 04 Apr 2011) | 1 line
-
-some changes
-------------------------------------------------------------------------
-r439 | marakl | 2011-04-03 21:03:18 +0200 (Sun, 03 Apr 2011) | 1 line
-
-small changes
-------------------------------------------------------------------------
-r438 | coupriem | 2011-04-03 16:56:36 +0200 (Sun, 03 Apr 2011) | 1 line
-
-adding python/pink/histo.py
-------------------------------------------------------------------------
-r437 | coupriem | 2011-04-03 10:55:42 +0200 (Sun, 03 Apr 2011) | 1 line
-
-updates in tutorials MC-TP1, 5 and 6
-------------------------------------------------------------------------
-r436 | coupriem | 2011-04-02 10:34:40 +0200 (Sat, 02 Apr 2011) | 1 line
-
-change in bash interface for selndg
-------------------------------------------------------------------------
-r435 | marakl | 2011-04-01 18:22:07 +0200 (Fri, 01 Apr 2011) | 1 line
-
-amira export minor bug
-------------------------------------------------------------------------
-r434 | coupriem | 2011-04-01 17:38:26 +0200 (Fri, 01 Apr 2011) | 1 line
-
-python interface for asf - updates in tutorials
-------------------------------------------------------------------------
-r433 | marakl | 2011-03-30 18:21:37 +0200 (Wed, 30 Mar 2011) | 1 line
-
-pyopening corrected
-------------------------------------------------------------------------
-r432 | marakl | 2011-03-30 16:56:57 +0200 (Wed, 30 Mar 2011) | 1 line
-
-python bug, where the x button could not be used to close the window corrected
-------------------------------------------------------------------------
-r431 | coupriem | 2011-03-30 08:00:43 +0200 (Wed, 30 Mar 2011) | 1 line
-
-corr. error in doc. curve2spline
-------------------------------------------------------------------------
-r430 | marakl | 2011-03-28 11:32:38 +0200 (Mon, 28 Mar 2011) | 1 line
-
-bug corrected, when error was thrown in python, pink segfaulted. not any more
-------------------------------------------------------------------------
-r429 | coupriem | 2011-03-27 19:08:50 +0200 (Sun, 27 Mar 2011) | 1 line
-
-adding mc-tp6-0.py (dealing with histograms)
-------------------------------------------------------------------------
-r428 | coupriem | 2011-03-27 09:25:29 +0200 (Sun, 27 Mar 2011) | 1 line
-
-option superimpose dans manipulate - MC-TP1/solution/mc-demo-morph1.py
-------------------------------------------------------------------------
-r427 | marakl | 2011-03-26 19:32:32 +0100 (Sat, 26 Mar 2011) | 1 line
-
-pinkhq.com ftp password
-------------------------------------------------------------------------
-r426 | marakl | 2011-03-25 20:30:56 +0100 (Fri, 25 Mar 2011) | 1 line
-
-minor changes for package management
-------------------------------------------------------------------------
-r425 | coupriem | 2011-03-25 16:03:07 +0100 (Fri, 25 Mar 2011) | 1 line
-
-adding tutorial/python/MC-TP5/solution/mc-tp5-5.py
-------------------------------------------------------------------------
-r424 | coupriem | 2011-03-25 11:20:45 +0100 (Fri, 25 Mar 2011) | 1 line
-
-manipulate now returns the last parameter value ; updates in MC-TP5-2
-------------------------------------------------------------------------
-r423 | marakl | 2011-03-23 13:29:18 +0100 (Wed, 23 Mar 2011) | 1 line
-
-CMake tuning for xen.openSUSE11.2, hopefully won't mess up configurations already functional
-------------------------------------------------------------------------
-r422 | marakl | 2011-03-23 13:26:27 +0100 (Wed, 23 Mar 2011) | 1 line
-
-CMake tuning for xen.openSUSE11.2, hopefully won't mess up configurations already functional
-------------------------------------------------------------------------
-r421 | marakl | 2011-03-22 12:22:27 +0100 (Tue, 22 Mar 2011) | 1 line
-
-should configure
-------------------------------------------------------------------------
-r420 | marakl | 2011-03-22 12:05:22 +0100 (Tue, 22 Mar 2011) | 1 line
-
-rpm package try
-------------------------------------------------------------------------
-r419 | marakl | 2011-03-21 23:48:17 +0100 (Mon, 21 Mar 2011) | 1 line
-
-pink.spec temporarily added
-------------------------------------------------------------------------
-r418 | marakl | 2011-03-21 23:46:41 +0100 (Mon, 21 Mar 2011) | 1 line
-
-package creation prepared
-------------------------------------------------------------------------
-r417 | marakl | 2011-03-21 20:37:55 +0100 (Mon, 21 Mar 2011) | 1 line
-
-source package generator
-------------------------------------------------------------------------
-r416 | marakl | 2011-03-21 20:26:27 +0100 (Mon, 21 Mar 2011) | 1 line
-
-Experimental package generation
-------------------------------------------------------------------------
-r415 | coupriem | 2011-03-20 09:17:49 +0100 (Sun, 20 Mar 2011) | 1 line
-
-update lattribute.c + create python operator (attribute) + new exercice in MC-TP5
-------------------------------------------------------------------------
-r414 | marakl | 2011-03-18 18:19:19 +0100 (Fri, 18 Mar 2011) | 1 line
-
-warning are presented if parts of the python package cannot be imported
-------------------------------------------------------------------------
-r413 | marakl | 2011-03-18 17:34:52 +0100 (Fri, 18 Mar 2011) | 1 line
-
-some packages where semi-published
-------------------------------------------------------------------------
-r412 | marakl | 2011-03-18 16:16:00 +0100 (Fri, 18 Mar 2011) | 1 line
-
-CMake polish for centos
-------------------------------------------------------------------------
-r411 | marakl | 2011-03-18 13:20:31 +0100 (Fri, 18 Mar 2011) | 1 line
-
-CMakeLists.txt reverted
-------------------------------------------------------------------------
-r410 | marakl | 2011-03-18 13:05:20 +0100 (Fri, 18 Mar 2011) | 1 line
-
-pypink.cpp reverted to 408
-------------------------------------------------------------------------
-r409 | marakl | 2011-03-18 13:01:43 +0100 (Fri, 18 Mar 2011) | 1 line
-
-proposition for correction for the bug conserning function with one parameter
-------------------------------------------------------------------------
-r408 | marakl | 2011-03-17 16:29:24 +0100 (Thu, 17 Mar 2011) | 1 line
-
-imview adjusted for lists of images
-------------------------------------------------------------------------
-r407 | marakl | 2011-03-17 16:02:30 +0100 (Thu, 17 Mar 2011) | 1 line
-
-polish CMakeLists a little more
-------------------------------------------------------------------------
-r406 | coupriem | 2011-03-17 16:00:13 +0100 (Thu, 17 Mar 2011) | 1 line
-
-adding tutorial/python/MC-TP7
-------------------------------------------------------------------------
-r405 | marakl | 2011-03-17 14:43:04 +0100 (Thu, 17 Mar 2011) | 1 line
-
-dependencies corrected for debian 6.0 and CMake polished further
-------------------------------------------------------------------------
-r404 | marakl | 2011-03-17 14:26:24 +0100 (Thu, 17 Mar 2011) | 1 line
-
-CMake patched a little more, documentation altered; installation added into the documentation
-------------------------------------------------------------------------
-r403 | marakl | 2011-03-17 13:34:42 +0100 (Thu, 17 Mar 2011) | 1 line
-
-CMake corrected, now it compiles on debian 6.0 opensuse 11.2, the blade is to be tested. I have also removed the LIAR option, because it was connected with the Python front-end anyways
-------------------------------------------------------------------------
-r402 | najmanl | 2011-03-16 11:53:56 +0100 (Wed, 16 Mar 2011) | 1 line
-
-conflicts solved
-------------------------------------------------------------------------
-r401 | coupriem | 2011-03-16 07:34:29 +0100 (Wed, 16 Mar 2011) | 1 line
-
-adding src/com/gammacor.c
-------------------------------------------------------------------------
-r400 | marakl | 2011-03-15 16:15:32 +0100 (Tue, 15 Mar 2011) | 1 line
-
-pink should be importable without X as well
-------------------------------------------------------------------------
-r399 | marakl | 2011-03-15 16:14:41 +0100 (Tue, 15 Mar 2011) | 1 line
-
-cfitsio is silented
-------------------------------------------------------------------------
-r398 | marakl | 2011-03-15 16:03:40 +0100 (Tue, 15 Mar 2011) | 1 line
-
-ungerflow, maxflow partially documented and ported into Python. Note that they are still in the development directory. Also ungerflow example created in python tutorials
-------------------------------------------------------------------------
-r397 | marakl | 2011-03-11 13:02:42 +0100 (Fri, 11 Mar 2011) | 1 line
-
-imview bug corrected, now it works an debian 4.0 with the cde package
-------------------------------------------------------------------------
-r396 | marakl | 2011-03-10 19:21:26 +0100 (Thu, 10 Mar 2011) | 1 line
-
-libtiff promoted to fatal_error
-------------------------------------------------------------------------
-r395 | marakl | 2011-03-10 19:12:27 +0100 (Thu, 10 Mar 2011) | 1 line
-
-standard libpath corrected to lib64 on 64bit systems. This is achieved by testing the size of 'void*'
-------------------------------------------------------------------------
-r394 | marakl | 2011-03-10 19:01:35 +0100 (Thu, 10 Mar 2011) | 1 line
-
-correction to the previous message, libpink is needed
-------------------------------------------------------------------------
-r393 | marakl | 2011-03-10 19:00:31 +0100 (Thu, 10 Mar 2011) | 1 line
-
-correction to the previous message, libpink is needed
-------------------------------------------------------------------------
-r392 | marakl | 2011-03-10 18:17:32 +0100 (Thu, 10 Mar 2011) | 1 line
-
-cmake changes, the Python module now can be installed using the PYTHON_MODULE_INSTALL_PATH variable. You do not have to set it up, it is detected automatically by cmake. After the installation import pink works in pure python. Note that libpink.so is not necessary for the python module
-------------------------------------------------------------------------
-r391 | marakl | 2011-03-10 14:59:34 +0100 (Thu, 10 Mar 2011) | 1 line
-
-doc__gammacor does not exist
-------------------------------------------------------------------------
-r390 | coupriem | 2011-03-09 14:24:19 +0100 (Wed, 09 Mar 2011) | 1 line
-
-support for short type images
-------------------------------------------------------------------------
-r389 | talboth | 2011-03-09 01:29:27 +0100 (Wed, 09 Mar 2011) | 1 line
-
-nightmare of the cfitsio
-------------------------------------------------------------------------
-r388 | talboth | 2011-03-09 01:27:48 +0100 (Wed, 09 Mar 2011) | 1 line
-
-nightmare of the cfitsio
-------------------------------------------------------------------------
-r387 | talboth | 2011-03-09 01:21:08 +0100 (Wed, 09 Mar 2011) | 1 line
-
-nightmare
-------------------------------------------------------------------------
-r386 | talboth | 2011-03-09 00:57:26 +0100 (Wed, 09 Mar 2011) | 1 line
-
-no understand
-------------------------------------------------------------------------
-r385 | talboth | 2011-03-09 00:56:36 +0100 (Wed, 09 Mar 2011) | 1 line
-
-module
-------------------------------------------------------------------------
-r384 | coustyj | 2011-03-08 18:13:14 +0100 (Tue, 08 Mar 2011) | 1 line
-
-JC operateur morpho graphe updates
-------------------------------------------------------------------------
-r383 | charpeju | 2011-03-08 18:04:47 +0100 (Tue, 08 Mar 2011) | 1 line
-
-le programme de Juju marche
-------------------------------------------------------------------------
-r382 | coustyj | 2011-03-08 16:20:05 +0100 (Tue, 08 Mar 2011) | 1 line
-
-Ajout morpho de bases sur graphes par JC, cf Cousty - Najman - Serra ISMM2009
-------------------------------------------------------------------------
-r381 | coustyj | 2011-03-08 15:31:35 +0100 (Tue, 08 Mar 2011) | 1 line
-
-Ajout morpho de bases sur graphes par JC, cf Cousty - Najman - Serra ISMM2009
-------------------------------------------------------------------------
-r380 | coustyj | 2011-03-08 15:21:02 +0100 (Tue, 08 Mar 2011) | 1 line
-
-Ajout morpho de bases sur graphes par JC, cf Cousty - Najman - Serra ISMM2009
-------------------------------------------------------------------------
-r379 | coustyj | 2011-03-08 15:18:45 +0100 (Tue, 08 Mar 2011) | 1 line
-
-Ajout morpho de bases sur graphes par JC, cf Cousty - Najman - Serra ISMM2009
-------------------------------------------------------------------------
-r378 | charpeju | 2011-03-04 18:43:23 +0100 (Fri, 04 Mar 2011) | 1 line
-
-progress in the FITS reader
-------------------------------------------------------------------------
-r377 | charpeju | 2011-03-04 10:39:53 +0100 (Fri, 04 Mar 2011) | 1 line
-
-FITS reader
-------------------------------------------------------------------------
-r376 | marakl | 2011-03-02 17:44:07 +0100 (Wed, 02 Mar 2011) | 1 line
-
-read_raw_image corrected and error messages changed. Now you have a 'pink_error' global macro and it substitutes the filename and the line number automatically
-------------------------------------------------------------------------
-r375 | talboth | 2011-03-02 15:58:01 +0100 (Wed, 02 Mar 2011) | 1 line
-
-segmenti missing from the library
-------------------------------------------------------------------------
-r374 | marakl | 2011-02-28 13:46:49 +0100 (Mon, 28 Feb 2011) | 1 line
-
-debug corrections
-------------------------------------------------------------------------
-r373 | marakl | 2011-02-28 13:36:17 +0100 (Mon, 28 Feb 2011) | 1 line
-
-debug code tyding up
-------------------------------------------------------------------------
-r372 | marakl | 2011-02-26 19:47:48 +0100 (Sat, 26 Feb 2011) | 1 line
-
-documentation upgrade
-------------------------------------------------------------------------
-r371 | marakl | 2011-02-26 02:55:19 +0100 (Sat, 26 Feb 2011) | 1 line
-
-documentation changes for pinkhq.com
-------------------------------------------------------------------------
-r370 | marakl | 2011-02-26 02:54:49 +0100 (Sat, 26 Feb 2011) | 1 line
-
-documentation changes for pinkhq.com
-------------------------------------------------------------------------
-r369 | marakl | 2011-02-25 14:00:36 +0100 (Fri, 25 Feb 2011) | 1 line
-
-tutorials checked
-------------------------------------------------------------------------
-r368 | marakl | 2011-02-24 23:28:06 +0100 (Thu, 24 Feb 2011) | 1 line
-
-manipulate function added. Boost requirement raised at 1.37
-------------------------------------------------------------------------
-r367 | coupriem | 2011-02-24 16:05:09 +0100 (Thu, 24 Feb 2011) | 1 line
-
-updating include/larith.h and corresponding changes in pink.h
-------------------------------------------------------------------------
-r366 | marakl | 2011-02-23 15:34:39 +0100 (Wed, 23 Feb 2011) | 1 line
-
-cmake modifications temporarily revoked until I can talk with Hugues. Also some issues remain: you have to call cmake twice
-------------------------------------------------------------------------
-r365 | marakl | 2011-02-23 15:18:56 +0100 (Wed, 23 Feb 2011) | 1 line
-
-experimental cmake modifications
-------------------------------------------------------------------------
-r364 | coupriem | 2011-02-23 09:07:14 +0100 (Wed, 23 Feb 2011) | 1 line
-
-remplacement des <x|y> par des {x|y} dans les docs
-------------------------------------------------------------------------
-r363 | marakl | 2011-02-22 17:35:52 +0100 (Tue, 22 Feb 2011) | 1 line
-
-bug corrected in printf
-------------------------------------------------------------------------
-r362 | coupriem | 2011-02-22 15:35:53 +0100 (Tue, 22 Feb 2011) | 1 line
-
-updating label, larith, mcimage...
-------------------------------------------------------------------------
-r361 | coupriem | 2011-02-20 08:30:03 +0100 (Sun, 20 Feb 2011) | 1 line
-
-updating tutorial/python/MC-TP?
-------------------------------------------------------------------------
-r360 | coupriem | 2011-02-20 08:20:55 +0100 (Sun, 20 Feb 2011) | 1 line
-
-updating tutorial/python/MC-TP?
-------------------------------------------------------------------------
-r359 | coupriem | 2011-02-20 07:27:56 +0100 (Sun, 20 Feb 2011) | 1 line
-
-updates in tutorial/python/MC-TP?
-------------------------------------------------------------------------
-r358 | coupriem | 2011-02-20 07:18:16 +0100 (Sun, 20 Feb 2011) | 1 line
-
-adding tutorial/python/MC-TP6
-------------------------------------------------------------------------
-r357 | coupriem | 2011-02-20 05:56:34 +0100 (Sun, 20 Feb 2011) | 1 line
-
-changes in llpemeyer.c
-------------------------------------------------------------------------
-r356 | marakl | 2011-02-17 12:46:56 +0100 (Thu, 17 Feb 2011) | 1 line
-
-ui_wrap_function documentation
-------------------------------------------------------------------------
-r355 | talboth | 2011-02-15 19:50:51 +0100 (Tue, 15 Feb 2011) | 1 line
-
-added crop
-------------------------------------------------------------------------
-r354 | coupriem | 2011-02-15 16:44:32 +0100 (Tue, 15 Feb 2011) | 1 line
-
-adding lambdamedialaxis2.tcl
-------------------------------------------------------------------------
-r353 | coupriem | 2011-02-15 16:43:06 +0100 (Tue, 15 Feb 2011) | 1 line
-
-changes in lambdamedialaxis and openingfunction
-------------------------------------------------------------------------
-r352 | marakl | 2011-02-11 19:50:30 +0100 (Fri, 11 Feb 2011) | 1 line
-
-Compiles on Windows
-------------------------------------------------------------------------
-r351 | marakl | 2011-02-11 19:39:22 +0100 (Fri, 11 Feb 2011) | 1 line
-
-complex images ported in python; wrapper functions adjusted (partially) three functions wrapped: lreal, limaginary, lmodulus, NOT yet tested
-------------------------------------------------------------------------
-r350 | coupriem | 2011-02-11 10:52:36 +0100 (Fri, 11 Feb 2011) | 1 line
-
-fixing ACCEPTED_TYPESx macros (&& instead of ||) and minor things, adding tests
-------------------------------------------------------------------------
-r349 | coupriem | 2011-02-11 07:21:08 +0100 (Fri, 11 Feb 2011) | 1 line
-
-fixing some bugs - regression tests ok
-------------------------------------------------------------------------
-r348 | marakl | 2011-02-10 19:26:06 +0100 (Thu, 10 Feb 2011) | 1 line
-
-Windows compilation changes.
-------------------------------------------------------------------------
-r347 | marakl | 2011-02-10 18:57:54 +0100 (Thu, 10 Feb 2011) | 1 line
-
-compiling on windows changes
-------------------------------------------------------------------------
-r346 | talboth | 2011-02-10 18:38:32 +0100 (Thu, 10 Feb 2011) | 1 line
-
-watershed changes
-------------------------------------------------------------------------
-r345 | marakl | 2011-02-10 18:28:41 +0100 (Thu, 10 Feb 2011) | 1 line
-
-ACCEPTED_TYPES, COMPARE_SIZE, ONLY_2D, ONLY_3D
-------------------------------------------------------------------------
-r344 | marakl | 2011-02-10 16:41:37 +0100 (Thu, 10 Feb 2011) | 1 line
-
-mcimage corrected
-------------------------------------------------------------------------
-r343 | marakl | 2011-02-10 16:13:19 +0100 (Thu, 10 Feb 2011) | 1 line
-
-Jamroot compacted.
-------------------------------------------------------------------------
-r342 | marakl | 2011-02-10 16:01:20 +0100 (Thu, 10 Feb 2011) | 1 line
-
-minor change
-------------------------------------------------------------------------
-r341 | marakl | 2011-02-10 16:00:10 +0100 (Thu, 10 Feb 2011) | 1 line
-
-Windows port should be complete and testable.
-------------------------------------------------------------------------
-r340 | marakl | 2011-02-10 15:31:36 +0100 (Thu, 10 Feb 2011) | 1 line
-
-Windows port, 2nd iteration.
-------------------------------------------------------------------------
-r339 | talboth | 2011-02-09 19:21:07 +0100 (Wed, 09 Feb 2011) | 1 line
-
-this recompiles ok on linux
-------------------------------------------------------------------------
-r338 | marakl | 2011-02-09 18:02:11 +0100 (Wed, 09 Feb 2011) | 1 line
-
-Windows iteration 1 check on Linux
-------------------------------------------------------------------------
-r337 | marakl | 2011-02-09 13:20:31 +0100 (Wed, 09 Feb 2011) | 1 line
-
-Windows support begins
-------------------------------------------------------------------------
-r336 | marakl | 2011-02-02 17:29:18 +0100 (Wed, 02 Feb 2011) | 1 line
-
-this revision compiles on blade08
-------------------------------------------------------------------------
-r335 | marakl | 2011-02-01 18:41:56 +0100 (Tue, 01 Feb 2011) | 1 line
-
-more documentation
-------------------------------------------------------------------------
-r334 | marakl | 2011-02-01 17:35:54 +0100 (Tue, 01 Feb 2011) | 1 line
-
-documentation reorganization, conventions and function export description
-------------------------------------------------------------------------
-r333 | coupriem | 2011-01-28 16:38:05 +0100 (Fri, 28 Jan 2011) | 1 line
-
-updating leden.cxx
-------------------------------------------------------------------------
-r332 | coupriem | 2011-01-28 16:12:08 +0100 (Fri, 28 Jan 2011) | 1 line
-
-updating src/lib/mctopo3d_table.c
-------------------------------------------------------------------------
-r331 | coupriem | 2011-01-28 16:08:02 +0100 (Fri, 28 Jan 2011) | 1 line
-
-minor changes
-------------------------------------------------------------------------
-r330 | coupriem | 2011-01-27 20:29:57 +0100 (Thu, 27 Jan 2011) | 1 line
-
-more tests
-------------------------------------------------------------------------
-r329 | coupriem | 2011-01-27 12:00:54 +0100 (Thu, 27 Jan 2011) | 1 line
-
-adding tests and changes in ldist
-------------------------------------------------------------------------
-r328 | coupriem | 2011-01-26 16:30:38 +0100 (Wed, 26 Jan 2011) | 1 line
-
-changes in ldist
-------------------------------------------------------------------------
-r327 | coupriem | 2011-01-26 12:52:32 +0100 (Wed, 26 Jan 2011) | 1 line
-
-adding include/mctopo3d_table.h
-------------------------------------------------------------------------
-r326 | coupriem | 2011-01-26 12:50:04 +0100 (Wed, 26 Jan 2011) | 1 line
-
-lattrib et suite index_t
-------------------------------------------------------------------------
-r325 | coupriem | 2011-01-26 08:27:16 +0100 (Wed, 26 Jan 2011) | 1 line
-
-update leden.cxx (check parameter topo)
-------------------------------------------------------------------------
-r324 | marakl | 2011-01-25 13:41:38 +0100 (Tue, 25 Jan 2011) | 1 line
-
-minor doc corrections in pypink
-------------------------------------------------------------------------
-r323 | coupriem | 2011-01-25 13:41:00 +0100 (Tue, 25 Jan 2011) | 1 line
-
-updating mctopo3d_table and holeclosing
-------------------------------------------------------------------------
-r322 | marakl | 2011-01-25 13:37:37 +0100 (Tue, 25 Jan 2011) | 1 line
-
-ui_wrap_result corrected
-------------------------------------------------------------------------
-r321 | coupriem | 2011-01-24 15:52:44 +0100 (Mon, 24 Jan 2011) | 1 line
-
-adding mask.c
-------------------------------------------------------------------------
-r320 | coupriem | 2011-01-24 14:05:41 +0100 (Mon, 24 Jan 2011) | 1 line
-
-adding makelin64 li64.make
-------------------------------------------------------------------------
-r319 | coupriem | 2011-01-24 14:01:54 +0100 (Mon, 24 Jan 2011) | 1 line
-
-index_t suite
-------------------------------------------------------------------------
-r318 | coupriem | 2011-01-24 13:58:03 +0100 (Mon, 24 Jan 2011) | 1 line
-
-fix bug in lhisto.c
-------------------------------------------------------------------------
-r317 | coupriem | 2011-01-24 06:20:02 +0100 (Mon, 24 Jan 2011) | 1 line
-
-index_t suite
-------------------------------------------------------------------------
-r316 | coupriem | 2011-01-24 06:18:49 +0100 (Mon, 24 Jan 2011) | 1 line
-
-index_t suite
-------------------------------------------------------------------------
-r315 | coupriem | 2011-01-22 06:32:10 +0100 (Sat, 22 Jan 2011) | 1 line
-
-adding src/com/planarity.c
-------------------------------------------------------------------------
-r314 | coupriem | 2011-01-22 05:34:54 +0100 (Sat, 22 Jan 2011) | 1 line
-
-index_t : suite des m.a.j
-------------------------------------------------------------------------
-r313 | coupriem | 2011-01-21 11:53:58 +0100 (Fri, 21 Jan 2011) | 1 line
-
-update lcrop.c
-------------------------------------------------------------------------
-r312 | coupriem | 2011-01-21 10:27:34 +0100 (Fri, 21 Jan 2011) | 1 line
-
-fix bug in lfloat.c
-------------------------------------------------------------------------
-r311 | coupriem | 2011-01-21 09:29:45 +0100 (Fri, 21 Jan 2011) | 1 line
-
-fixing small bug
-------------------------------------------------------------------------
-r310 | coupriem | 2011-01-21 09:23:41 +0100 (Fri, 21 Jan 2011) | 1 line
-
-adding src/com/rawthreshold.c
-------------------------------------------------------------------------
-r309 | coupriem | 2011-01-21 09:10:10 +0100 (Fri, 21 Jan 2011) | 1 line
-
-intro. index_t + several updates
-------------------------------------------------------------------------
-r308 | marakl | 2011-01-18 16:42:13 +0100 (Tue, 18 Jan 2011) | 1 line
-
-python_documenter.py put in order. It automatically extracts the documentation and generates the python_doc.h file. It detects the changes in documentation and is only called at the beggining or after something's changed.
-------------------------------------------------------------------------
-r307 | marakl | 2011-01-18 11:29:02 +0100 (Tue, 18 Jan 2011) | 1 line
-
-t26pp corrected
-------------------------------------------------------------------------
-r306 | marakl | 2011-01-18 11:11:01 +0100 (Tue, 18 Jan 2011) | 1 line
-
-ui_wrap functions created, automatic parameter-type-decomposition, simple functions (about 190) exported to python, functionality tested on the tp-s
-------------------------------------------------------------------------
-r305 | coupriem | 2011-01-13 08:43:18 +0100 (Thu, 13 Jan 2011) | 1 line
-
-adding FAQ
-------------------------------------------------------------------------
-r304 | coupriem | 2011-01-12 15:26:34 +0100 (Wed, 12 Jan 2011) | 1 line
-
-type complexe 3 et MC-TP5
-------------------------------------------------------------------------
-r303 | coupriem | 2011-01-12 11:38:36 +0100 (Wed, 12 Jan 2011) | 1 line
-
-changements TODO
-------------------------------------------------------------------------
-r302 | coupriem | 2011-01-11 21:04:20 +0100 (Tue, 11 Jan 2011) | 1 line
-
-type complex 2
-------------------------------------------------------------------------
-r301 | coupriem | 2011-01-11 17:54:48 +0100 (Tue, 11 Jan 2011) | 1 line
-
-type complexe - 1
-------------------------------------------------------------------------
-r300 | coupriem | 2011-01-03 06:28:59 +0100 (Mon, 03 Jan 2011) | 1 line
-
-minor updates
-------------------------------------------------------------------------
-r299 | marakl | 2011-01-01 20:21:33 +0100 (Sat, 01 Jan 2011) | 1 line
-
-cmake tuned
-------------------------------------------------------------------------
-r298 | coupriem | 2010-12-25 08:15:55 +0100 (Sat, 25 Dec 2010) | 1 line
-
-update deriche gaussianfilter gradientcd lderiche; delete lderiche3d
-------------------------------------------------------------------------
-r297 | coupriem | 2010-12-23 21:01:42 +0100 (Thu, 23 Dec 2010) | 1 line
-
-nettoyage mcxbib et al. ; operateurs sur les images de complexes (fft...)
-------------------------------------------------------------------------
-r296 | talboth | 2010-12-22 19:28:50 +0100 (Wed, 22 Dec 2010) | 1 line
-
-more work on imview
-------------------------------------------------------------------------
-r295 | talboth | 2010-12-22 11:43:52 +0100 (Wed, 22 Dec 2010) | 1 line
-
-reasonable init
-------------------------------------------------------------------------
-r294 | talboth | 2010-12-22 11:43:15 +0100 (Wed, 22 Dec 2010) | 1 line
-
-librt
-------------------------------------------------------------------------
-r293 | marakl | 2010-12-22 01:05:54 +0100 (Wed, 22 Dec 2010) | 1 line
-
-realtime librari added to cmake needed by imview
-------------------------------------------------------------------------
-r292 | talboth | 2010-12-21 13:58:09 +0100 (Tue, 21 Dec 2010) | 1 line
-
-not sure this is any good
-------------------------------------------------------------------------
-r291 | talboth | 2010-12-21 03:54:50 +0100 (Tue, 21 Dec 2010) | 1 line
-
-toto
-------------------------------------------------------------------------
-r290 | talboth | 2010-12-21 03:51:16 +0100 (Tue, 21 Dec 2010) | 1 line
-
-version imview marche
-------------------------------------------------------------------------
-r289 | talboth | 2010-12-20 20:01:37 +0100 (Mon, 20 Dec 2010) | 1 line
-
-
-------------------------------------------------------------------------
-r288 | talboth | 2010-12-20 03:48:31 +0100 (Mon, 20 Dec 2010) | 2 lines
-
-always a bit further'
-
-------------------------------------------------------------------------
-r287 | talboth | 2010-12-20 02:07:13 +0100 (Mon, 20 Dec 2010) | 1 line
-
-corrections
-------------------------------------------------------------------------
-r286 | talboth | 2010-12-20 01:43:00 +0100 (Mon, 20 Dec 2010) | 1 line
-
-clipping warning
-------------------------------------------------------------------------
-r285 | talboth | 2010-12-20 01:21:09 +0100 (Mon, 20 Dec 2010) | 1 line
-
-closer to adding some stuff to pink
-------------------------------------------------------------------------
-r284 | marakl | 2010-12-19 00:43:31 +0100 (Sun, 19 Dec 2010) | 1 line
-
-vtk import loosened
-------------------------------------------------------------------------
-r283 | talboth | 2010-12-18 01:51:06 +0100 (Sat, 18 Dec 2010) | 1 line
-
-with this the osx port compiles OK
-------------------------------------------------------------------------
-r282 | talboth | 2010-12-17 02:47:26 +0100 (Fri, 17 Dec 2010) | 1 line
-
-no change
-------------------------------------------------------------------------
-r281 | marakl | 2010-12-16 08:52:51 +0100 (Thu, 16 Dec 2010) | 1 line
-
-forgot to add
-------------------------------------------------------------------------
-r280 | marakl | 2010-12-16 08:38:41 +0100 (Thu, 16 Dec 2010) | 1 line
-
-additional dependencies
-------------------------------------------------------------------------
-r279 | coupriem | 2010-12-16 07:47:56 +0100 (Thu, 16 Dec 2010) | 1 line
-
-updating skel_NK2
-------------------------------------------------------------------------
-r278 | marakl | 2010-12-15 23:10:35 +0100 (Wed, 15 Dec 2010) | 1 line
-
-some comments and ungerflow put back in place
-------------------------------------------------------------------------
-r277 | talboth | 2010-12-15 11:48:03 +0100 (Wed, 15 Dec 2010) | 1 line
-
-small pb with pink.h
-------------------------------------------------------------------------
-r276 | coupriem | 2010-12-12 08:16:43 +0100 (Sun, 12 Dec 2010) | 1 line
-
-update skel2graph
-------------------------------------------------------------------------
-r275 | marakl | 2010-12-11 20:24:25 +0100 (Sat, 11 Dec 2010) | 1 line
-
-tutorials tested, wireframe corrected
-------------------------------------------------------------------------
-r274 | marakl | 2010-12-11 20:01:08 +0100 (Sat, 11 Dec 2010) | 1 line
-
-the windows are excellently closing, but there's no wireframe
-------------------------------------------------------------------------
-r273 | marakl | 2010-12-11 18:52:15 +0100 (Sat, 11 Dec 2010) | 1 line
-
-visualisation works I quickly save before I change something and it disappears
-------------------------------------------------------------------------
-r272 | marakl | 2010-12-11 18:45:56 +0100 (Sat, 11 Dec 2010) | 1 line
-
-visualisation almost working
-------------------------------------------------------------------------
-r271 | marakl | 2010-12-11 18:32:39 +0100 (Sat, 11 Dec 2010) | 1 line
-
-Now render works but view3d doesn't
-------------------------------------------------------------------------
-r270 | marakl | 2010-12-11 15:17:18 +0100 (Sat, 11 Dec 2010) | 1 line
-
-preliminary documentation
-------------------------------------------------------------------------
-r269 | marakl | 2010-12-10 18:54:51 +0100 (Fri, 10 Dec 2010) | 1 line
-
-Tutorials added Python solutions and bash solutions as well
-------------------------------------------------------------------------
-r268 | marakl | 2010-12-10 10:14:21 +0100 (Fri, 10 Dec 2010) | 1 line
-
-the four TPs of Michel are ready and tested, they may need to be tuned. TPs of Hugues are mostly covered either by the TPs of Michel or by themselfs. Official solutions needed to complete. Minor issue remains with calling at least two graphical interfaces consecutively. I will look in to it today, Hugues' imview function is also missing
-------------------------------------------------------------------------
-r267 | marakl | 2010-12-09 13:40:53 +0100 (Thu, 09 Dec 2010) | 1 line
-
-Michel's TP3 finished and tested. A minor issue remains, with launching graphival functions (view3d and render) consecutively
-------------------------------------------------------------------------
-r266 | talboth | 2010-12-07 03:15:26 +0100 (Tue, 07 Dec 2010) | 1 line
-
-some progress
-------------------------------------------------------------------------
-r265 | talboth | 2010-12-07 03:01:18 +0100 (Tue, 07 Dec 2010) | 1 line
-
-stuff from Australia
-------------------------------------------------------------------------
-r264 | marakl | 2010-12-06 17:07:01 +0100 (Mon, 06 Dec 2010) | 1 line
-
-view3d, render and seuilmesh written and tested on basic images, mcube_tmp created and basic functionality tested. mcube_tmp needs to be backported to 'mcube'
-------------------------------------------------------------------------
-r263 | marakl | 2010-12-06 01:06:48 +0100 (Mon, 06 Dec 2010) | 1 line
-
-mcube repartition
-------------------------------------------------------------------------
-r262 | talboth | 2010-12-05 01:45:05 +0100 (Sun, 05 Dec 2010) | 1 line
-
-this will eventually become a hugely important function...
-------------------------------------------------------------------------
-r261 | marakl | 2010-12-04 19:20:17 +0100 (Sat, 04 Dec 2010) | 1 line
-
-renderer written and works, for now in it takes textfiles, next step is to generate .vtk -s on the fly
-------------------------------------------------------------------------
-r260 | coupriem | 2010-12-04 10:40:49 +0100 (Sat, 04 Dec 2010) | 1 line
-
-cor. bug src/com/histo.c
-------------------------------------------------------------------------
-r259 | marakl | 2010-12-02 19:33:26 +0100 (Thu, 02 Dec 2010) | 1 line
-
-view3d image visualisation routine finished
-------------------------------------------------------------------------
-r258 | marakl | 2010-12-02 18:55:50 +0100 (Thu, 02 Dec 2010) | 1 line
-
-minor cmake changes
-------------------------------------------------------------------------
-r257 | marakl | 2010-12-02 18:53:25 +0100 (Thu, 02 Dec 2010) | 1 line
-
-minor cmake changes
-------------------------------------------------------------------------
-r256 | marakl | 2010-12-02 17:38:18 +0100 (Thu, 02 Dec 2010) | 1 line
-
-view3d almost ready
-------------------------------------------------------------------------
-r255 | marakl | 2010-12-01 18:11:54 +0100 (Wed, 01 Dec 2010) | 1 line
-
-view3d implemented in python
-------------------------------------------------------------------------
-r254 | marakl | 2010-11-28 10:14:01 +0100 (Sun, 28 Nov 2010) | 1 line
-
-genball forgotten
-------------------------------------------------------------------------
-r253 | marakl | 2010-11-28 10:11:13 +0100 (Sun, 28 Nov 2010) | 1 line
-
-MC-TP1 finished and works
-------------------------------------------------------------------------
-r252 | coupriem | 2010-11-26 10:03:34 +0100 (Fri, 26 Nov 2010) | 1 line
-
-minor updates
-------------------------------------------------------------------------
-r251 | marakl | 2010-11-25 23:48:20 +0100 (Thu, 25 Nov 2010) | 1 line
-
-minor changes
-------------------------------------------------------------------------
-r250 | marakl | 2010-11-25 23:42:43 +0100 (Thu, 25 Nov 2010) | 1 line
-
-cpp python directory added
-------------------------------------------------------------------------
-r249 | marakl | 2010-11-25 17:04:45 +0100 (Thu, 25 Nov 2010) | 1 line
-
-Hugues' tp1 almost ready
-------------------------------------------------------------------------
-r248 | marakl | 2010-11-24 12:14:05 +0100 (Wed, 24 Nov 2010) | 1 line
-
-inverse function moved to lattribheight.c; compilation corrected
-------------------------------------------------------------------------
-r247 | marakl | 2010-11-24 10:48:37 +0100 (Wed, 24 Nov 2010) | 1 line
-
-functions for TP Hugues and TP Michel exported. Before testing
-------------------------------------------------------------------------
-r246 | marakl | 2010-11-23 21:26:04 +0100 (Tue, 23 Nov 2010) | 1 line
-
-lheightminima created and the inversion moved within
-------------------------------------------------------------------------
-r245 | marakl | 2010-11-23 21:11:29 +0100 (Tue, 23 Nov 2010) | 1 line
-
-backup
-------------------------------------------------------------------------
-r244 | marakl | 2010-11-23 16:08:48 +0100 (Tue, 23 Nov 2010) | 1 line
-
-most functions for Michel's TPs added notable exceptions are mcube and randrgb not tested, starting Hugues' functions
-------------------------------------------------------------------------
-r243 | marakl | 2010-11-22 18:06:04 +0100 (Mon, 22 Nov 2010) | 1 line
-
-boost python tp3 port finished tp4 port started not yet tested
-------------------------------------------------------------------------
-r242 | marakl | 2010-11-20 19:04:26 +0100 (Sat, 20 Nov 2010) | 1 line
-
-now the python port is capable of accepting multiple return-type functions
-------------------------------------------------------------------------
-r241 | marakl | 2010-11-17 15:31:01 +0100 (Wed, 17 Nov 2010) | 1 line
-
-Michel TP1 functions exported to python (not tested)
-------------------------------------------------------------------------
-r240 | marakl | 2010-11-16 17:03:31 +0100 (Tue, 16 Nov 2010) | 1 line
-
-pink towards the portion to python. The image object proted with all the operators, +- and vector field
-------------------------------------------------------------------------
-r239 | marakl | 2010-11-15 12:53:21 +0100 (Mon, 15 Nov 2010) | 1 line
-
-reorganization for debian 5.0 lenny compatibility
-------------------------------------------------------------------------
-r238 | marakl | 2010-11-12 13:53:39 +0100 (Fri, 12 Nov 2010) | 1 line
-
-curvlength and curvetangents moved to cxx
-------------------------------------------------------------------------
-r237 | marakl | 2010-11-12 13:11:02 +0100 (Fri, 12 Nov 2010) | 1 line
-
-cmake corrections
-------------------------------------------------------------------------
-r236 | marakl | 2010-11-12 12:43:57 +0100 (Fri, 12 Nov 2010) | 1 line
-
-cmake correction part1 for debian 5.0 lenny
-------------------------------------------------------------------------
-r235 | coupriem | 2010-11-10 09:29:42 +0100 (Wed, 10 Nov 2010) | 1 line
-
-fix bug in ltangents.cxx
-------------------------------------------------------------------------
-r234 | coupriem | 2010-11-06 09:34:22 +0100 (Sat, 06 Nov 2010) | 1 line
-
-fixing bug in ltangents.cxx
-------------------------------------------------------------------------
-r233 | coupriem | 2010-11-06 08:05:34 +0100 (Sat, 06 Nov 2010) | 1 line
-
-adding drawfieldlists.c
-------------------------------------------------------------------------
-r232 | coupriem | 2010-11-05 09:35:07 +0100 (Fri, 05 Nov 2010) | 1 line
-
-lengthcurve.c -> curvelength.c
-------------------------------------------------------------------------
-r231 | coupriem | 2010-11-04 16:25:31 +0100 (Thu, 04 Nov 2010) | 1 line
-
-updating ltangents
-------------------------------------------------------------------------
-r230 | coupriem | 2010-11-04 11:54:42 +0100 (Thu, 04 Nov 2010) | 1 line
-
-deleted latex doc files from the repository (they are generated by Doxygen)
-------------------------------------------------------------------------
-r229 | coupriem | 2010-11-03 20:56:14 +0100 (Wed, 03 Nov 2010) | 1 line
-
-updating ltangents.cxx
-------------------------------------------------------------------------
-r228 | coupriem | 2010-11-03 20:51:15 +0100 (Wed, 03 Nov 2010) | 1 line
-
-updating ltangents.cxx
-------------------------------------------------------------------------
-r227 | coupriem | 2010-11-03 20:49:52 +0100 (Wed, 03 Nov 2010) | 1 line
-
-updating ltangents.cxx
-------------------------------------------------------------------------
-r226 | coupriem | 2010-11-03 20:47:20 +0100 (Wed, 03 Nov 2010) | 1 line
-
-updating ltangents.cxx
-------------------------------------------------------------------------
-r225 | coupriem | 2010-11-03 15:43:19 +0100 (Wed, 03 Nov 2010) | 1 line
-
-updating ltangents.cxx
-------------------------------------------------------------------------
-r224 | coupriem | 2010-11-03 15:25:29 +0100 (Wed, 03 Nov 2010) | 1 line
-
-updating ltangents.cxx
-------------------------------------------------------------------------
-r223 | coupriem | 2010-10-27 11:52:50 +0200 (Wed, 27 Oct 2010) | 1 line
-
-adding lbdigitalline.cxx, ltangents.cxx and lengthcurve.c
-------------------------------------------------------------------------
-r222 | coupriem | 2010-10-27 10:42:52 +0200 (Wed, 27 Oct 2010) | 1 line
-
-added warning in writeimage (mcimage)
-------------------------------------------------------------------------
-r221 | coupriem | 2010-10-27 09:30:28 +0200 (Wed, 27 Oct 2010) | 1 line
-
-updating pgm2curve
-------------------------------------------------------------------------
-r220 | marakl | 2010-10-20 15:12:04 +0200 (Wed, 20 Oct 2010) | 1 line
-
-no change
-------------------------------------------------------------------------
-r219 | marakl | 2010-10-20 15:11:45 +0200 (Wed, 20 Oct 2010) | 1 line
-
-some more files to delete
-------------------------------------------------------------------------
-r218 | marakl | 2010-10-20 15:10:55 +0200 (Wed, 20 Oct 2010) | 1 line
-
-no change
-------------------------------------------------------------------------
-r217 | marakl | 2010-10-20 15:01:44 +0200 (Wed, 20 Oct 2010) | 1 line
-
-automaticly generated doc files tried to be deleted
-------------------------------------------------------------------------
-r216 | coupriem | 2010-10-16 11:52:56 +0200 (Sat, 16 Oct 2010) | 1 line
-
-remove scripts hmaxima hminima
-------------------------------------------------------------------------
-r215 | najmanl | 2010-10-15 18:21:26 +0200 (Fri, 15 Oct 2010) | 1 line
-
-Un oubli chiant
-------------------------------------------------------------------------
-r214 | najmanl | 2010-10-15 17:34:47 +0200 (Fri, 15 Oct 2010) | 1 line
-
-.exe enleve
-------------------------------------------------------------------------
-r213 | najmanl | 2010-10-14 18:00:03 +0200 (Thu, 14 Oct 2010) | 1 line
-
-ppm2GA.c
-------------------------------------------------------------------------
-r212 | najmanl | 2010-10-14 17:59:41 +0200 (Thu, 14 Oct 2010) | 1 line
-
-ppm2GA.c
-------------------------------------------------------------------------
-r211 | najmanl | 2010-10-14 17:31:13 +0200 (Thu, 14 Oct 2010) | 1 line
-
-jccomptre_ avait Ã©tÃ© oubliÃ©...
-------------------------------------------------------------------------
-r210 | coupriem | 2010-10-07 08:11:38 +0200 (Thu, 07 Oct 2010) | 1 line
-
-corrections in include/lmedialaxis.h
-------------------------------------------------------------------------
-r209 | marakl | 2010-09-24 15:31:39 +0200 (Fri, 24 Sep 2010) | 1 line
-
-dependency file created
-------------------------------------------------------------------------
-r208 | marakl | 2010-09-23 13:42:42 +0200 (Thu, 23 Sep 2010) | 1 line
-
-almost no change
-------------------------------------------------------------------------
-r207 | marakl | 2010-09-22 16:20:30 +0200 (Wed, 22 Sep 2010) | 1 line
-
-backup
-------------------------------------------------------------------------
-r206 | coupriem | 2010-09-21 09:24:07 +0200 (Tue, 21 Sep 2010) | 1 line
-
-updating mcimage.c
-------------------------------------------------------------------------
-r205 | coupriem | 2010-09-15 21:54:37 +0200 (Wed, 15 Sep 2010) | 1 line
-
-updates in ?dflowskeleton
-------------------------------------------------------------------------
-r204 | marakl | 2010-09-12 19:16:20 +0200 (Sun, 12 Sep 2010) | 1 line
-
-ui_fit_circle compiles, but it needs yet to be linked with lapack
-------------------------------------------------------------------------
-r203 | marakl | 2010-09-12 15:29:07 +0200 (Sun, 12 Sep 2010) | 1 line
-
-CMakefile.txt adjusted for eigen2 and an include-file-path-bug corrected
-------------------------------------------------------------------------
-r202 | marakl | 2010-09-12 13:49:49 +0200 (Sun, 12 Sep 2010) | 1 line
-
-circle and ellipse fitting
-------------------------------------------------------------------------
-r201 | coupriem | 2010-09-09 15:09:58 +0200 (Thu, 09 Sep 2010) | 1 line
-
-adding 2dtopoflow.c
-------------------------------------------------------------------------
-r200 | coupriem | 2010-09-09 15:06:47 +0200 (Thu, 09 Sep 2010) | 1 line
-
-adding pthseparatinggray.c + updates
-------------------------------------------------------------------------
-r199 | coupriem | 2010-09-07 11:58:00 +0200 (Tue, 07 Sep 2010) | 1 line
-
-adding distsets and minor updates
-------------------------------------------------------------------------
-r198 | talboth | 2010-08-25 23:48:13 +0200 (Wed, 25 Aug 2010) | 1 line
-
-no change really
-------------------------------------------------------------------------
-r197 | talboth | 2010-08-25 23:35:20 +0200 (Wed, 25 Aug 2010) | 2 lines
-
-Beginning of a tutorial
-
-------------------------------------------------------------------------
-r196 | coupriem | 2010-08-22 20:53:54 +0200 (Sun, 22 Aug 2010) | 1 line
-
-updates + add tcl/medialaxisfilter
-------------------------------------------------------------------------
-r195 | talboth | 2010-08-19 19:19:01 +0200 (Thu, 19 Aug 2010) | 1 line
-
-fewer warnings
-------------------------------------------------------------------------
-r194 | talboth | 2010-08-19 18:00:47 +0200 (Thu, 19 Aug 2010) | 1 line
-
-compiles again on OS/X
-------------------------------------------------------------------------
-r193 | coupriem | 2010-07-27 08:27:00 +0200 (Tue, 27 Jul 2010) | 1 line
-
-update lhisto
-------------------------------------------------------------------------
-r192 | coupriem | 2010-07-25 07:26:26 +0200 (Sun, 25 Jul 2010) | 1 line
-
-adding src/com/lengthsplines.c
-------------------------------------------------------------------------
-r191 | coupriem | 2010-07-23 17:11:53 +0200 (Fri, 23 Jul 2010) | 1 line
-
-adding watershedwithoutlinelab
-------------------------------------------------------------------------
-r190 | marakl | 2010-07-22 17:51:11 +0200 (Thu, 22 Jul 2010) | 1 line
-
-backup
-------------------------------------------------------------------------
-r189 | coupriem | 2010-07-22 16:48:20 +0200 (Thu, 22 Jul 2010) | 1 line
-
-more updates
-------------------------------------------------------------------------
-r188 | coupriem | 2010-07-22 12:09:28 +0200 (Thu, 22 Jul 2010) | 1 line
-
-adding drawsplinesorient.c
-------------------------------------------------------------------------
-r187 | chaussaj | 2010-07-20 17:07:02 +0200 (Tue, 20 Jul 2010) | 1 line
-
-John: Ajoute algos de Benjamin dans skelpar3d_others
-------------------------------------------------------------------------
-r186 | chaussaj | 2010-07-20 17:04:49 +0200 (Tue, 20 Jul 2010) | 1 line
-
-John: Ajoute algos de Benjamin dans skelpar3d_others
-------------------------------------------------------------------------
-r185 | marakl | 2010-07-20 16:54:38 +0200 (Tue, 20 Jul 2010) | 1 line
-
-uiCutPlane works on the first images, I am able to set the angle of the cut
-------------------------------------------------------------------------
-r184 | coupriem | 2010-07-20 12:03:06 +0200 (Tue, 20 Jul 2010) | 1 line
-
-adding ptjunction
-------------------------------------------------------------------------
-r183 | coupriem | 2010-07-20 12:02:41 +0200 (Tue, 20 Jul 2010) | 1 line
-
-adding ptjunction
-------------------------------------------------------------------------
-r182 | coupriem | 2010-07-17 05:46:19 +0200 (Sat, 17 Jul 2010) | 1 line
-
-update histograms
-------------------------------------------------------------------------
-r181 | marakl | 2010-07-16 19:46:25 +0200 (Fri, 16 Jul 2010) | 1 line
-
-backup
-------------------------------------------------------------------------
-r180 | marakl | 2010-07-15 10:58:49 +0200 (Thu, 15 Jul 2010) | 1 line
-
-fill and repr written and exported in python
-------------------------------------------------------------------------
-r179 | marakl | 2010-07-15 09:30:17 +0200 (Thu, 15 Jul 2010) | 1 line
-
-uiCutPlane first try. This will be deleted
-------------------------------------------------------------------------
-r178 | marakl | 2010-07-14 00:18:03 +0200 (Wed, 14 Jul 2010) | 1 line
-
-uiCutPlane backup, bug in skeleton corrected
-------------------------------------------------------------------------
-r177 | coupriem | 2010-07-13 15:27:43 +0200 (Tue, 13 Jul 2010) | 1 line
-
-adding drawsplineorient.c histoazimuth.c genfield.c histodist.c drawfield.c histoelevation.c lengthspline.c
-------------------------------------------------------------------------
-r176 | coupriem | 2010-07-12 11:57:14 +0200 (Mon, 12 Jul 2010) | 8 lines
-
-M drawspline : nouveau paramÃ¨tre extension 
-A lengthspline
-M ldraw : ajout ldrawtangents3d()
-M mcimage : modif readimage writeimage 
-A genfield.c
-M lhisto.c
-A histoazimuth.c
-A histoelevation.c
-------------------------------------------------------------------------
-r175 | marakl | 2010-07-08 00:22:30 +0200 (Thu, 08 Jul 2010) | 1 line
-
-seuil, insert image, merge max added into python. Macro for exporting all image types created, it is called UI_EXPORT_FUNCTION in include/pyexport.hpp. pink.sh script modified, so it can now accept parameters after ipython. There is a bug un cmake. After it copies the python module directory it recursively copies the .svn directories as well. This is a problem, because of the rights set by SVN. These right interfere with cmake when inwoking make. 
-------------------------------------------------------------------------
-r174 | chaussaj | 2010-07-06 13:34:36 +0200 (Tue, 06 Jul 2010) | 1 line
-
-John - Added some thinning algorithms in skelpar - not working yet
-------------------------------------------------------------------------
-r173 | coupriem | 2010-07-05 09:37:39 +0200 (Mon, 05 Jul 2010) | 1 line
-
-delete doc/aide.txt
-------------------------------------------------------------------------
-r172 | coupriem | 2010-07-05 08:38:17 +0200 (Mon, 05 Jul 2010) | 1 line
-
-cropondisk shrinkondisk
-------------------------------------------------------------------------
-r171 | coupriem | 2010-07-05 08:10:14 +0200 (Mon, 05 Jul 2010) | 1 line
-
-cleaning
-------------------------------------------------------------------------
-r170 | coupriem | 2010-07-03 10:08:50 +0200 (Sat, 03 Jul 2010) | 1 line
-
-documentation
-------------------------------------------------------------------------
-r169 | coupriem | 2010-07-03 08:21:49 +0200 (Sat, 03 Jul 2010) | 1 line
-
-update lseltopo.c ptmultiple.c
-------------------------------------------------------------------------
-r168 | coupriem | 2010-06-24 20:56:07 +0200 (Thu, 24 Jun 2010) | 1 line
-
-2dlabel + doc
-------------------------------------------------------------------------
-r167 | coupriem | 2010-06-08 15:31:42 +0200 (Tue, 08 Jun 2010) | 1 line
-
-update general.make
-------------------------------------------------------------------------
-r166 | coupriem | 2010-06-08 15:12:03 +0200 (Tue, 08 Jun 2010) | 1 line
-
-update general.make
-------------------------------------------------------------------------
-r165 | marakl | 2010-05-24 19:06:30 +0200 (Mon, 24 May 2010) | 1 line
-
-Changes: cmake created for the bash and the python front-end. It has been tested on Linux snow leopard and on windows. The python front-end does not compile on windows. The tool for windows compilation is cygwin. The documentation compiles as well. After the python front-end is build pink.sh is created which launches a python either iphython or python with loadable pink module. The following functions have been added: maxflow, simplemaxflow, ungerflow and qdistance. These use boost heavily, so they only compile if the python front-end does. If you want a c++ executable to compile even without the python front-end, name it .cxx
-------------------------------------------------------------------------
-r164 | marakl | 2010-05-24 18:51:45 +0200 (Mon, 24 May 2010) | 1 line
-
-header check and compiler check done
-------------------------------------------------------------------------
-r163 | talboth | 2010-05-21 11:13:08 +0200 (Fri, 21 May 2010) | 1 line
-
-Olena: corrected pgm2raw: unsigned char and int accepted only
-------------------------------------------------------------------------
-r162 | coupriem | 2010-05-20 09:27:19 +0200 (Thu, 20 May 2010) | 1 line
-
-added 1D isthmus detection - skelpar3d
-------------------------------------------------------------------------
-r161 | coupriem | 2010-05-19 08:22:35 +0200 (Wed, 19 May 2010) | 1 line
-
-modif selndg.c
-------------------------------------------------------------------------
-r160 | marakl | 2010-05-17 22:03:17 +0200 (Mon, 17 May 2010) | 1 line
-
-cmake file now generates the documentation as well in /doc/html. pink.dox moved to the /doc directory
-------------------------------------------------------------------------
-r159 | talboth | 2010-05-17 12:53:33 +0200 (Mon, 17 May 2010) | 1 line
-
-small changes
-------------------------------------------------------------------------
-r158 | marakl | 2010-05-17 12:40:00 +0200 (Mon, 17 May 2010) | 1 line
-
-cmakefiles
-------------------------------------------------------------------------
-r157 | marakl | 2010-05-17 02:39:08 +0200 (Mon, 17 May 2010) | 1 line
-
-make me beautiful
-------------------------------------------------------------------------
-r156 | marakl | 2010-05-17 02:39:06 +0200 (Mon, 17 May 2010) | 1 line
-
-backup
-------------------------------------------------------------------------
-r155 | marakl | 2010-05-17 02:39:03 +0200 (Mon, 17 May 2010) | 1 line
-
-backup
-------------------------------------------------------------------------
-r154 | marakl | 2010-05-17 02:39:00 +0200 (Mon, 17 May 2010) | 1 line
-
-backup
-------------------------------------------------------------------------
-r153 | marakl | 2010-05-17 02:38:57 +0200 (Mon, 17 May 2010) | 1 line
-
-backup
-------------------------------------------------------------------------
-r152 | marakl | 2010-05-17 02:38:53 +0200 (Mon, 17 May 2010) | 1 line
-
-backup
-------------------------------------------------------------------------
-r151 | marakl | 2010-05-17 02:38:49 +0200 (Mon, 17 May 2010) | 1 line
-
-backup
-------------------------------------------------------------------------
-r150 | marakl | 2010-05-17 02:38:45 +0200 (Mon, 17 May 2010) | 1 line
-
-regularization
-------------------------------------------------------------------------
-r149 | coupriem | 2010-05-10 21:27:17 +0200 (Mon, 10 May 2010) | 1 line
-
-add src/com/watershedMeyer2lab.c
-------------------------------------------------------------------------
-r148 | talboth | 2010-05-10 17:28:44 +0200 (Mon, 10 May 2010) | 1 line
-
-un assert mal place
-------------------------------------------------------------------------
-r147 | chaussaj | 2010-05-05 16:03:50 +0200 (Wed, 05 May 2010) | 1 line
-
-John et Olena - Ajout de support long sur pgm2raw
-------------------------------------------------------------------------
-r146 | coupriem | 2010-05-05 13:30:13 +0200 (Wed, 05 May 2010) | 1 line
-
-fix bug lambdamedialaxis
-------------------------------------------------------------------------
-r145 | chaussaj | 2010-05-05 09:45:08 +0200 (Wed, 05 May 2010) | 1 line
-
-John - integer medial axis modified
-------------------------------------------------------------------------
-r144 | coupriem | 2010-05-05 08:52:29 +0200 (Wed, 05 May 2010) | 1 line
-
-fix bug integermedialaxis
-------------------------------------------------------------------------
-r143 | coupriem | 2010-04-30 17:59:02 +0200 (Fri, 30 Apr 2010) | 1 line
-
-add watershedMeyer3.c histosieve.c + divers
-------------------------------------------------------------------------
-r142 | chaussaj | 2010-04-30 17:51:37 +0200 (Fri, 30 Apr 2010) | 1 line
-
-John - integermedialaxis, partie commentee corrigee
-------------------------------------------------------------------------
-r141 | coupriem | 2010-04-28 07:32:50 +0200 (Wed, 28 Apr 2010) | 1 line
-
-mcsplines.c : curvatures in 3D
-------------------------------------------------------------------------
-r140 | coupriem | 2010-04-26 17:00:34 +0200 (Mon, 26 Apr 2010) | 1 line
-
-update lskelend3d()
-------------------------------------------------------------------------
-r139 | coupriem | 2010-04-23 08:09:57 +0200 (Fri, 23 Apr 2010) | 1 line
-
-randimage
-------------------------------------------------------------------------
-r138 | chaussaj | 2010-04-22 18:59:15 +0200 (Thu, 22 Apr 2010) | 1 line
-
-John - Modifie pgm2ps, support de format float dans label quand mode m utilise
-------------------------------------------------------------------------
-r137 | chaussaj | 2010-04-20 16:15:06 +0200 (Tue, 20 Apr 2010) | 1 line
-
-John - debug flag on, optimisation off in li.make
-------------------------------------------------------------------------
-r136 | chaussaj | 2010-04-20 16:13:32 +0200 (Tue, 20 Apr 2010) | 1 line
-
-John - leden does not add anymore points on the frame
-------------------------------------------------------------------------
-r135 | coupriem | 2010-04-16 11:05:17 +0200 (Fri, 16 Apr 2010) | 1 line
-
-add script openballrec
-------------------------------------------------------------------------
-r134 | coupriem | 2010-04-14 10:29:24 +0200 (Wed, 14 Apr 2010) | 1 line
-
-remove skelfilter?.c
-------------------------------------------------------------------------
-r133 | coupriem | 2010-04-09 07:52:28 +0200 (Fri, 09 Apr 2010) | 1 line
-
-add lcurves.[ch]
-------------------------------------------------------------------------
-r132 | coupriem | 2010-04-09 07:44:38 +0200 (Fri, 09 Apr 2010) | 1 line
-
-pgm2curve
-------------------------------------------------------------------------
-r131 | coupriem | 2010-04-08 22:19:44 +0200 (Thu, 08 Apr 2010) | 1 line
-
-lskelcurv
-------------------------------------------------------------------------
-r130 | chaussaj | 2010-04-07 19:20:54 +0200 (Wed, 07 Apr 2010) | 1 line
-
-John - added Palagyi algorithms in skelpar3d_others
-------------------------------------------------------------------------
-r129 | coupriem | 2010-04-07 12:55:12 +0200 (Wed, 07 Apr 2010) | 1 line
-
-fix bug pgm2curve
-------------------------------------------------------------------------
-r128 | coupriem | 2010-04-06 10:07:59 +0200 (Tue, 06 Apr 2010) | 1 line
-
-fix bug border
-------------------------------------------------------------------------
-r127 | coupriem | 2010-04-05 08:48:29 +0200 (Mon, 05 Apr 2010) | 1 line
-
-cor. bug mcsplines
-------------------------------------------------------------------------
-r126 | coupriem | 2010-04-01 06:59:03 +0200 (Thu, 01 Apr 2010) | 1 line
-
-drawcircle skelfilter3
-------------------------------------------------------------------------
-r125 | coupriem | 2010-03-30 17:00:55 +0200 (Tue, 30 Mar 2010) | 1 line
-
-new skelfilter3, modifs lskelcurv mcskelcurv mclin mcsplines...
-------------------------------------------------------------------------
-r124 | chaussaj | 2010-03-26 09:43:09 +0100 (Fri, 26 Mar 2010) | 1 line
-
-John - Corrected rotation3dbin.c, so that no resize happen when center of rotation is specified.
-------------------------------------------------------------------------
-r123 | chaussaj | 2010-03-26 09:01:01 +0100 (Fri, 26 Mar 2010) | 1 line
-
-John - Corrected a memory leak in LookUpTable3d.c
-------------------------------------------------------------------------
-r122 | coupriem | 2010-03-26 07:58:24 +0100 (Fri, 26 Mar 2010) | 1 line
-
-pas mal de choses
-------------------------------------------------------------------------
-r121 | coupriem | 2010-02-13 06:28:17 +0100 (Sat, 13 Feb 2010) | 1 line
-
-fix lgeodesic.c
-------------------------------------------------------------------------
-r120 | coupriem | 2010-02-12 08:24:12 +0100 (Fri, 12 Feb 2010) | 1 line
-
-corr. bug lsection() dans lgeo.c
-------------------------------------------------------------------------
-r119 | coupriem | 2010-02-01 08:15:05 +0100 (Mon, 01 Feb 2010) | 1 line
-
-minor update
-------------------------------------------------------------------------
-r118 | coupriem | 2010-01-31 08:03:07 +0100 (Sun, 31 Jan 2010) | 1 line
-
-3 new modes in skelpar3d
-------------------------------------------------------------------------
-r117 | coupriem | 2010-01-27 09:45:44 +0100 (Wed, 27 Jan 2010) | 1 line
-
-corr. bug lballincl.c
-------------------------------------------------------------------------
-r116 | najmanl | 2010-01-24 14:17:58 +0100 (Sun, 24 Jan 2010) | 1 line
-
-Flow mapping pas recursif==marche mieux
-------------------------------------------------------------------------
-r115 | coupriem | 2010-01-24 08:29:27 +0100 (Sun, 24 Jan 2010) | 1 line
-
-adding scripts/invariants2d
-------------------------------------------------------------------------
-r114 | najmanl | 2010-01-23 15:39:11 +0100 (Sat, 23 Jan 2010) | 1 line
-
-Un petit oubli dans la doc de saliencyGA
-------------------------------------------------------------------------
-r113 | najmanl | 2010-01-23 15:28:23 +0100 (Sat, 23 Jan 2010) | 1 line
-
-Un petit oubli dans la doc de saliencyGA
-------------------------------------------------------------------------
-r112 | coupriem | 2010-01-22 08:01:20 +0100 (Fri, 22 Jan 2010) | 1 line
-
-minor updates
-------------------------------------------------------------------------
-r111 | coupriem | 2010-01-21 16:17:43 +0100 (Thu, 21 Jan 2010) | 1 line
-
-add threshold.c
-------------------------------------------------------------------------
-r110 | coupriem | 2010-01-16 17:34:28 +0100 (Sat, 16 Jan 2010) | 1 line
-
-update area
-------------------------------------------------------------------------
-r109 | coupriem | 2010-01-06 20:40:04 +0100 (Wed, 06 Jan 2010) | 1 line
-
-update lmedialaxis
-------------------------------------------------------------------------
-r108 | coupriem | 2010-01-05 07:41:21 +0100 (Tue, 05 Jan 2010) | 1 line
-
-add scripts/lmaskel
-------------------------------------------------------------------------
-r107 | coupriem | 2010-01-04 06:11:35 +0100 (Mon, 04 Jan 2010) | 1 line
-
-minor updates
-------------------------------------------------------------------------
-r106 | coupriem | 2009-12-26 20:54:23 +0100 (Sat, 26 Dec 2009) | 1 line
-
-update worms
-------------------------------------------------------------------------
-r105 | coupriem | 2009-12-26 08:06:09 +0100 (Sat, 26 Dec 2009) | 1 line
-
-add rotate3dbin worms
-------------------------------------------------------------------------
-r104 | coupriem | 2009-12-22 20:38:32 +0100 (Tue, 22 Dec 2009) | 1 line
-
-update src/com/skel_ACK3a.c
-------------------------------------------------------------------------
-r103 | coupriem | 2009-12-18 06:41:54 +0100 (Fri, 18 Dec 2009) | 1 line
-
-add tcl/multirender_1transp src/com/skel_ACK3a.c src/com/skel_ACK3.c src/com/pgm2skel2.c scripts/visuskel2
-------------------------------------------------------------------------
-r102 | coupriem | 2009-12-14 06:21:26 +0100 (Mon, 14 Dec 2009) | 1 line
-
-update lskelcurv.c
-------------------------------------------------------------------------
-r101 | coupriem | 2009-12-11 10:10:20 +0100 (Fri, 11 Dec 2009) | 1 line
-
-update lskelcurv.c
-------------------------------------------------------------------------
-r100 | coupriem | 2009-12-11 05:58:27 +0100 (Fri, 11 Dec 2009) | 1 line
-
-update lskelcurv.c
-------------------------------------------------------------------------
-r99 | coupriem | 2009-12-09 21:31:07 +0100 (Wed, 09 Dec 2009) | 1 line
-
-update lskelcurv.c
-------------------------------------------------------------------------
-r98 | coupriem | 2009-12-08 11:30:59 +0100 (Tue, 08 Dec 2009) | 1 line
-
-modif lskelcurv.c; add visu4pgm
-------------------------------------------------------------------------
-r97 | coupriem | 2009-12-07 06:06:34 +0100 (Mon, 07 Dec 2009) | 1 line
-
-update lskelcurv.c
-------------------------------------------------------------------------
-r96 | coupriem | 2009-12-04 17:40:14 +0100 (Fri, 04 Dec 2009) | 1 line
-
-further update lskelcurv.c
-------------------------------------------------------------------------
-r95 | coupriem | 2009-12-03 15:47:50 +0100 (Thu, 03 Dec 2009) | 1 line
-
-update lskelcurv.c
-------------------------------------------------------------------------
-r94 | coupriem | 2009-12-02 11:52:27 +0100 (Wed, 02 Dec 2009) | 1 line
-
-update doc gaussianfilter
-------------------------------------------------------------------------
-r93 | coupriem | 2009-11-30 22:14:58 +0100 (Mon, 30 Nov 2009) | 1 line
-
-pca.c
-------------------------------------------------------------------------
-r92 | coupriem | 2009-11-27 16:56:07 +0100 (Fri, 27 Nov 2009) | 1 line
-
-complete doc graph2pgm
-------------------------------------------------------------------------
-r91 | coupriem | 2009-11-27 16:52:22 +0100 (Fri, 27 Nov 2009) | 1 line
-
-fix bug graph2pgm
-------------------------------------------------------------------------
-r90 | coupriem | 2009-11-22 21:33:41 +0100 (Sun, 22 Nov 2009) | 1 line
-
-update lskelcurv
-------------------------------------------------------------------------
-r89 | coupriem | 2009-11-21 06:34:39 +0100 (Sat, 21 Nov 2009) | 1 line
-
-skel2graph, graph2ps
-------------------------------------------------------------------------
-r88 | coupriem | 2009-11-19 21:29:51 +0100 (Thu, 19 Nov 2009) | 1 line
-
-ppmascmode.c
-------------------------------------------------------------------------
-r87 | coupriem | 2009-11-19 21:24:44 +0100 (Thu, 19 Nov 2009) | 1 line
-
-3dview2 skel2graph.c
-------------------------------------------------------------------------
-r86 | coupriem | 2009-11-16 09:44:45 +0100 (Mon, 16 Nov 2009) | 1 line
-
-update lborder.c
-------------------------------------------------------------------------
-r85 | coupriem | 2009-11-15 10:06:27 +0100 (Sun, 15 Nov 2009) | 1 line
-
-skelcurv, lskeletons
-------------------------------------------------------------------------
-r84 | coupriem | 2009-11-15 06:33:50 +0100 (Sun, 15 Nov 2009) | 1 line
-
-replace #elif by #else in bimage.c
-------------------------------------------------------------------------
-r83 | coupriem | 2009-11-13 15:29:12 +0100 (Fri, 13 Nov 2009) | 1 line
-
-minor updates cont'd
-------------------------------------------------------------------------
-r82 | coupriem | 2009-11-13 13:27:54 +0100 (Fri, 13 Nov 2009) | 1 line
-
-minor updates
-------------------------------------------------------------------------
-r81 | coupriem | 2009-11-09 18:55:18 +0100 (Mon, 09 Nov 2009) | 1 line
-
-cor bug lskelcurv
-------------------------------------------------------------------------
-r80 | coupriem | 2009-11-07 17:48:51 +0100 (Sat, 07 Nov 2009) | 1 line
-
-drawline
-------------------------------------------------------------------------
-r79 | coupriem | 2009-11-05 17:48:26 +0100 (Thu, 05 Nov 2009) | 1 line
-
-skelfilter1 and 2
-------------------------------------------------------------------------
-r78 | coupriem | 2009-11-04 11:36:15 +0100 (Wed, 04 Nov 2009) | 1 line
-
-cor. bug llabelextrema
-------------------------------------------------------------------------
-r77 | coupriem | 2009-11-04 10:12:16 +0100 (Wed, 04 Nov 2009) | 1 line
-
-lskelcurv
-------------------------------------------------------------------------
-r76 | coupriem | 2009-11-04 07:23:24 +0100 (Wed, 04 Nov 2009) | 1 line
-
-lderiche,lderiche3d
-------------------------------------------------------------------------
-r75 | coupriem | 2009-11-01 10:54:29 +0100 (Sun, 01 Nov 2009) | 1 line
-
-pinktest.tcl
-------------------------------------------------------------------------
-r74 | coupriem | 2009-10-31 21:37:15 +0100 (Sat, 31 Oct 2009) | 1 line
-
-cor. bug skelsurf
-------------------------------------------------------------------------
-r73 | coupriem | 2009-10-31 08:24:33 +0100 (Sat, 31 Oct 2009) | 1 line
-
-lstat.h
-------------------------------------------------------------------------
-r72 | coupriem | 2009-10-31 08:23:36 +0100 (Sat, 31 Oct 2009) | 1 line
-
-identifyparabola.c
-------------------------------------------------------------------------
-r71 | coupriem | 2009-10-30 08:43:00 +0100 (Fri, 30 Oct 2009) | 1 line
-
-variance1, standarddeviation1, lstat
-------------------------------------------------------------------------
-r70 | coupriem | 2009-10-05 11:18:07 +0200 (Mon, 05 Oct 2009) | 1 line
-
-update inverse
-------------------------------------------------------------------------
-r69 | talboth | 2009-09-28 15:30:16 +0200 (Mon, 28 Sep 2009) | 1 line
-
-removed a few warnings
-------------------------------------------------------------------------
-r68 | coupriem | 2009-09-28 10:18:18 +0200 (Mon, 28 Sep 2009) | 1 line
-
-update simplepair - add minimalsimplepair
-------------------------------------------------------------------------
-r67 | coupriem | 2009-09-24 14:55:38 +0200 (Thu, 24 Sep 2009) | 1 line
-
-changing GCC -> __GNUC__
-------------------------------------------------------------------------
-r66 | coupriem | 2009-09-22 08:22:28 +0200 (Tue, 22 Sep 2009) | 1 line
-
-suppress values.h everywhere
-------------------------------------------------------------------------
-r65 | coupriem | 2009-09-21 20:26:41 +0200 (Mon, 21 Sep 2009) | 1 line
-
-add CeCILL header in .h files
-------------------------------------------------------------------------
-r64 | coupriem | 2009-09-21 20:23:34 +0200 (Mon, 21 Sep 2009) | 1 line
-
-add CeCILL header in tcl scripts
-------------------------------------------------------------------------
-r63 | coupriem | 2009-09-21 19:11:33 +0200 (Mon, 21 Sep 2009) | 1 line
-
-replace MAXFLOAT by FLT_MAX
-------------------------------------------------------------------------
-r62 | talboth | 2009-09-21 14:36:07 +0200 (Mon, 21 Sep 2009) | 1 line
-
-pour le probleme du values.h
-------------------------------------------------------------------------
-r61 | coupriem | 2009-09-20 19:00:18 +0200 (Sun, 20 Sep 2009) | 1 line
-
-add CeCILL headers
-------------------------------------------------------------------------
-r60 | coupriem | 2009-09-17 17:13:32 +0200 (Thu, 17 Sep 2009) | 1 line
-
-add some comments
-------------------------------------------------------------------------
-r59 | coupriem | 2009-09-17 16:38:26 +0200 (Thu, 17 Sep 2009) | 1 line
-
-fix bug mctopo3d
-------------------------------------------------------------------------
-r58 | najmanl | 2009-09-17 10:42:14 +0200 (Thu, 17 Sep 2009) | 1 line
-
-Scripts constrained connectivity 
-------------------------------------------------------------------------
-r57 | najmanl | 2009-09-16 14:46:01 +0200 (Wed, 16 Sep 2009) | 1 line
-
-Hierarchy of constrained connectivity - Ultrametric implementation
-------------------------------------------------------------------------
-r56 | coupriem | 2009-09-14 06:47:16 +0200 (Mon, 14 Sep 2009) | 1 line
-
-minor changes
-------------------------------------------------------------------------
-r55 | coupriem | 2009-09-11 16:59:10 +0200 (Fri, 11 Sep 2009) | 1 line
-
-more cleaning
-------------------------------------------------------------------------
-r54 | najmanl | 2009-09-11 16:19:43 +0200 (Fri, 11 Sep 2009) | 4 lines
-
-Correction pour cygwin
-- Ajout de values.h uniquement pour cygwin.
-Correction de pb de dÃ©pendences
-Correction de prototypes pas correctes pour mcgraphe.(c,h)
-------------------------------------------------------------------------
-r53 | coupriem | 2009-09-10 18:49:54 +0200 (Thu, 10 Sep 2009) | 1 line
-
-change UINT32_T to INT32_T
-------------------------------------------------------------------------
-r52 | coupriem | 2009-09-10 11:08:37 +0200 (Thu, 10 Sep 2009) | 1 line
-
-cleaning (finished) - last revision before changing ULONG to SLONG
-------------------------------------------------------------------------
-r51 | coupriem | 2009-09-09 22:19:05 +0200 (Wed, 09 Sep 2009) | 1 line
-
-cleaning (continued)
-------------------------------------------------------------------------
-r50 | coupriem | 2009-09-08 22:22:25 +0200 (Tue, 08 Sep 2009) | 1 line
-
-cleaning
-------------------------------------------------------------------------
-r49 | talboth | 2009-09-08 17:08:15 +0200 (Tue, 08 Sep 2009) | 1 line
-
-little more info
-------------------------------------------------------------------------
-r48 | mcouprie | 2009-09-08 11:06:02 +0200 (Tue, 08 Sep 2009) | 2 lines
-
-*** empty log message ***
-
-------------------------------------------------------------------------
-r47 | mcouprie | 2009-09-02 16:23:36 +0200 (Wed, 02 Sep 2009) | 2 lines
-
-last changes before migration to svn
-
-------------------------------------------------------------------------
-r46 | mcouprie | 2009-07-15 07:31:01 +0200 (Wed, 15 Jul 2009) | 2 lines
-
-adding graph2pgm.c 2dtopoflow.c
-
-------------------------------------------------------------------------
-r45 | mcouprie | 2009-07-10 07:43:29 +0200 (Fri, 10 Jul 2009) | 2 lines
-
-adding meanfilter
-
-------------------------------------------------------------------------
-r44 | htalbot | 2009-07-09 16:09:02 +0200 (Thu, 09 Jul 2009) | 2 lines
-
-added Fast Marching Method
-
-------------------------------------------------------------------------
-r43 | mcouprie | 2009-06-30 07:15:47 +0200 (Tue, 30 Jun 2009) | 2 lines
-
-3dsurfacecollapse.c
-
-------------------------------------------------------------------------
-r42 | mcouprie | 2009-06-29 11:10:50 +0200 (Mon, 29 Jun 2009) | 2 lines
-
-collapse
-
-------------------------------------------------------------------------
-r41 | mcouprie | 2009-06-24 07:32:12 +0200 (Wed, 24 Jun 2009) | 2 lines
-
-add 2dseltopo
-
-------------------------------------------------------------------------
-r40 | mcouprie | 2009-06-19 08:21:29 +0200 (Fri, 19 Jun 2009) | 2 lines
-
-*** empty log message ***
-
-------------------------------------------------------------------------
-r39 | mcouprie | 2009-06-18 08:34:55 +0200 (Thu, 18 Jun 2009) | 2 lines
-
-divers
-
-------------------------------------------------------------------------
-r38 | mcouprie | 2009-05-14 13:37:26 +0200 (Thu, 14 May 2009) | 2 lines
-
-add 2dview + divers
-
-------------------------------------------------------------------------
-r37 | mcouprie | 2009-03-29 12:08:10 +0200 (Sun, 29 Mar 2009) | 2 lines
-
-adding doc/images
-
-------------------------------------------------------------------------
-r36 | mcouprie | 2009-03-27 16:54:22 +0100 (Fri, 27 Mar 2009) | 2 lines
-
-*** empty log message ***
-
-------------------------------------------------------------------------
-r35 | mcouprie | 2009-03-27 16:40:25 +0100 (Fri, 27 Mar 2009) | 2 lines
-
-masks
-
-------------------------------------------------------------------------
-r34 | mcouprie | 2009-03-27 13:55:53 +0100 (Fri, 27 Mar 2009) | 2 lines
-
-delete segbi
-
-------------------------------------------------------------------------
-r33 | mcouprie | 2009-03-24 16:34:09 +0100 (Tue, 24 Mar 2009) | 2 lines
-
-3dmakepolygons
-
-------------------------------------------------------------------------
-r32 | mcouprie | 2009-03-24 15:50:25 +0100 (Tue, 24 Mar 2009) | 2 lines
-
-3dmakepolygons et mcpolygons
-
-------------------------------------------------------------------------
-r31 | mcouprie | 2009-03-23 13:45:35 +0100 (Mon, 23 Mar 2009) | 2 lines
-
-updating eden.c
-
-------------------------------------------------------------------------
-r30 | mcouprie | 2009-03-23 13:37:11 +0100 (Mon, 23 Mar 2009) | 2 lines
-
-adding eden.c and leden.[cxx,h]
-
-------------------------------------------------------------------------
-r29 | mcouprie | 2009-03-16 16:52:23 +0100 (Mon, 16 Mar 2009) | 2 lines
-
-nettoyage pour bibliothÃ¨que
-
-------------------------------------------------------------------------
-r28 | mcouprie | 2009-03-13 15:46:14 +0100 (Fri, 13 Mar 2009) | 2 lines
-
-effacement mcfahdouble et mcrbt1
-
-------------------------------------------------------------------------
-r27 | htalbot | 2009-03-12 16:50:01 +0100 (Thu, 12 Mar 2009) | 2 lines
-
-generic header
-
-------------------------------------------------------------------------
-r26 | mcouprie | 2009-03-05 16:50:20 +0100 (Thu, 05 Mar 2009) | 2 lines
-
-add src/com/lambdapmedialaxis.c
-
-------------------------------------------------------------------------
-r25 | mcouprie | 2009-03-03 11:53:16 +0100 (Tue, 03 Mar 2009) | 2 lines
-
-update lmedialaxis et lattribarea et divers
-
-------------------------------------------------------------------------
-r24 | mcouprie | 2009-02-19 08:44:08 +0100 (Thu, 19 Feb 2009) | 2 lines
-
-update larith, ajout average1 et fix bug redt
-
-------------------------------------------------------------------------
-r23 | mcouprie | 2009-02-11 14:57:51 +0100 (Wed, 11 Feb 2009) | 2 lines
-
-update mciomesh
-
-------------------------------------------------------------------------
-r22 | mcouprie | 2009-02-11 14:38:56 +0100 (Wed, 11 Feb 2009) | 2 lines
-
-update mcmesh et mcpolygons
-
-------------------------------------------------------------------------
-r21 | mcouprie | 2009-01-22 08:05:36 +0100 (Thu, 22 Jan 2009) | 2 lines
-
-fix des int32_t main + nouvelle fonction CheckComplex dans mcmesh.c
-
-------------------------------------------------------------------------
-r20 | lnajman | 2009-01-19 10:38:30 +0100 (Mon, 19 Jan 2009) | 2 lines
-
-GA2tikz
-
-------------------------------------------------------------------------
-r19 | lnajman | 2009-01-19 10:33:58 +0100 (Mon, 19 Jan 2009) | 2 lines
-
-Chgt d'allocation pour allocimage reporte dans jcimage.c
-
-------------------------------------------------------------------------
-r18 | mcouprie | 2009-01-12 09:59:38 +0100 (Mon, 12 Jan 2009) | 2 lines
-
-update 3dmakepolygons, mcmesh, mcpolygons
-
-------------------------------------------------------------------------
-r17 | lnajman | 2009-01-08 15:05:19 +0100 (Thu, 08 Jan 2009) | 2 lines
-
-Conflits de type avec gcc sous cygwin
-
-------------------------------------------------------------------------
-r16 | mcouprie | 2009-01-08 14:20:52 +0100 (Thu, 08 Jan 2009) | 2 lines
-
-update llpgm2GA.c
-
-------------------------------------------------------------------------
-r15 | mcouprie | 2009-01-07 16:39:11 +0100 (Wed, 07 Jan 2009) | 2 lines
-
-cor. bug lvoronoilabelling.c
-
-------------------------------------------------------------------------
-r14 | mcouprie | 2009-01-07 16:09:31 +0100 (Wed, 07 Jan 2009) | 2 lines
-
-cor. bug ldist.c
-
-------------------------------------------------------------------------
-r13 | mcouprie | 2009-01-07 13:46:35 +0100 (Wed, 07 Jan 2009) | 2 lines
-
-version propre pour g++
-
-------------------------------------------------------------------------
-r12 | mcouprie | 2009-01-06 14:18:28 +0100 (Tue, 06 Jan 2009) | 2 lines
-
-divers ajouts et updates - compatibilie g++
-
-------------------------------------------------------------------------
-r11 | mcouprie | 2008-12-19 14:10:43 +0100 (Fri, 19 Dec 2008) | 2 lines
-
-corrige bugs mctopo3d_table.c et recalagerigide_num.c
-
-------------------------------------------------------------------------
-r10 | mcouprie | 2008-12-15 08:01:27 +0100 (Mon, 15 Dec 2008) | 2 lines
-
-nettoyage des warnings
-
-------------------------------------------------------------------------
-r9 | mcouprie | 2008-12-15 07:38:50 +0100 (Mon, 15 Dec 2008) | 2 lines
-
-shortestpath et recalage rigide
-
-------------------------------------------------------------------------
-r8 | mcouprie | 2008-12-11 14:46:16 +0100 (Thu, 11 Dec 2008) | 2 lines
-
-adding affine.c
-
-------------------------------------------------------------------------
-r7 | mcouprie | 2008-12-03 08:42:31 +0100 (Wed, 03 Dec 2008) | 2 lines
-
-maj. lbresen et autres
-
-------------------------------------------------------------------------
-r6 | mcouprie | 2008-12-01 14:20:03 +0100 (Mon, 01 Dec 2008) | 2 lines
-
-adding lballincl
-
-------------------------------------------------------------------------
-r5 | mcouprie | 2008-11-27 10:29:55 +0100 (Thu, 27 Nov 2008) | 2 lines
-
-adding tcl/insert.tcl
-
-------------------------------------------------------------------------
-r3 | mcouprie | 2008-11-25 09:02:37 +0100 (Tue, 25 Nov 2008) | 3 lines
-
-This commit was generated by cvs2svn to compensate for changes in r2,
-which included commits to RCS files with non-trunk default branches.
-
-------------------------------------------------------------------------
-r1 | (no author) | 2008-11-25 09:02:37 +0100 (Tue, 25 Nov 2008) | 1 line
-
-New repository initialized by cvs2svn.
-------------------------------------------------------------------------
diff -r 8b1af7363833 makefile
--- a/makefile	Sat May 25 21:53:33 2013 +0200
+++ b/makefile	Mon Jan 13 15:50:10 2014 +0100
@@ -308,6 +308,7 @@
 $(BDIR)/skel_ACK3_pers \
 $(BDIR)/skel_AK2 \
 $(BDIR)/skel_AMK \
+$(BDIR)/skel_CK2_pers \
 $(BDIR)/skel_CK3 \
 $(BDIR)/skel_CK3a \
 $(BDIR)/skel_CK3p \
@@ -1502,7 +1503,7 @@
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/hthiniso.c $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mctopo.o $(ODIR)/lhthiniso.o $(LIBS) -o $(BDIR)/hthiniso
 
 $(BDIR)/hthinpar:	$(CDIR)/hthinpar.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/lskelpar.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mctopo.o $(ODIR)/lskelpar.o 
-	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/hthinpar.c $(OBJ_COMMON) $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar.o $(ODIR)/mclifo.o $(LIBS) -o $(BDIR)/hthinpar
+	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/hthinpar.c $(OBJ_COMMON) $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/hthinpar
 
 $(BDIR)/htkern:	$(CDIR)/htkern.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mcindic.h $(IDIR)/mcfah.h $(IDIR)/mclifo.h $(IDIR)/lhisto.h $(IDIR)/llabelextrema.h $(IDIR)/lhtkern.h $(IDIR)/lhtkern3d.h $(OBJ_COMMON) $(ODIR)/libpink.a
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/htkern.c $(OBJ_COMMON) $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/htkern
@@ -1649,7 +1650,7 @@
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_ACK3_pers.c $(OBJ_COMMON) $(ODIR)/mctopo3d.o $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar3d.o $(ODIR)/mclifo.o $(ODIR)/mcindic.o $(ODIR)/mcrlifo.o $(LIBS) -o $(BDIR)/skel_ACK3_pers
 
 $(BDIR)/skel_AK2:	$(CDIR)/skel_AK2.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/lskelpar.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mctopo.o $(ODIR)/lskelpar.o 
-	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_AK2.c $(OBJ_COMMON) $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar.o $(ODIR)/mclifo.o $(LIBS) -o $(BDIR)/skel_AK2
+	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_AK2.c $(OBJ_COMMON) $(ODIR)/libpink.a -o $(BDIR)/skel_AK2
 
 $(BDIR)/skel_AMK:	$(CDIR)/skel_AMK.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mcindic.h $(IDIR)/lskelpar3d.h $(IDIR)/ldist.h $(IDIR)/mcgeo.h $(IDIR)/lmedialaxis.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mcindic.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/lballincl.o $(ODIR)/lmedialaxis.o $(ODIR)/avsimage.o $(ODIR)/llut.o $(ODIR)/ltopotypes.o $(ODIR)/lskelpar3d.o $(ODIR)/lskelpar.o $(ODIR)/mcrlifo.o
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_AMK.c $(OBJ_COMMON) $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar.o $(ODIR)/lskelpar3d.o $(ODIR)/mcindic.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/lballincl.o $(ODIR)/lmedialaxis.o $(ODIR)/avsimage.o $(ODIR)/llut.o $(ODIR)/ltopotypes.o $(ODIR)/mcrlifo.o $(LIBS) -o $(BDIR)/skel_AMK
@@ -1669,6 +1670,9 @@
 $(BDIR)/skel_CKG:	$(CDIR)/skel_CKG.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mctopo3d.h $(IDIR)/mckhalimsky3d.h $(IDIR)/mcindic.h $(IDIR)/lskeletons.h $(IDIR)/ldist.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mckhalimsky3d.o $(ODIR)/mcindic.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/mcrlifo.o $(ODIR)/lskeletons.o $(ODIR)/bdd1.alphacube.o $(ODIR)/bdd2.alpha.o $(ODIR)/bdd2.beta.o $(ODIR)/bdd3.o 
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_CKG.c $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_CKG
 
+$(BDIR)/skel_CK2_pers:	$(CDIR)/skel_CK2_pers.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mctopo3d.h $(IDIR)/mckhalimsky3d.h $(IDIR)/mcindic.h $(IDIR)/lskeletons.h $(IDIR)/ldist.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mckhalimsky3d.o $(ODIR)/mcindic.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/mcrlifo.o $(ODIR)/lskeletons.o $(ODIR)/bdd1.alphacube.o $(ODIR)/bdd2.alpha.o $(ODIR)/bdd2.beta.o $(ODIR)/bdd3.o $(ODIR)/libpink.a
+	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_CK2_pers.c $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_CK2_pers
+
 $(BDIR)/skel_CKG_map:	$(CDIR)/skel_CKG_map.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mctopo3d.h $(IDIR)/mckhalimsky3d.h $(IDIR)/mcindic.h $(IDIR)/lskeletons.h $(IDIR)/ldist.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mckhalimsky3d.o $(ODIR)/mcindic.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/mcrlifo.o $(ODIR)/lskeletons.o $(ODIR)/bdd1.alphacube.o $(ODIR)/bdd2.alpha.o $(ODIR)/bdd2.beta.o $(ODIR)/bdd3.o 
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_CKG_map.c $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_CKG_map
 
@@ -1679,13 +1683,13 @@
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_EK3.c $(OBJ_COMMON) $(ODIR)/mctopo3d.o $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar3d.o $(ODIR)/mclifo.o $(ODIR)/mcindic.o $(ODIR)/mcrlifo.o $(LIBS) -o $(BDIR)/skel_EK3
 
 $(BDIR)/skel_MK2:	$(CDIR)/skel_MK2.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/lskelpar.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mctopo.o $(ODIR)/lskelpar.o 
-	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_MK2.c $(OBJ_COMMON) $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar.o $(ODIR)/mclifo.o $(LIBS) -o $(BDIR)/skel_MK2
+	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_MK2.c $(OBJ_COMMON) $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_MK2
 
 $(BDIR)/skel_MK3:	$(CDIR)/skel_MK3.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/lskelpar3d.h $(IDIR)/mctopo3d.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mctopo3d.o $(ODIR)/mctopo.o $(ODIR)/lskelpar3d.o $(ODIR)/mcindic.o $(ODIR)/mcrlifo.o 
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_MK3.c $(OBJ_COMMON) $(ODIR)/mctopo3d.o $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar3d.o $(ODIR)/mclifo.o $(ODIR)/mcindic.o $(ODIR)/mcrlifo.o $(LIBS) -o $(BDIR)/skel_MK3
 
 $(BDIR)/skel_NK2:	$(CDIR)/skel_NK2.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/lskelpar.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mctopo.o $(ODIR)/lskelpar.o 
-	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_NK2.c $(OBJ_COMMON) $(ODIR)/mctopo.o $(ODIR)/mccodimage.o $(ODIR)/lskelpar.o $(ODIR)/mclifo.o $(LIBS) -o $(BDIR)/skel_NK2
+	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_NK2.c $(OBJ_COMMON) $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_NK2
 
 $(BDIR)/skel_PSG:	$(CDIR)/skel_PSG.c $(IDIR)/mcimage.h $(IDIR)/mccodimage.h $(IDIR)/mctopo.h $(IDIR)/mctopo3d.h $(IDIR)/mckhalimsky3d.h $(IDIR)/mcindic.h $(IDIR)/lskeletons.h $(IDIR)/ldist.h $(OBJ_COMMON) $(ODIR)/mccodimage.o $(ODIR)/mclifo.o $(ODIR)/mcfifo.o $(ODIR)/mctopo.o $(ODIR)/mctopo3d.o $(ODIR)/mckhalimsky3d.o $(ODIR)/mcindic.o $(ODIR)/mcrbt.o $(ODIR)/mcgeo.o $(ODIR)/ldist.o $(ODIR)/mcrlifo.o $(ODIR)/lskeletons.o $(ODIR)/bdd1.alphacube.o $(ODIR)/bdd2.alpha.o $(ODIR)/bdd2.beta.o $(ODIR)/bdd3.o 
 	$(CC) $(CCFLAGS) -I$(IDIR) $(CDIR)/skel_PSG.c $(ODIR)/libpink.a $(LIBS) -o $(BDIR)/skel_PSG
diff -r 8b1af7363833 masks/cercle12.pgm
--- a/masks/cercle12.pgm	Sat May 25 21:53:33 2013 +0200
+++ b/masks/cercle12.pgm	Mon Jan 13 15:50:10 2014 +0100
@@ -1,6 +1,5 @@
 P2
-# CREATOR: writeimage by MC - 07/1996
-##genbini() rayon 6 centre 5 5
+#origin 5 5
 12 12
 255
 
diff -r 8b1af7363833 masks/voisb
--- a/masks/voisb	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,7 +0,0 @@
-P2
-#origin 0 1
-##sym(voisd,c)
-1 2
-255
-1
-1
diff -r 8b1af7363833 python/pink/__init__.pyc
Binary file python/pink/__init__.pyc has changed
diff -r 8b1af7363833 python/pink/cpp/__init__.pyc
Binary file python/pink/cpp/__init__.pyc has changed
diff -r 8b1af7363833 python/pink/exceptions.pyc
Binary file python/pink/exceptions.pyc has changed
diff -r 8b1af7363833 python/pink/histo.pyc
Binary file python/pink/histo.pyc has changed
diff -r 8b1af7363833 python/pink/imview.pyc
Binary file python/pink/imview.pyc has changed
diff -r 8b1af7363833 python/pink/isize.pyc
Binary file python/pink/isize.pyc has changed
diff -r 8b1af7363833 python/pink/manipulate.pyc
Binary file python/pink/manipulate.pyc has changed
diff -r 8b1af7363833 python/pink/pil_photoimage.pyc
Binary file python/pink/pil_photoimage.pyc has changed
diff -r 8b1af7363833 python/pink/render.pyc
Binary file python/pink/render.pyc has changed
diff -r 8b1af7363833 python/pink/seuilmesh.pyc
Binary file python/pink/seuilmesh.pyc has changed
diff -r 8b1af7363833 python/pink/view3d.pyc
Binary file python/pink/view3d.pyc has changed
diff -r 8b1af7363833 python/pink/windowing.pyc
Binary file python/pink/windowing.pyc has changed
diff -r 8b1af7363833 python/pinktest/__init__.pyc
Binary file python/pinktest/__init__.pyc has changed
diff -r 8b1af7363833 python/pinktest/__init__.py~
--- a/python/pinktest/__init__.py~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,74 +0,0 @@
-# -*- coding: utf-8 -*-
-# 
-# This software is licensed under 
-# CeCILL FREE SOFTWARE LICENSE AGREEMENT
-
-# This software comes in hope that it will be useful but 
-# without any warranty to the extent permitted by applicable law.
-  
-# (C) UjoImro <ujoimro@gmail.com>, 2012
-# ProCarPlan s.r.o.
-
-## The unit test framework
-# from 2dcollapse import *
-# from 2dkhalimskize import *
-# from 3dcollapse import *
-# from 3dkhalimskize import *
-from areaopening import *
-from areaselnb import *
-from bisector import *
-from closeball import *
-from curve2segments import *
-from curve2spline import *
-from dilatball import *
-from dilation import *
-from drawline import *
-from drawspline import *
-from drawsplines import *
-from erosball import *
-from erosion import *
-from float2byte import *
-from gaussianfilter import *
-from geodilat import *
-from gradientcd import *
-from heightmaxima import *
-from heightminima import *
-from heightselnb import *
-from holeclosing import *
-from identifyline import *
-from identifyparabola2 import *
-from identifyparabola3 import *
-from label import *
-from labelfgd import *
-from lambdamedialaxis import *
-from lambdamedialaxisauto import *
-from long2byte import *
-from medialaxis import *
-from medianfilter import *
-from openball import *
-from pca import *
-from pgm2curve import *
-from pgm2skel import *
-from points2spline import *
-from rankfilter import *
-from redt import *
-from rotate3dbin import *
-from rotatebin import *
-from segmentarea import *
-from segmentheight import *
-from segmentvol import *
-from seuil import *
-from skelcurv import *
-from skeleton import *
-from skelfindelbows import *
-from skelpar import *
-from skelpar3d import *
-from skelpruning import *
-from skelsurf import *
-from skelvertex import *
-from volmaxima import *
-from volselnb import *
-from watershed import *
-from zoom import *
-
-#LuM end of file
diff -r 8b1af7363833 python/pinktest/areaopening.pyc
Binary file python/pinktest/areaopening.pyc has changed
diff -r 8b1af7363833 python/pinktest/areaopening.py~
--- a/python/pinktest/areaopening.py~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,56 +0,0 @@
-# -*- coding: utf-8 -*- 
-#  
-# This software is licensed under  
-# CeCILL FREE SOFTWARE LICENSE AGREEMENT 
- 
-# This software comes in hope that it will be useful but  
-# without any warranty to the extent permitted by applicable law. 
-   
-# (C) UjoImro <ujoimro@gmail.com>, 2012 
-# ProCarPlan s.r.o. 
- 
-import os 
-import pink 
-import unittest 
-import xmlrunner 
- 
-try:   
-    IMAGES  = os.environ["PINKTEST"] + "/images" 
-    RESULTS = os.environ["PINKTEST"] + "/results_prev" 
-except KeyError:  
-    raise Exception, "PINKTEST environment variable must be defined for the testing module. It must point to the testimages directory" 
-
-
-class areaopening(unittest.TestCase):
-    def test_0(self):
-        result = pink.cpp.areaopening( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2gel.pgm' ), 4, 20)
-        gold   = pink.cpp.readimage( RESULTS + '/areaopening_g2gel_4_20.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_1(self):
-        result = pink.cpp.areaopening( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2gel.pgm' ), 8, 20)
-        gold   = pink.cpp.readimage( RESULTS + '/areaopening_g2gel_8_20.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_2(self):
-        result = pink.cpp.areaopening( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 6, 20)
-        gold   = pink.cpp.readimage( RESULTS + '/areaopening_g3a_6_20.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_3(self):
-        result = pink.cpp.areaopening( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 18, 20)
-        gold   = pink.cpp.readimage( RESULTS + '/areaopening_g3a_18_20.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_4(self):
-        result = pink.cpp.areaopening( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 26, 20)
-        gold   = pink.cpp.readimage( RESULTS + '/areaopening_g3a_26_20.pgm')
-        self.assertTrue( result == gold )
-
-
-if __name__ == '__main__':
-    unittest.main(testRunner=xmlrunner.XMLTestRunner(output='test-reports'))
diff -r 8b1af7363833 python/pinktest/areaselnb.pyc
Binary file python/pinktest/areaselnb.pyc has changed
diff -r 8b1af7363833 python/pinktest/bisector.pyc
Binary file python/pinktest/bisector.pyc has changed
diff -r 8b1af7363833 python/pinktest/bisector.py~
--- a/python/pinktest/bisector.py~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,33 +0,0 @@
-# -*- coding: utf-8 -*- 
-#  
-# This software is licensed under  
-# CeCILL FREE SOFTWARE LICENSE AGREEMENT 
- 
-# This software comes in hope that it will be useful but  
-# without any warranty to the extent permitted by applicable law. 
-   
-# (C) UjoImro <ujoimro@gmail.com>, 2012 
-# ProCarPlan s.r.o. 
- 
-import os 
-import pink 
-import unittest 
-import xmlrunner 
- 
-try:   
-    IMAGES  = os.environ["PINKTEST"] + "/images" 
-    RESULTS = os.environ["PINKTEST"] + "/results_prev" 
-except KeyError:  
-    raise Exception, "PINKTEST environment variable must be defined for the testing module. It must point to the testimages directory" 
-
-
-class bisector(unittest.TestCase):
-    def test_0(self):
-        lead   = pink.cpp.readimage( IMAGES + '/2dlong/l2fish1.pgm' )
-        result = bisector( lead , %IMAGES/2dbyte/binary/b2fish1.pgm)
-        gold   = pink.cpp.readimage( RESULTS + '/bisector_b2fish1.pgm')
-        self.assertTrue( result == gold )
-
-
-if __name__ == '__main__':
-    unittest.main(testRunner=xmlrunner.XMLTestRunner(output='test-reports'))
diff -r 8b1af7363833 python/pinktest/closeball.pyc
Binary file python/pinktest/closeball.pyc has changed
diff -r 8b1af7363833 python/pinktest/curve2segments.pyc
Binary file python/pinktest/curve2segments.pyc has changed
diff -r 8b1af7363833 python/pinktest/curve2spline.pyc
Binary file python/pinktest/curve2spline.pyc has changed
diff -r 8b1af7363833 python/pinktest/dilatball.pyc
Binary file python/pinktest/dilatball.pyc has changed
diff -r 8b1af7363833 python/pinktest/dilatball.py~
--- a/python/pinktest/dilatball.py~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,128 +0,0 @@
-# -*- coding: utf-8 -*- 
-#  
-# This software is licensed under  
-# CeCILL FREE SOFTWARE LICENSE AGREEMENT 
- 
-# This software comes in hope that it will be useful but  
-# without any warranty to the extent permitted by applicable law. 
-   
-# (C) UjoImro <ujoimro@gmail.com>, 2012 
-# ProCarPlan s.r.o. 
- 
-import os 
-import pink 
-import unittest 
-import xmlrunner 
- 
-try:   
-    IMAGES  = os.environ["PINKTEST"] + "/images" 
-    RESULTS = os.environ["PINKTEST"] + "/results_prev" 
-except KeyError:  
-    raise Exception, "PINKTEST environment variable must be defined for the testing module. It must point to the testimages directory" 
-
-
-class dilatball(unittest.TestCase):
-    def test_0(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 3, 0)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_b2hebreu_3_0.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_1(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 15, 2)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_b2hebreu_15_2.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_2(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 3, 3)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_b2hebreu_3_3.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_3(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 3, 4)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_b2hebreu_3_4.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_4(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 3, 8)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_b2hebreu_3_8.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_5(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/2dlong/l2fish1ma3.pgm' ), -1, 3)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_l2fish1ma3__1_3.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_6(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/2dlong/l2fish1ma4.pgm' ), -1, 4)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_l2fish1ma4__1_4.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_7(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/2dlong/l2fish1ma8.pgm' ), -1, 8)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_l2fish1ma8__1_8.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_8(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 3, 0)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_b3a_3_0.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_9(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 15, 2)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_b3a_15_2.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_10(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 3, 3)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_b3a_3_3.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_11(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 3, 6)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_b3a_3_6.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_12(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 3, 18)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_b3a_3_18.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_13(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 3, 26)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_b3a_3_26.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_14(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/3dlong/l3mortierma3.pgm' ), -1, 3)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_l3mortierma3__1_3.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_15(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/3dlong/l3mortierma6.pgm' ), -1, 6)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_l3mortierma6__1_6.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_16(self):
-        result = pink.cpp.dilatball( pink.cpp.readimage( IMAGES + '/3dlong/l3mortierma26.pgm' ), -1, 26)
-        gold   = pink.cpp.readimage( RESULTS + '/dilatball_l3mortierma26__1_26.pgm')
-        self.assertTrue( result == gold )
-
-
-if __name__ == '__main__':
-    unittest.main(testRunner=xmlrunner.XMLTestRunner(output='test-reports'))
diff -r 8b1af7363833 python/pinktest/dilation.pyc
Binary file python/pinktest/dilation.pyc has changed
diff -r 8b1af7363833 python/pinktest/drawline.pyc
Binary file python/pinktest/drawline.pyc has changed
diff -r 8b1af7363833 python/pinktest/drawspline.pyc
Binary file python/pinktest/drawspline.pyc has changed
diff -r 8b1af7363833 python/pinktest/drawsplines.pyc
Binary file python/pinktest/drawsplines.pyc has changed
diff -r 8b1af7363833 python/pinktest/erosball.pyc
Binary file python/pinktest/erosball.pyc has changed
diff -r 8b1af7363833 python/pinktest/erosion.pyc
Binary file python/pinktest/erosion.pyc has changed
diff -r 8b1af7363833 python/pinktest/float2byte.pyc
Binary file python/pinktest/float2byte.pyc has changed
diff -r 8b1af7363833 python/pinktest/gaussianfilter.pyc
Binary file python/pinktest/gaussianfilter.pyc has changed
diff -r 8b1af7363833 python/pinktest/geodilat.pyc
Binary file python/pinktest/geodilat.pyc has changed
diff -r 8b1af7363833 python/pinktest/gradientcd.pyc
Binary file python/pinktest/gradientcd.pyc has changed
diff -r 8b1af7363833 python/pinktest/heightmaxima.pyc
Binary file python/pinktest/heightmaxima.pyc has changed
diff -r 8b1af7363833 python/pinktest/heightminima.pyc
Binary file python/pinktest/heightminima.pyc has changed
diff -r 8b1af7363833 python/pinktest/heightselnb.pyc
Binary file python/pinktest/heightselnb.pyc has changed
diff -r 8b1af7363833 python/pinktest/holeclosing.pyc
Binary file python/pinktest/holeclosing.pyc has changed
diff -r 8b1af7363833 python/pinktest/identifyline.pyc
Binary file python/pinktest/identifyline.pyc has changed
diff -r 8b1af7363833 python/pinktest/identifyparabola2.pyc
Binary file python/pinktest/identifyparabola2.pyc has changed
diff -r 8b1af7363833 python/pinktest/identifyparabola3.pyc
Binary file python/pinktest/identifyparabola3.pyc has changed
diff -r 8b1af7363833 python/pinktest/label.pyc
Binary file python/pinktest/label.pyc has changed
diff -r 8b1af7363833 python/pinktest/labelfgd.pyc
Binary file python/pinktest/labelfgd.pyc has changed
diff -r 8b1af7363833 python/pinktest/lambdamedialaxis.pyc
Binary file python/pinktest/lambdamedialaxis.pyc has changed
diff -r 8b1af7363833 python/pinktest/lambdamedialaxisauto.pyc
Binary file python/pinktest/lambdamedialaxisauto.pyc has changed
diff -r 8b1af7363833 python/pinktest/long2byte.pyc
Binary file python/pinktest/long2byte.pyc has changed
diff -r 8b1af7363833 python/pinktest/medialaxis.pyc
Binary file python/pinktest/medialaxis.pyc has changed
diff -r 8b1af7363833 python/pinktest/medianfilter.pyc
Binary file python/pinktest/medianfilter.pyc has changed
diff -r 8b1af7363833 python/pinktest/numpymodule.py~
--- a/python/pinktest/numpymodule.py~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,119 +0,0 @@
-# -*- coding: utf-8 -*- 
-#  
-# This software is licensed under  
-# CeCILL FREE SOFTWARE LICENSE AGREEMENT 
- 
-# This software comes in hope that it will be useful but  
-# without any warranty to the extent permitted by applicable law. 
-   
-# (C) UjoImro <ujoimro@gmail.com>, 2012 
-# ProCarPlan s.r.o. 
-
-## unittest for the NumPy wrapper in Python 
-
-import os 
-import pink 
-import numpy
-import random
-import unittest 
-import xmlrunner 
- 
-try:   
-    IMAGES  = os.environ["PINKTEST"] + "/images" 
-    RESULTS = os.environ["PINKTEST"] + "/results_prev" 
-except KeyError:  
-    raise Exception, "PINKTEST environment variable must be defined for the testing module. It must point to the testimages directory" 
-
-
-class numpymodule(unittest.TestCase):
-    def test_static(self): ## simple static test
-
-        ## Part 1 true copy from pink to numpy
-        I = pink.cpp.char_image([10, 14]);
-        A = pink.cpp.pink2numpy(I); # this command makes a true copy
-        self.assertTrue( A.dtype == numpy.uint8 )
-        I[[2,3]]=10
-        A[2,3]=207
-        self.assertTrue( I[[2,3]] == 10 )
-        self.assertTrue( A[2,3] == 207 )
-
-        ## Part 2 true copy from numpy to pink
-        B = numpy.ones([44,20], dtype=numpy.float32)
-        J = pink.cpp.numpy2pink(B)
-        self.assertTrue( J.imtype() == 'float' )
-        B[4,5]=1.1
-        I[[4,5]]=-7
-        self.assertTrue( B[4,5] == 1.1 )
-        self.assertTrue( I[[4,5]] == -7 )
-        
-        ## Part 3 wrapper
-        J = pink.cpp.int_image([90, 100])
-        C = pink.cpp.wrap2numpy(J)
-        
-        J[[4,5]] = -111
-        C[4,5] = 91
-        self.assertTrue( J[[4,5]] == 91 )
-        self.assertTrue( C[4,5] == 91 )
-
-        C[9,3]=-1424
-        J[[9,3]]=-33
-        self.assertTrue( C[9,3]==-33 )
-        self.assertTrue( J[[9,3]] == -33)
-        
-    def test_dynamic(self): ## test with random matrices
-        
-        size = [ random.randint(200,300), random.randint(300, 400) ]
-
-        I = pink.cpp.int_image(size);
-
-        print("filling up the matrix with random data")
-
-        for q in range(size[0]):
-            for w in range(size[1]):
-                I[[q,w]] = random.randint(-1000,1000)
-
-        print("Copy invariance")
-        A = pink.cpp.pink2numpy(I)
-        J = pink.cpp.numpy2pink(A)
-
-        self.assertTrue( I==J )
-
-        A[[199, 144]] = 23232
-        J[[199, 144]] = -11231
-        I[[199, 144]] = 434
-
-        self.assertTrue( A[199, 144] == 23232 )
-        self.assertTrue( J[[ 199, 144]] == -11231 )
-        self.assertTrue( I[[ 199, 144]] == 434 )
-
-        print("Wrapper")
-        B = pink.cpp.wrap2numpy(I)
-        for q in range(size[0]):
-            for w in range(size[1]):
-                B[q,w] = random.randint(-1000,1000)
-        
-        J = pink.cpp.numpy2pink(B)
-
-        self.assertTrue(J==I)
-
-    def test_garbage_collection(self): ## this would only work if the image is properly destroyed in each iteration
-        size = [ random.randint(200,300), random.randint(300, 400) ]
-
-        I = pink.cpp.int_image(size);
-
-        print("filling up the matrix with random data")
-
-        for q in range(size[0]):
-            for w in range(size[1]):
-                I[[q,w]] = random.randint(-1000,1000)
-        
-
-        for q in range(1000):
-            B = pink.cpp.pink2numpy(I)
-
-        self.assertTrue(True) ## if it gets up here, the memory was never filled
-
-
-
-if __name__ == '__main__':
-    unittest.main(testRunner=xmlrunner.XMLTestRunner(output='test-reports'))
diff -r 8b1af7363833 python/pinktest/openball.pyc
Binary file python/pinktest/openball.pyc has changed
diff -r 8b1af7363833 python/pinktest/pca.pyc
Binary file python/pinktest/pca.pyc has changed
diff -r 8b1af7363833 python/pinktest/pgm2curve.pyc
Binary file python/pinktest/pgm2curve.pyc has changed
diff -r 8b1af7363833 python/pinktest/pgm2skel.pyc
Binary file python/pinktest/pgm2skel.pyc has changed
diff -r 8b1af7363833 python/pinktest/points2spline.pyc
Binary file python/pinktest/points2spline.pyc has changed
diff -r 8b1af7363833 python/pinktest/rankfilter.pyc
Binary file python/pinktest/rankfilter.pyc has changed
diff -r 8b1af7363833 python/pinktest/redt.pyc
Binary file python/pinktest/redt.pyc has changed
diff -r 8b1af7363833 python/pinktest/rotate3dbin.pyc
Binary file python/pinktest/rotate3dbin.pyc has changed
diff -r 8b1af7363833 python/pinktest/rotatebin.pyc
Binary file python/pinktest/rotatebin.pyc has changed
diff -r 8b1af7363833 python/pinktest/segmentarea.pyc
Binary file python/pinktest/segmentarea.pyc has changed
diff -r 8b1af7363833 python/pinktest/segmentheight.pyc
Binary file python/pinktest/segmentheight.pyc has changed
diff -r 8b1af7363833 python/pinktest/segmentvol.pyc
Binary file python/pinktest/segmentvol.pyc has changed
diff -r 8b1af7363833 python/pinktest/seuil.pyc
Binary file python/pinktest/seuil.pyc has changed
diff -r 8b1af7363833 python/pinktest/seuil.py~
--- a/python/pinktest/seuil.py~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-# -*- coding: utf-8 -*- 
-#  
-# This software is licensed under  
-# CeCILL FREE SOFTWARE LICENSE AGREEMENT 
- 
-# This software comes in hope that it will be useful but  
-# without any warranty to the extent permitted by applicable law. 
-   
-# (C) UjoImro <ujoimro@gmail.com>, 2012 
-# ProCarPlan s.r.o. 
- 
-import os 
-import pink 
-import unittest 
-import xmlrunner 
- 
-try:   
-    IMAGES  = os.environ["PINKTEST"] + "/images" 
-    RESULTS = os.environ["PINKTEST"] + "/results_prev" 
-except KeyError:  
-    raise Exception, "PINKTEST environment variable must be defined for the testing module. It must point to the testimages directory" 
-
-
-class seuil(unittest.TestCase):
-    def test_0(self):
-        result = pink.cpp.seuil( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2fish1.pgm' ), 3)
-        gold   = pink.cpp.readimage( RESULTS + '/seuil_g2fish1_3.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_1(self):
-        result = pink.cpp.seuil( pink.cpp.readimage( IMAGES + '/2dlong/l2fish1.pgm' ), 3)
-        gold   = pink.cpp.readimage( RESULTS + '/seuil_l2fish1_3.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_2(self):
-        result = pink.cpp.seuil( pink.cpp.readimage( IMAGES + '/2dfloat/f2fish1.pgm' ), 3)
-        gold   = pink.cpp.readimage( RESULTS + '/seuil_f2fish1_3.pgm')
-        self.assertTrue( result == gold )
-
-
-if __name__ == '__main__':
-    unittest.main(testRunner=xmlrunner.XMLTestRunner(output='test-reports'))
diff -r 8b1af7363833 python/pinktest/skelcurv.pyc
Binary file python/pinktest/skelcurv.pyc has changed
diff -r 8b1af7363833 python/pinktest/skeleton.pyc
Binary file python/pinktest/skeleton.pyc has changed
diff -r 8b1af7363833 python/pinktest/skelfindelbows.pyc
Binary file python/pinktest/skelfindelbows.pyc has changed
diff -r 8b1af7363833 python/pinktest/skelpar.pyc
Binary file python/pinktest/skelpar.pyc has changed
diff -r 8b1af7363833 python/pinktest/skelpar3d.pyc
Binary file python/pinktest/skelpar3d.pyc has changed
diff -r 8b1af7363833 python/pinktest/skelpruning.pyc
Binary file python/pinktest/skelpruning.pyc has changed
diff -r 8b1af7363833 python/pinktest/skelsurf.pyc
Binary file python/pinktest/skelsurf.pyc has changed
diff -r 8b1af7363833 python/pinktest/skelvertex.pyc
Binary file python/pinktest/skelvertex.pyc has changed
diff -r 8b1af7363833 python/pinktest/volmaxima.pyc
Binary file python/pinktest/volmaxima.pyc has changed
diff -r 8b1af7363833 python/pinktest/volselnb.pyc
Binary file python/pinktest/volselnb.pyc has changed
diff -r 8b1af7363833 python/pinktest/watershed.pyc
Binary file python/pinktest/watershed.pyc has changed
diff -r 8b1af7363833 python/pinktest/watershed.py~
--- a/python/pinktest/watershed.py~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,38 +0,0 @@
-# -*- coding: utf-8 -*- 
-#  
-# This software is licensed under  
-# CeCILL FREE SOFTWARE LICENSE AGREEMENT 
- 
-# This software comes in hope that it will be useful but  
-# without any warranty to the extent permitted by applicable law. 
-   
-# (C) UjoImro <ujoimro@gmail.com>, 2012 
-# ProCarPlan s.r.o. 
- 
-import os 
-import pink 
-import unittest 
-import xmlrunner 
- 
-try:   
-    IMAGES  = os.environ["PINKTEST"] + "/images" 
-    RESULTS = os.environ["PINKTEST"] + "/results_prev" 
-except KeyError:  
-    raise Exception, "PINKTEST environment variable must be defined for the testing module. It must point to the testimages directory" 
-
-
-class watershed(unittest.TestCase):
-    def test_0(self):
-        result = pink.cpp.watershed( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2relief.pgm' ), pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2marqueur.pgm' ), 4)
-        gold   = pink.cpp.readimage( RESULTS + '/watershed_g2relief_b2marqueur_4.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_1(self):
-        result = pink.cpp.watershed( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2relief.pgm' ), pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2marqueur.pgm' ), 8)
-        gold   = pink.cpp.readimage( RESULTS + '/watershed_g2relief_b2marqueur_8.pgm')
-        self.assertTrue( result == gold )
-
-
-if __name__ == '__main__':
-    unittest.main(testRunner=xmlrunner.XMLTestRunner(output='test-reports'))
diff -r 8b1af7363833 python/pinktest/zoom.pyc
Binary file python/pinktest/zoom.pyc has changed
diff -r 8b1af7363833 python/pinktest/zoom.py~
--- a/python/pinktest/zoom.py~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,74 +0,0 @@
-# -*- coding: utf-8 -*- 
-#  
-# This software is licensed under  
-# CeCILL FREE SOFTWARE LICENSE AGREEMENT 
- 
-# This software comes in hope that it will be useful but  
-# without any warranty to the extent permitted by applicable law. 
-   
-# (C) UjoImro <ujoimro@gmail.com>, 2012 
-# ProCarPlan s.r.o. 
- 
-import os 
-import pink 
-import unittest 
-import xmlrunner 
- 
-try:   
-    IMAGES  = os.environ["PINKTEST"] + "/images" 
-    RESULTS = os.environ["PINKTEST"] + "/results_prev" 
-except KeyError:  
-    raise Exception, "PINKTEST environment variable must be defined for the testing module. It must point to the testimages directory" 
-
-
-class zoom(unittest.TestCase):
-    def test_0(self):
-        result = pink.cpp.zoom( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 0.7)
-        gold   = pink.cpp.readimage( RESULTS + '/zoom_b2hebreu_07.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_1(self):
-        result = pink.cpp.zoom( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 1.7)
-        gold   = pink.cpp.readimage( RESULTS + '/zoom_b2hebreu_17.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_2(self):
-        result = pink.cpp.zoom( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), x, 100)
-        gold   = pink.cpp.readimage( RESULTS + '/zoom_b2hebreu_x_100.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_3(self):
-        result = pink.cpp.zoom( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 0.5, 0.25, 1)
-        gold   = pink.cpp.readimage( RESULTS + '/zoom_b2hebreu_05_025_1.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_4(self):
-        result = pink.cpp.zoom( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 0.7)
-        gold   = pink.cpp.readimage( RESULTS + '/zoom_b3a_07.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_5(self):
-        result = pink.cpp.zoom( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 1.7)
-        gold   = pink.cpp.readimage( RESULTS + '/zoom_b3a_17.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_6(self):
-        result = pink.cpp.zoom( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), x, 100)
-        gold   = pink.cpp.readimage( RESULTS + '/zoom_b3a_x_100.pgm')
-        self.assertTrue( result == gold )
-
-
-    def test_7(self):
-        result = pink.cpp.zoom( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 0.5, 0.25, 0.9)
-        gold   = pink.cpp.readimage( RESULTS + '/zoom_b3a_05_025_09.pgm')
-        self.assertTrue( result == gold )
-
-
-if __name__ == '__main__':
-    unittest.main(testRunner=xmlrunner.XMLTestRunner(output='test-reports'))
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.areaopening.areaopening.xml
--- a/python/test-reports/TEST-pinktest.areaopening.areaopening.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,10 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.areaopening.areaopening" tests="3" time="0.000">
-	<testcase classname="pinktest.areaopening.areaopening" name="test_2" time="0.000"/>
-	<testcase classname="pinktest.areaopening.areaopening" name="test_3" time="0.000"/>
-	<testcase classname="pinktest.areaopening.areaopening" name="test_4" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.dilatball.dilatball.xml
--- a/python/test-reports/TEST-pinktest.dilatball.dilatball.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,18 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.dilatball.dilatball" tests="11" time="0.000">
-	<testcase classname="pinktest.dilatball.dilatball" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.dilatball.dilatball" name="test_1" time="0.000"/>
-	<testcase classname="pinktest.dilatball.dilatball" name="test_10" time="0.000"/>
-	<testcase classname="pinktest.dilatball.dilatball" name="test_11" time="0.000"/>
-	<testcase classname="pinktest.dilatball.dilatball" name="test_12" time="0.000"/>
-	<testcase classname="pinktest.dilatball.dilatball" name="test_13" time="0.000"/>
-	<testcase classname="pinktest.dilatball.dilatball" name="test_2" time="0.000"/>
-	<testcase classname="pinktest.dilatball.dilatball" name="test_3" time="0.000"/>
-	<testcase classname="pinktest.dilatball.dilatball" name="test_4" time="0.000"/>
-	<testcase classname="pinktest.dilatball.dilatball" name="test_8" time="0.000"/>
-	<testcase classname="pinktest.dilatball.dilatball" name="test_9" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.dilation.dilation.xml
--- a/python/test-reports/TEST-pinktest.dilation.dilation.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,39 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="4" failures="0" name="pinktest.dilation.dilation" tests="4" time="0.000">
-	<testcase classname="pinktest.dilation.dilation" name="test_0" time="0.000">
-		<error message="unidentifiable C++ exception" type="RuntimeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/dilation.py", line 26, in test_0
-    result = pink.cpp.dilation( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2_se_5_7.pgm' ))
-RuntimeError: unidentifiable C++ exception
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.dilation.dilation" name="test_1" time="0.000">
-		<error message="unidentifiable C++ exception" type="RuntimeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/dilation.py", line 32, in test_1
-    result = pink.cpp.dilation( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2fish1.pgm' ), pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2_se_5_7.pgm' ))
-RuntimeError: unidentifiable C++ exception
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.dilation.dilation" name="test_2" time="0.000">
-		<error message="unidentifiable C++ exception" type="RuntimeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/dilation.py", line 38, in test_2
-    result = pink.cpp.dilation( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3_se_5_5_7.pgm' ))
-RuntimeError: unidentifiable C++ exception
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.dilation.dilation" name="test_3" time="0.000">
-		<error message="unidentifiable C++ exception" type="RuntimeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/dilation.py", line 44, in test_3
-    result = pink.cpp.dilation( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3_se_5_5_7.pgm' ))
-RuntimeError: unidentifiable C++ exception
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.drawline.drawline.xml
--- a/python/test-reports/TEST-pinktest.drawline.drawline.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,9 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.drawline.drawline" tests="2" time="0.000">
-	<testcase classname="pinktest.drawline.drawline" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.drawline.drawline" name="test_1" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.drawspline.drawspline.xml
--- a/python/test-reports/TEST-pinktest.drawspline.drawspline.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,23 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="2" failures="0" name="pinktest.drawspline.drawspline" tests="2" time="0.000">
-	<testcase classname="pinktest.drawspline.drawspline" name="test_0" time="0.000">
-		<error message="'module' object has no attribute 'drawspline'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/drawspline.py", line 26, in test_0
-    result = pink.cpp.drawspline( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2empty_30_40.pgm' ), pink.cpp.readimage( IMAGES + '/2dlist/binary/l2spline1.spline' ))
-AttributeError: 'module' object has no attribute 'drawspline'
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.drawspline.drawspline" name="test_1" time="0.000">
-		<error message="'module' object has no attribute 'drawspline'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/drawspline.py", line 32, in test_1
-    result = pink.cpp.drawspline( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3empty_20_30_40.pgm' ), pink.cpp.readimage( IMAGES + '/3dlist/binary/l3spline1.spline' ))
-AttributeError: 'module' object has no attribute 'drawspline'
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.erosball.erosball.xml
--- a/python/test-reports/TEST-pinktest.erosball.erosball.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,18 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.erosball.erosball" tests="11" time="0.000">
-	<testcase classname="pinktest.erosball.erosball" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.erosball.erosball" name="test_1" time="0.000"/>
-	<testcase classname="pinktest.erosball.erosball" name="test_10" time="0.000"/>
-	<testcase classname="pinktest.erosball.erosball" name="test_2" time="0.000"/>
-	<testcase classname="pinktest.erosball.erosball" name="test_3" time="0.000"/>
-	<testcase classname="pinktest.erosball.erosball" name="test_4" time="0.000"/>
-	<testcase classname="pinktest.erosball.erosball" name="test_5" time="0.000"/>
-	<testcase classname="pinktest.erosball.erosball" name="test_6" time="0.000"/>
-	<testcase classname="pinktest.erosball.erosball" name="test_7" time="0.000"/>
-	<testcase classname="pinktest.erosball.erosball" name="test_8" time="0.000"/>
-	<testcase classname="pinktest.erosball.erosball" name="test_9" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.geodilat.geodilat.xml
--- a/python/test-reports/TEST-pinktest.geodilat.geodilat.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,11 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.geodilat.geodilat" tests="4" time="0.000">
-	<testcase classname="pinktest.geodilat.geodilat" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.geodilat.geodilat" name="test_1" time="0.000"/>
-	<testcase classname="pinktest.geodilat.geodilat" name="test_2" time="0.000"/>
-	<testcase classname="pinktest.geodilat.geodilat" name="test_3" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.gradientcd.gradientcd.xml
--- a/python/test-reports/TEST-pinktest.gradientcd.gradientcd.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,9 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.gradientcd.gradientcd" tests="2" time="0.000">
-	<testcase classname="pinktest.gradientcd.gradientcd" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.gradientcd.gradientcd" name="test_1" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.heightmaxima.heightmaxima.xml
--- a/python/test-reports/TEST-pinktest.heightmaxima.heightmaxima.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,12 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.heightmaxima.heightmaxima" tests="5" time="0.000">
-	<testcase classname="pinktest.heightmaxima.heightmaxima" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.heightmaxima.heightmaxima" name="test_1" time="0.000"/>
-	<testcase classname="pinktest.heightmaxima.heightmaxima" name="test_2" time="0.000"/>
-	<testcase classname="pinktest.heightmaxima.heightmaxima" name="test_3" time="0.000"/>
-	<testcase classname="pinktest.heightmaxima.heightmaxima" name="test_4" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.heightminima.heightminima.xml
--- a/python/test-reports/TEST-pinktest.heightminima.heightminima.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,12 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.heightminima.heightminima" tests="5" time="0.000">
-	<testcase classname="pinktest.heightminima.heightminima" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.heightminima.heightminima" name="test_1" time="0.000"/>
-	<testcase classname="pinktest.heightminima.heightminima" name="test_2" time="0.000"/>
-	<testcase classname="pinktest.heightminima.heightminima" name="test_3" time="0.000"/>
-	<testcase classname="pinktest.heightminima.heightminima" name="test_4" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.heightselnb.heightselnb.xml
--- a/python/test-reports/TEST-pinktest.heightselnb.heightselnb.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,137 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="5" failures="0" name="pinktest.heightselnb.heightselnb" tests="5" time="0.000">
-	<testcase classname="pinktest.heightselnb.heightselnb" name="test_0" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.heightselnb(char_image, int, int)
-did not match C++ signature:
-    heightselnb(pink::ujoi&lt;dcomplex&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;fcomplex&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;double&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;float&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;int&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;unsigned short&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;unsigned char&gt; image, int connexity, int height, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/heightselnb.py", line 26, in test_0
-    result = pink.cpp.heightselnb( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2gel.pgm' ), 4, 3)
-ArgumentError: Python argument types in
-    libcpp_pink.heightselnb(char_image, int, int)
-did not match C++ signature:
-    heightselnb(pink::ujoi<dcomplex> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<fcomplex> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<double> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<float> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<int> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<unsigned short> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<unsigned char> image, int connexity, int height, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.heightselnb.heightselnb" name="test_1" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.heightselnb(char_image, int, int)
-did not match C++ signature:
-    heightselnb(pink::ujoi&lt;dcomplex&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;fcomplex&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;double&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;float&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;int&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;unsigned short&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;unsigned char&gt; image, int connexity, int height, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/heightselnb.py", line 32, in test_1
-    result = pink.cpp.heightselnb( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2gel.pgm' ), 8, 3)
-ArgumentError: Python argument types in
-    libcpp_pink.heightselnb(char_image, int, int)
-did not match C++ signature:
-    heightselnb(pink::ujoi<dcomplex> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<fcomplex> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<double> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<float> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<int> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<unsigned short> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<unsigned char> image, int connexity, int height, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.heightselnb.heightselnb" name="test_2" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.heightselnb(char_image, int, int)
-did not match C++ signature:
-    heightselnb(pink::ujoi&lt;dcomplex&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;fcomplex&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;double&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;float&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;int&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;unsigned short&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;unsigned char&gt; image, int connexity, int height, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/heightselnb.py", line 38, in test_2
-    result = pink.cpp.heightselnb( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 6, 3)
-ArgumentError: Python argument types in
-    libcpp_pink.heightselnb(char_image, int, int)
-did not match C++ signature:
-    heightselnb(pink::ujoi<dcomplex> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<fcomplex> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<double> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<float> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<int> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<unsigned short> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<unsigned char> image, int connexity, int height, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.heightselnb.heightselnb" name="test_3" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.heightselnb(char_image, int, int)
-did not match C++ signature:
-    heightselnb(pink::ujoi&lt;dcomplex&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;fcomplex&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;double&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;float&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;int&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;unsigned short&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;unsigned char&gt; image, int connexity, int height, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/heightselnb.py", line 44, in test_3
-    result = pink.cpp.heightselnb( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 18, 3)
-ArgumentError: Python argument types in
-    libcpp_pink.heightselnb(char_image, int, int)
-did not match C++ signature:
-    heightselnb(pink::ujoi<dcomplex> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<fcomplex> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<double> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<float> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<int> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<unsigned short> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<unsigned char> image, int connexity, int height, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.heightselnb.heightselnb" name="test_4" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.heightselnb(char_image, int, int)
-did not match C++ signature:
-    heightselnb(pink::ujoi&lt;dcomplex&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;fcomplex&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;double&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;float&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;int&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;unsigned short&gt; image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi&lt;unsigned char&gt; image, int connexity, int height, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/heightselnb.py", line 50, in test_4
-    result = pink.cpp.heightselnb( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 26, 3)
-ArgumentError: Python argument types in
-    libcpp_pink.heightselnb(char_image, int, int)
-did not match C++ signature:
-    heightselnb(pink::ujoi<dcomplex> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<fcomplex> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<double> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<float> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<int> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<unsigned short> image, int connexity, int height, int mode)
-    heightselnb(pink::ujoi<unsigned char> image, int connexity, int height, int mode)
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.identifyline.identifyline.xml
--- a/python/test-reports/TEST-pinktest.identifyline.identifyline.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,23 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="2" failures="0" name="pinktest.identifyline.identifyline" tests="2" time="0.000">
-	<testcase classname="pinktest.identifyline.identifyline" name="test_0" time="0.000">
-		<error message="unidentifiable C++ exception" type="RuntimeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/identifyline.py", line 26, in test_0
-    result = pink.cpp.identifyline( pink.cpp.readimage( IMAGES + '/2dlist/binary/l2line1.list' ))
-RuntimeError: unidentifiable C++ exception
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.identifyline.identifyline" name="test_1" time="0.000">
-		<error message="unidentifiable C++ exception" type="RuntimeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/identifyline.py", line 32, in test_1
-    result = pink.cpp.identifyline( pink.cpp.readimage( IMAGES + '/2dlist/binary/l2line2.list' ))
-RuntimeError: unidentifiable C++ exception
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.medianfilter.medianfilter.xml
--- a/python/test-reports/TEST-pinktest.medianfilter.medianfilter.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,23 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="2" name="pinktest.medianfilter.medianfilter" tests="2" time="0.000">
-	<testcase classname="pinktest.medianfilter.medianfilter" name="test_0" time="0.000">
-		<failure message="False is not true" type="AssertionError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/medianfilter.py", line 28, in test_0
-    self.assertTrue( result == gold )
-AssertionError: False is not true
-]]>		</failure>
-	</testcase>
-	<testcase classname="pinktest.medianfilter.medianfilter" name="test_1" time="0.000">
-		<failure message="False is not true" type="AssertionError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/medianfilter.py", line 34, in test_1
-    self.assertTrue( result == gold )
-AssertionError: False is not true
-]]>		</failure>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.openball.openball.xml
--- a/python/test-reports/TEST-pinktest.openball.openball.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,18 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.openball.openball" tests="11" time="0.000">
-	<testcase classname="pinktest.openball.openball" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.openball.openball" name="test_1" time="0.000"/>
-	<testcase classname="pinktest.openball.openball" name="test_10" time="0.000"/>
-	<testcase classname="pinktest.openball.openball" name="test_2" time="0.000"/>
-	<testcase classname="pinktest.openball.openball" name="test_3" time="0.000"/>
-	<testcase classname="pinktest.openball.openball" name="test_4" time="0.000"/>
-	<testcase classname="pinktest.openball.openball" name="test_5" time="0.000"/>
-	<testcase classname="pinktest.openball.openball" name="test_6" time="0.000"/>
-	<testcase classname="pinktest.openball.openball" name="test_7" time="0.000"/>
-	<testcase classname="pinktest.openball.openball" name="test_8" time="0.000"/>
-	<testcase classname="pinktest.openball.openball" name="test_9" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.rankfilter.rankfilter.xml
--- a/python/test-reports/TEST-pinktest.rankfilter.rankfilter.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,87 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="2" failures="0" name="pinktest.rankfilter.rankfilter" tests="2" time="0.000">
-	<testcase classname="pinktest.rankfilter.rankfilter" name="test_0" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.rankfilter(char_image, char_image, float)
-did not match C++ signature:
-    rankfilter(pink::ujoi&lt;dcomplex&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;fcomplex&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;double&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;float&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;int&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;unsigned short&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;unsigned char&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;dcomplex&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;fcomplex&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;double&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;float&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;int&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;unsigned short&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;unsigned char&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/rankfilter.py", line 26, in test_0
-    result = pink.cpp.rankfilter( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2gel.pgm' ), pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2_se_5_7.pgm' ), 0.8)
-ArgumentError: Python argument types in
-    libcpp_pink.rankfilter(char_image, char_image, float)
-did not match C++ signature:
-    rankfilter(pink::ujoi<dcomplex> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<fcomplex> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<double> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<float> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<int> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<unsigned short> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<unsigned char> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<dcomplex> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<fcomplex> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<double> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<float> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<int> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<unsigned short> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<unsigned char> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.rankfilter.rankfilter" name="test_1" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.rankfilter(char_image, char_image, float)
-did not match C++ signature:
-    rankfilter(pink::ujoi&lt;dcomplex&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;fcomplex&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;double&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;float&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;int&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;unsigned short&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;unsigned char&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi&lt;dcomplex&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;fcomplex&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;double&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;float&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;int&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;unsigned short&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi&lt;unsigned char&gt; image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/rankfilter.py", line 32, in test_1
-    result = pink.cpp.rankfilter( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3_se_5_5_7.pgm' ), 0.8)
-ArgumentError: Python argument types in
-    libcpp_pink.rankfilter(char_image, char_image, float)
-did not match C++ signature:
-    rankfilter(pink::ujoi<dcomplex> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<fcomplex> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<double> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<float> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<int> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<unsigned short> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<unsigned char> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, int center_z, double r)
-    rankfilter(pink::ujoi<dcomplex> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<fcomplex> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<double> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<float> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<int> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<unsigned short> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-    rankfilter(pink::ujoi<unsigned char> image, pink::pink_image {lvalue} structuring element, int center_x, int center_y, double r)
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.rotatebin.rotatebin.xml
--- a/python/test-reports/TEST-pinktest.rotatebin.rotatebin.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,15 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="1" failures="0" name="pinktest.rotatebin.rotatebin" tests="1" time="0.000">
-	<testcase classname="pinktest.rotatebin.rotatebin" name="test_0" time="0.000">
-		<error message="'module' object has no attribute 'rotatebin'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/rotatebin.py", line 26, in test_0
-    result = pink.cpp.rotatebin( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2_se_5_7.pgm' ), 25)
-AttributeError: 'module' object has no attribute 'rotatebin'
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.segmentarea.segmentarea.xml
--- a/python/test-reports/TEST-pinktest.segmentarea.segmentarea.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,207 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="5" failures="0" name="pinktest.segmentarea.segmentarea" tests="5" time="0.000">
-	<testcase classname="pinktest.segmentarea.segmentarea" name="test_0" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentarea(char_image, int, int)
-did not match C++ signature:
-    segmentarea(pink::ujoi&lt;dcomplex&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;fcomplex&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;double&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;float&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;int&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;unsigned short&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;unsigned char&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;dcomplex&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;fcomplex&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;double&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;float&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;int&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;unsigned short&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;unsigned char&gt; image, int connexity, int area, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentarea.py", line 26, in test_0
-    result = pink.cpp.segmentarea( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2gel.pgm' ), 4, 100)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentarea(char_image, int, int)
-did not match C++ signature:
-    segmentarea(pink::ujoi<dcomplex> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<fcomplex> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<double> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<float> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<int> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<unsigned short> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<unsigned char> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<dcomplex> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<fcomplex> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<double> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<float> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<int> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<unsigned short> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<unsigned char> image, int connexity, int area, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentarea.segmentarea" name="test_1" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentarea(char_image, int, int)
-did not match C++ signature:
-    segmentarea(pink::ujoi&lt;dcomplex&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;fcomplex&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;double&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;float&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;int&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;unsigned short&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;unsigned char&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;dcomplex&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;fcomplex&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;double&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;float&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;int&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;unsigned short&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;unsigned char&gt; image, int connexity, int area, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentarea.py", line 32, in test_1
-    result = pink.cpp.segmentarea( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2gel.pgm' ), 8, 100)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentarea(char_image, int, int)
-did not match C++ signature:
-    segmentarea(pink::ujoi<dcomplex> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<fcomplex> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<double> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<float> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<int> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<unsigned short> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<unsigned char> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<dcomplex> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<fcomplex> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<double> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<float> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<int> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<unsigned short> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<unsigned char> image, int connexity, int area, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentarea.segmentarea" name="test_2" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentarea(char_image, int, int)
-did not match C++ signature:
-    segmentarea(pink::ujoi&lt;dcomplex&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;fcomplex&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;double&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;float&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;int&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;unsigned short&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;unsigned char&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;dcomplex&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;fcomplex&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;double&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;float&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;int&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;unsigned short&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;unsigned char&gt; image, int connexity, int area, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentarea.py", line 38, in test_2
-    result = pink.cpp.segmentarea( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 6, 100)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentarea(char_image, int, int)
-did not match C++ signature:
-    segmentarea(pink::ujoi<dcomplex> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<fcomplex> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<double> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<float> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<int> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<unsigned short> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<unsigned char> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<dcomplex> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<fcomplex> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<double> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<float> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<int> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<unsigned short> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<unsigned char> image, int connexity, int area, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentarea.segmentarea" name="test_3" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentarea(char_image, int, int)
-did not match C++ signature:
-    segmentarea(pink::ujoi&lt;dcomplex&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;fcomplex&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;double&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;float&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;int&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;unsigned short&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;unsigned char&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;dcomplex&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;fcomplex&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;double&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;float&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;int&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;unsigned short&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;unsigned char&gt; image, int connexity, int area, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentarea.py", line 44, in test_3
-    result = pink.cpp.segmentarea( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 18, 100)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentarea(char_image, int, int)
-did not match C++ signature:
-    segmentarea(pink::ujoi<dcomplex> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<fcomplex> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<double> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<float> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<int> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<unsigned short> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<unsigned char> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<dcomplex> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<fcomplex> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<double> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<float> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<int> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<unsigned short> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<unsigned char> image, int connexity, int area, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentarea.segmentarea" name="test_4" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentarea(char_image, int, int)
-did not match C++ signature:
-    segmentarea(pink::ujoi&lt;dcomplex&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;fcomplex&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;double&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;float&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;int&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;unsigned short&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;unsigned char&gt; image, int connexity, int area, int m)
-    segmentarea(pink::ujoi&lt;dcomplex&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;fcomplex&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;double&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;float&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;int&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;unsigned short&gt; image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi&lt;unsigned char&gt; image, int connexity, int area, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentarea.py", line 50, in test_4
-    result = pink.cpp.segmentarea( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 26, 100)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentarea(char_image, int, int)
-did not match C++ signature:
-    segmentarea(pink::ujoi<dcomplex> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<fcomplex> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<double> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<float> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<int> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<unsigned short> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<unsigned char> image, int connexity, int area, int m)
-    segmentarea(pink::ujoi<dcomplex> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<fcomplex> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<double> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<float> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<int> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<unsigned short> image, int connexity, int area, int mode)
-    segmentarea(pink::ujoi<unsigned char> image, int connexity, int area, int mode)
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.segmentheight.segmentheight.xml
--- a/python/test-reports/TEST-pinktest.segmentheight.segmentheight.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,137 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="5" failures="0" name="pinktest.segmentheight.segmentheight" tests="5" time="0.000">
-	<testcase classname="pinktest.segmentheight.segmentheight" name="test_0" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentheight(char_image, int, int)
-did not match C++ signature:
-    segmentheight(pink::ujoi&lt;dcomplex&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;fcomplex&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;double&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;float&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;int&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;unsigned short&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;unsigned char&gt; image, int connexity, int height, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentheight.py", line 26, in test_0
-    result = pink.cpp.segmentheight( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2gel.pgm' ), 4, 20)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentheight(char_image, int, int)
-did not match C++ signature:
-    segmentheight(pink::ujoi<dcomplex> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<fcomplex> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<double> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<float> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<int> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<unsigned short> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<unsigned char> image, int connexity, int height, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentheight.segmentheight" name="test_1" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentheight(char_image, int, int)
-did not match C++ signature:
-    segmentheight(pink::ujoi&lt;dcomplex&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;fcomplex&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;double&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;float&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;int&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;unsigned short&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;unsigned char&gt; image, int connexity, int height, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentheight.py", line 32, in test_1
-    result = pink.cpp.segmentheight( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2gel.pgm' ), 8, 20)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentheight(char_image, int, int)
-did not match C++ signature:
-    segmentheight(pink::ujoi<dcomplex> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<fcomplex> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<double> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<float> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<int> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<unsigned short> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<unsigned char> image, int connexity, int height, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentheight.segmentheight" name="test_2" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentheight(char_image, int, int)
-did not match C++ signature:
-    segmentheight(pink::ujoi&lt;dcomplex&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;fcomplex&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;double&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;float&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;int&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;unsigned short&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;unsigned char&gt; image, int connexity, int height, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentheight.py", line 38, in test_2
-    result = pink.cpp.segmentheight( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 6, 20)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentheight(char_image, int, int)
-did not match C++ signature:
-    segmentheight(pink::ujoi<dcomplex> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<fcomplex> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<double> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<float> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<int> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<unsigned short> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<unsigned char> image, int connexity, int height, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentheight.segmentheight" name="test_3" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentheight(char_image, int, int)
-did not match C++ signature:
-    segmentheight(pink::ujoi&lt;dcomplex&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;fcomplex&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;double&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;float&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;int&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;unsigned short&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;unsigned char&gt; image, int connexity, int height, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentheight.py", line 44, in test_3
-    result = pink.cpp.segmentheight( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 18, 20)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentheight(char_image, int, int)
-did not match C++ signature:
-    segmentheight(pink::ujoi<dcomplex> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<fcomplex> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<double> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<float> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<int> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<unsigned short> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<unsigned char> image, int connexity, int height, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentheight.segmentheight" name="test_4" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentheight(char_image, int, int)
-did not match C++ signature:
-    segmentheight(pink::ujoi&lt;dcomplex&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;fcomplex&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;double&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;float&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;int&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;unsigned short&gt; image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi&lt;unsigned char&gt; image, int connexity, int height, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentheight.py", line 50, in test_4
-    result = pink.cpp.segmentheight( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 26, 20)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentheight(char_image, int, int)
-did not match C++ signature:
-    segmentheight(pink::ujoi<dcomplex> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<fcomplex> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<double> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<float> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<int> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<unsigned short> image, int connexity, int height, int mode)
-    segmentheight(pink::ujoi<unsigned char> image, int connexity, int height, int mode)
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.segmentvol.segmentvol.xml
--- a/python/test-reports/TEST-pinktest.segmentvol.segmentvol.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,207 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="5" failures="0" name="pinktest.segmentvol.segmentvol" tests="5" time="0.000">
-	<testcase classname="pinktest.segmentvol.segmentvol" name="test_0" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentvol(char_image, int, int)
-did not match C++ signature:
-    segmentvol(pink::ujoi&lt;dcomplex&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;fcomplex&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;double&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;float&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;int&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;unsigned short&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;unsigned char&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;dcomplex&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;fcomplex&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;double&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;float&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;int&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;unsigned short&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;unsigned char&gt; image, int connexity, int vol, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentvol.py", line 26, in test_0
-    result = pink.cpp.segmentvol( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2gel.pgm' ), 4, 200)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentvol(char_image, int, int)
-did not match C++ signature:
-    segmentvol(pink::ujoi<dcomplex> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<fcomplex> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<double> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<float> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<int> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<unsigned short> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<unsigned char> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<dcomplex> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<fcomplex> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<double> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<float> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<int> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<unsigned short> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<unsigned char> image, int connexity, int vol, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentvol.segmentvol" name="test_1" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentvol(char_image, int, int)
-did not match C++ signature:
-    segmentvol(pink::ujoi&lt;dcomplex&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;fcomplex&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;double&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;float&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;int&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;unsigned short&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;unsigned char&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;dcomplex&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;fcomplex&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;double&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;float&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;int&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;unsigned short&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;unsigned char&gt; image, int connexity, int vol, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentvol.py", line 32, in test_1
-    result = pink.cpp.segmentvol( pink.cpp.readimage( IMAGES + '/2dbyte/gray/g2gel.pgm' ), 8, 200)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentvol(char_image, int, int)
-did not match C++ signature:
-    segmentvol(pink::ujoi<dcomplex> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<fcomplex> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<double> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<float> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<int> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<unsigned short> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<unsigned char> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<dcomplex> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<fcomplex> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<double> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<float> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<int> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<unsigned short> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<unsigned char> image, int connexity, int vol, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentvol.segmentvol" name="test_2" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentvol(char_image, int, int)
-did not match C++ signature:
-    segmentvol(pink::ujoi&lt;dcomplex&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;fcomplex&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;double&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;float&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;int&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;unsigned short&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;unsigned char&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;dcomplex&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;fcomplex&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;double&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;float&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;int&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;unsigned short&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;unsigned char&gt; image, int connexity, int vol, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentvol.py", line 38, in test_2
-    result = pink.cpp.segmentvol( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 6, 200)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentvol(char_image, int, int)
-did not match C++ signature:
-    segmentvol(pink::ujoi<dcomplex> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<fcomplex> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<double> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<float> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<int> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<unsigned short> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<unsigned char> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<dcomplex> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<fcomplex> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<double> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<float> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<int> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<unsigned short> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<unsigned char> image, int connexity, int vol, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentvol.segmentvol" name="test_3" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentvol(char_image, int, int)
-did not match C++ signature:
-    segmentvol(pink::ujoi&lt;dcomplex&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;fcomplex&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;double&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;float&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;int&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;unsigned short&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;unsigned char&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;dcomplex&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;fcomplex&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;double&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;float&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;int&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;unsigned short&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;unsigned char&gt; image, int connexity, int vol, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentvol.py", line 44, in test_3
-    result = pink.cpp.segmentvol( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 18, 200)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentvol(char_image, int, int)
-did not match C++ signature:
-    segmentvol(pink::ujoi<dcomplex> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<fcomplex> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<double> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<float> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<int> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<unsigned short> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<unsigned char> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<dcomplex> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<fcomplex> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<double> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<float> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<int> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<unsigned short> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<unsigned char> image, int connexity, int vol, int mode)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.segmentvol.segmentvol" name="test_4" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.segmentvol(char_image, int, int)
-did not match C++ signature:
-    segmentvol(pink::ujoi&lt;dcomplex&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;fcomplex&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;double&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;float&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;int&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;unsigned short&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;unsigned char&gt; image, int connexity, int param, int m)
-    segmentvol(pink::ujoi&lt;dcomplex&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;fcomplex&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;double&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;float&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;int&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;unsigned short&gt; image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi&lt;unsigned char&gt; image, int connexity, int vol, int mode)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/segmentvol.py", line 50, in test_4
-    result = pink.cpp.segmentvol( pink.cpp.readimage( IMAGES + '/3dbyte/gray/g3a.pgm' ), 26, 200)
-ArgumentError: Python argument types in
-    libcpp_pink.segmentvol(char_image, int, int)
-did not match C++ signature:
-    segmentvol(pink::ujoi<dcomplex> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<fcomplex> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<double> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<float> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<int> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<unsigned short> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<unsigned char> image, int connexity, int param, int m)
-    segmentvol(pink::ujoi<dcomplex> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<fcomplex> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<double> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<float> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<int> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<unsigned short> image, int connexity, int vol, int mode)
-    segmentvol(pink::ujoi<unsigned char> image, int connexity, int vol, int mode)
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.seuil.seuil.xml
--- a/python/test-reports/TEST-pinktest.seuil.seuil.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,8 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.seuil.seuil" tests="1" time="0.000">
-	<testcase classname="pinktest.seuil.seuil" name="test_0" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.skeleton.skeleton.xml
--- a/python/test-reports/TEST-pinktest.skeleton.skeleton.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,26 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.skeleton.skeleton" tests="19" time="0.001">
-	<testcase classname="pinktest.skeleton.skeleton" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_1" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_10" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_11" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_12" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_13" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_14" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_15" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_16" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_17" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_18" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_2" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_3" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_4" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_5" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_6" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_7" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_8" time="0.000"/>
-	<testcase classname="pinktest.skeleton.skeleton" name="test_9" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.skelpar.skelpar.xml
--- a/python/test-reports/TEST-pinktest.skelpar.skelpar.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,63 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="7" failures="0" name="pinktest.skelpar.skelpar" tests="7" time="0.000">
-	<testcase classname="pinktest.skelpar.skelpar" name="test_0" time="0.000">
-		<error message="'module' object has no attribute 'skelpar'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelpar.py", line 26, in test_0
-    result = pink.cpp.skelpar( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 2, -1)
-AttributeError: 'module' object has no attribute 'skelpar'
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelpar.skelpar" name="test_1" time="0.000">
-		<error message="'module' object has no attribute 'skelpar'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelpar.py", line 32, in test_1
-    result = pink.cpp.skelpar( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 3, -1)
-AttributeError: 'module' object has no attribute 'skelpar'
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelpar.skelpar" name="test_2" time="0.000">
-		<error message="'module' object has no attribute 'skelpar'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelpar.py", line 38, in test_2
-    result = pink.cpp.skelpar( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 4, -1)
-AttributeError: 'module' object has no attribute 'skelpar'
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelpar.skelpar" name="test_3" time="0.000">
-		<error message="'module' object has no attribute 'skelpar'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelpar.py", line 44, in test_3
-    result = pink.cpp.skelpar( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 22, -1)
-AttributeError: 'module' object has no attribute 'skelpar'
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelpar.skelpar" name="test_4" time="0.000">
-		<error message="'module' object has no attribute 'skelpar'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelpar.py", line 50, in test_4
-    result = pink.cpp.skelpar( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 23, -1)
-AttributeError: 'module' object has no attribute 'skelpar'
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelpar.skelpar" name="test_5" time="0.000">
-		<error message="'module' object has no attribute 'skelpar'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelpar.py", line 56, in test_5
-    result = pink.cpp.skelpar( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 2, 3)
-AttributeError: 'module' object has no attribute 'skelpar'
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelpar.skelpar" name="test_6" time="0.000">
-		<error message="'module' object has no attribute 'skelpar'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelpar.py", line 62, in test_6
-    result = pink.cpp.skelpar( pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreu.pgm' ), 2, -1, pink.cpp.readimage( IMAGES + '/2dbyte/binary/b2hebreui.pgm' ))
-AttributeError: 'module' object has no attribute 'skelpar'
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.skelsurf.skelsurf.xml
--- a/python/test-reports/TEST-pinktest.skelsurf.skelsurf.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,367 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="9" failures="0" name="pinktest.skelsurf.skelsurf" tests="9" time="0.000">
-	<testcase classname="pinktest.skelsurf.skelsurf" name="test_0" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelsurf.py", line 26, in test_0
-    result = pink.cpp.skelsurf( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 0, 26)
-ArgumentError: Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelsurf.skelsurf" name="test_1" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelsurf.py", line 32, in test_1
-    result = pink.cpp.skelsurf( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 1, 26)
-ArgumentError: Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelsurf.skelsurf" name="test_2" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelsurf.py", line 38, in test_2
-    result = pink.cpp.skelsurf( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 2, 26)
-ArgumentError: Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelsurf.skelsurf" name="test_3" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelsurf.py", line 44, in test_3
-    result = pink.cpp.skelsurf( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 3, 26)
-ArgumentError: Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelsurf.skelsurf" name="test_4" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelsurf.py", line 50, in test_4
-    result = pink.cpp.skelsurf( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 6, 26)
-ArgumentError: Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelsurf.skelsurf" name="test_5" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelsurf.py", line 56, in test_5
-    result = pink.cpp.skelsurf( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 18, 26)
-ArgumentError: Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelsurf.skelsurf" name="test_6" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelsurf.py", line 62, in test_6
-    result = pink.cpp.skelsurf( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 26, 26)
-ArgumentError: Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelsurf.skelsurf" name="test_7" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelsurf.py", line 68, in test_7
-    result = pink.cpp.skelsurf( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 0, 6)
-ArgumentError: Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int)
-did not match C++ signature:
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelsurf.skelsurf" name="test_8" time="0.000">
-		<error message="Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int, char_image)
-did not match C++ signature:
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;dcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;fcomplex&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;double&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;float&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;int&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned short&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)
-    skelsurf(pink::ujoi&lt;unsigned char&gt; image, pink::ujoi&lt;unsigned char&gt; priority_image, pink::ujoi&lt;unsigned char&gt; inhibit, int connexity)" type="ArgumentError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelsurf.py", line 74, in test_8
-    result = pink.cpp.skelsurf( pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a.pgm' ), 0, 26, pink.cpp.readimage( IMAGES + '/3dbyte/binary/b3a2.pgm' ))
-ArgumentError: Python argument types in
-    libcpp_pink.skelsurf(char_image, int, int, char_image)
-did not match C++ signature:
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<dcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<fcomplex> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<double> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<float> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<int> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned short> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-    skelsurf(pink::ujoi<unsigned char> image, pink::ujoi<unsigned char> priority_image, pink::ujoi<unsigned char> inhibit, int connexity)
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.skelvertex.skelvertex.xml
--- a/python/test-reports/TEST-pinktest.skelvertex.skelvertex.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,23 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="2" failures="0" name="pinktest.skelvertex.skelvertex" tests="2" time="0.000">
-	<testcase classname="pinktest.skelvertex.skelvertex" name="test_0" time="0.000">
-		<error message="'module' object has no attribute 'skelvertex'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelvertex.py", line 26, in test_0
-    result = pink.cpp.skelvertex( pink.cpp.readimage( IMAGES + '/2dskel/s2skel4.skel' ), 5)
-AttributeError: 'module' object has no attribute 'skelvertex'
-]]>		</error>
-	</testcase>
-	<testcase classname="pinktest.skelvertex.skelvertex" name="test_1" time="0.000">
-		<error message="'module' object has no attribute 'skelvertex'" type="AttributeError">
-<![CDATA[Traceback (most recent call last):
-  File "/home/ujoimro/doc/projects/pink/pink-svn/python/pinktest/skelvertex.py", line 32, in test_1
-    result = pink.cpp.skelvertex( pink.cpp.readimage( IMAGES + '/3dskel/s3skel6.skel' ), 5)
-AttributeError: 'module' object has no attribute 'skelvertex'
-]]>		</error>
-	</testcase>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.volmaxima.volmaxima.xml
--- a/python/test-reports/TEST-pinktest.volmaxima.volmaxima.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,12 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.volmaxima.volmaxima" tests="5" time="0.000">
-	<testcase classname="pinktest.volmaxima.volmaxima" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.volmaxima.volmaxima" name="test_1" time="0.000"/>
-	<testcase classname="pinktest.volmaxima.volmaxima" name="test_2" time="0.000"/>
-	<testcase classname="pinktest.volmaxima.volmaxima" name="test_3" time="0.000"/>
-	<testcase classname="pinktest.volmaxima.volmaxima" name="test_4" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.volselnb.volselnb.xml
--- a/python/test-reports/TEST-pinktest.volselnb.volselnb.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,12 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.volselnb.volselnb" tests="5" time="0.000">
-	<testcase classname="pinktest.volselnb.volselnb" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.volselnb.volselnb" name="test_1" time="0.000"/>
-	<testcase classname="pinktest.volselnb.volselnb" name="test_2" time="0.000"/>
-	<testcase classname="pinktest.volselnb.volselnb" name="test_3" time="0.000"/>
-	<testcase classname="pinktest.volselnb.volselnb" name="test_4" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.watershed.watershed.xml
--- a/python/test-reports/TEST-pinktest.watershed.watershed.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,9 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.watershed.watershed" tests="2" time="0.000">
-	<testcase classname="pinktest.watershed.watershed" name="test_0" time="0.000"/>
-	<testcase classname="pinktest.watershed.watershed" name="test_1" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python/test-reports/TEST-pinktest.zoom.zoom.xml
--- a/python/test-reports/TEST-pinktest.zoom.zoom.xml	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,8 +0,0 @@
-<?xml version="1.0" ?>
-<testsuite errors="0" failures="0" name="pinktest.zoom.zoom" tests="1" time="0.000">
-	<testcase classname="pinktest.zoom.zoom" name="test_3" time="0.000"/>
-	<system-out>
-<![CDATA[]]>	</system-out>
-	<system-err>
-<![CDATA[]]>	</system-err>
-</testsuite>
diff -r 8b1af7363833 python_documenter.py.candidate~
--- a/python_documenter.py.candidate~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,219 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# This software is licensed under 
-# CeCILL FREE SOFTWARE LICENSE AGREEMENT
-
-# This software comes in hope that it will be useful but 
-# without any warranty to the extent permitted by applicable law.
-  
-# (C) UjoImro, 2011
-# UniversitÃ© Paris-Est, Laboratoire d'Informatique Gaspard-Monge, Equipe A3SI, ESIEE Paris, 93162, Noisy le Grand CEDEX
-# ujoimro@gmail.com
-
-# (C) UjoImro, 2012
-# ProCarPlan s.r.o.
-# ujoimro@gmail.com
-
-#
-
-""" 
-This program searches all the source files in the given directory and
-extracts the first level doxygen documentation from it.  The first
-level documentation corresponds to the statement \file. From
-'filename.*', then the program generates a macro
-
-#define doc__filename__*__ "documentation for\n"
-"the file filename.* "
-
-The program should be used as:
-./python_documenter directory documentation.c
-"""
-
-from sys import argv
-from os import listdir
-from os.path import join
-from time import strftime
-
-def header():
-    result = ""
-    result += "// This file has been generated automatically by the \n"
-    result += "// python_documenter, part of the PInK package (UjoImro, 2011)\n"
-    result += "// the date of generation: " + strftime("%Y-%m-%dT%H:%M:%SZ")+"\n"
-    result += "// warning: DO NOT EDIT. All your changes will be lost at \n"
-    result += "// the next generation\n\n"
-    result += "#ifndef PINK__PYTHON__DOCUMENTER__HPP__\n"
-    result += "#define PINK__PYTHON__DOCUMENTER__HPP__\n"
-
-    return result
-
-def footer():
-    result = ""
-    result += "#endif /* PINK__PYTHON__DOCUMENTER__HPP__ */\n"
-    result += "// LuM end of file\n"
-
-    return result
-
-def simple_filter(text):
-    result = text
-    result.replace( "\n", ""  )
-    result.replace( "/*!", "" )
-    result.replace( "*/", ""  )
-    return result
-
-def advanced_filter(text):
-    result = ""
-
-    rep = False
-    xml = False
-
-    # the first cases are beginings of the eliminations \li <B> ... are eliminated
-    for current in text:
-        if current=='\\':
-            rep = True
-            
-        elif current=='<':
-            xml = True
-      
-
-        if (not rep) and (not xml):                
-            # here we filter some inconvenient characters as '\"'
-            if current =='\"':
-                result += "\\\""
-
-            # newline is handled by readline
-            # # the newline must be handled carefully
-            # elif (current == '\n'):
-            #     result += "\\n\"    \\\n\""
-
-            else:        
-                result += current;          
-            
-
-        # these are the ends of eliminations \li' ' <B'>' ... note the end of the eliminations
-        if (current=='>') and (xml):
-            xml = False;        
-        
-        elif (current==' ') and (rep):
-            rep = False;
-            result += " "
-    
-    return result
-
-def parse_file(filedesc, instance_name):
-    result = instance_name
-    rawdoc = get_raw_text(filedesc);
-
-    for q in rawdoc:
-        result += "\"" + advanced_filter(simple_filter(q)) + "\\n\"         \\\n"
-
-    result += "\"\\n\""
-    return result
-
-def get_raw_text(filedesc):
-    result = []
-    
-    inside_documentation = False
-    documented = False
-
-    q = filedesc.readline()
-    while q!="":
-
-        if not inside_documentation and (q.find("/*!")!=-1):
-            documented = True
-            inside_documentation = True            
-
-        if inside_documentation:            
-            result.append(q)
-
-        if inside_documentation and (q.find("*/")!=-1):
-            inside_documentation = False
-
-        q = filedesc.readline()
-
-    if not documented:
-        result = ["WRITE ME!!!"]
-
-    return result
-
-
-def parse_filename(filename):
-    filename.replace( ".", "__");
-    filename.replace( "#", "")
-    result = "#define doc__" + filename + "__ "
-    return result
-
-
-### **********************************************************************
-### **********************************************************************
-### **********************************************************************
-### ***                            MAIN                                ***
-### **********************************************************************
-### **********************************************************************
-### **********************************************************************
-
-if len(argv)!=3:
-#                                0               1           2
-    print("error: usage: ./python_documenter directory documentation.c")
-    exit(1)
-
-print("Boost python documenter")
-
-dir = argv[1]
-outfile = open(argv[2], "w")
-outfile.write(header())
-
-for q in listdir(dir):
-    opened = False
-    try:
-        filedesc = open(join(dir, q), "r")
-        opened = True
-    except:
-        print("skipping " + join(dir, q))
-
-    if opened:
-        print("processing file " + join(dir, q))
-        outfile.write( parse_file( filedesc, parse_filename(q) ) )
-        filedesc.close()
-        outfile.write("\n\n\n")
-
-outfile.write(footer())
-outfile.close()
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-# Lum end of file
diff -r 8b1af7363833 python_test_generator.py
--- a/python_test_generator.py	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,130 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# 
-# This software is licensed under 
-# CeCILL FREE SOFTWARE LICENSE AGREEMENT
-
-# This software comes in hope that it will be useful but 
-# without any warranty to the extent permitted by applicable law.
-  
-# (C) UjoImro <ujoimro@gmail.com>, 2012
-# ProCarPlan s.r.o.
-
-# This script generates the unittests from the src/com directory
-
-from sys import argv
-from os import listdir
-from os.path import join
-from time import strftime
-from string import replace, find
-
-
-
-def parse_file(filename):
-    result = []
-    parsfile = open( filename, 'r' )
-    lines = parsfile.readlines();
-    for line in lines:
-        test_pos   = line.find('%TEST')
-        images_pos = line.find('%IMAGES')
-        results_pos = line.find('%RESULTS')
-
-        if test_pos>=0:
-            split = map( test_filter, line[:len(line)-1].split(' ') )
-            command = '';
-            command += '        result = pink.cpp.' + split[1] + '( ' + split[2]
-            for q in split[3:len(split)-1]:
-                 command += ', ' + q;
-                
-            command += ')\n'
-            command += '        gold   = pink.cpp.readimage( RESULTS + \'' +  split[len(split)-1].replace('%RESULTS', '') + '\')'
-
-            result.append(command)
-
-    return result
-
-def test_filter( test ):
-    if test.find('%IMAGES')>=0:
-        return test.replace('%IMAGES','pink.cpp.readimage( IMAGES + \'') + '\' )'
-    else:
-        return test
-
-def generate_unit_test( filename, tests, testname ):
-    commands = ''
-    commands += '# -*- coding: utf-8 -*- \n'
-    commands += '#  \n'
-    commands += '# This software is licensed under  \n'
-    commands += '# CeCILL FREE SOFTWARE LICENSE AGREEMENT \n'
-    commands += ' \n'
-    commands += '# This software comes in hope that it will be useful but  \n'
-    commands += '# without any warranty to the extent permitted by applicable law. \n'
-    commands += '   \n'
-    commands += '# (C) UjoImro <ujoimro@gmail.com>, 2012 \n'
-    commands += '# ProCarPlan s.r.o. \n'
-    commands += ' \n'
-    commands += 'import os \n'
-    commands += 'import pink \n'
-    commands += 'import unittest \n'
-    commands += 'import xmlrunner \n'
-    commands += ' \n'
-    commands += 'try:   \n'
-    commands += '    IMAGES  = os.environ["PINKTEST"] + "/images" \n'
-    commands += '    RESULTS = os.environ["PINKTEST"] + "/results_prev" \n'
-    commands += 'except KeyError:  \n'
-    commands += '    raise Exception, "PINKTEST environment variable must be defined for the testing module. It must point to the testimages directory" \n\n\n'
-
-    commands += 'class ' + testname + '(unittest.TestCase):\n'
-
-    for q in range(len(tests)):
-        commands += generate_test_method( tests[q], q )
-        
-    commands += 'if __name__ == \'__main__\':\n'
-    commands += '    unittest.main(testRunner=xmlrunner.XMLTestRunner(output=\'test-reports\'))\n'
-
-
-    print('filename = ' + filename)
-    outfile = open(filename, 'w')
-    outfile.write(commands)
-    outfile.close()
-    return commands
-
-
-
-def generate_test_method( test, number ):
-    result = ''    
-    result += '    def test_' + str(number) + '(self):\n'
-    result += test + '\n'
-    result += '        self.assertTrue( result == gold )\n\n\n'
-
-    return result;
-
-
-if len(argv)!=3:
-#                                             0                    1                    2
-    raise Exception, "error: usage: ./python_test_generator source_directory python_module_directory"
-
-dir = argv[1]
-target = argv[2]
-
-#for q in ['seuil.c']:
-for q in listdir(dir):
-    opened = False
-    try:
-        filedesc = open(join(dir, q), "r")
-        filedesc.close()
-        opened = True
-    except:
-        print "skipping " + join(dir, q)
-
-    if opened:
-        print('processing file = ' + q )
-        basename = q[:q.rfind('.')]
-
-        tests = parse_file( dir + '/' + q )
-
-        if len(tests) > 0:
-            generate_unit_test( target + '/' + basename + '.py', tests, basename )
-
-
-# LuM end of file
-
diff -r 8b1af7363833 python_test_generator.py~
--- a/python_test_generator.py~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,132 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# 
-# This software is licensed under 
-# CeCILL FREE SOFTWARE LICENSE AGREEMENT
-
-# This software comes in hope that it will be useful but 
-# without any warranty to the extent permitted by applicable law.
-  
-# (C) UjoImro <ujoimro@gmail.com>, 2012
-# ProCarPlan s.r.o.
-
-# This script generates the unittests from the src/com directory
-
-from sys import argv
-from os import listdir
-from os.path import join
-from time import strftime
-from string import replace, find
-
-
-
-def parse_file(filename):
-    result = []
-    parsfile = open( filename, 'r' )
-    lines = parsfile.readlines();
-    for line in lines:
-        test_pos   = line.find('%TEST')
-        images_pos = line.find('%IMAGES')
-        results_pos = line.find('%RESULTS')
-
-        if test_pos>=0:
-            split = line[:len(line)-1].split(' ')
-            command = '';
-            command += '        lead   = pink.cpp.readimage( IMAGES + \'' + split[2].replace('%IMAGES','') + '\' )\n'
-            command += '        result = ' + split[1] + '( lead '
-            for q in split[3:len(split)-1]:
-                command += ', ' + q;
-                
-            command += ')\n'
-            command += '        gold   = pink.cpp.readimage( RESULTS + \'' +  split[len(split)-1].replace('%RESULTS', '') + '\')'
-
-            result.append(command)
-
-    return result
-
-def filtered_test( test ):
-    if test.find('%IMAGES')>=0:
-        return test.replace('%IMAGES','pink.cpp.readimage(\'') + '\')'
-    else:
-        return test
-
-def generate_unit_test( filename, tests, testname ):
-    commands = ''
-    commands += '# -*- coding: utf-8 -*- \n'
-    commands += '#  \n'
-    commands += '# This software is licensed under  \n'
-    commands += '# CeCILL FREE SOFTWARE LICENSE AGREEMENT \n'
-    commands += ' \n'
-    commands += '# This software comes in hope that it will be useful but  \n'
-    commands += '# without any warranty to the extent permitted by applicable law. \n'
-    commands += '   \n'
-    commands += '# (C) UjoImro <ujoimro@gmail.com>, 2012 \n'
-    commands += '# ProCarPlan s.r.o. \n'
-    commands += ' \n'
-    commands += 'import os \n'
-    commands += 'import pink \n'
-    commands += 'import unittest \n'
-    commands += 'import xmlrunner \n'
-    commands += ' \n'
-    commands += 'try:   \n'
-    commands += '    IMAGES  = os.environ["PINKTEST"] + "/images" \n'
-    commands += '    RESULTS = os.environ["PINKTEST"] + "/results_prev" \n'
-    commands += 'except KeyError:  \n'
-    commands += '    raise Exception, "PINKTEST environment variable must be defined for the testing module. It must point to the testimages directory" \n\n\n'
-
-    commands += 'class ' + testname + '(unittest.TestCase):\n'
-
-    for q in range(len(tests)):
-        filtered_test = map( test_filter, tests[q] )
-        commands += generate_test_method( filtered_test, q )
-        
-    commands += 'if __name__ == \'__main__\':\n'
-    commands += '    unittest.main(testRunner=xmlrunner.XMLTestRunner(output=\'test-reports\'))\n'
-
-
-    print('filename = ' + filename)
-    outfile = open(filename, 'w')
-    outfile.write(commands)
-    outfile.close()
-    return commands
-
-
-
-def generate_test_method( test, number ):
-    result = ''    
-    result += '    def test_' + str(number) + '(self):\n'
-    result += test + '\n'
-    result += '        self.assertTrue( result == gold )\n\n\n'
-
-    return result;
-
-
-if len(argv)!=3:
-#                                             0                    1                    2
-    raise Exception, "error: usage: ./python_test_generator source_directory python_module_directory"
-
-dir = argv[1]
-target = argv[2]
-
-#for q in ['seuil.c']: #listdir(dir):
-for q in listdir(dir):
-    opened = False
-    try:
-        filedesc = open(join(dir, q), "r")
-        filedesc.close()
-        opened = True
-    except:
-        print "skipping " + join(dir, q)
-
-    if opened:
-        print('processing file = ' + q )
-        basename = q[:q.rfind('.')]
-
-        tests = parse_file( dir + '/' + q )
-
-        if len(tests) > 0:
-            generate_unit_test( target + '/' + basename + '.py', tests, basename )
-
-
-# LuM end of file
-
diff -r 8b1af7363833 scripts/addconstcolor
--- a/scripts/addconstcolor	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,18 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in const"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-convert         $1  $1.ppm
-ppm2pgm         $1.ppm _r _g _b
-addconst        _r $2 _r
-addconst        _g $2 _g
-addconst        _b $2 _b
-pgm2ppm         _r _g _b $1.ppm
diff -r 8b1af7363833 scripts/ajoutecadre
--- a/scripts/ajoutecadre	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,16 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-cadre           $1          _$1.tmp
-add             $1          _$1.tmp   $2
-rm              _$1.tmp
-
diff -r 8b1af7363833 scripts/close
--- a/scripts/close	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-# ATTENTION : version valable seulement pour des elements structurants
-# symetriques par rapport a l'origine
-USAGE="Usage: $0 in elstruct out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-dilation        $1  $2  $3
-erosion         $3  $2  $3
-
diff -r 8b1af7363833 scripts/closebin
--- a/scripts/closebin	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,18 +0,0 @@
-#!/bin/sh
-# ATTENTION : version valable seulement pour des elements structurants
-# symetriques par rapport a l'origine
-USAGE="Usage: $0 in elstruct xorig yorig out"
-if [ $# -gt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-dilatbin    $1  $2  $3  $4  _$1.dilat
-erosbin    _$1.dilat  $2  $3  $4  $5
-rm         _$1.dilat
-
diff -r 8b1af7363833 scripts/closebin3d
--- a/scripts/closebin3d	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-# ATTENTION : version valable seulement pour des elements structurants
-# symetriques par rapport a l'origine
-USAGE="Usage: $0 in elstruct xorig yorig zorig out"
-if [ $# -gt 6 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 6 ]
-then
-	echo $USAGE
-        exit
-fi
-dilatbin3d   $1  $2  $3  $4  $5  _$1.dilat
-erosbin3d   _$1.dilat  $2  $3  $4  $5  $6
-rm          _$1.dilat
diff -r 8b1af7363833 scripts/closerec
--- a/scripts/closerec	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,16 +0,0 @@
-#!/bin/sh
-# fermeture par reconstruction (dilatation suivie d'une reconstruction geodesique)
-USAGE="Usage: $0 in elstruct xorig yorig out"
-if [ $# -gt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-dilat       $1  $2  $3  $4  _$1.dilat
-geoeros    _$1.dilat  $1  4  -1  $5
-rm         _$1.dilat
diff -r 8b1af7363833 scripts/col2gray
--- a/scripts/col2gray	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,20 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in.ppm out.pgm"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-rgb2bw       $1       _$1.r       _$1.g       _$1.b
-byte2long    _$1.r       _$1.r
-byte2long    _$1.g       _$1.g
-byte2long    _$1.b       _$1.b
-add          _$1.r       _$1.g       _$1.g
-add          _$1.b       _$1.g       _$1.g
-long2byte    _$1.g       2           $2
-rm           _$1.*
diff -r 8b1af7363833 scripts/combine
--- a/scripts/combine	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,19 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 i1 i2 mask out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-
-min $2 $3 /tmp/_combine_1
-inverse $3 /tmp/_combine_i
-min $1 /tmp/_combine_i /tmp/_combine_2
-max /tmp/_combine_1 /tmp/_combine_2 $4
-
-rm /tmp/_combine_?
diff -r 8b1af7363833 scripts/combine_color
--- a/scripts/combine_color	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,21 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 i1 i2 mask out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-
-ppm2pgm $1 /tmp/_combine_color_r1 /tmp/_combine_color_g1 /tmp/_combine_color_b1
-ppm2pgm $2 /tmp/_combine_color_r2 /tmp/_combine_color_g2 /tmp/_combine_color_b2
-combine  /tmp/_combine_color_r1 /tmp/_combine_color_r2 $3 /tmp/_combine_color_r3
-combine  /tmp/_combine_color_g1 /tmp/_combine_color_g2 $3 /tmp/_combine_color_g3
-combine  /tmp/_combine_color_b1 /tmp/_combine_color_b2 $3 /tmp/_combine_color_b3
-pgm2ppm /tmp/_combine_color_r3 /tmp/_combine_color_g3 /tmp/_combine_color_b3 $4
-
-rm /tmp/_combine_color_??
diff -r 8b1af7363833 scripts/crestrest0
--- a/scripts/crestrest0	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,4 +0,0 @@
-hthin $1 null 4 5 $1.th
-crestheight $1.th 4 $1.th.ch
-hthin $1.th.ch null 4 1 $1.th.ch
-crestsegment $1 4 $2 $3 $4 $1.cs
diff -r 8b1af7363833 scripts/crestrest1
--- a/scripts/crestrest1	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,11 +0,0 @@
-crestrestoration $1.th.ch $1.cs 4 $2 $1.th.ch.cr $1.cs.cr 
-min $1.cs.cr $1.th.ch _1
-seuil _1 40 _2
-ptisolated _2 8 _3
-sub _2 _3 _2 
-min $1.th.ch.cr _2 _3
-max $1.th.ch _3 _4
-hthin $1.th.ch.cr _4 4 -1 _5
-mv _2 $1.cs 
-mv _5 $1.th.ch
-rm _*
\ No newline at end of file
diff -r 8b1af7363833 scripts/cropppm
--- a/scripts/cropppm	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,19 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in x y w h out"
-if [ $# -gt 6 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 6 ]
-then
-	echo $USAGE
-        exit
-fi
-ppm2pgm      $1 _$1.r _$1.g _$1.b
-crop        _$1.r  $2  $3  $4  $5 _$1.r
-crop        _$1.g  $2  $3  $4  $5 _$1.g
-crop        _$1.b  $2  $3  $4  $5 _$1.b
-pgm2ppm      _$1.r _$1.g _$1.b $6
-rm          _$1.r _$1.g _$1.b
-
diff -r 8b1af7363833 scripts/cut
--- a/scripts/cut	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,16 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in param out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-medialaxis $1 0 0 $3
-seuil2     $3 $2 255 0 255 $3
-medialaxis $3 0 1 $3
-seuil      $3 1 $3
diff -r 8b1af7363833 scripts/dareaop
--- a/scripts/dareaop	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,16 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in connex area out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-areaopening  $1  $2  $3  $4
-inverse      $4  $4
-areaopening  $4  $2  $3  $4
-inverse      $4  $4
diff -r 8b1af7363833 scripts/deconnecte
--- a/scripts/deconnecte	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,20 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in connex out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-topotypes $1 1 $2 _$1.1
-selndg _$1.1 2 2 _$1.1
-seuilbin _$1.1 1 _$1.1
-uniconnectant $1 4 _$1.2
-inverse _$1.2  _$1.2 
-sub _$1.1 _$1.2 _$1.3
-sub $1 _$1.3 $3
-rm          _$1.?
diff -r 8b1af7363833 scripts/detectbifurcations
--- a/scripts/detectbifurcations	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,47 +0,0 @@
-# Script to detct bifurcations
-# input has to be an skeleton-image with a 8-neighbourhood
-
-# First Element
-erosion $1 ~/Pink/masks/bifurcation8v1_0.pgm out.pgm
-
-# Turn around and continue
-erosion $1 ~/Pink/masks/bifurcation8v1_90.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v1_180.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v1_240.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-# Second Element
-erosion $1 ~/Pink/masks/bifurcation8v2_0.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-# Turn around and continue
-erosion $1 ~/Pink/masks/bifurcation8v2_90.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v2_180.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v2_240.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-# Third Element
-erosion $1 ~/Pink/masks/bifurcation8v3_0.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-# Turn around and continue
-erosion $1 ~/Pink/masks/bifurcation8v3_90.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v3_180.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v3_240.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-#and the intersection
-erosion $1 ~/Pink/masks/intersection_1.pgm help.pgm
-max help.pgm out.pgm out.pgm
diff -r 8b1af7363833 scripts/detectbifurcations2
--- a/scripts/detectbifurcations2	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,47 +0,0 @@
-# Script to detct bifurcations
-# input has to be an skeleton-image with a 8-neighbourhood
-
-# First Element
-erosion $1 ~/Pink/masks/bifurcation8v1_0.pgm out.pgm
-
-# Turn around and continue
-erosion $1 ~/Pink/masks/bifurcation8v1_90.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v1_180.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v1_240.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-# Second Element
-erosion $1 ~/Pink/masks/bifurcation8v2_0.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-# Turn around and continue
-erosion $1 ~/Pink/masks/bifurcation8v2_90.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v2_180.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v2_240.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-# Third Element
-erosion $1 ~/Pink/masks/bifurcation8v3_0.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-# Turn around and continue
-erosion $1 ~/Pink/masks/bifurcation8v3_90.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v3_180.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-erosion $1 ~/Pink/masks/bifurcation8v3_240.pgm help.pgm
-max help.pgm out.pgm out.pgm
-
-#and the intersection
-erosion $1 ~/Pink/masks/intersection_1.pgm help.pgm
-max help.pgm out.pgm out.pgm
diff -r 8b1af7363833 scripts/dilattopo
--- a/scripts/dilattopo	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,14 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in rayon connex out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-dilatball  $1  $2  $4
-hthick     $1  $4  $3  10000 delta $4
diff -r 8b1af7363833 scripts/elim1
--- a/scripts/elim1	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,9 +0,0 @@
-rgb2bw $1 _r _g _b
-xv _r &
-echo "fabriquer un masque blanc sur fond noir _m, par exemple : "
-echo "seuilbin _r 230 _rs ; xv _rs"
-echo "showgrid _rs &"
-echo "selrect _rs x y w h _rss"
-echo "dilat _rss vois4 _m"
-echo "et lancer elim2 <element-structurant>"
-
diff -r 8b1af7363833 scripts/elim2
--- a/scripts/elim2	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,12 +0,0 @@
-inverse _m _mi
-min _r _mi _r1
-add _r _m _r2
-reconsdilat _r1 _r2 $1 _r3
-min _g _mi _g1
-add _g _m _g2
-reconsdilat _g1 _g2 $1 _g3
-min _b _mi _b1
-add _b _m _b2
-reconsdilat _b1 _b2 $1 _b3
-bw2rgb _r3 _g3 _b3 out.ppm
-xv out.ppm&
diff -r 8b1af7363833 scripts/erostopo
--- a/scripts/erostopo	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,14 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in rayon connex out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-erosball  $1  $2  $4
-hthin     $1  $4  $3  10000 delta $4
diff -r 8b1af7363833 scripts/filtrecols
--- a/scripts/filtrecols	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,27 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in taillemin taillecretes taillecols out"
-if [ $# -gt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-# =========================================================
-# elimine les regions minimales de petite taille
-# =========================================================
-lthick        $1       null     4         $2      delta     _$1.tmp1 
-htkern       _$1.tmp1  $1       4         _$1.tmp2
-# =========================================================
-# amincit les cretes
-# =========================================================
-lthin        _$1.tmp2  null     4         $3      delta     _$1.tmp3 
-# =========================================================
-# releve les cols
-# =========================================================
-montecols    _$1.tmp3  4        $4        $5
-
-
diff -r 8b1af7363833 scripts/filtrecomp
--- a/scripts/filtrecomp	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,23 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in connex tailletrous out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-attribute    $1      $2      0     max    area    _$1.a
-seuilbin    _$1.a    $3     _$1.s
-seuilbin    _$1.a    1      _$1.s1
-sub         _$1.s1  _$1.s   _$1.t
-inverse     _$1.t   _$1.t
-min          $1     _$1.t    $4
-rm          _$1.a
-rm          _$1.s
-rm          _$1.s1
-rm          _$1.t
-
diff -r 8b1af7363833 scripts/filtreimp
--- a/scripts/filtreimp	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-lthin         $1       null     8         $2      delta     _$1.tmp1 
-htkernu      _$1.tmp1  $1       8         _$1.tmp2
-lthick       _$1.tmp2  null     4         $2      delta     _$1.tmp3 
-htkern       _$1.tmp3  _$1.tmp2 4         $3 
-
diff -r 8b1af7363833 scripts/filtrepics4
--- a/scripts/filtrepics4	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-hthin         $1      null       4         $2   _$1.tmp 
-deletepeaks  _$1.tmp    4        _$1.tmp
-htkernu      _$1.tmp    $1       4         $3
-rm           _$1.tmp
-
diff -r 8b1af7363833 scripts/filtrepics6
--- a/scripts/filtrepics6	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-hthin3d       $1      null       6         $2   _$1.tmp 
-deletepeaks  _$1.tmp    6        _$1.tmp
-htkernu3d    _$1.tmp    $1       6         $3
-rm           _$1.tmp
-
diff -r 8b1af7363833 scripts/filtrepics8
--- a/scripts/filtrepics8	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-hthin         $1      null       8         $2   _$1.tmp 
-deletepeaks  _$1.tmp    8        _$1.tmp
-htkernu      _$1.tmp    $1       8         $3
-rm           _$1.tmp
-
diff -r 8b1af7363833 scripts/filtrepointes
--- a/scripts/filtrepointes	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,23 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-inverse   $1 $2
-erosion   $2 ~/Pink/masks/2d_east.pgm  /tmp/filtrepointes_1
-erosion   $2 ~/Pink/masks/2d_north.pgm /tmp/filtrepointes_2
-max       /tmp/filtrepointes_1 /tmp/filtrepointes_2 /tmp/filtrepointes_1
-erosion   $2 ~/Pink/masks/2d_west.pgm  /tmp/filtrepointes_2
-max       /tmp/filtrepointes_1 /tmp/filtrepointes_2 /tmp/filtrepointes_1
-erosion   $2 ~/Pink/masks/2d_south.pgm /tmp/filtrepointes_2
-max       /tmp/filtrepointes_1 /tmp/filtrepointes_2 /tmp/filtrepointes_1
-min       $1 /tmp/filtrepointes_1 $2
-sub       $1 $2 $2
-rm        /tmp/filtrepointes_?
diff -r 8b1af7363833 scripts/filtrepointes3d
--- a/scripts/filtrepointes3d	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,27 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-inverse   $1 $2
-erosion   $2 ~/Pink/masks/3d_up.pgm    /tmp/filtrepointes_1
-erosion   $2 ~/Pink/masks/3d_down.pgm  /tmp/filtrepointes_2
-max       /tmp/filtrepointes_1 /tmp/filtrepointes_2 /tmp/filtrepointes_1
-erosion   $2 ~/Pink/masks/3d_east.pgm  /tmp/filtrepointes_2
-max       /tmp/filtrepointes_1 /tmp/filtrepointes_2 /tmp/filtrepointes_1
-erosion   $2 ~/Pink/masks/3d_north.pgm /tmp/filtrepointes_2
-max       /tmp/filtrepointes_1 /tmp/filtrepointes_2 /tmp/filtrepointes_1
-erosion   $2 ~/Pink/masks/3d_west.pgm  /tmp/filtrepointes_2
-max       /tmp/filtrepointes_1 /tmp/filtrepointes_2 /tmp/filtrepointes_1
-erosion   $2 ~/Pink/masks/3d_south.pgm /tmp/filtrepointes_2
-max       /tmp/filtrepointes_1 /tmp/filtrepointes_2 /tmp/filtrepointes_1
-min       $1 /tmp/filtrepointes_1 $2
-sub       $1 $2 $2
-rm        /tmp/filtrepointes_?
diff -r 8b1af7363833 scripts/filtrepuits4
--- a/scripts/filtrepuits4	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-hthick        $1      null       4         $2   _$1.tmp 
-deletewells  _$1.tmp    4        _$1.tmp
-htkern       _$1.tmp    $1       4         $3
-rm           _$1.tmp
-
diff -r 8b1af7363833 scripts/filtrepuits6
--- a/scripts/filtrepuits6	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-hthick3d      $1      null       6         $2   _$1.tmp 
-deletewells  _$1.tmp    6        _$1.tmp
-htkern3d     _$1.tmp    $1       6         $3
-rm           _$1.tmp
-
diff -r 8b1af7363833 scripts/filtrepuits8
--- a/scripts/filtrepuits8	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-hthick        $1      null       8         $2    _$1.tmp 
-deletewells  _$1.tmp    8        _$1.tmp
-htkern       _$1.tmp    $1       8         $3
-rm           _$1.tmp
-
diff -r 8b1af7363833 scripts/firstcomp
--- a/scripts/firstcomp	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,16 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in connex out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-label $1 $2 max _$1.1
-long2byte _$1.1 3 2 _$1.1 
-seuilbin _$1.1 1 $3
-rm _$1.1
diff -r 8b1af7363833 scripts/hautdeforme
--- a/scripts/hautdeforme	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,74 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-
-dilat $1 $PINK/masks/dir0_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir0_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-mv _hdf $2
-
-dilat $1 $PINK/masks/dir1_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir1_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-max _hdf $2 $2
-
-dilat $1 $PINK/masks/dir2_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir2_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-max _hdf $2 $2
-
-dilat $1 $PINK/masks/dir3_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir3_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-max _hdf $2 $2
-
-dilat $1 $PINK/masks/dir4_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir4_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-max _hdf $2 $2
-
-dilat $1 $PINK/masks/dir5_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir5_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-max _hdf $2 $2
-
-dilat $1 $PINK/masks/dir6_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir6_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-max _hdf $2 $2
-
-dilat $1 $PINK/masks/dir7_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir7_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-max _hdf $2 $2
-
-dilat $1 $PINK/masks/dir8_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir8_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-max _hdf $2 $2
-
-dilat $1 $PINK/masks/dir9_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir9_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-max _hdf $2 $2
-
-dilat $1 $PINK/masks/dir10_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir10_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-max _hdf $2 $2
-
-dilat $1 $PINK/masks/dir11_7x7.pgm 3 3 _hdf
-eros _hdf $PINK/masks/dir11_7x7.pgm 3 3 _hdf
-sub _hdf $1 _hdf
-max _hdf $2 $2
-
-rm _hdf
diff -r 8b1af7363833 scripts/hccut
--- a/scripts/hccut	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,25 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in param out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-medialaxis $1 0 0 /tmp/hccut_1
-seuil      /tmp/hccut_1 1 /tmp/hccut_2
-inverse    $1 /tmp/hccut_3
-dist       /tmp/hccut_3 0 /tmp/hccut_3
-long2byte  /tmp/hccut_3 /tmp/hccut_3
-max        /tmp/hccut_3 /tmp/hccut_2 /tmp/hccut_4
-byte2long  /tmp/hccut_4 /tmp/hccut_4
-squelubp   $1 /tmp/hccut_4 8 255 /tmp/hccut_5
-hthin      /tmp/hccut_5 null 4 $2 delta /tmp/hccut_5
-max        /tmp/hccut_3 /tmp/hccut_1 /tmp/hccut_6
-min        /tmp/hccut_5 /tmp/hccut_6 /tmp/hccut_6
-medialaxis /tmp/hccut_6 0 1 /tmp/hccut_7
-seuil      /tmp/hccut_7 1 $3
diff -r 8b1af7363833 scripts/hcut
--- a/scripts/hcut	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,25 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in param out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-medialaxis $1 0 0 /tmp/hcut_1
-seuil2     /tmp/hcut_1 $2 255 0 255 /tmp/hcut_1
-seuil      /tmp/hcut_1 1 /tmp/hcut_2
-inverse    $1 /tmp/hcut_3
-dist       /tmp/hcut_3 0 /tmp/hcut_3
-long2byte  /tmp/hcut_3 /tmp/hcut_3
-max        /tmp/hcut_3 /tmp/hcut_2 /tmp/hcut_4
-byte2long  /tmp/hcut_4 /tmp/hcut_4
-squelubp   $1 /tmp/hcut_4 8 255 /tmp/hcut_5
-min        /tmp/hcut_5 /tmp/hcut_3 /tmp/hcut_6
-max        /tmp/hcut_6 /tmp/hcut_1 /tmp/hcut_6
-medialaxis /tmp/hcut_6 0 1 /tmp/hcut_7
-seuil      /tmp/hcut_7 1 $3
diff -r 8b1af7363833 scripts/hmaxima
--- a/scripts/hmaxima	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,16 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in h out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-addconst     $1       -$2  _$1.sub
-reconsdilat  _$1.sub  $1   vois4     $3
-rm           _$1.sub
-
diff -r 8b1af7363833 scripts/hminima
--- a/scripts/hminima	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,16 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in h out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-addconst     $1       $2  _$1.add
-reconseros  _$1.add  $1   vois4     $3
-rm           _$1.add
-
diff -r 8b1af7363833 scripts/hminimar
--- a/scripts/hminimar	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,22 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in h out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-addconst     $1      $2  _$1.tmp1
-reconseros  _$1.tmp1 $1   vois4    _$1.tmp1
-minima      _$1.tmp1 4   _$1.tmp2
-inverse     _$1.tmp2 _$1.tmp2
-max         _$1.tmp2 $1  _$1.tmp3
-min         _$1.tmp11 _$1.tmp3  $3
-rm           _$1.tmp1
-rm           _$1.tmp2
-rm           _$1.tmp3
-
diff -r 8b1af7363833 scripts/inftophat
--- a/scripts/inftophat	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,18 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in es out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-
-erosion $1 $2 /tmp/_inftophat_1
-sub $1 /tmp/_inftophat_1 $3
-
-rm /tmp/_inftophat_1
-
diff -r 8b1af7363833 scripts/inseregif
--- a/scripts/inseregif	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,21 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in1.gif in2.pgm x y out.gif"
-if [ $# -gt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-convert     $1 _$1.ppm
-ppm2pgm     _$1.ppm _$1.r _$1.g _$1.b
-insere     _$1.r  $2  $3  $4  0 _$1.r
-insere     _$1.g  $2  $3  $4  0 _$1.g
-insere     _$1.b  $2  $3  $4  0 _$1.b
-pgm2ppm    _$1.r _$1.g _$1.b _$1.ppm
-convert    _$1.ppm $5
-rm         _$1.r _$1.g _$1.b _$1.ppm
-
diff -r 8b1af7363833 scripts/insertppm
--- a/scripts/insertppm	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,21 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in1.ppm in2.ppm x y out"
-if [ $# -gt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-ppm2pgm     $1 _$1.r _$1.g _$1.b
-ppm2pgm     $2 _$2.r _$2.g _$2.b
-insert     _$1.r  _$2.r  $3  $4  0 _$1.r
-insert     _$1.g  _$2.g  $3  $4  0 _$1.g
-insert     _$1.b  _$2.b  $3  $4  0 _$1.b
-pgm2ppm    _$1.r _$1.g _$1.b $5
-rm         _$1.r _$1.g _$1.b
-rm         _$2.r _$2.g _$2.b
-
diff -r 8b1af7363833 scripts/invariants
--- a/scripts/invariants	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,18 +0,0 @@
-#!/bin/sh
-# calcul des invariants topologiques en 3D et en 26 connexite
-USAGE="Usage: $0 in"
-if [ $# -gt 1 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 1 ]
-then
-	echo $USAGE
-        exit
-fi
-
-3dkhalimskize $1 h _invariants_$1.k
-3dinvariants _invariants_$1.k
-rm -f _invariants_$1.k
-
diff -r 8b1af7363833 scripts/lfiltrepics4
--- a/scripts/lfiltrepics4	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n <alpha|delta> out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-lthin         $1      null       4         $2      $3      _$1.tmp 
-htkernu      _$1.tmp    $1       4         $4
-changename    $4     "lfiltrepics4($1,$2,$3)"
-rm           _$1.tmp
-
diff -r 8b1af7363833 scripts/lfiltrepuits4
--- a/scripts/lfiltrepuits4	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n <alpha|delta> out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-lthick        $1      null       4         $2      $3      _$1.tmp 
-htkern       _$1.tmp    $1       4         $4
-changename    $4     "lfiltrepuits4($1,$2,$3)"
-rm           _$1.tmp
-
diff -r 8b1af7363833 scripts/mkball
--- a/scripts/mkball	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,6 +0,0 @@
-#usage: $0 
-genimage 11 11 11 0 ball11.pgm
-point ball11.pgm 5 5 5 255 ball11.pgm
-dilatball ball11.pgm 5 0 ball11.pgm
-setorigin ball11.pgm 5 5 5
-
diff -r 8b1af7363833 scripts/mkplans
--- a/scripts/mkplans	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,29 +0,0 @@
-#usage: $0 in.pgm zoffset out.pgm
-crop $1 0 0 $2 160 120 24 _
-explode _ _
-genimage 640 720 1 0 _ 
-insere _0000.pgm _ 000 000 0 _
-insere _0001.pgm _ 160 000 0 _
-insere _0002.pgm _ 320 000 0 _
-insere _0003.pgm _ 480 000 0 _
-insere _0004.pgm _ 000 120 0 _
-insere _0005.pgm _ 160 120 0 _
-insere _0006.pgm _ 320 120 0 _
-insere _0007.pgm _ 480 120 0 _
-insere _0008.pgm _ 000 240 0 _
-insere _0009.pgm _ 160 240 0 _
-insere _0010.pgm _ 320 240 0 _
-insere _0011.pgm _ 480 240 0 _
-insere _0012.pgm _ 000 360 0 _
-insere _0013.pgm _ 160 360 0 _
-insere _0014.pgm _ 320 360 0 _
-insere _0015.pgm _ 480 360 0 _
-insere _0016.pgm _ 000 480 0 _
-insere _0017.pgm _ 160 480 0 _
-insere _0018.pgm _ 320 480 0 _
-insere _0019.pgm _ 480 480 0 _
-insere _0020.pgm _ 000 600 0 _
-insere _0021.pgm _ 160 600 0 _
-insere _0022.pgm _ 320 600 0 _
-insere _0023.pgm _ 480 600 0 _
-mv _ $3
diff -r 8b1af7363833 scripts/moyendir
--- a/scripts/moyendir	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,48 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in outmin outmax"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-
-convol $1 $HOME/Pink/masks/dir0_13x13.pgm _md
-cp _md _mdmin
-mv _md _mdmax
-
-convol $1 $HOME/Pink/masks/dir1_13x13.pgm _md
-min _md _mdmin _mdmin
-max _md _mdmax _mdmax
-
-convol $1 $HOME/Pink/masks/dir2_13x13.pgm _md
-min _md _mdmin _mdmin
-max _md _mdmax _mdmax
-
-convol $1 $HOME/Pink/masks/dir3_13x13.pgm _md
-min _md _mdmin _mdmin
-max _md _mdmax _mdmax
-
-convol $1 $HOME/Pink/masks/dir4_13x13.pgm _md
-min _md _mdmin _mdmin
-max _md _mdmax _mdmax
-
-convol $1 $HOME/Pink/masks/dir5_13x13.pgm _md
-min _md _mdmin _mdmin
-max _md _mdmax _mdmax
-
-convol $1 $HOME/Pink/masks/dir6_13x13.pgm _md
-min _md _mdmin _mdmin
-max _md _mdmax _mdmax
-
-convol $1 $HOME/Pink/masks/dir7_13x13.pgm _md
-min _md _mdmin $2
-max _md _mdmax $3
-
-rm _md
-rm _mdmin
-rm _mdmax
diff -r 8b1af7363833 scripts/open
--- a/scripts/open	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-# ATTENTION : version valable seulement pour des elements structurants
-# symetriques par rapport a l'origine
-USAGE="Usage: $0 in elstruct out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-erosion        $1  $2  $3
-dilation       $3  $2  $3
-
diff -r 8b1af7363833 scripts/openbin
--- a/scripts/openbin	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-# ATTENTION : version valable seulement pour des elements structurants
-# symetriques par rapport a l'origine
-USAGE="Usage: $0 in elstruct xorig yorig out"
-if [ $# -gt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-erosbin    $1  $2  $3  $4  _$1.eros
-dilatbin   _$1.eros  $2  $3  $4  $5
-rm         _$1.eros
diff -r 8b1af7363833 scripts/openbin3d
--- a/scripts/openbin3d	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-# ATTENTION : version valable seulement pour des elements structurants
-# symetriques par rapport a l'origine
-USAGE="Usage: $0 in elstruct xorig yorig zorig out"
-if [ $# -gt 6 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 6 ]
-then
-	echo $USAGE
-        exit
-fi
-erosbin3d    $1  $2  $3  $4  $5  _$1.eros
-dilatbin3d  _$1.eros  $2  $3  $4  $5  $6
-rm          _$1.eros
diff -r 8b1af7363833 scripts/openpar
--- a/scripts/openpar	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-# ouverture paramétrique
-USAGE="Usage: $0 in elstruct param out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-rankfilter   $1  $2  $3 /tmp/_openpar.1
-dilation     /tmp/_openpar.1 $2 /tmp/_openpar.2
-min          /tmp/_openpar.2 $1 $4
-rm           /tmp/_openpar.?
diff -r 8b1af7363833 scripts/openrec
--- a/scripts/openrec	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,16 +0,0 @@
-#!/bin/sh
-# ouverture par reconstruction (erosion suivie d'une reconstruction geodesique)
-USAGE="Usage: $0 in elstruct xorig yorig out"
-if [ $# -gt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 5 ]
-then
-	echo $USAGE
-        exit
-fi
-eros        $1  $2  $3  $4  _$1.eros
-reconsdilat _$1.eros  $1  vois4  $5
-rm         _$1.eros
diff -r 8b1af7363833 scripts/opentophat
--- a/scripts/opentophat	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,18 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in es out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-
-opening $1 $2 /tmp/_opentophat_1
-sub $1 /tmp/_opentophat_1 $3
-
-rm /tmp/_opentophat_1
-
diff -r 8b1af7363833 scripts/ouvrecycles
--- a/scripts/ouvrecycles	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,21 +0,0 @@
-#!/bin/sh
-# ouverture de cycles 
-USAGE="Usage: $0 in area out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-ptseparating  $1 4 /tmp/ouvrecycles_1
-inverse       $1 /tmp/ouvrecycles_2
-areaopening   /tmp/ouvrecycles_2 4 $2 /tmp/ouvrecycles_2
-inverse       /tmp/ouvrecycles_2 /tmp/ouvrecycles_2
-ptseparating  /tmp/ouvrecycles_2 4 /tmp/ouvrecycles_2
-sub           /tmp/ouvrecycles_1 /tmp/ouvrecycles_2 /tmp/ouvrecycles_3
-sub           $1 /tmp/ouvrecycles_3 $3
-rm            /tmp/ouvrecycles_?
diff -r 8b1af7363833 scripts/preparekern
--- a/scripts/preparekern	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,18 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-cadre    $1 _$1.cadre
-inverse  _$1.cadre _$1.cadre
-seuil    $1 1 255 1 255 _$1.seuil
-min      _$1.seuil _$1.cadre $2
-rm         _$1.cadre
-rm         _$1.seuil
diff -r 8b1af7363833 scripts/pseudocloseballnumrec
--- a/scripts/pseudocloseballnumrec	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,16 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-hthick $1 null 8 $2 _$1.tmp
-deletewells _$1.tmp 8 _$1.tmp
-geoeros _$1.tmp $1 4 -1 $3 
-rm _$1.tmp
diff -r 8b1af7363833 scripts/pulstopo
--- a/scripts/pulstopo	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,45 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-filtrepuits4    $1        2      asft_tmp
-filtrepics8    asft_tmp   2      _$1.res1
-
-filtrepuits4   _$1.res1   4      asft_tmp
-filtrepics8    asft_tmp   4      _$1.res2
-
-filtrepuits4   _$1.res2   6      asft_tmp
-filtrepics8    asft_tmp   6      _$1.res3
-
-filtrepuits4   _$1.res3   8      asft_tmp
-filtrepics8    asft_tmp   8      _$1.res4
-
-filtrepuits4   _$1.res4   10      asft_tmp
-filtrepics8    asft_tmp   10      _$1.res5
-
-filtrepuits4   _$1.res5   15      asft_tmp
-filtrepics8    asft_tmp   15      _$1.res6
-
-filtrepuits4   _$1.res6   20      asft_tmp
-filtrepics8    asft_tmp   20      _$1.res7
-
-filtrepuits4   _$1.res7   25      asft_tmp
-filtrepics8    asft_tmp   25      _$1.res8
-
-filtrepuits4   _$1.res8   30      asft_tmp
-filtrepics8    asft_tmp   30      _$1.res9
-
-filtrepuits4   _$1.res9   40      asft_tmp
-filtrepics8    asft_tmp   40      _$1.res10
-
-mv _$1.res10 $2
-
-
diff -r 8b1af7363833 scripts/pulstopo2
--- a/scripts/pulstopo2	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,28 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-filtrepuits4    $1        50     asft_tmp
-filtrepics8    asft_tmp   50     _$1.res1
-
-filtrepuits4   _$1.res1   60     asft_tmp
-filtrepics8    asft_tmp   60     _$1.res2
-
-filtrepuits4   _$1.res2   80     asft_tmp
-filtrepics8    asft_tmp   80     _$1.res3
-
-filtrepuits4   _$1.res3   90      asft_tmp
-filtrepics8    asft_tmp   90      _$1.res4
-
-filtrepuits4   _$1.res4   100     asft_tmp
-filtrepics8    asft_tmp   100     _$1.res5
-
-mv _$1.res5 $2
diff -r 8b1af7363833 scripts/pulstopo3
--- a/scripts/pulstopo3	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-openballnumrec        $1       1 asft_tmp
-pseudocloseballnumrec asft_tmp 1 _$1.res1
-
-openballnumrec        _$1.res1 2 asft_tmp
-pseudocloseballnumrec asft_tmp 2 _$1.res2
-
-openballnumrec        _$1.res2 3 asft_tmp
-pseudocloseballnumrec asft_tmp 3 _$1.res3
-
-openballnumrec        _$1.res3 4 asft_tmp
-pseudocloseballnumrec asft_tmp 4 _$1.res4
-
-openballnumrec        _$1.res4 5 asft_tmp
-pseudocloseballnumrec asft_tmp 5 _$1.res5
-
-openballnumrec        _$1.res5 6 asft_tmp
-pseudocloseballnumrec asft_tmp 6 _$1.res6
-
-openballnumrec        _$1.res6 7 asft_tmp
-pseudocloseballnumrec asft_tmp 7 _$1.res7
-
-openballnumrec        _$1.res7 8 asft_tmp
-pseudocloseballnumrec asft_tmp 8 _$1.res8
-
-openballnumrec        _$1.res8 9 asft_tmp
-pseudocloseballnumrec asft_tmp 9 _$1.res9
-
-openballnumrec        _$1.res9 10 asft_tmp
-pseudocloseballnumrec asft_tmp 10 _$1.res10
-
-rm -f asft_tmp
-mv _$1.res10 $2
diff -r 8b1af7363833 scripts/pulstopo4
--- a/scripts/pulstopo4	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-openballnumrec        $1       11 asft_tmp
-pseudocloseballnumrec asft_tmp 11 _$1.res11
-
-openballnumrec        _$1.res11 12 asft_tmp
-pseudocloseballnumrec asft_tmp 12 _$1.res12
-
-openballnumrec        _$1.res12 13 asft_tmp
-pseudocloseballnumrec asft_tmp 13 _$1.res13
-
-openballnumrec        _$1.res13 14 asft_tmp
-pseudocloseballnumrec asft_tmp 14 _$1.res14
-
-openballnumrec        _$1.res14 15 asft_tmp
-pseudocloseballnumrec asft_tmp 15 _$1.res15
-
-openballnumrec        _$1.res15 16 asft_tmp
-pseudocloseballnumrec asft_tmp 16 _$1.res16
-
-openballnumrec        _$1.res16 17 asft_tmp
-pseudocloseballnumrec asft_tmp 17 _$1.res17
-
-openballnumrec        _$1.res17 18 asft_tmp
-pseudocloseballnumrec asft_tmp 18 _$1.res18
-
-openballnumrec        _$1.res18 19 asft_tmp
-pseudocloseballnumrec asft_tmp 19 _$1.res19
-
-openballnumrec        _$1.res19 20 asft_tmp
-pseudocloseballnumrec asft_tmp 20 _$1.res20
-
-rm -f asft_tmp
-mv _$1.res20 $2
diff -r 8b1af7363833 scripts/pulstopo5
--- a/scripts/pulstopo5	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-openballnumrec        $1       1 asft_tmp
-pseudocloseballnumrec asft_tmp 1 _$1.res1
-
-openballnumrec        _$1.res1 2 asft_tmp
-pseudocloseballnumrec asft_tmp 2 _$1.res2
-
-openballnumrec        _$1.res2 3 asft_tmp
-pseudocloseballnumrec asft_tmp 3 _$1.res3
-
-openballnumrec        _$1.res3 4 asft_tmp
-pseudocloseballnumrec asft_tmp 4 _$1.res4
-
-openballnumrec        _$1.res4 5 asft_tmp
-pseudocloseballnumrec asft_tmp 5 _$1.res5
-
-openballnumrec        _$1.res5 6 asft_tmp
-pseudocloseballnumrec asft_tmp 6 _$1.res6
-
-openballnumrec        _$1.res6 8 asft_tmp
-pseudocloseballnumrec asft_tmp 8 _$1.res7
-
-openballnumrec        _$1.res7 10 asft_tmp
-pseudocloseballnumrec asft_tmp 10 _$1.res8
-
-openballnumrec        _$1.res8 12 asft_tmp
-pseudocloseballnumrec asft_tmp 12 _$1.res9
-
-openballnumrec        _$1.res9 16 asft_tmp
-pseudocloseballnumrec asft_tmp 16 _$1.res10
-
-rm -f asft_tmp
-cp _$1.res10 $2
diff -r 8b1af7363833 scripts/reconnex
--- a/scripts/reconnex	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,22 +0,0 @@
-#!/bin/sh
-# $1 : image binaire (contours deconnectes = 255)
-# $2 : parametre pour le filtrage de distance (typiquement 5)
-# $3 : image resultat
-USAGE="Usage: $0 in.bin h out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-dist        $1         0        _$1.dist
-hmaxima     _$1.dist   $2       _$1.dist
-inverse     _$1.dist   _$1.dist
-minima      _$1.dist   8        _$1.min
-lpemeyer    _$1.dist   _$1.min  $3
-rm          _$1.dist
-rm          _$1.min
diff -r 8b1af7363833 scripts/reconsreg
--- a/scripts/reconsreg	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,16 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 img msk"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-fusreg      $1  $2 1  _tmprr
-long2byte   _tmprr 1 _tmprr
-randrgb     _tmprr _tmprr
-xv _tmprr&
diff -r 8b1af7363833 scripts/round
--- a/scripts/round	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,23 +0,0 @@
-#!/bin/sh
-#-------------------------------------------------------
-# Experimentation d'une chaine de segmentation 
-# de bacteries dans une image de microscopie par epifluorescence
-# Michel Couprie - avril 1999 
-#-------------------------------------------------------
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-
-label       $1 4 max _lab
-tmp         _lab 4 _lab
-long2byte   _lab _lab
-seuilbin    _lab 1 $2
-rm          _lab
diff -r 8b1af7363833 scripts/segbact
--- a/scripts/segbact	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,21 +0,0 @@
-#!/bin/sh
-#-------------------------------------------------------
-# Experimentation d'une chaine de segmentation 
-# de bacteries dans une image de microscopie par epifluorescence
-# Michel Couprie - avril 1999 
-#-------------------------------------------------------
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-
-segment     $1 4 prof 23 max _segmax
-recons      $1 _segmax 4 $2
-rm          _segmax
diff -r 8b1af7363833 scripts/segmentnext
--- a/scripts/segmentnext	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in segprev rayon connex smooth out"
-if [ $# -gt 6 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 6 ]
-then
-	echo $USAGE
-        exit
-fi
-dilattopo $2 $3 $4 /tmp/segmentnext_1
-inverse /tmp/segmentnext_1 /tmp/segmentnext_1
-gradientcd $1 $5 /tmp/segmentnext_2
-watershed /tmp/segmentnext_2 /tmp/segmentnext_1 null null $4 $6
-
diff -r 8b1af7363833 scripts/segmox1
--- a/scripts/segmox1	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,29 +0,0 @@
-#!/bin/sh
-# =======================================================================
-# Segmentation de pastilles Mox (zones U)
-# Methode : seuillage du reseau de transitions 
-#           et obtention de marqueurs avec la fonction distance
-# =======================================================================
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-deriche $1 1 3 0.5 _segmox1.r
-deriche _segmox1.r 1 0 _segmox1.gr
-seuilbin _segmox1.gr 18 _segmox1.sgr
-attribute _segmox1.sgr 4 20000 max area _segmox1.asgr
-seuilbin _segmox1.asgr 1 _segmox1.asgr
-dist _segmox1.asgr 0 _segmox1.dasgr
-long2byte _segmox1.dasgr _segmox1.dasgr
-inverse _segmox1.dasgr _segmox1.dasgr
-segment _segmox1.dasgr 4 2 _segmox1.sdasgr
-inverse $1 _segmox1.i
-propgeo _segmox1.i _segmox1.sdasgr 4 min1 _segmox1.psdasgr
-lpemeyer _segmox1.i _segmox1.psdasgr $2
diff -r 8b1af7363833 scripts/segmox2
--- a/scripts/segmox2	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,21 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in alpha seuilprof out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-deriche             $1            $2           0      _$1.g
-segment          _$1.g             4        prof         $3          min        _$1.sg
-bouchetrous     _$1.sg             4        1000    _$1.bsg
-erosfast       _$1.bsg         vois8    _$1.ebsg
-erosfast      _$1.ebsg         vois8    _$1.ebsg
-reconsdilat   _$1.ebsg       _$1.bsg       vois4  _$1.rebsg
-propgeo          _$1.g     _$1.rebsg           4       min1      _$1.prebsg
-lpemeyer         _$1.g    _$1.prebsg          $4
-#showsurimp          $1            $4&
diff -r 8b1af7363833 scripts/segvessels
--- a/scripts/segvessels	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,3 +0,0 @@
-inverse       $1 _0
-hthin         _0 null 4 4 _1
-volumelignes  _1 _0 4 5 _2
diff -r 8b1af7363833 scripts/sel1comp
--- a/scripts/sel1comp	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in connex out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-label $1 $2 max /tmp/_$1.1
-long2byte /tmp/_$1.1 3 2 $3
-seuil $3 1 $3
-rm /tmp/_$1.1
-
diff -r 8b1af7363833 scripts/sf
--- a/scripts/sf	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,4 +0,0 @@
-float2byte     $1    2    _$1.sf
-xv         _$1.sf
-rm         _$1.sf
-
diff -r 8b1af7363833 scripts/showdestr
--- a/scripts/showdestr	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,10 +0,0 @@
-topotypes   $1           255            _$1.destr
-sel        _$1.destr     6              8               _$1.destr68
-sel        _$1.destr     13             13              _$1.destr
-max        _$1.destr     _$1.destr68    _$1.destr
-inverse    _$1.destr     _$1.destrinv
-min         $1           _$1.destrinv   _$1.destrmin
-add        _$1.destrmin  _$1.destr      _$1.destr
-bw2rgb     _$1.destr     _$1.destrmin   _$1.destrmin    _$1.destr
-xv         _$1.destr
-rm         _$1.destr*
diff -r 8b1af7363833 scripts/showfloat
--- a/scripts/showfloat	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,4 +0,0 @@
-float2byte     $1     2      _$1.sf
-xv         _$1.sf
-rm         _$1.sf
-
diff -r 8b1af7363833 scripts/showmaxima
--- a/scripts/showmaxima	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,12 +0,0 @@
-maxima      $1         8 _$1.maxima
-inverse    _$1.maxima    _$1.maximainv
-min         $1           _$1.maximainv   _$1.maximamin
-add        _$1.maximamin _$1.maxima      _$1.maxima
-bw2rgb     _$1.maxima    _$1.maximamin   _$1.maximamin    _$1.maxima
-if [ $# -gt 1 ]
-then
-	xv   -geometry +$2+$3 -fixed      _$1.maxima
-else
-	xv         _$1.maxima
-fi
-rm         _$1.maxima*
diff -r 8b1af7363833 scripts/showmingrid
--- a/scripts/showmingrid	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,5 +0,0 @@
-minima      $1            4 _$1.showmingrid
-inverse    _$1.showmingrid  _$1.showmingrid
-grid       _$1.showmingrid  10         _$1.showmingrid
-xv         _$1.showmingrid
-rm         _$1.showmingrid
diff -r 8b1af7363833 scripts/showminima
--- a/scripts/showminima	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,12 +0,0 @@
-minima      $1         4 _$1.minima
-inverse    _$1.minima    _$1.minimainv
-min         $1           _$1.minimainv   _$1.minimamin
-add        _$1.minimamin _$1.minima      _$1.minima
-bw2rgb     _$1.minima    _$1.minimamin   _$1.minimamin    _$1.minima
-if [ $# -gt 1 ]
-then
-	xv   -geometry +$2+$3 -fixed      _$1.minima
-else
-	xv         _$1.minima
-fi
-rm         _$1.minima*
diff -r 8b1af7363833 scripts/showpeaks
--- a/scripts/showpeaks	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,8 +0,0 @@
-topotypes   $1           255            _$1.peaks
-selndg     _$1.peaks     1              1               _$1.peaks
-inverse    _$1.peaks     _$1.peaksinv
-min         $1           _$1.peaksinv   _$1.peaksmin
-add        _$1.peaksmin  _$1.peaks      _$1.peaks
-bw2rgb     _$1.peaks     _$1.peaksmin   _$1.peaksmin    _$1.peaks
-xv         _$1.peaks
-rm         _$1.peaks*
diff -r 8b1af7363833 scripts/showstretch
--- a/scripts/showstretch	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,4 +0,0 @@
-stretch     $1           _$1.show
-xv         _$1.show
-rm         _$1.show
-
diff -r 8b1af7363833 scripts/shrink
--- a/scripts/shrink	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,21 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-inverse $1 /tmp/_1 
-dist /tmp/_1 0 /tmp/_1 
-medialaxis $1 /tmp/_1 0 /tmp/_1 
-seuil /tmp/_1 1 /tmp/_2
-hthin $1 /tmp/_2 4 -1 delta /tmp/_2
-hthin /tmp/_2 null 4 $2 delta /tmp/_2
-min /tmp/_2 /tmp/_1 /tmp/_2
-medialaxis /tmp/_2 0 1 $3
-seuil $3 1 $3
diff -r 8b1af7363833 scripts/shrinkc
--- a/scripts/shrinkc	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,26 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in n out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-inverse $1 /tmp/SHRINKC_1 
-dist /tmp/SHRINKC_1 0 /tmp/SHRINKC_d 
-medialaxis $1 /tmp/SHRINKC_d 0 /tmp/SHRINKC_1 
-cadre $1 /tmp/SHRINKC_3
-long2byte /tmp/SHRINKC_d /tmp/SHRINKC_d 
-min /tmp/SHRINKC_d /tmp/SHRINKC_3 /tmp/SHRINKC_3
-max /tmp/SHRINKC_3 /tmp/SHRINKC_1 /tmp/SHRINKC_1
-seuil /tmp/SHRINKC_1 1 /tmp/SHRINKC_2
-hthin $1 /tmp/SHRINKC_2 4 -1 delta /tmp/SHRINKC_2
-hthin /tmp/SHRINKC_2 null 4 $2 delta /tmp/SHRINKC_2
-min /tmp/SHRINKC_2 /tmp/SHRINKC_1 /tmp/SHRINKC_2
-medialaxis /tmp/SHRINKC_2 0 1 $3
-seuil $3 1 $3
-rm -f /tmp/SHRINKC_?
diff -r 8b1af7363833 scripts/skiz2
--- a/scripts/skiz2	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,19 +0,0 @@
-#!/bin/sh
-# les composantes de in1 sont considerees comme un meme objet
-USAGE="Usage: $0 in1 in2 out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-max $1 $2 /tmp/_skiz0
-dist /tmp/_skiz0 0 /tmp/_skiz1
-long2byte /tmp/_skiz1 2 /tmp/_skiz1
-lpemeyer /tmp/_skiz1 4 $2 $1 $3
-changename   $3 "skiz2($1,$2)"
-#rm /tmp/_skiz?
diff -r 8b1af7363833 scripts/sm
--- a/scripts/sm	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,12 +0,0 @@
-minima      $1         4 _$1.minima
-inverse    _$1.minima    _$1.minimainv
-min         $1           _$1.minimainv   _$1.minimamin
-add        _$1.minimamin _$1.minima      _$1.minima
-bw2rgb     _$1.minima    _$1.minimamin   _$1.minimamin    _$1.minima
-if [ $# -gt 1 ]
-then
-	xv   -geometry +$2+$3 -fixed      _$1.minima
-else
-	xv         _$1.minima
-fi
-rm         _$1.minima*
diff -r 8b1af7363833 scripts/sma
--- a/scripts/sma	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,12 +0,0 @@
-maxima      $1         8 _$1.maxima
-inverse    _$1.maxima    _$1.maximainv
-min         $1           _$1.maximainv   _$1.maximamin
-add        _$1.maximamin _$1.maxima      _$1.maxima
-bw2rgb     _$1.maxima    _$1.maximamin   _$1.maximamin    _$1.maxima
-if [ $# -gt 1 ]
-then
-	xv   -geometry +$2+$3 -fixed      _$1.maxima
-else
-	xv         _$1.maxima
-fi
-rm         _$1.maxima*
diff -r 8b1af7363833 scripts/smoothgif
--- a/scripts/smoothgif	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,22 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out.gif"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-convert      $1 _$1.ppm
-ppm2pgm      _$1.ppm _$1.r _$1.g _$1.b
-convol       _$1.r $PINK/masks/vois8.pgm _$1.r
-convol       _$1.g $PINK/masks/vois8.pgm _$1.g
-convol       _$1.b $PINK/masks/vois8.pgm _$1.b
-pgm2ppm      _$1.r _$1.g _$1.b _$2.ppm
-convert      _$2.ppm $2
-gifsicle     $2 -O -o $2
-rm          _$1.r _$1.g _$1.b _$1.ppm _$2.ppm
-
diff -r 8b1af7363833 scripts/smoothppm
--- a/scripts/smoothppm	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,19 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-ppm2pgm      $1 _$1.r _$1.g _$1.b
-convol       _$1.r $PINK/masks/vois8.pgm _$1.r
-convol       _$1.g $PINK/masks/vois8.pgm _$1.g
-convol       _$1.b $PINK/masks/vois8.pgm _$1.b
-pgm2ppm      _$1.r _$1.g _$1.b $2
-rm          _$1.r _$1.g _$1.b
-
diff -r 8b1af7363833 scripts/so
--- a/scripts/so	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,4 +0,0 @@
-shadow     $1 7          _$1.show
-xv         _$1.show
-rm         _$1.show
-
diff -r 8b1af7363833 scripts/squel1
--- a/scripts/squel1	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,17 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in connex out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-medialaxis $1 $2 0 /tmp/_squel1_1
-seuil      /tmp/_squel1_1 1 /tmp/_squel1_1
-hthin      $1 /tmp/_squel1_1 $2 -1 delta $3
-rm         /tmp/_squel1_?
-
diff -r 8b1af7363833 scripts/squel2
--- a/scripts/squel2	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,18 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in dist connex out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-medialaxis $1 $2 0 /tmp/_squel1_1
-seuil      /tmp/_squel1_1 1 /tmp/_squel1_1
-hthin      $1 /tmp/_squel1_1 $3 -1 delta /tmp/_squel1_2
-squelbin   /tmp/_squel1_2 $3 $4
-rm         /tmp/_squel1_?
-
diff -r 8b1af7363833 scripts/squel3
--- a/scripts/squel3	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,19 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in connex k out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-medialaxis $1 $2 0 /tmp/_squel1_1
-seuil      /tmp/_squel1_1 1 /tmp/_squel1_1
-hthin      $1 /tmp/_squel1_1 $2 -1 delta /tmp/_squel1_2
-squelbin   /tmp/_squel1_2 $2 /tmp/_squel1_3
-ebarbe     /tmp/_squel1_3 $2 $3 $4
-rm         /tmp/_squel1_?
-
diff -r 8b1af7363833 scripts/squelette
--- a/scripts/squelette	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,22 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in connex n out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-medialaxis $1 0 0 /tmp/_squel1_1
-seuil      /tmp/_squel1_1 1 /tmp/_squel1_1
-inverse    $1 /tmp/_squel1_2
-dist       /tmp/_squel1_2 0 /tmp/_squel1_2
-byte2long  /tmp/_squel1_1 /tmp/_squel1_1
-max        /tmp/_squel1_1 /tmp/_squel1_2 /tmp/_squel1_2
-squelubp   $1 /tmp/_squel1_2 $2 255 $4
-hthinbin   $4 null $2 -1 $3 $4
-rm         /tmp/_squel1_?
-
diff -r 8b1af7363833 scripts/squelette3d
--- a/scripts/squelette3d	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,22 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in connex n out"
-if [ $# -gt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 4 ]
-then
-	echo $USAGE
-        exit
-fi
-medialaxis  $1 0 0 /tmp/_squel1_1
-seuil       /tmp/_squel1_1 1 /tmp/_squel1_1
-inverse     $1 /tmp/_squel1_2
-dist        /tmp/_squel1_2 0 /tmp/_squel1_2
-byte2long   /tmp/_squel1_1 /tmp/_squel1_1
-max         /tmp/_squel1_1 /tmp/_squel1_2 /tmp/_squel1_2
-squelubp    $1 /tmp/_squel1_2 $2 255 $4
-htkern3dbin $4 $2 $3 $4
-rm          /tmp/_squel1_?
-
diff -r 8b1af7363833 scripts/ss
--- a/scripts/ss	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,4 +0,0 @@
-stretch     $1           _$1.show
-xv         _$1.show
-rm         _$1.show
-
diff -r 8b1af7363833 scripts/sur
--- a/scripts/sur	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,20 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 image_ndg image_bin"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-# $1 : image en ndg
-# $2 : image binaire, objet 255, fond 0
-inverse     $2           /tmp/surimpinv
-min         $1           /tmp/surimpinv   /tmp/surimpmin
-add        /tmp/surimpmin  $2             /tmp/surimpmax  
-pgm2ppm    /tmp/surimpmax /tmp/surimpmin   /tmp/surimpmin   /tmp/surimpmin
-xv         /tmp/surimpmin
-rm         /tmp/surimp*
diff -r 8b1af7363833 scripts/surimpcol
--- a/scripts/surimpcol	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,32 +0,0 @@
-#!/bin/sh
-# $1 : image en ndg
-# $2 : image en couleurs (ex: marqueurs), fond noir
-# $3 : image resultat en couleurs
-USAGE="Usage: $0 i1.pgm i2.ppm out.ppm"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-
-# genere le masque des marqueurs en couleur
-rgb2bw      $2           _$2.r          _$2.g           _$2.b
-max         _$2.r        _$2.g          _$2.m
-max         _$2.m        _$2.b          _$2.m
-seuilbin    _$2.m        1              _$2.m
-inverse     _$2.m        _$2.mi
-
-# incruste les marqueurs couleur dans l'image ndg
-min         $1           _$2.mi         _$1.i
-max         _$2.r        _$1.i          _$2.r
-max         _$2.g        _$1.i          _$2.g
-max         _$2.b        _$1.i          _$2.b
-
-bw2rgb      _$2.r        _$2.g          _$2.b          $3
-
-rm _$2.r; rm _$2.g; rm _$2.b; rm _$2.m; rm _$2.mi; rm _$1.i
\ No newline at end of file
diff -r 8b1af7363833 scripts/tak
--- a/scripts/tak	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,62 +0,0 @@
-#!/bin/sh
-#-------------------------------------------------------
-# Experimentation d'une chaine de segmentation 
-# et de compression selective de documents
-# Michel Couprie - avril 1999 
-#-------------------------------------------------------
-USAGE="Usage: $0 in"
-if [ $# -gt 1 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 1 ]
-then
-	echo $USAGE
-        exit
-fi
-#-------------------------------------------------------
-# segmentation du texte
-#-------------------------------------------------------
-segment     $1 4 prof 80 max _seg
-recons      $1 _seg 4 _segr
-inverse     _segr _segri
-#-------------------------------------------------------
-# extraction des frontieres interne et externe 
-# et des points interieurs et exterieurs
-#-------------------------------------------------------
-border      _segr 4 _bordint
-border      _segri 8 _bordext
-min         _segr _bordint _int
-inverse     _bordext _bordexti
-min         _segri _bordexti _ext
-#-------------------------------------------------------
-# extraction du fond
-#-------------------------------------------------------
-max        _segr _bordext _maskbg
-propgeo    $1 _maskbg 4 randb _bg
-inverse    _maskbg _maskbg
-min        $1 _maskbg _maskbg
-max        _bg _maskbg _bg
-#-------------------------------------------------------
-# extraction des valeurs de gris des frontieres
-#-------------------------------------------------------
-max        _bordint _bordext _bordmask
-min        $1 _bordmask _bord
-#-------------------------------------------------------
-# compression sur 4, 8 ou 16 niveaux de gris
-#-------------------------------------------------------
-scale      _bord 0.0625 _bordc16
-scale      _bordc16 16 _bordc16
-scale      _bord 0.03125 _bordc8
-scale      _bordc8 32 _bordc8
-scale      _bord 0.015625 _bordc4
-scale      _bordc4 64 _bordc4
-#-------------------------------------------------------
-# reconstruction
-#-------------------------------------------------------
-min        _bg _ext _
-max        _ _bordc16 _recons16
-max        _ _bordc8 _recons8
-max        _ _bordc4 _recons4
-min        _bg _segri _recons
diff -r 8b1af7363833 scripts/tak1
--- a/scripts/tak1	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,62 +0,0 @@
-#!/bin/sh
-#-------------------------------------------------------
-# Experimentation d'une chaine de segmentation 
-# et de compression selective de documents
-# Michel Couprie - avril 1999 
-#-------------------------------------------------------
-USAGE="Usage: $0 in"
-if [ $# -gt 1 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 1 ]
-then
-	echo $USAGE
-        exit
-fi
-#-------------------------------------------------------
-# segmentation du texte
-#-------------------------------------------------------
-segment     $1 4 prof 80 max _seg
-recons      $1 _seg 4 _segr
-inverse     _segr _segri
-#-------------------------------------------------------
-# extraction des frontieres interne et externe 
-# et des points interieurs et exterieurs
-#-------------------------------------------------------
-border      _segr 4 _bordint
-border      _segri 8 _bordext
-min         _segr _bordint _int
-inverse     _bordext _bordexti
-min         _segri _bordexti _ext
-#-------------------------------------------------------
-# extraction du fond
-#-------------------------------------------------------
-max        _segr _bordext _maskbg
-propgeo    $1 _maskbg 4 randb _bg
-inverse    _maskbg _maskbg
-min        $1 _maskbg _maskbg
-max        _bg _maskbg _bg
-#-------------------------------------------------------
-# extraction des valeurs de gris des frontieres
-#-------------------------------------------------------
-max        _bordint _bordext _bordmask
-min        $1 _bordmask _bord
-#-------------------------------------------------------
-# compression sur 4, 8 ou 16 niveaux de gris
-#-------------------------------------------------------
-scale      _bord 0.0625 _bordc16
-scale      _bordc16 16 _bordc16
-scale      _bord 0.03125 _bordc8
-scale      _bordc8 32 _bordc8
-scale      _bord 0.015625 _bordc4
-scale      _bordc4 64 _bordc4
-#-------------------------------------------------------
-# reconstruction
-#-------------------------------------------------------
-min        _bg _ext _
-max        _ _bordc16 _recons16
-max        _ _bordc8 _recons8
-max        _ _bordc4 _recons4
-min        _bg _segri _recons
diff -r 8b1af7363833 scripts/tak2
--- a/scripts/tak2	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-#!/bin/sh
-#-------------------------------------------------------
-# Experimentation d'une chaine de segmentation 
-# et de compression selective de documents
-# Segmentation multiclasses
-# Michel Couprie - mai 1999 
-#-------------------------------------------------------
-USAGE="Usage: $0 in out"
-if [ $# -gt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 2 ]
-then
-	echo $USAGE
-        exit
-fi
-#-------------------------------------------------------
-# segmentation du texte
-#-------------------------------------------------------
-segmentnum  $1      prof    15      _seg
-#-------------------------------------------------------
-# bouchage des trous
-#-------------------------------------------------------
-tmp         _seg    4      _segb
-#-------------------------------------------------------
-# extraction des frontieres (suppression du cadre)
-#-------------------------------------------------------
-border      _segb   8      _bord
-long2byte   _bord   _bord
-cadre       _bord   _tmp
-sub         _bord   _tmp   _bord
-#-------------------------------------------------------
-# marquage des regions epaisses
-#-------------------------------------------------------
-dist        _bord   0      _dist
-seuilbin    _dist   15     _mark
-#-------------------------------------------------------
-# reconstruction
-#-------------------------------------------------------
-reconsplateaux _segb _mark 4 _rec
-long2byte   _rec    _tmp
-seuilbin    _tmp    1      $2
diff -r 8b1af7363833 scripts/trous
--- a/scripts/trous	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,19 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in connex out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-cadre $1 _$1.1
-inverse $1 _$1.2
-reconsdilat _$1.1 _$1.2 $2 _$1.3
-sub _$1.2 _$1.3 $3
-#rm _$1.?
-
-    
\ No newline at end of file
diff -r 8b1af7363833 scripts/zoomintgif
--- a/scripts/zoomintgif	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,21 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in.gif zoom-int-factor out.gif"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-convert    $1 _$1.ppm
-rgb2bw    _$1.ppm _$1.r _$1.g _$1.b
-zoomint   _$1.r $2 _$1.r
-zoomint   _$1.g $2 _$1.g
-zoomint   _$1.b $2 _$1.b
-bw2rgb    _$1.r _$1.g _$1.b _$1.ppm
-convert   _$1.ppm $3
-rm        _$1.?
-
diff -r 8b1af7363833 scripts/zoomintppm
--- a/scripts/zoomintppm	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,19 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in.ppm zoom-int-factor out.ppm"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-ppm2pgm     $1 _$1.r _$1.g _$1.b
-zoomint   _$1.r $2 _$1.r
-zoomint   _$1.g $2 _$1.g
-zoomint   _$1.b $2 _$1.b
-pgm2ppm   _$1.r _$1.g _$1.b $3
-rm        _$1.?
-
diff -r 8b1af7363833 scripts/zoomintrgb
--- a/scripts/zoomintrgb	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,19 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in.ppm zoom-int-factor out.ppm"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-rgb2bw     $1 _$1.r _$1.g _$1.b
-zoomint   _$1.r $2 _$1.r
-zoomint   _$1.g $2 _$1.g
-zoomint   _$1.b $2 _$1.b
-bw2rgb    _$1.r _$1.g _$1.b $3
-rm        _$1.?
-
diff -r 8b1af7363833 scripts/zoomppm
--- a/scripts/zoomppm	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,19 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in k out"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-ppm2pgm      $1 _$1.r _$1.g _$1.b
-zoom        _$1.r  $2  _$1.r
-zoom        _$1.g  $2  _$1.g
-zoom        _$1.b  $2  _$1.b
-pgm2ppm     _$1.r _$1.g _$1.b $3
-rm          _$1.r _$1.g _$1.b
-
diff -r 8b1af7363833 scripts/zoomrgb
--- a/scripts/zoomrgb	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,19 +0,0 @@
-#!/bin/sh
-USAGE="Usage: $0 in.ppm zoom-factor out.ppm"
-if [ $# -gt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-if [ $# -lt 3 ]
-then
-	echo $USAGE
-        exit
-fi
-bw2rgb     $1 _$1.r _$1.g _$1.b
-zoom      _$1.r $2 _$1.r
-zoom      _$1.g $2 _$1.g
-zoom      _$1.b $2 _$1.b
-rgb2bw    _$1.r _$1.g _$1.b $3
-rm        _$1.?
-
diff -r 8b1af7363833 src/com/autocrop.c
--- a/src/com/autocrop.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/autocrop.c	Mon Jan 13 15:50:10 2014 +0100
@@ -69,6 +69,7 @@
   struct xvimage * in;
   struct xvimage * out;
   double seuil;
+  index_t w, h, p, xmin, ymin, zmin;
 
   if ((argc != 2) && (argc != 3) && (argc != 4))
   {
@@ -88,7 +89,15 @@
   else 
     seuil = 0;
 
+#ifdef VERBOSE
+  lautocrop2(in, seuil, &xmin, &ymin, &zmin, &w, &h, &p);
+  printf("Crop: xmin=%d, ymin=%d, zmin=%d, w=%d, h=%d, p=%d\n",
+	 xmin, ymin, zmin, w, h, p);
+  if (p == 1) out = lcrop(in, xmin, ymin, w, h);
+  else        out = lcrop3d(in, xmin, ymin, zmin, w, h, p);
+#else
   out = lautocrop(in, seuil);
+#endif
   if (out == NULL)
   {
     fprintf(stderr, "%s: lautocrop failed\n", argv[0]);
diff -r 8b1af7363833 src/com/axones._notused_c
--- a/src/com/axones._notused_c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/axones._notused_c	Mon Jan 13 15:50:10 2014 +0100
@@ -1,3 +1,37 @@
+/*
+Copyright ESIEE (2009) 
+
+m.couprie@esiee.fr
+
+This software is an image processing library whose purpose is to be
+used primarily for research and teaching.
+
+This software is governed by the CeCILL  license under French law and
+abiding by the rules of distribution of free software. You can  use, 
+modify and/ or redistribute the software under the terms of the CeCILL
+license as circulated by CEA, CNRS and INRIA at the following URL
+"http://www.cecill.info". 
+
+As a counterpart to the access to the source code and  rights to copy,
+modify and redistribute granted by the license, users are provided only
+with a limited warranty  and the software's author,  the holder of the
+economic rights,  and the successive licensors  have only  limited
+liability. 
+
+In this respect, the user's attention is drawn to the risks associated
+with loading,  using,  modifying and/or developing or reproducing the
+software by the user in light of its specific status of free software,
+that may mean  that it is complicated to manipulate,  and  that  also
+therefore means  that it is reserved for developers  and  experienced
+professionals having in-depth computer knowledge. Users are therefore
+encouraged to load and test the software's suitability as regards their
+requirements in conditions enabling the security of their systems and/or 
+data to be ensured and,  more generally, to use and operate it in the 
+same conditions as regards security. 
+
+The fact that you are presently reading this means that you have had
+knowledge of the CeCILL license and that you accept its terms.
+*/
 /* rotation et superposition d'images de coupes d'axones  */
 /* Michel Couprie - mai 1997, juillet 1998 */
 
@@ -19,6 +53,7 @@
 #include <mccodimage.h>
 #include <mcimage.h>
 #include <llabelplateaux.h>
+#include <lwarp.h>
 
 /* ==================================== */
 int32_t laxones(
@@ -277,7 +312,7 @@
     fprintf(stderr, "laxones: allocimage failed\n");
     exit(0);
   }
-  LABEL = ULONGDATA(lab);
+  LABEL = SLONGDATA(lab);
   if (! llabelplateaux(imcentres, 8, lab, &nblabels))
   {
     fprintf(stderr, "laxones: llabelplateaux failed\n");
@@ -731,8 +766,8 @@
 
   n = 0;
   cumulndg = 0.0;
-  for (x = mcmax(0,xc-r); x < mcmin(xc+r+1,rs); x++) 
-    for (y = mcmax(0,yc-r); y < mcmin(yc+r+1,cs); y++) 
+  for (x = max(0,xc-r); x < min(xc+r+1,rs); x++) 
+    for (y = max(0,yc-r); y < min(yc+r+1,cs); y++) 
       if ((int32_t)sqrt(((x - xc) * (x - xc)) + ((y - yc) * (y - yc))) == r)
       {
         n++;
@@ -746,9 +781,8 @@
 
 
 /* =============================================================== */
-int main(argc, argv) 
+int main(int argc, char **argv)
 /* =============================================================== */
-  int argc; char **argv;
 {
   struct xvimage * image;
   struct xvimage * imcentres;
diff -r 8b1af7363833 src/com/ball._notused_c
--- a/src/com/ball._notused_c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/ball._notused_c	Mon Jan 13 15:50:10 2014 +0100
@@ -1,4 +1,37 @@
-/* $Id: ball.c,v 1.1.1.1 2008-11-25 08:01:38 mcouprie Exp $ */
+/*
+Copyright ESIEE (2009) 
+
+m.couprie@esiee.fr
+
+This software is an image processing library whose purpose is to be
+used primarily for research and teaching.
+
+This software is governed by the CeCILL  license under French law and
+abiding by the rules of distribution of free software. You can  use, 
+modify and/ or redistribute the software under the terms of the CeCILL
+license as circulated by CEA, CNRS and INRIA at the following URL
+"http://www.cecill.info". 
+
+As a counterpart to the access to the source code and  rights to copy,
+modify and redistribute granted by the license, users are provided only
+with a limited warranty  and the software's author,  the holder of the
+economic rights,  and the successive licensors  have only  limited
+liability. 
+
+In this respect, the user's attention is drawn to the risks associated
+with loading,  using,  modifying and/or developing or reproducing the
+software by the user in light of its specific status of free software,
+that may mean  that it is complicated to manipulate,  and  that  also
+therefore means  that it is reserved for developers  and  experienced
+professionals having in-depth computer knowledge. Users are therefore
+encouraged to load and test the software's suitability as regards their
+requirements in conditions enabling the security of their systems and/or 
+data to be ensured and,  more generally, to use and operate it in the 
+same conditions as regards security. 
+
+The fact that you are presently reading this means that you have had
+knowledge of the CeCILL license and that you accept its terms.
+*/
 
 OBSOLETE - VOIR DRAWBALL
 
@@ -36,9 +69,8 @@
 #include <mcimage.h>
 
 /* =============================================================== */
-int main(argc, argv) 
+int main(int argc, char **argv)
 /* =============================================================== */
-  int argc; char **argv; 
 {
   struct xvimage * image;
   int32_t i, j, k, xc, yc, zc;
diff -r 8b1af7363833 src/com/blob.c
--- a/src/com/blob.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,60 +0,0 @@
-/* $Id: blob.c,v 1.1.1.1 2008-11-25 08:01:38 mcouprie Exp $ */
-/* \file blob.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <string.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lblob.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  int32_t niter;
-
-  if (argc != 4)
-  {
-    fprintf(stderr, "usage: %s filein.pgm niter fileout.pgm\n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-
-  niter = atoi(argv[2]);
-
-  if (! lblob(image, niter))
-  {
-    fprintf(stderr, "%s: blob failed\n", argv[0]);
-    exit(1);
-  }
-
-  writeimage(image, argv[argc-1]);
-  freeimage(image);
-
-  return 0;
-} /* main */
-
diff -r 8b1af7363833 src/com/click2d.c
--- a/src/com/click2d.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,108 +0,0 @@
-/* $Id: click2d.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* \file click2d.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <string.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lclick.h>
-
-#define NBMAXCLICKS 10000 
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  struct xvimage * result;
-  int32_t zoom;
-  int32_t i, rs, cs, ds, ps, N, nlabs;
-  FILE *fd;
-
-  if ((argc != 4) && (argc != 5))
-  {
-    fprintf(stderr, "usage: %s filein.pgm [labs.pgm] zoom fileout\n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-  rs = rowsize(image);
-  cs = colsize(image);
-  ds = depth(image);
-  ps = rs * cs;
-  N = ps * ds;
-
-  if (argc == 4) /* pas d'image de labels */
-  {
-    uint32_t * R;
-    result = allocimage(NULL, rs, cs, ds, VFF_TYP_4_BYTE);
-    if (result == NULL)
-    {   
-      fprintf(stderr, "%s: malloc failed\n", argv[0]);
-      exit(1);
-    }
-    R = ULONGDATA(result);
-    memset(R, 0, N*sizeof(int32_t));
-    zoom = atoi(argv[2]);
-
-    if (! lclick2d(image, result, zoom))
-    {
-      fprintf(stderr, "%s: lclick2d failed\n", argv[0]);
-      exit(1);
-    }
-  }
-  else /* image de labels disponible */
-  {
-    result = readimage(argv[2]);
-    if (result == NULL)
-    {   
-      fprintf(stderr, "%s: readimage failed\n", argv[0]);
-      exit(1);
-    }
-    if ((rowsize(result) != rs) || (colsize(result) != cs) || (depth(result) != ds))
-    {
-      fprintf(stderr, "%s: incompatible image sizes\n", argv[0]);
-      exit(1);
-    }
-    if (datatype(result) != VFF_TYP_4_BYTE)
-    {   
-      fprintf(stderr, "%s: type of label image MUST be int32_t\n", argv[0]);
-      exit(1);
-    }
-    zoom = atoi(argv[3]);
-
-    if (! lclick2d(image, result, zoom))
-    {
-      fprintf(stderr, "%s: lclick2d failed\n", argv[0]);
-      exit(1);
-    }
-  }
-
-  writelongimage(result, argv[argc - 1]);
-  freeimage(result);
-  freeimage(image);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/click3d.c
--- a/src/com/click3d.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,131 +0,0 @@
-/* $Id: click3d.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* \file click3d.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <string.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lclick.h>
-
-#define NBMAXCLICKS 10000 
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  struct xvimage * result;
-  uint32_t *LAB;
-  int32_t *VLAB;
-  int32_t zoom;
-  int32_t i, rs, cs, ds, ps, N, nlabs;
-  FILE *fd;
-
-  if ((argc != 4) && (argc != 5))
-  {
-    fprintf(stderr, "usage: %s filein.pgm [labs.pgm] zoom fileout\n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-  rs = rowsize(image);
-  cs = colsize(image);
-  ds = depth(image);
-  ps = rs * cs;
-  N = ps * ds;
-
-  if (argc == 4) /* pas d'image de labels : sortie dans une liste de points */
-  {
-    LAB = (uint32_t *)calloc(1,NBMAXCLICKS * sizeof(int32_t));
-    VLAB = (int32_t *)calloc(1,NBMAXCLICKS * sizeof(int32_t));
-    if ((LAB == NULL) || (VLAB == NULL))
-    {   
-      fprintf(stderr, "%s: malloc failed\n", argv[0]);
-      exit(1);
-    }
-    zoom = atoi(argv[2]);
-
-    if (! lclick3d(image, LAB, VLAB, &nlabs, zoom))
-    {
-      fprintf(stderr, "%s: lclick3d failed\n", argv[0]);
-      exit(1);
-    }
-
-    fd = fopen(argv[argc - 1],"w");
-    if (!fd)
-    {
-      fprintf(stderr, "%s: cannot open file: %s\n", argv[0], argv[argc - 1]);
-      exit(1);
-    }
-
-    if (ds == 1) 
-    {
-      fprintf(fd, "n %d\n", nlabs);
-      for (i = 0; i < nlabs; i++)
-        fprintf(fd, "%d %d %d\n", LAB[i] % rs, LAB[i] / rs, VLAB[i]); 
-    }
-    else
-    {
-      fprintf(fd, "N %d\n", nlabs);
-      for (i = 0; i < nlabs; i++)
-        fprintf(fd, "%d %d %d %d\n", LAB[i] % rs, (LAB[i] % ps) / rs, LAB[i] / ps, VLAB[i]); 
-    }
-    fclose(fd);
-    free(LAB);
-    freeimage(image);
-  }
-  else /* image de labels disponible */
-  {
-    result = readimage(argv[2]);
-    if (result == NULL)
-    {   
-      fprintf(stderr, "%s: readimage failed\n", argv[0]);
-      exit(1);
-    }
-    if ((rowsize(result) != rs) || (colsize(result) != cs) || (depth(result) != ds))
-    {
-      fprintf(stderr, "%s: incompatible image sizes\n", argv[0]);
-      exit(1);
-    }
-    if (datatype(result) != VFF_TYP_4_BYTE)
-    {   
-      fprintf(stderr, "%s: type of label image MUST be int32_t\n", argv[0]);
-      exit(1);
-    }
-    zoom = atoi(argv[3]);
-
-    if (! lclick2d(image, result, zoom))
-    {
-      fprintf(stderr, "%s: lclick2d failed\n", argv[0]);
-      exit(1);
-    }
-
-    writelongimage(result, argv[4]);
-    freeimage(result);
-    freeimage(image);
-  }
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/deriche.c
--- a/src/com/deriche.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/deriche.c	Mon Jan 13 15:50:10 2014 +0100
@@ -98,7 +98,7 @@
     l = atof(argv[4]);
   }
 
-  if (! lderiche_lderiche(image1, alpha, function, l))
+  if (! lderiche(image1, alpha, function, l))
   {
     fprintf(stderr, "%s: function lderiche failed\n", argv[0]);
     exit(1);
diff -r 8b1af7363833 src/com/deriche3d.c
--- a/src/com/deriche3d.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/deriche3d.c	Mon Jan 13 15:50:10 2014 +0100
@@ -98,7 +98,7 @@
 
   if (function == 4)
   { 
-    if (! lderiche_llisseurrec3d(image1, alpha))
+    if (! llisseurrec3d(image1, alpha))
     {
       fprintf(stderr, "deriche3d: function llisseurrec3d failed\n");
       exit(1);
diff -r 8b1af7363833 src/com/dilatbin3d.c
--- a/src/com/dilatbin3d.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/dilatbin3d.c	Mon Jan 13 15:50:10 2014 +0100
@@ -105,7 +105,7 @@
   x = atoi(argv[3]);
   y = atoi(argv[4]);
   z = atoi(argv[5]);
-  if (! ldilateros3d_ldilatbin3d(image, elem, x, y, z))
+  if (! ldilatbin3d(image, elem, x, y, z))
   {
     fprintf(stderr, "%s: function ldilatbin3d failed\n", argv[0]);
     exit(1);
diff -r 8b1af7363833 src/com/dilatfast3d._notused_c
--- a/src/com/dilatfast3d._notused_c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/dilatfast3d._notused_c	Mon Jan 13 15:50:10 2014 +0100
@@ -1,4 +1,37 @@
-/* $Id: dilatfast3d.c,v 1.1.1.1 2008-11-25 08:01:37 mcouprie Exp $ */
+/*
+Copyright ESIEE (2009) 
+
+m.couprie@esiee.fr
+
+This software is an image processing library whose purpose is to be
+used primarily for research and teaching.
+
+This software is governed by the CeCILL  license under French law and
+abiding by the rules of distribution of free software. You can  use, 
+modify and/ or redistribute the software under the terms of the CeCILL
+license as circulated by CEA, CNRS and INRIA at the following URL
+"http://www.cecill.info". 
+
+As a counterpart to the access to the source code and  rights to copy,
+modify and redistribute granted by the license, users are provided only
+with a limited warranty  and the software's author,  the holder of the
+economic rights,  and the successive licensors  have only  limited
+liability. 
+
+In this respect, the user's attention is drawn to the risks associated
+with loading,  using,  modifying and/or developing or reproducing the
+software by the user in light of its specific status of free software,
+that may mean  that it is complicated to manipulate,  and  that  also
+therefore means  that it is reserved for developers  and  experienced
+professionals having in-depth computer knowledge. Users are therefore
+encouraged to load and test the software's suitability as regards their
+requirements in conditions enabling the security of their systems and/or 
+data to be ensured and,  more generally, to use and operate it in the 
+same conditions as regards security. 
+
+The fact that you are presently reading this means that you have had
+knowledge of the CeCILL license and that you accept its terms.
+*/
 
 OBSOLETE - voir dilatfast
 
@@ -50,10 +83,15 @@
 #include <mcimage.h>
 #include <ldilateros3d.h>
 
+/* les elements structurants */
+/*                               0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 */
+static uint8_t vois26[26]={1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
+static uint8_t vois18[26]={0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0};
+static uint8_t vois6 [26]={0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
+
 /* =============================================================== */
-int main(argc, argv) 
+int main(int argc, char **argv)
 /* =============================================================== */
-  int argc; char **argv; 
 {
   struct xvimage * image;
   uint8_t *mask = NULL;
diff -r 8b1af7363833 src/com/dilatplan.c
--- a/src/com/dilatplan.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,86 +0,0 @@
-/* $Id: dilatplan.c,v 1.1.1.1 2008-11-25 08:01:38 mcouprie Exp $ */
-/* \file dilatplan.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-/* 
-NAME
-
-<B>dilat</B> - morphological dilation by a plane structuring element
-
-SYNOPSIS
-
-<B>dilat</B> in.pgm el.pgm x y out.pgm
-
-DESCRIPTION
-
-The (plane) structuring element is given the non-null values in <B>el.pgm</B>, 
-its origin (wrt the point (0,0) of <B>el.pgm</B>) is given by the values of the parameters 
-<B>x</B> and <B>y</B>. 
-
-Types supported: byte 2D.
-
-CLASS 
-
-morph
-
-*/
-
-/* Michel Couprie - mars 1997 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <ldilateros.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  struct xvimage * elem;
-  int32_t x, y;
-
-  if (argc != 6)
-  {
-    fprintf(stderr, "usage: %s f.pgm el.pgm x y out.pgm \n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  elem = readimage(argv[2]);
-  if ((image == NULL) || (elem == NULL))
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-  
-  x = atoi(argv[3]);
-  y = atoi(argv[4]);
-  if (! ldilateros_ldilat(image, elem, x, y))
-  {
-    fprintf(stderr, "%s: function ldilat failed\n", argv[0]);
-    exit(1);
-  }
-
-  writeimage(image, argv[5]);
-  freeimage(image);
-  freeimage(elem);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/geodilat.c
--- a/src/com/geodilat.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/geodilat.c	Mon Jan 13 15:50:10 2014 +0100
@@ -46,7 +46,7 @@
 The parameter \b niter sets the number of iterations. If \b niter = -1,
 then the iterations continue until stability.
 
-<B>Types supported:</B> byte 2d, byte 3d.
+<B>Types supported:</B> byte 2d, byte 3d, short 2d, short 3d, long 2d, long 3d.
 
 <B>Category:</B> connect, morpho
 \ingroup  connect, morpho
@@ -105,21 +105,10 @@
 
   niter = atoi(argv[4]);
 
-  if (depth(image1) == 1)
+  if (! lgeodilat(image1, image2, connex, niter))
   {
-    if (! lgeodilat(image1, image2, connex, niter))
-    {
-      fprintf(stderr, "%s: function lgeodilat failed\n", argv[0]);
-      exit(1);
-    }
-  }
-  else
-  {
-    if (! lgeodilat3d(image1, image2, connex, niter))
-    {
-      fprintf(stderr, "%s: function lgeodilat3d failed\n", argv[0]);
-      exit(1);
-    }
+    fprintf(stderr, "%s: function lgeodilat failed\n", argv[0]);
+    exit(1);
   }
 
   writeimage(image1, argv[argc-1]);
diff -r 8b1af7363833 src/com/gradinf.c
--- a/src/com/gradinf.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,60 +0,0 @@
-/* $Id: gradinf.c,v 1.1.1.1 2008-11-25 08:01:38 mcouprie Exp $ */
-/* \file gradinf.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-/* gradient inf */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lgradinf.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  int32_t i;
-  uint8_t *pt;
-  int32_t N;
-
-  if (argc != 3)
-  {
-    fprintf(stderr, "usage: %s in.pgm out.pgm \n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "gradinf: readimage failed\n");
-    exit(1);
-  }
-
-  if (! lgradinf(image))
-  {
-    fprintf(stderr, "gradinf: function lgradinf failed\n");
-    exit(1);
-  }
-
-  writeimage(image, argv[2]);
-  freeimage(image);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/gradinf3d._notused_c
--- a/src/com/gradinf3d._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,60 +0,0 @@
-/* $Id: gradinf3d.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* \file gradinf3d.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-/* gradient inf */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lgradinf3d.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  int32_t i;
-  uint8_t *pt;
-  int32_t N;
-
-  if (argc != 3)
-  {
-    fprintf(stderr, "usage: %s in.pgm out.pgm \n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "gradinf3d: readimage failed\n");
-    exit(1);
-  }
-
-  if (! lgradinf3d_lgradinf3d(image))
-  {
-    fprintf(stderr, "gradinf3d: function lgradinf3d failed\n");
-    exit(1);
-  }
-
-  writeimage(image, argv[2]);
-  freeimage(image);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/gradsup.c
--- a/src/com/gradsup.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,60 +0,0 @@
-/* $Id: gradsup.c,v 1.1.1.1 2008-11-25 08:01:38 mcouprie Exp $ */
-/* \file gradsup.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-/* gradient sup */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lgradsup.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  int32_t i;
-  uint8_t *pt;
-  int32_t N;
-
-  if (argc != 3)
-  {
-    fprintf(stderr, "usage: %s in.pgm out.pgm \n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "gradsup: readimage failed\n");
-    exit(1);
-  }
-
-  if (! lgradsup(image))
-  {
-    fprintf(stderr, "gradsup: function lgradsup failed\n");
-    exit(1);
-  }
-
-  writeimage(image, argv[2]);
-  freeimage(image);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/hk_tophat_lin_rotall.c
--- a/src/com/hk_tophat_lin_rotall.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,243 +0,0 @@
-/*hk_tophat_lin_rotall.c*/
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <ldilateros.h>
-
-//#define DEBUG 
-
-/* =============================================================== */
-void setMask(uint8_t * mask, int32_t length, int32_t x, int32_t y) 
-/* =============================================================== */
-{
-    mask[y*length + x] = 1;
-}
-
-/* =============================================================== */
-void drawLine(uint8_t * mask, int32_t length, int32_t angle) 
-/* =============================================================== */
-{
-    int32_t x=0, y=0, dx=0, dy=0, error=0, delta=0, schritt=0;
-    int32_t x1=0, y1=0, x2=45; // TODO: noch nicht ganz korrekt!!!
-
-    int32_t quater = angle/45;
-
-    int32_t y2;
-    if(quater%2 == 0){
-	y2 = angle%45;
-    }
-    else{
-	y2 = 45 - angle%45;
-    }
-
-    dy    = y2 - y1;                               // Hoehenzuwachs berechnen
-    dx    = x2 - x1;                               // Schrittweite
-
-// That's the trick:
-// After commputing dx, dy set x2 to the lenght
-// of the structuring element.
-// So you draw a line from 0|0 to 45|angle but only 'length' pixels int32_t 
-    x2 = length/2;
-
-    x = x1;                                        // Koordinaten retten
-    y = y1;
-  
-    error = -dx;                                   // momentaner Fehler
-    delta = 2*dy;                                  // 'Steigung'
-    schritt = -2*dx;                               // Fehlerschrittweite
-
-    while (x <= x2) {                              // fuer jede x-Koordinate
-	if (quater == 0){
-	    setMask(mask, length, length/2+x , length/2+y);                          // setze Pixel    
-	    //printf("setMask: %i %i\n", length/2+x , length/2+y);
-	    setMask(mask, length, length/2-x , length/2-y);                          // setze Pixel
-	    //printf("setMask: %i %i\n", length/2-x , length/2-y);
-	}
-	else if (quater == 1){
-	    setMask(mask, length , length/2+y, length/2+x);                          // setze Pixel    
-	    //printf("setMask: %i %i\n", length/2+y, length/2+x);
-	    setMask(mask, length , length/2-y, length/2-x);                          // setze Pixel
-	    //printf("setMask: %i %i\n", length/2-y, length/2-x);
-	}
-	else if (quater == 2){
-	    setMask(mask, length , length/2+(-1*y), length/2+x);                          // setze Pixel    
-	    //printf("setMask: %i %i\n", length/2+(-1*y), length/2+x);
-	    setMask(mask, length , length/2-(-1*y), length/2-x);                          // setze Pixel
-	    //printf("setMask: %i %i\n",  length/2-(-1*y), length/2-x);
-	}
-	else if (quater == 3){
-	    setMask(mask, length, length/2+x , length/2+(-1*y));                          // setze Pixel    
-	    //printf("setMask: %i %i\n", length/2+x , length/2+(-1*y));
-	    setMask(mask, length, length/2-x , length/2-(-1*y));                          // setze Pixel
-	    //printf("setMask: %i %i\n", length/2-x , length/2-(-1*y));
-	}
-	x++;                                         // naechste x-Koordinate
-	error += delta;                              // Fehler aktualisieren
-	if (error > 0) {                             // naechste Zeile erreicht?
-	    y++;                                       // neue y-Koordinate
-	    error += schritt;                          // Fehler anpassen
-	}
-    }
-	
-}
-
-
-// Get the max_value of two images and write it into img1 
-
-/* =============================================================== */
-void max(struct xvimage * img1, struct xvimage * img2) 
-/* =============================================================== */
-{
-    if(rowsize(img1)!=rowsize(img2) || colsize(img1)!=colsize(img2)){
-	printf ("Image1: %i x %i\n", rowsize(img1), colsize(img1));
-	printf ("Image1: %i x %i\n", rowsize(img2), colsize(img2));
-	printf ("Can't get max!\n");
-	exit(1);
-    }
-    int32_t i;
-    int32_t N = rowsize(img1)*colsize(img1);
-    uint8_t * img1_data = img1->image_data;
-    uint8_t * img2_data = img2->image_data;
-    for (i=0; i<N; i++){
-	if(img1_data[i] < img2_data[i]){
-	    img1_data[i] = img2_data[i];
-	}
-    }
-    return;
-}
-
-// Subtract two images and write the result into img1 
-
-/* =============================================================== */
-void sub(struct xvimage * img1, struct xvimage * img2) 
-/* =============================================================== */
-{
-    if(rowsize(img1)!=rowsize(img2) || colsize(img1)!=colsize(img2)){
-	printf ("Image1: %i x %i\n", rowsize(img1), colsize(img1));
-	printf ("Image2: %i x %i\n", rowsize(img2), colsize(img2));
-	printf ("Can't sub!\n");
-	exit(1);
-    }
-    int32_t i;
-    int32_t N = rowsize(img1)*colsize(img1);
-    uint8_t * img1_data = img1->image_data;
-    uint8_t * img2_data = img2->image_data;
-    for (i=0; i<N; i++){
-	int32_t help = img1_data[i] - img2_data[i];
-	if(help < 0){
-	    img1_data[i] = 0;
-	}
-	else{
-	    img1_data[i] = help;
-	}
-    }
-    return;
-}
-
-// Close the org_image and write the result into img
-////////////////////////////////////////////////////////////////////
-// Adapter, that creates a copy of the original image 
-// and executes an erosion after an dilatation on the copy
-// Gets: an result_image, the original imgage, the mask, and the center element coordinates
-////////////////////////////////////////////////////////////////////
-/* =============================================================== */
-void close_image(struct xvimage * img, struct xvimage * org_img, struct xvimage * mask, int32_t ce_x, int32_t ce_y ) 
-/* =============================================================== */
-{	
-    int32_t i=0; 
-    int32_t N=rowsize(img)*colsize(img);
-    uint8_t * img_data = img->image_data;
-    uint8_t * org_img_data = org_img->image_data;
-	
-    // Copy org_img to img
-    for(i=0; i<N; i++){
-	img_data[i] = org_img_data[i];
-    }
-	
-    //Dilation
-    ldilatnum(img, mask, ce_x, ce_y);
-    //Erosion
-    lerosnum(img, mask, ce_x, ce_y);
-
-    return;
-}
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-int argc; char **argv; 
-{
-    struct xvimage * image; // Pointer fr das Bild
-    int32_t rs;    // row_size ^= width, erhlt man mit(s.u.): rowsize(image)
-    int32_t cs;    // col_size ^= height, erhlt man mit(s.u.): colsize(image)
-    int32_t d;     // dimesion, erhlt man mit(s.u.): depth(image)
-    int32_t N;	 // number of pixels ^= rs*cs*d
-
-    if (argc != 5)
-    {
-	fprintf(stderr, "usage: %s in.pgm length angle out.pgm\n", argv[0]);
-	exit(1);
-    }
-
-    image = readimage(argv[1]);
-    if (image == NULL)
-    {
-	fprintf(stderr, "histstretch: readimage failed\n");
-	exit(1);
-    }
-
-    rs = rowsize(image);     /* taille ligne */
-    cs = colsize(image);     /* taille colonne */
-    d = depth(image);        /* nombre plans */
-    N = rs * cs * d;         /* taille image */
-    int32_t length = atoi(argv[2]);	// length of structuring element
-    length = (length/2) * 2 +1; 	// has to be 2*x+1 (impair)
-    printf("Length is: %i\n", length);
-    int32_t angle = atoi(argv[3]);
-    int32_t i=0, j=0, k=0;
-
-    struct xvimage * mask = allocimage(NULL, length, length, d, image->data_storage_type);
-    uint8_t * mask_imagedata = mask->image_data;
-
-    struct xvimage * closed_image = allocimage(NULL, rs, cs, d, image->data_storage_type);
-
-    struct xvimage * result_image = allocimage(NULL, rs, cs, d, image->data_storage_type);
-
-// For every angle
-    for(k=0; k<180; k+=angle){
-	
-	//reset mask_imagedata
-	for(i=0; i<length*length; i++){
-	    mask_imagedata[i] = 0;
-	}
-	// write new Mask, k^=angle
-	drawLine(mask_imagedata, length, k);
-	
-	//Open
-	close_image(closed_image, image, mask, length/2+1, length/2+1);
-	//Sub
-	sub(closed_image, image);
-	//Max
-	max(result_image, closed_image);
-    }
-
-  
-// Test:
-    writeimage(mask, "mask.pgm");
-    writeimage(closed_image, "open.pgm");
-    writeimage(result_image, argv[argc-1]);
-
-    freeimage(mask);
-    freeimage(closed_image);
-    freeimage(result_image);
-    freeimage(image);
-
-    return 0;
-} /* main */
-
-#include <stdint.h>
-#include <sys/types.h>
diff -r 8b1af7363833 src/com/htkernu.c
--- a/src/com/htkernu.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/htkernu.c	Mon Jan 13 15:50:10 2014 +0100
@@ -118,7 +118,7 @@
 
   if ((connex == 4) || (connex == 8))
   {
-    if (! lhtkern_lhtkernu(image, imagecond, connex))
+    if (! lhtkernu(image, imagecond, connex))
     {
       fprintf(stderr, "%s: lhtkernu failed\n", argv[0]);
       exit(1);
diff -r 8b1af7363833 src/com/laplacian.c
--- a/src/com/laplacian.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/laplacian.c	Mon Jan 13 15:50:10 2014 +0100
@@ -83,7 +83,7 @@
   }
   alpha = atof(argv[2]);
 
-  if (! lderiche_lderiche(image1, alpha, 2, dummy))
+  if (! lderiche(image1, alpha, 2, dummy))
   {
     fprintf(stderr, "laplacian: function lderiche failed\n");
     exit(1);
diff -r 8b1af7363833 src/com/lintophat.c
--- a/src/com/lintophat.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/lintophat.c	Mon Jan 13 15:50:10 2014 +0100
@@ -127,7 +127,7 @@
 // Get the max_value of two images and write it into img1 
 
 /* =============================================================== */
-void imagemax(struct xvimage * img1, struct xvimage * img2) 
+void max(struct xvimage * img1, struct xvimage * img2) 
 /* =============================================================== */
 {
 	index_t i, N;
@@ -292,10 +292,10 @@
 
  	close_image(closed_image, image, mask, length/2+1, length/2+1);
 #ifdef DEBUG
-	imagemax(result_imageII, closed_image);
+	max(result_imageII, closed_image);
 #endif
  	sub(closed_image, image);
- 	imagemax(result_image, closed_image);
+ 	max(result_image, closed_image);
  	
  	
  	//Second Quater
@@ -311,10 +311,10 @@
 
  	close_image(closed_image, image, mask, length/2+1, length/2+1);
 #ifdef DEBUG
-	imagemax(result_imageII, closed_image);
+	max(result_imageII, closed_image);
 #endif
  	sub(closed_image, image);
- 	imagemax(result_image, closed_image);
+ 	max(result_image, closed_image);
  	
  	
  	//Third Quater
@@ -330,10 +330,10 @@
  	
  	close_image(closed_image, image, mask, length/2+1, length/2+1);
 #ifdef DEBUG
-	imagemax(result_imageII, closed_image);
+	max(result_imageII, closed_image);
 #endif
  	sub(closed_image, image);
- 	imagemax(result_image, closed_image);
+ 	max(result_image, closed_image);
  	  	
  	//Fourth Quater
  	//reset mask_data
@@ -348,10 +348,10 @@
  	
  	close_image(closed_image, image, mask, length/2+1, length/2+1);
 #ifdef DEBUG
-	imagemax(result_imageII, closed_image);
+	max(result_imageII, closed_image);
 #endif
  	sub(closed_image, image);
- 	imagemax(result_image, closed_image);
+ 	max(result_image, closed_image);
  }
  
    
diff -r 8b1af7363833 src/com/lpemeyer._notused_c
--- a/src/com/lpemeyer._notused_c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/lpemeyer._notused_c	Mon Jan 13 15:50:10 2014 +0100
@@ -1,4 +1,37 @@
-/* $Id: lpemeyer.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
+/*
+Copyright ESIEE (2009) 
+
+m.couprie@esiee.fr
+
+This software is an image processing library whose purpose is to be
+used primarily for research and teaching.
+
+This software is governed by the CeCILL  license under French law and
+abiding by the rules of distribution of free software. You can  use, 
+modify and/ or redistribute the software under the terms of the CeCILL
+license as circulated by CEA, CNRS and INRIA at the following URL
+"http://www.cecill.info". 
+
+As a counterpart to the access to the source code and  rights to copy,
+modify and redistribute granted by the license, users are provided only
+with a limited warranty  and the software's author,  the holder of the
+economic rights,  and the successive licensors  have only  limited
+liability. 
+
+In this respect, the user's attention is drawn to the risks associated
+with loading,  using,  modifying and/or developing or reproducing the
+software by the user in light of its specific status of free software,
+that may mean  that it is complicated to manipulate,  and  that  also
+therefore means  that it is reserved for developers  and  experienced
+professionals having in-depth computer knowledge. Users are therefore
+encouraged to load and test the software's suitability as regards their
+requirements in conditions enabling the security of their systems and/or 
+data to be ensured and,  more generally, to use and operate it in the 
+same conditions as regards security. 
+
+The fact that you are presently reading this means that you have had
+knowledge of the CeCILL license and that you accept its terms.
+*/
 /* \file lpemeyer.c
 
 \brief 
@@ -48,9 +81,8 @@
 #include <llpemeyer.h>
 
 /* =============================================================== */
-int main(argc, argv) 
+int main(int argc, char **argv)
 /* =============================================================== */
-  int argc; char **argv; 
 {
   struct xvimage * image;
   struct xvimage * marqueurs;
diff -r 8b1af7363833 src/com/lvkern.c
--- a/src/com/lvkern.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/lvkern.c	Mon Jan 13 15:50:10 2014 +0100
@@ -134,7 +134,7 @@
 
   if ((connex == 4) || (connex == 8))
   {
-    if (! lhtkern_llvkern(image, imagecond, connex))
+    if (! llvkern(image, imagecond, connex))
     {
       fprintf(stderr, "%s: llvkern failed\n", argv[0]);
       exit(1);
diff -r 8b1af7363833 src/com/meshoffset.c
--- a/src/com/meshoffset.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/meshoffset.c	Mon Jan 13 15:50:10 2014 +0100
@@ -75,7 +75,6 @@
   FILE *fileout = NULL;
   int32_t i;
   int32_t formatin, formatout;
-  int32_t resolution;
 
   if ((argc != 3) && (argc != 4))
   {
diff -r 8b1af7363833 src/com/meshwarp._notused_c
--- a/src/com/meshwarp._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,69 +0,0 @@
-/* $Id: meshwarp.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* \file meshwarp.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-/* generation interactice de grille pour mesh warper */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcgeo.h>
-#include <lmeshwarp.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  int32_t mrs, rs, cs;
-  double s;
-
-  if (argc != 4)
-  {
-    fprintf(stderr, "usage: %s in.pgm nbcol out.pgm\n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "meshwarp: readimage failed\n");
-    exit(1);
-  }
-  rs = image->row_size;
-  cs = image->col_size;
-
-  mrs = atoi(argv[2]);
-  if ((mrs < 0) || (mrs >= rs/2))
-  {
-    fprintf(stderr, "meshwarp: bad number of columns : %d\n", mrs);
-    exit(1);
-  }
-
-  if (! lmeshwarp_lmeshwarp(image, mrs))
-  {
-    fprintf(stderr, "meshwarp: function lmeshwarp failed\n");
-    exit(1);
-  }
-
-  writeimage(image, argv[3]);
-  freeimage(image);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/profil.c
--- a/src/com/profil.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,55 +0,0 @@
-/* $Id: profil.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* \file profil.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lprofil.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-
-  if (argc != 2)
-  {
-    fprintf(stderr, "usage: %s filein.pgm\n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-
-  if (! lprofil(image))
-  {
-    fprintf(stderr, "%s: lprofil failed\n", argv[0]);
-    exit(1);
-  }
-  freeimage(image);
-
-  return 0;
-} /* main */
-
-
diff -r 8b1af7363833 src/com/reconsdilat.c
--- a/src/com/reconsdilat.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,81 +0,0 @@
-/* $Id: reconsdilat.c,v 1.1.1.1 2008-11-25 08:01:38 mcouprie Exp $ */
-/* 
-obsolete - use geodilat
-
-<B>reconsdilat</B> - morphological reconstruction by dilation
-
-SYNOPSIS
-
-<B>reconsdilat</B> g.pgm f.pgm connex out.pgm
-
-DESCRIPTION
-
-Reconstruction of <B>g.pgm</B> under <B>f.pgm</B>.
-The structuring element is specified by the value of the parameter <B>connex</B>, 
-which can be one of the following ones: vois4 (or 4), vois8 (or 8).
-
-Types supported: byte 2D.
-
-CLASS 
-
-morph
-
-*/
-
-/* Michel Couprie - juillet 1996 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <string.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lgeodesic.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image1;
-  struct xvimage * image2;
-  int32_t connex;
-
-  if (argc != 5)
-  {
-    fprintf(stderr, "usage: %s g.pgm f.pgm connex out.pgm \n", argv[0]);
-    fprintf(stderr, "       connex = [vois4|vois8|4|8]\n");
-    exit(1);
-  }
-
-  image1 = readimage(argv[1]);
-  image2 = readimage(argv[2]);
-  if ((image1 == NULL) || (image2 == NULL))
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-  
-  if (strcmp(argv[3], "vois8") == 0) connex = 8; else
-  if (strcmp(argv[3], "vois4") == 0) connex = 4; else
-  if (strcmp(argv[3], "8") == 0) connex = 8; else
-  if (strcmp(argv[3], "4") == 0) connex = 4; else
-  {
-    fprintf(stderr, "%s: bad connexity - use one of the following:\n", argv[0]);
-    fprintf(stderr, "vois8, vois4, 8, 4\n");
-    exit(1);
-  }
-
-  if (! lreconsdilat_lreconsdilat(image1, image2, connex))
-  {
-    fprintf(stderr, "%s: function lreconsdilat failed\n", argv[0]);
-    exit(1);
-  }
-
-  writeimage(image1, argv[4]);
-  freeimage(image1);
-  freeimage(image2);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/reconsdilat3d.c
--- a/src/com/reconsdilat3d.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,87 +0,0 @@
-/* $Id: reconsdilat3d.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* \file reconsdilat3d.c
-
-obsolete - use geodilat
-
-\brief morphological reconstruction by dilation
-
-<B>Usage:</B> reconsdilat3d g.pgm f.pgm el out.pgm
-
-<B>Description:</B>
-Reconstruction of <B>g.pgm</B> under <B>f.pgm</B>.
-The structuring element is specified by the value of the parameter <B>el</B>, 
-which can be one of the following ones: vois6 (or 6), vois18 (or 18), vois26 (or 26).
-
-<B>Types supported:</B> byte 3d
-
-<B>Category:</B> morpho
-\ingroup  morpho
-
-\author Michel Couprie
-*/
-
-/* Michel Couprie - novembre 1999 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <string.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lreconsdilat3d.h>
-
-/* les elements structurants */
-/*                        0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 */
-uint8_t vois26[26]={1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-uint8_t vois18[26]={0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0};
-uint8_t vois6 [26]={0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image1;
-  struct xvimage * image2;
-  uint8_t *mask = NULL;
-
-  if (argc != 5)
-  {
-    fprintf(stderr, "usage: %s g.pgm f.pgm maskname out.pgm \n", argv[0]);
-    exit(1);
-  }
-
-  image1 = readimage(argv[1]);
-  image2 = readimage(argv[2]);
-  if ((image1 == NULL) || (image2 == NULL))
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-  
-  if (strcmp(argv[3], "vois26") == 0) mask = vois26; else
-  if (strcmp(argv[3], "vois18") == 0) mask = vois18; else
-  if (strcmp(argv[3], "vois6") == 0) mask = vois6; else
-  if (strcmp(argv[3], "26") == 0) mask = vois26; else
-  if (strcmp(argv[3], "18") == 0) mask = vois18; else
-  if (strcmp(argv[3], "6") == 0) mask = vois6; else
-  {
-    fprintf(stderr, "%s: bad maskname - use one of the following:\n", argv[0]);
-    fprintf(stderr, "vois26, vois18, vois6, 26, 18, 6\n");
-    exit(1);
-  }
-
-  if (! lreconsdilat3d_lreconsdilat3d(image1, image2, mask))
-  {
-    fprintf(stderr, "%s: function lreconsdilat3d failed\n", argv[0]);
-    exit(1);
-  }
-
-  writeimage(image1, argv[4]);
-  freeimage(image1);
-  freeimage(image2);
-
-  return 0;
-} /* main */
-
diff -r 8b1af7363833 src/com/reconseros._notused_c
--- a/src/com/reconseros._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,81 +0,0 @@
-/* $Id: reconseros.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* 
-obsolete - use geoeros
-
-<B>reconseros</B> - morphological reconstruction by erosion
-
-SYNOPSIS
-
-<B>reconseros</B> g.pgm f.pgm connex out.pgm
-
-DESCRIPTION
-
-Reconstruction of <B>g.pgm</B> under <B>f.pgm</B>.
-The structuring element is specified by the value of the parameter <B>connex</B>, 
-which can be one of the following ones: vois4 (or 4), vois8 (or 8).
-
-Types supported: byte 2D.
-
-CLASS 
-
-morph
-
-*/
-
-/* Michel Couprie - juillet 1996 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <string.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lgeodesic.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image1;
-  struct xvimage * image2;
-  int32_t connex;
-
-  if (argc != 5)
-  {
-    fprintf(stderr, "usage: %s g.pgm f.pgm connex out.pgm \n", argv[0]);
-    fprintf(stderr, "       connex = [vois4|vois8|4|8]\n");
-    exit(1);
-  }
-
-  image1 = readimage(argv[1]);
-  image2 = readimage(argv[2]);
-  if ((image1 == NULL) || (image2 == NULL))
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-  
-  if (strcmp(argv[3], "vois8") == 0) connex = 8; else
-  if (strcmp(argv[3], "vois4") == 0) connex = 4; else
-  if (strcmp(argv[3], "8") == 0) connex = 8; else
-  if (strcmp(argv[3], "4") == 0) connex = 4; else
-  {
-    fprintf(stderr, "%s: bad connexity - use one of the following:\n", argv[0]);
-    fprintf(stderr, "vois8, vois4, 8, 4\n");
-    exit(1);
-  }
-
-  if (! lgeodesic_lreconseros(image1, image2, connex))
-  {
-    fprintf(stderr, "%s: function lreconseros failed\n", argv[0]);
-    exit(1);
-  }
-
-  writeimage(image1, argv[4]);
-  freeimage(image1);
-  freeimage(image2);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/reconseros3d._notused_c
--- a/src/com/reconseros3d._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,87 +0,0 @@
-/* $Id: reconseros3d.c,v 1.1.1.1 2008-11-25 08:01:38 mcouprie Exp $ */
-/* \file reconseros3d.c
-
-obsolete - use geoeros
-
-\brief morphological reconstruction by erosion
-
-<B>Usage:</B> reconseros3d g.pgm f.pgm el out.pgm
-
-<B>Description:</B>
-Reconstruction by erosion of <B>g.pgm</B> over <B>f.pgm</B>.
-The structuring element is specified by the value of the parameter <B>el</B>, 
-which can be one of the following ones: vois6 (or 6), vois18 (or 18), vois26 (or 26).
-
-<B>Types supported:</B> byte 3d
-
-<B>Category:</B> morpho
-\ingroup  morpho
-
-\author Michel Couprie
-*/
-
-/* Michel Couprie - novembre 1999 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <string.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lreconseros3d.h>
-
-/* les elements structurants */
-/*                        0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 */
-uint8_t vois26[26]={1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-uint8_t vois18[26]={0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0};
-uint8_t vois6 [26]={0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image1;
-  struct xvimage * image2;
-  uint8_t *mask = NULL;
-
-  if (argc != 5)
-  {
-    fprintf(stderr, "usage: %s g.pgm f.pgm maskname out.pgm \n", argv[0]);
-    exit(1);
-  }
-
-  image1 = readimage(argv[1]);
-  image2 = readimage(argv[2]);
-  if ((image1 == NULL) || (image2 == NULL))
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-  
-  if (strcmp(argv[3], "vois26") == 0) mask = vois26; else
-  if (strcmp(argv[3], "vois18") == 0) mask = vois18; else
-  if (strcmp(argv[3], "vois6") == 0) mask = vois6; else
-  if (strcmp(argv[3], "26") == 0) mask = vois26; else
-  if (strcmp(argv[3], "18") == 0) mask = vois18; else
-  if (strcmp(argv[3], "6") == 0) mask = vois6; else
-  {
-    fprintf(stderr, "%s: bad maskname - use one of the following:\n", argv[0]);
-    fprintf(stderr, "vois26, vois18, vois6, vois8, vois4, vois2\n");
-    exit(1);
-  }
-
-  if (! lreconseros3d(image1, image2, mask))
-  {
-    fprintf(stderr, "%s: function lreconseros3d failed\n", argv[0]);
-    exit(1);
-  }
-
-  writeimage(image1, argv[4]);
-  freeimage(image1);
-  freeimage(image2);
-
-  return 0;
-} /* main */
-
diff -r 8b1af7363833 src/com/segbi._notused_c
--- a/src/com/segbi._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,66 +0,0 @@
-/* $Id: segbi.c,v 1.1.1.1 2008-11-25 08:01:38 mcouprie Exp $ */
-/* \file segbi.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lsegbi.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  int32_t connex;
-  double cmin = 1.0;
-  double cmax = 1.0;
-
-  if ((argc != 4) && (argc != 6))
-  {
-    fprintf(stderr, "usage: %s filein.pgm connex [cmin cmax] fileout.pgm\n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "segbi: readimage failed\n");
-    exit(1);
-  }
-
-  connex = atoi(argv[2]);
-
-  if (argc == 6)
-  {
-    cmin = atof(argv[3]);
-    cmax = atof(argv[4]);
-  }
-
-  if (! lsegbihomotopique(image, connex, cmin, cmax))
-  {
-    fprintf(stderr, "segbi: lsegbi failed\n");
-    exit(1);
-  }
-
-  if (argc == 6) writeimage(image, argv[5]); else writeimage(image, argv[3]);
-  freeimage(image);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/segment.c
--- a/src/com/segment.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,144 +0,0 @@
-/* $Id: segment.c,v 1.1.1.1 2008-11-25 08:01:38 mcouprie Exp $ */
-/* \file segment.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-/* 
-NAME
-
-<B>segment</B> - tool for image segmentation
-
-SYNOPSIS
-
-<B>segment</B> in.pgm connex out.pgm
-<B>segment</B> in.pgm connex [mes1 seuil1 [mes2 seuil2 ... ]] [max] out.pgm
-
-DESCRIPTION
-
-Segmentation by selection of components in the component tree.
-
-The first syntax, with only the three parameters <B>in.pgm</B>, <B>connex</B> and
-<B>out.pgm</B>, calls an interactive version of the tool.
-The parameter <B>connex</B> specifies the connexity (4, 8).
-
-The second syntax allows to specify one or several couples "mes seuil".
-The parameter "mes" specifies one of the following measures: <B>surf</B> (area), 
-<B>prof</B> (depth), or <B>vol</B> (volume). The parameter "seuil" is an integer 
-value. The optional parameter <B>max</B> indicates that the resulting segmentation 
-must be maximal (in the sense of the inclusion) while still equivalent to the 
-"standard" one.
-
-Types supported: byte 2D.
-
-CLASS 
-
-morph ctree
-
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <string.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lsegment.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  int32_t connex;
-  int32_t mesure;
-  int32_t seuil;
-  int32_t maximise = 0;
-  int32_t a;
-  int32_t seuilsurf;
-  int32_t seuilprof;
-  int32_t seuilvol;
-#ifdef VERSION_EXPERIMENTALE
-  int32_t seuilper;
-  int32_t seuilcirc;
-  int32_t seuilrdis;
-  int32_t seuilnbtr;
-  int32_t seuildtr;
-  int32_t seuilexc;
-#endif
-
-  if (argc < 4) goto Erreur;
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-
-  connex = atoi(argv[2]);
-  mesure = 0;
-  for (a = 3; a < argc - 2; a += 2)
-  { 
-    if      (strcmp(argv[a], "surf") == 0) { mesure |= SURFACE;      seuilsurf = atoi(argv[a+1]); }
-    else if (strcmp(argv[a], "prof") == 0) { mesure |= PROFONDEUR;   seuilprof = atoi(argv[a+1]); }
-    else if (strcmp(argv[a], "vol")  == 0) { mesure |= VOLUME;       seuilvol  = atoi(argv[a+1]); }
-#ifdef VERSION_EXPERIMENTALE
-    else if (strcmp(argv[a], "per")  == 0) { mesure |= PERIMETRE;    seuilper  = atoi(argv[a+1]); }
-    else if (strcmp(argv[a], "circ") == 0) { mesure |= CIRCULARITE;  seuilcirc = atoi(argv[a+1]); }
-    else if (strcmp(argv[a], "rdis") == 0) { mesure |= ROOTDIST;     seuilrdis = atoi(argv[a+1]); }
-    else if (strcmp(argv[a], "nbtr") == 0) { mesure |= NBTROUS;      seuilnbtr = atoi(argv[a+1]); }
-    else if (strcmp(argv[a], "dtr")  == 0) { mesure |= DENSTROUS;    seuildtr  = atoi(argv[a+1]); }
-    else if (strcmp(argv[a], "exc")  == 0) { mesure |= EXCENTRICITE; seuilexc  = atoi(argv[a+1]); }
-#endif
-    else { fprintf(stderr, "1 : a:%d, argv[a] = %s\n", a, argv[a]); goto Erreur; }
-  }
-
-  if ((argc % 2) == 1)
-  {
-    if (strcmp(argv[argc - 2], "max") == 0) maximise = 1;
-    else { fprintf(stderr, "2\n"); goto Erreur; }
-  }
-  
-#ifdef VERSION_EXPERIMENTALE
-  if (! lsegment(image, connex, mesure, seuilsurf, seuilprof, seuilvol, seuilper, seuilcirc,
-                 seuilrdis, seuilnbtr, seuildtr, seuilexc, maximise))
-#else
-  if (! lsegment(image, connex, mesure, seuilsurf, seuilprof, seuilvol, maximise))
-#endif
-  {
-    fprintf(stderr, "%s: lsegment failed\n", argv[0]);
-    exit(1);
-  }
-  
-  writeimage(image, argv[argc - 1]);
-  freeimage(image);
-  return;
-
-Erreur:
-#ifdef VERSION_EXPERIMENTALE
-  fprintf(stderr, 
-  "usage: %s filein.pgm connex [mes1 seuil1 [mes2 seuil2 ... ]] [max] fileout.pgm\n  mes = <surf | prof | vol | per | circ | rdis | nbtr | dtr | exc>\n", argv[0]);
-#else
-  fprintf(stderr, 
-  "usage: %s filein.pgm connex [mes1 seuil1 [mes2 seuil2 ... ]] [max] fileout.pgm\n  mes = <surf | prof | vol>\n", argv[0]);
-#endif
-  exit(1);
-
-  return 0;
-} /* main */
-
-
-
diff -r 8b1af7363833 src/com/segment3di.c
--- a/src/com/segment3di.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,83 +0,0 @@
-/* $Id: segment3di.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* \file segment3di.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-/* 
-NAME
-
-<B>segment3di</B> - interactive tool for 3D image segmentation
-
-SYNOPSIS
-
-<B>segment3di</B> in.pgm connex out.pgm
-
-DESCRIPTION
-
-Segmentation by selection of components in the component tree.
-The parameter <B>connex</B> specifies the connexity (6, 18, 26).
-
-Types supported: byte 3D.
-
-CLASS 
-
-morph ctree
-
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lsegment3di.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  int32_t connex;
-
-  if (argc != 4)
-  {
-    fprintf(stderr, "usage: %s filein.pgm connex fileout.pgm\n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "segment3di: readimage failed\n");
-    exit(1);
-  }
-
-  connex = atoi(argv[2]);
-
-  if (! lsegment3di(image, connex))
-  {
-    fprintf(stderr, "segment3di: lsegment3di failed\n");
-    exit(1);
-  }
-
-  writeimage(image, argv[3]);
-  freeimage(image);
-
-  return 0;
-} /* main */
-
-
-
diff -r 8b1af7363833 src/com/segmentnumi.c
--- a/src/com/segmentnumi.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,67 +0,0 @@
-/* $Id: segmentnumi.c,v 1.1.1.1 2008-11-25 08:01:38 mcouprie Exp $ */
-/* \file segmentnumi.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <string.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lsegmentnumi.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-  struct xvimage * result;
-
-  if (argc != 3)
-  {
-    fprintf(stderr, "usage: %s filein.pgm fileout.pgm\n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "segmentnumi: readimage failed\n");
-    exit(1);
-  }
-
-  result = allocimage(NULL, rowsize(image), colsize(image), depth(image), VFF_TYP_4_BYTE);
-  if (result == NULL)
-  {   
-    fprintf(stderr, "segmentnumi: allocimage failed\n");
-    exit(1);
-  }
-
-  if (! lsegmentnumi(image, result))
-  {
-    fprintf(stderr, "segmentnumi: lsegmentnumi failed\n");
-    exit(1);
-  }
-
-  writelongimage(result, argv[2]);
-  freeimage(image);
-  freeimage(result);
-  return 0;
-} /* main */
-
-
-
diff -r 8b1af7363833 src/com/seuili.c
--- a/src/com/seuili.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,55 +0,0 @@
-/* $Id: seuili.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* \file seuili.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lseuili.h>
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image;
-
-  if (argc != 3)
-  {
-    fprintf(stderr, "usage: %s filein.pgm fileout.pgm\n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "seuili: readimage failed\n");
-    exit(1);
-  }
-
-  if (! lseuili(image))
-  {
-    fprintf(stderr, "seuili: function lseuili failed\n");
-    exit(1);
-  }
-
-  writeimage(image, argv[2]);
-  freeimage(image);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/skel_ASK3b._notused_c
--- a/src/com/skel_ASK3b._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,124 +0,0 @@
-/*
-Copyright ESIEE (2009) 
-
-m.couprie@esiee.fr
-
-This software is an image processing library whose purpose is to be
-used primarily for research and teaching.
-
-This software is governed by the CeCILL  license under French law and
-abiding by the rules of distribution of free software. You can  use, 
-modify and/ or redistribute the software under the terms of the CeCILL
-license as circulated by CEA, CNRS and INRIA at the following URL
-"http://www.cecill.info". 
-
-As a counterpart to the access to the source code and  rights to copy,
-modify and redistribute granted by the license, users are provided only
-with a limited warranty  and the software's author,  the holder of the
-economic rights,  and the successive licensors  have only  limited
-liability. 
-
-In this respect, the user's attention is drawn to the risks associated
-with loading,  using,  modifying and/or developing or reproducing the
-software by the user in light of its specific status of free software,
-that may mean  that it is complicated to manipulate,  and  that  also
-therefore means  that it is reserved for developers  and  experienced
-professionals having in-depth computer knowledge. Users are therefore
-encouraged to load and test the software's suitability as regards their
-requirements in conditions enabling the security of their systems and/or 
-data to be ensured and,  more generally, to use and operate it in the 
-same conditions as regards security. 
-
-The fact that you are presently reading this means that you have had
-knowledge of the CeCILL license and that you accept its terms.
-*/
-/*! \file skel_ASK3b.c
-
-\brief parallel 3D binary surface, asymetric skeleton based on thin 2D isthmuses
-
-<B>Usage:</B> skel_ASK3b in.pgm nsteps isthmus_persistence [inhibit] out.pgm
-
-<B>Description:</B> Parallel 3D binary thinning or surface,
-asymetric skeleton based on thin 2D isthmuses. The parameter \b nsteps
-gives, if positive, the number of parallel thinning steps to be
-processed.  If the value given for \b nsteps equals -1, the thinning
-is continued until stability.
-
-When a point x is detected as a 2D isthmus, a counter p(x) is
-associated to this point and initialized with value 1. This counter is
-incremented a each iteration as long as x is still an isthmus. At each
-iteration, the isthmuses x such that p(x) >= \b isthmus_persistence are
-stored as a constraint set (see also \b inhibit parameter).
-
-If the parameter \b inhibit is given and is a binary image name,
-then the points of this image will be left unchanged. 
-
-\warning The object must not have any point on the frame of the image.
-
-<B>Types supported:</B> byte 3d
-
-<B>Category:</B> topobin
-\ingroup  topobin
-
-\author Michel Couprie
-*/
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <lskelpar3d.h>
-
-/* =============================================================== */
-int main(int argc, char **argv)
-/* =============================================================== */
-{
-  struct xvimage * image;
-  struct xvimage * inhibit = NULL;
-  int32_t nsteps, isthmus_persistence;
-
-  if ((argc != 5) && (argc != 6))
-  {
-    fprintf(stderr, "usage: %s in.pgm nsteps isthmus_persistence [inhibit] out.pgm\n", argv[0]);
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-
-  nsteps = atoi(argv[2]);
-  isthmus_persistence = atoi(argv[3]);
-  if (argc == 6)
-  {
-    inhibit = readimage(argv[4]);
-    if (inhibit == NULL)
-    {
-      fprintf(stderr, "%s: readimage failed\n", argv[0]);
-      exit(1);
-    }
-  }
-
-  if (depth(image) != 1)
-  {
-    if (! lskelASK3b(image, nsteps, isthmus_persistence, inhibit))
-    {
-      fprintf(stderr, "%s: lskelASK3b failed\n", argv[0]);
-      exit(1);
-    } 
-  }
-  else
-  {
-    fprintf(stderr, "%s: image must be 3D\n", argv[0]);
-    exit(1);
-  }
-
-  writeimage(image, argv[argc-1]);
-  freeimage(image);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/skel_ASK3b.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/com/skel_ASK3b.c	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,124 @@
+/*
+Copyright ESIEE (2009) 
+
+m.couprie@esiee.fr
+
+This software is an image processing library whose purpose is to be
+used primarily for research and teaching.
+
+This software is governed by the CeCILL  license under French law and
+abiding by the rules of distribution of free software. You can  use, 
+modify and/ or redistribute the software under the terms of the CeCILL
+license as circulated by CEA, CNRS and INRIA at the following URL
+"http://www.cecill.info". 
+
+As a counterpart to the access to the source code and  rights to copy,
+modify and redistribute granted by the license, users are provided only
+with a limited warranty  and the software's author,  the holder of the
+economic rights,  and the successive licensors  have only  limited
+liability. 
+
+In this respect, the user's attention is drawn to the risks associated
+with loading,  using,  modifying and/or developing or reproducing the
+software by the user in light of its specific status of free software,
+that may mean  that it is complicated to manipulate,  and  that  also
+therefore means  that it is reserved for developers  and  experienced
+professionals having in-depth computer knowledge. Users are therefore
+encouraged to load and test the software's suitability as regards their
+requirements in conditions enabling the security of their systems and/or 
+data to be ensured and,  more generally, to use and operate it in the 
+same conditions as regards security. 
+
+The fact that you are presently reading this means that you have had
+knowledge of the CeCILL license and that you accept its terms.
+*/
+/*! \file skel_ASK3b.c
+
+\brief parallel 3D binary surface, asymetric skeleton based on thin 2D isthmuses
+
+<B>Usage:</B> skel_ASK3b in.pgm nsteps isthmus_persistence [inhibit] out.pgm
+
+<B>Description:</B> Parallel 3D binary thinning or surface,
+asymetric skeleton based on thin 2D isthmuses. The parameter \b nsteps
+gives, if positive, the number of parallel thinning steps to be
+processed.  If the value given for \b nsteps equals -1, the thinning
+is continued until stability.
+
+When a point x is detected as a 2D isthmus, a counter p(x) is
+associated to this point and initialized with value 1. This counter is
+incremented a each iteration as long as x is still an isthmus. At each
+iteration, the isthmuses x such that p(x) >= \b isthmus_persistence are
+stored as a constraint set (see also \b inhibit parameter).
+
+If the parameter \b inhibit is given and is a binary image name,
+then the points of this image will be left unchanged. 
+
+\warning The object must not have any point on the frame of the image.
+
+<B>Types supported:</B> byte 3d
+
+<B>Category:</B> topobin
+\ingroup  topobin
+
+\author Michel Couprie
+*/
+#include <stdio.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <stdlib.h>
+#include <mccodimage.h>
+#include <mcimage.h>
+#include <lskelpar3d.h>
+
+/* =============================================================== */
+int main(int argc, char **argv)
+/* =============================================================== */
+{
+  struct xvimage * image;
+  struct xvimage * inhibit = NULL;
+  int32_t nsteps, isthmus_persistence;
+
+  if ((argc != 5) && (argc != 6))
+  {
+    fprintf(stderr, "usage: %s in.pgm nsteps isthmus_persistence [inhibit] out.pgm\n", argv[0]);
+    exit(1);
+  }
+
+  image = readimage(argv[1]);
+  if (image == NULL)
+  {
+    fprintf(stderr, "%s: readimage failed\n", argv[0]);
+    exit(1);
+  }
+
+  nsteps = atoi(argv[2]);
+  isthmus_persistence = atoi(argv[3]);
+  if (argc == 6)
+  {
+    inhibit = readimage(argv[4]);
+    if (inhibit == NULL)
+    {
+      fprintf(stderr, "%s: readimage failed\n", argv[0]);
+      exit(1);
+    }
+  }
+
+  if (depth(image) != 1)
+  {
+    if (! lskelASK3b(image, nsteps, isthmus_persistence, inhibit))
+    {
+      fprintf(stderr, "%s: lskelASK3b failed\n", argv[0]);
+      exit(1);
+    } 
+  }
+  else
+  {
+    fprintf(stderr, "%s: image must be 3D\n", argv[0]);
+    exit(1);
+  }
+
+  writeimage(image, argv[argc-1]);
+  freeimage(image);
+
+  return 0;
+} /* main */
diff -r 8b1af7363833 src/com/skel_CK2_pers.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/com/skel_CK2_pers.c	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,104 @@
+/*
+Copyright ESIEE (2009) 
+
+m.couprie@esiee.fr
+
+This software is an image processing library whose purpose is to be
+used primarily for research and teaching.
+
+This software is governed by the CeCILL  license under French law and
+abiding by the rules of distribution of free software. You can  use, 
+modify and/ or redistribute the software under the terms of the CeCILL
+license as circulated by CEA, CNRS and INRIA at the following URL
+"http://www.cecill.info". 
+
+As a counterpart to the access to the source code and  rights to copy,
+modify and redistribute granted by the license, users are provided only
+with a limited warranty  and the software's author,  the holder of the
+economic rights,  and the successive licensors  have only  limited
+liability. 
+
+In this respect, the user's attention is drawn to the risks associated
+with loading,  using,  modifying and/or developing or reproducing the
+software by the user in light of its specific status of free software,
+that may mean  that it is complicated to manipulate,  and  that  also
+therefore means  that it is reserved for developers  and  experienced
+professionals having in-depth computer knowledge. Users are therefore
+encouraged to load and test the software's suitability as regards their
+requirements in conditions enabling the security of their systems and/or 
+data to be ensured and,  more generally, to use and operate it in the 
+same conditions as regards security. 
+
+The fact that you are presently reading this means that you have had
+knowledge of the CeCILL license and that you accept its terms.
+*/
+/*! \file skel_CK2_pers.c
+
+\brief topological persistence of 1D isthmuses, based on parallel 2D symmetric thinning
+
+<B>Usage:</B> skel_CK2_pers in.pgm out.pgm
+
+<B>Description:</B> Topological persistence of 1D isthmuses, based on 
+parallel 2D symmetric thinning.
+
+When a point x is detected as a 1D isthmus, a counter p(x) is
+associated to this point and initialized with value 1. This counter is
+incremented a each iteration as long as x is still an isthmus. When this point x is
+eventually deleted, the value of the counter is freezed.
+
+\warning The object must not have any point on the frame of the image.
+
+<B>Types supported:</B> byte 2d
+
+<B>Category:</B> topobin
+\ingroup  topobin
+
+\author Michel Couprie
+*/
+#include <stdio.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <stdlib.h>
+#include <mccodimage.h>
+#include <mcimage.h>
+#include <lskelpar.h>
+
+/* =============================================================== */
+int main(int argc, char **argv)
+/* =============================================================== */
+{
+  struct xvimage * image;
+  struct xvimage * persistence;
+
+  if (argc != 3)
+  {
+    fprintf(stderr, "usage: %s in.pgm out.pgm\n", argv[0]);
+    exit(1);
+  }
+
+  image = readimage(argv[1]);
+  if (image == NULL)
+  {
+    fprintf(stderr, "%s: readimage failed\n", argv[0]);
+    exit(1);
+  }
+
+  persistence = allocimage(NULL, rowsize(image), colsize(image), depth(image), VFF_TYP_FLOAT);
+  if (persistence == NULL)
+  {
+    fprintf(stderr, "%s: allocimage failed\n", argv[0]);
+    exit(1);
+  }
+
+  if (! lskelCK2_pers(image, persistence))
+  {
+    fprintf(stderr, "%s: lskelCK2_pers failed\n", argv[0]);
+    exit(1);
+  } 
+
+  writeimage(persistence, argv[argc-1]);
+  freeimage(image);
+  freeimage(persistence);
+
+  return 0;
+} /* main */
diff -r 8b1af7363833 src/com/skelpar.c
--- a/src/com/skelpar.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/skelpar.c	Mon Jan 13 15:50:10 2014 +0100
@@ -72,13 +72,15 @@
 \li 22: Couprie and Bertrand, ultimate asymmetrical with medial axis (NK2)
 \li 23: Bertrand curvilinear with reconstruction, asymmetrical
 \li 24: Bertrand curvilinear with reconstruction, symmetrical
-\li 25: Rosenfeld directionnel
+\li 25: Rosenfeld directionnal (NSEW order)
 \li 26: Nemeth et Palagyi, 2009 (1)
 \li 27: Nemeth et Palagyi, 2009 (2)
 \li 28: Nemeth et Palagyi, 2009 (3)
 \li 29: Couprie and Bertrand, ultimate, asymmetrical (NK2)
 \li 30: Couprie and Bertrand, ultimate, symmetrical (MK2b)
 \li 31: Couprie and Bertrand, curvilinear, symmetrical, based on 1D isthmuses (CK2)
+\li 32: Rosenfeld directionnal (variant: WESN order)
+\li 33: Rosenfeld directionnal (variant: ENWS order)
 
 If the parameter \b inhibit is given and is a binary image name,
 then the points of this image will be left unchanged.
@@ -158,13 +160,15 @@
     fprintf(stderr, "  22: Couprie and Bertrand, ultimate asymmetrical with medial axis (NK2)\n");
     fprintf(stderr, "  23: Bertrand curvilinear with reconstruction, asymmetrical\n");
     fprintf(stderr, "  24: Bertrand curvilinear with reconstruction, symmetrical\n");
-    fprintf(stderr, "  25: Rosenfeld directionnel\n");
+    fprintf(stderr, "  25: Rosenfeld directionnal (NSEW order)\n");
     fprintf(stderr, "  26: Nemeth and Palagyi 2009 (detects endpoints type 1)\n");
     fprintf(stderr, "  27: Nemeth and Palagyi 2009 (detects endpoints type 2)\n");
     fprintf(stderr, "  28: Nemeth and Palagyi 2009 (detects endpoints type 3)\n");
     fprintf(stderr, "  29: Couprie and Bertrand, ultimate, asymmetrical (NK2)\n");
     fprintf(stderr, "  30: Couprie and Bertrand, ultimate, symmetrical (MK2b)\n");
     fprintf(stderr, "  31: Couprie and Bertrand, curvilinear, symmetrical, based on 1D isthmuses (CK2)\n");
+    fprintf(stderr, "  32: Rosenfeld directionnal (variant: WESN order)\n");
+    fprintf(stderr, "  33: Rosenfeld directionnal (variant: ENWS order)\n");
     exit(1);
   }
 
@@ -359,7 +363,7 @@
     case 25:
       if (! lskelrosenfeld(image, nsteps, inhibit))
       {
-	fprintf(stderr, "%s: lskelbertrand_asym_s failed\n", argv[0]);
+	fprintf(stderr, "%s: lskelrosenfeld failed\n", argv[0]);
 	exit(1);
       } break;
     case 26:
@@ -398,6 +402,18 @@
 	fprintf(stderr, "%s: lskelCK2 failed\n", argv[0]);
 	exit(1);
       } break;
+    case 32:
+      if (! lskelrosenfeld_var1(image, nsteps, inhibit))
+      {
+	fprintf(stderr, "%s: lskelrosenfeld_var1 failed\n", argv[0]);
+	exit(1);
+      } break;
+    case 33:
+      if (! lskelrosenfeld_var2(image, nsteps, inhibit))
+      {
+	fprintf(stderr, "%s: lskelrosenfeld_var2 failed\n", argv[0]);
+	exit(1);
+      } break;
     default:
       fprintf(stderr, "%s: mode %d not implemented\n", argv[0], mode);
       exit(1);
diff -r 8b1af7363833 src/com/skelpar3d.c
--- a/src/com/skelpar3d.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/skelpar3d.c	Mon Jan 13 15:50:10 2014 +0100
@@ -76,7 +76,6 @@
 \li 20: surface and curvilinear, symmetric, based on 1D and 2D isthmus with persistence (SCK3p)
 \li 21: surface, symmetric, based on residual points (RK3), variant (uses 26-connectivity to define residual points)
 
-
 In modes other than 2, if the parameter \b inhibit is given and is a
 binary image name, then the points of this image will be left
 unchanged.
diff -r 8b1af7363833 src/com/skelpar3d_others.c_
--- a/src/com/skelpar3d_others.c_	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,103 +0,0 @@
-/* $Id: skelpar3d_others.c,v 1.1.1.1 2008-11-25 08:01:37 mcouprie Exp $ */
-/*! \file skelpar3d_others.c
-
-\brief parallel 3D binary skeleton
-
-<B>Usage:</B> skelpar3d in.pgm algorithm nsteps [inhibit] out.pgm
-
-<B>Description:</B>
-Parallel 3D binary thinning or skeleton. The parameter \b nsteps gives,
-if positive, the number of parallel thinning steps to be processed.
-If the value given for \b nsteps equals -1, the thinning is continued
-until stability.
-
-The parameter \b algorithm is a numerical code
-indicating which method will be used for the thinning.
-The possible choices are:
-\li 0: Palagyi (fully parallel, 2007)
-
-If the parameter \b inhibit is given and is a binary image name,
-then the points of this image will be left unchanged. 
-
-<B>Types supported:</B> byte 3d
-
-<B>Category:</B> topobin
-\ingroup  topobin
-
-\author Michel Couprie
-*/
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcgeo.h>
-#include <ldist.h>
-#include <lskelpar3d_others.h>
-#include <lmedialaxis.h>
-
-/* =============================================================== */
-int32_t main(argc, argv) 
-/* =============================================================== */
-  int32_t argc; char **argv; 
-{
-  struct xvimage * image;
-  struct xvimage * inhibit = NULL;
-  int32_t mode, ret, nsteps;
-
-  if ((argc != 5) && (argc != 6))
-  {
-    fprintf(stderr, "usage: %s in.pgm algorithm nsteps [inhibit] out.pgm\n", argv[0]);
-    fprintf(stderr, "   0: Palagyi (fully parallel, 2007)\n");
-    exit(1);
-  }
-
-  image = readimage(argv[1]);
-  if (image == NULL)
-  {
-    fprintf(stderr, "%s: readimage failed\n", argv[0]);
-    exit(1);
-  }
-
-  mode = atoi(argv[2]);
-  nsteps = atoi(argv[3]);
-
-  if (argc == 6)
-  {
-    inhibit = readimage(argv[4]);
-    if (inhibit == NULL)
-    {
-      fprintf(stderr, "%s: readimage failed\n", argv[0]);
-      exit(1);
-    }
-  }
-
-  if (depth(image) != 1)
-  {
-    switch (mode)
-    {
-    case 0:
-      if (argc == 6)
-	fprintf(stderr, "%s: warning: inhibit mode not implemented for algo %d\n", argv[0], mode);
-      if (! lpalagyi(image, nsteps))
-      {
-	fprintf(stderr, "%s: lpalagyi failed\n", argv[0]);
-	exit(1);
-      } break;
-    default: 
-      fprintf(stderr, "%s: mode %d not implemented\n", argv[0], mode);
-      exit(1);
-    }
-  }
-  else
-  {
-    fprintf(stderr, "%s: image must be 3D\n", argv[0]);
-    exit(1);
-  }
-
-  writeimage(image, argv[argc-1]);
-  freeimage(image);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/visu3d.c
--- a/src/com/visu3d.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,233 +0,0 @@
-/* $Id: visu3d.c,v 1.1.1.1 2008-11-25 08:01:37 mcouprie Exp $ */
-/* \file visu3d.c
-
-\brief 
-
-<B>Usage:</B> 
-
-<B>Description:</B>
-
-<B>Types supported:</B> byte 2D
-
-<B>Category:</B> 
-\ingroup  
-
-\author Michel Couprie
-*/
-/* Visualisation simultanee de deux images 3d */
-/* Michel Couprie - mai 2000 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcxbib.h>
-
-/* ==================================== */
-int32_t lvisu3d(struct xvimage *image1, struct xvimage *image2, int32_t zoom)
-/* ==================================== */
-{
-  char buf[32];
-  register int32_t i;              /* index muet */
-  int32_t k;                       /* index muet */
-  register int32_t x;              /* index muet de pixel */
-  int32_t rs = rowsize(image1);    /* taille ligne */
-  int32_t cs = colsize(image1);    /* taille colonne */
-  int32_t d = depth(image1);       /* nb plans */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
-  uint8_t *SOURCE1 = UCHARDATA(image1);
-  uint8_t *SOURCE2 = UCHARDATA(image2);
-  int32_t increment = 1;
-  int32_t iplan = 0;
-
-#define NBBUTTONS 5
-#define NBLIGBUTT 1
-#define BOXWIDTH 70
-#define BOXHEIGHT 20
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int32_t xx, yy;
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT;
-  int32_t Width = 2 * rs;
-  int32_t ImageHeight = cs;
-  int32_t ImageWidth = rs;
-
-  if (zoom)
-  {
-    Height += cs;
-    Width += rs;
-    ImageHeight += cs;
-    ImageWidth += rs;
-  }
-
-  if (BoxWidth * NBBUTTONS > Width) Width = BoxWidth * NBBUTTONS;
-
-  if ((rowsize(image2) != rs) || (colsize(image2) != cs) || (depth(image2) != d))
-  {
-    fprintf(stderr, "lvisu3d: incompatible image sizes\n");
-    return 0;
-  }
-  
-  InitColorGraphics(0, 0, /* x, y */
-                    Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], " PLAN");
-  sprintf(ButtonStrings[0][1], "%d", iplan);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], " QUIT");
-
-/*
-    affichage : 
-
-    <------- rs ------> <------- rs ------>     
-    ------------------- -------------------.
-    |                 | |                 |.
-    |                 | |                 |.
-    |                 | |                 |.
-    |      image      | |     image       |cs
-    |       ndg       | |      bin        |.
-    |                 | |                 |.
-    |                 | |                 |.
-    -------------------------------------------------
-    ------------------------------------
-    | plan | 111  |  +   |  -   | QUIT | BoxHeight
-    ------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-ReDisplayImage:
-
-  /* send output to the screen */
-  FRectangle(0, 0, ImageWidth, ImageHeight);
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-  {
-    Color(SOURCE1[x]/4);
-    if (zoom)
-    {
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point((x%n)%rs, (x%n)/rs);
-  }
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-  {
-    Color(SOURCE2[x]/4);
-    if (zoom)
-    {
-      Point(2*rs+2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*rs+2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*rs+2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*rs+2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point(rs+(x%n)%rs, (x%n)/rs);
-  }
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, ImageHeight + i * BoxHeight, k * BoxWidth, ImageHeight + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, ImageHeight + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  FlushGraphics();  
-
-  WaitMouseEvent(&xx, &yy);
-
-  xx /= BoxWidth;
-  yy -= ImageHeight;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: iplan++;
-                      if (iplan > d-1) iplan = d-1;
-                      sprintf(ButtonStrings[0][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 3: iplan--;
-                      if (iplan < 0) iplan = 0;
-                      sprintf(ButtonStrings[0][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 4: goto Terminate;
-            } /* switch(xx) */
-            break;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      free(ButtonStrings[i][k]);
-
-  return(1);
-}
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-  struct xvimage * image1;
-  struct xvimage * image2;
-  int32_t zoom;
-
-  if (argc != 4)
-  {
-    fprintf(stderr, "usage: %s i1.pgm i2.pgm <1|0>\n", argv[0]);
-    exit(1);
-  }
-
-  image1 = readimage(argv[1]);
-  image2 = readimage(argv[2]);
-  if ((image1 == NULL) || (image2 == NULL))
-  {
-    fprintf(stderr, "visu3d: readimage failed\n");
-    exit(1);
-  }
-
-  zoom = atoi(argv[3]);
-
-  if (! lvisu3d(image1, image2, zoom))
-  {
-    fprintf(stderr, "visu3d: function lvisu3d failed\n");
-    exit(1);
-  }
-
-  freeimage(image1);
-  freeimage(image2);
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/vskel2graph._notfinished_c
--- a/src/com/vskel2graph._notfinished_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,375 +0,0 @@
-PAS FINI
-
-
-/* $Id: vskel2graph.c,v 1.1.1.1 2008-11-25 08:01:38 mcouprie Exp $ */
-/* \file vskel2graph.c
-
-\brief generation of a graph from a curvilinear skeleton
-
-<B>Usage:</B> vskel2graph in.skel out.graph
-
-<B>Description:</B>
-Generation of a graph from a curvilinear skeleton.
-
-<B>Types supported:</B> 2Dskel, 3Dskel
-
-<B>Category:</B> topobin
-\ingroup  topobin
-
-\author Michel Couprie 2004
-*/
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcskelcurv.h>
-#include <lskelcurv.h>
-
-/* ====================================================================== */
-int32_t vskel2graph(char *filename_in, char *filename_out)
-/* ====================================================================== */
-// Les sommets du graphe sont les points isolés, les jonctions et les extrémités.
-// Il y a un arc entre deux sommets s'il y a au moins une branche du squelette entre les deux.
-// Pour les jonctions, on prend pour coordonnées le barycentre des points, et
-// pour valuation le max des valuations des points.
-{
-#undef F_NAME
-#define F_NAME "vskel2graph"
-#define BUFFERSIZE 1024
-  skel * S;
-  uint32_t i, j, k, v, n;
-  char buf[BUFFERSIZE];
-  FILE *fdin = NULL;
-  FILE *fdout = NULL;
-  int32_t ret, dim, rs, cs, ds;
-  int32_t nbisol, nbend, nbcurv, nbjunc, nvertex, ncell, connex;
-  float fval;
-  int32_t nsommets = 0, narcs = 0;
-
-  fdin = fopen(filename_in,"r");
-  if (!fdin)
-  {
-    fprintf(stderr, "%s: cannot open file: %s\n", F_NAME, filename_in);
-    return 0;
-  }
-
-  fdout = fopen(filename_out,"w");
-  if (!fdout)
-  {
-    fprintf(stderr, "%s: cannot open file: %s\n", F_NAME, filename_out);
-    return 0;
-  }
-
-  fscanf(fdin, "%s", buf);
-  if (strncmp(buf, "3Dvskel", 6) == 0) dim = 3; else
-  if (strncmp(buf, "2Dvskel", 6) == 0) dim = 2; else
-  {
-    fprintf(stderr, "%s : bad file format : %s\n", F_NAME, buf);
-    return 0;
-  }
-
-  fscanf(fdin, "%d %d %d %d %d %d", &connex, &nvertex, &ncell, &rs, &cs, &ds);
-
-#ifdef DEBUG
-  printf("connex : %d ; nvertex : %d ; ncell : %d ; rs : %d ; cs : %d ; ds : %d\n", 
-	 connex, nvertex, ncell, rs, cs, ds);
-#endif
-
-  S = initskel(rs, cs, ds, nvertex, ncell, connex); 
-  if (S == NULL)
-  {
-    fprintf(stderr, "%s : initskel failed\n", F_NAME);
-    return 0;
-  }
-
-  // POINTS ISOLES
-  fscanf(fdin, "%s", buf);
-  if (strncmp(buf, "isol", 4) != 0)
-  {
-    fprintf(stderr, "%s : bad file format (0) : %s\n", F_NAME, buf);
-    return 0;
-  }
-  fscanf(fdin, "%d", &nbisol);
-  S->e_isol = nbisol;
-
-#ifdef DEBUG
-  printf("points isolés : %d\n", nbisol);
-#endif
-
-  for (i = 0; i < nbisol; i++)
-  {
-    nsommets++;
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "vertex", 6) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (1) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d %f", &k, &fval);
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "adj", 3) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (2) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d", &n);
-    for (j = 0; j < n; j++)
-    {
-      fscanf(fdin, "%d", &v);
-      addadjlist(S, k, v);
-      narcs++;
-    }
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "pts", 3) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (3) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d", &n);
-    for (j = 0; j < n; j++)
-    {
-      fscanf(fdin, "%d %f", &v, &fval);
-      addptslist(S, k, v);
-    }
-    S->tskel[k].fval = fval;
-  }
-
-  // POINTS EXTREMITES
-  fscanf(fdin, "%s", buf);
-  if (strncmp(buf, "end", 3) != 0)
-  {
-    fprintf(stderr, "%s : bad file format (4) : %s\n", F_NAME, buf);
-    return 0;
-  }
-  fscanf(fdin, "%d", &nbend);
-  S->e_end = nbisol+nbend;
-
-#ifdef DEBUG
-  printf("points extrémités : %d\n", nbend);
-#endif
-
-  for (i = 0; i < nbend; i++)
-  {
-    nsommets++;
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "vertex", 6) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (5) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d", &k);
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "adj", 3) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (6) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d", &n);
-    for (j = 0; j < n; j++)
-    {
-      fscanf(fdin, "%d", &v);
-      addadjlist(S, k, v);
-      narcs++;
-    }
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "pts", 3) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (7) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d", &n);
-    for (j = 0; j < n; j++)
-    {
-      fscanf(fdin, "%d %f", &v, &fval);
-      addptslist(S, k, v);
-    }
-    S->tskel[k].fval = fval;
-  }
-
-  // POINTS DE COURBE
-  fscanf(fdin, "%s", buf);
-  if (strncmp(buf, "curv", 4) != 0)
-  {
-    fprintf(stderr, "%s : bad file format (8) : %s\n", F_NAME, buf);
-    return 0;
-  }
-  fscanf(fdin, "%d", &nbcurv);
-  S->e_curv = nbisol+nbend+nbcurv;
-
-#ifdef DEBUG
-  printf("courbes : %d\n", nbcurv);
-#endif
-
-  for (i = 0; i < nbcurv; i++)
-  {
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "vertex", 6) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (9) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d", &k);
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "adj", 3) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (10) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d", &n);
-    for (j = 0; j < n; j++)
-    {
-      fscanf(fdin, "%d", &v);
-      addadjlist(S, k, v);
-      narcs++;
-    }
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "pts", 3) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (11) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d", &n);
-    for (j = 0; j < n; j++)
-    {
-      fscanf(fdin, "%d %f", &v, &fval);
-      addptslist(S, k, v);
-    }
-    S->tskel[k].fval = 0.0;
-  }
-
-  // POINTS DE JONCTION
-  fscanf(fdin, "%s", buf);
-  if (strncmp(buf, "junc", 4) != 0)
-  {
-    fprintf(stderr, "%s : bad file format (12) : %s\n", F_NAME, buf);
-    return 0;
-  }
-  fscanf(fdin, "%d", &nbjunc);
-  S->e_junc = nbisol+nbend+nbcurv+nbjunc;
-
-#ifdef DEBUG
-  printf("jonctions : %d\n", nbjunc);
-#endif
-
-  for (i = 0; i < nbjunc; i++)
-  {
-    nsommets++;
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "vertex", 6) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (13) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d", &k);
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "adj", 3) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (14) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d", &n);
-    for (j = 0; j < n; j++)
-    {
-      fscanf(fdin, "%d", &v);
-      addadjlist(S, k, v);
-      narcs++;
-    }
-    fscanf(fdin, "%s", buf);
-    if (strncmp(buf, "pts", 3) != 0)
-    {
-      fprintf(stderr, "%s : bad file format (15) : %s\n", F_NAME, buf);
-      return 0;
-    }
-    fscanf(fdin, "%d", &n);
-    fmax = 0.0;
-    for (j = 0; j < n; j++)
-    {
-      fscanf(fdin, "%d %f", &v, &fval);
-      if (fval > fmax) fmax = fval;
-      addptslist(S, k, v);
-    }
-    S->tskel[k].fval = fmax;
-  }
-
-  // ECRITURE DU GRAPHE
-
-  fdout = fopen(filenameout,"w");
-  if (!fdout)
-  {
-    fprintf(stderr, "%s: cannot open file: %s\n", F_NAME, filename);
-    return;
-  }
-  
-  fprintf(fdout, "%d %d\n", nsommets, narcs);
-
-  fprintf(fdout, "val sommets\n");
-  for (i = 0; i < S->e_isol; i++) printf("%d 0\n", i); 
-  for (i = S->e_isol; i < S->e_end; i++) printf("%d 1\n", i); 
-  for (i = S->e_curv; i < S->e_junc; i++) printf("%d 2\n", i); 
-
-  fprintf(fdout, "coord sommets\n");
-
-  for (i = 0; i < S->e_isol; i++) 
-  { 
-    printf("%d ", i); printptsliste(S->tskel[i].pts, S->rs); printf("\n"); 
-  }
-  for (i = S->e_isol; i < S->e_end; i++) 
-  { 
-    printf("%d ", i); printptsliste(S->tskel[i].pts, S->rs); printf("\n"); 
-  }
-  for (i = S->e_curv; i < S->e_junc; i++) 
-  { 
-    printf("%d ", i); printptsliste(S->tskel[i].pts, S->rs); printf("\n"); 
-  }
-
-
-
-
-
-
-
-  PAS FINI 
-
-
-
-
-
-
-  fprintf(fdout, "arcs values\n");
-  for (i = 0; i < n; i++) 
-    for (p = g->gamma[i]; p != NULL; p = p->next)
-    {
-      j = p->som;
-      v = p->v_arc;
-      fprintf(fdout, "%d %d %ld\n", i, j, v);
-    }
-
-
-  fclose(fdin);
-  fclose(fdout);
-  termineskel(S);
-  return 1;
-} /* readvskel() */
-
-/* =============================================================== */
-int main(argc, argv) 
-/* =============================================================== */
-  int argc; char **argv; 
-{
-
-  if (argc != 3)
-  {
-    fprintf(stderr, "usage: %s filein.skel fileout.pgm\n", argv[0]);
-    exit(1);
-  }
-
-  if (!vskel2graph(argv[1], argv[2]))
-  {
-    fprintf(stderr, "%s: function vskel2graph failed\n", argv[0]);
-    exit(1);
-  }
-
-  return 0;
-} /* main */
diff -r 8b1af7363833 src/com/watershedMeyer.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/com/watershedMeyer.c	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,131 @@
+/*
+Copyright ESIEE (2009) 
+
+m.couprie@esiee.fr
+
+This software is an image processing library whose purpose is to be
+used primarily for research and teaching.
+
+This software is governed by the CeCILL  license under French law and
+abiding by the rules of distribution of free software. You can  use, 
+modify and/ or redistribute the software under the terms of the CeCILL
+license as circulated by CEA, CNRS and INRIA at the following URL
+"http://www.cecill.info". 
+
+As a counterpart to the access to the source code and  rights to copy,
+modify and redistribute granted by the license, users are provided only
+with a limited warranty  and the software's author,  the holder of the
+economic rights,  and the successive licensors  have only  limited
+liability. 
+
+In this respect, the user's attention is drawn to the risks associated
+with loading,  using,  modifying and/or developing or reproducing the
+software by the user in light of its specific status of free software,
+that may mean  that it is complicated to manipulate,  and  that  also
+therefore means  that it is reserved for developers  and  experienced
+professionals having in-depth computer knowledge. Users are therefore
+encouraged to load and test the software's suitability as regards their
+requirements in conditions enabling the security of their systems and/or 
+data to be ensured and,  more generally, to use and operate it in the 
+same conditions as regards security. 
+
+The fact that you are presently reading this means that you have had
+knowledge of the CeCILL license and that you accept its terms.
+*/
+/*! \file watershedMeyer.c
+
+\brief watershed transformation (Meyer's algorithm)
+
+<B>Usage:</B> watershedMeyer in mark {bgmark|null} {roi|null} connex out
+
+<B>Description:</B>
+Performs the watershed transformation on the image <B>in</B>, taking the
+set of markers in <B>mark</B>. 
+If this parameter is present, <B>bgmark</B>
+is used as a set of markers for the background.
+If this parameter is present, <B>roi</B>
+indicates the region of interest on which the operation is performed.
+The parameter <B>connex</B> gives the adjacency relation (4,8 in 2D; 6,18,26 in 3D) 
+for the makers.
+
+<B>Types supported:</B> byte 2d, byte 3d
+
+<B>Category:</B> connect
+\ingroup connect
+
+\author Michel Couprie
+*/
+
+#include <stdio.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <string.h>
+#include <stdlib.h>
+#include <mccodimage.h>
+#include <mcimage.h>
+#include <llpemeyer.h>
+
+/* =============================================================== */
+int main(int argc, char **argv)
+/* =============================================================== */
+{
+  struct xvimage * image;
+  struct xvimage * marqueurs;
+  struct xvimage * marqueursfond;
+  struct xvimage * masque;
+  int32_t connex;
+
+  if (argc != 7)
+  {
+    fprintf(stderr, "usage: %s in mark {bgmark|null} {roi|null} connex out\n", argv[0]);
+    exit(1);
+  }
+
+  image = readimage(argv[1]);
+  marqueurs = readimage(argv[2]);
+  if ((image == NULL) || (marqueurs == NULL))
+  {
+    fprintf(stderr, "%s: readimage failed\n", argv[0]);
+    exit(1);
+  }
+
+  if (strcmp(argv[3],"null") == 0) 
+    marqueursfond = NULL;
+  else
+  {
+    marqueursfond = readimage(argv[3]);
+    if (marqueursfond == NULL)
+    {
+      fprintf(stderr, "%s: readimage failed\n", argv[0]);
+      exit(1);
+    }
+  }
+
+  if (strcmp(argv[4],"null") == 0) 
+    masque = NULL;
+  else
+  {
+    masque = readimage(argv[4]);
+    if (masque == NULL)
+    {
+      fprintf(stderr, "%s: readimage failed\n", argv[0]);
+      exit(1);
+    }
+  }
+
+  connex = atoi(argv[5]);
+
+  if (! llpemeyer(image, marqueurs, marqueursfond, masque, connex))
+  {
+    fprintf(stderr, "%s: llpemeyer failed\n", argv[0]);
+    exit(1);
+  }
+
+  writeimage(image, argv[argc - 1]);
+  freeimage(image);
+  freeimage(marqueurs);
+  if (marqueursfond) freeimage(marqueursfond);
+  if (masque) freeimage(masque);
+
+  return 0;
+} /* main */
diff -r 8b1af7363833 src/com/watershedMeyer2.c
--- a/src/com/watershedMeyer2.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/watershedMeyer2.c	Mon Jan 13 15:50:10 2014 +0100
@@ -103,7 +103,7 @@
 
   connex = atoi(argv[4]);
 
-  if (! llpemeyer_llpemeyer2(image, marqueurs, masque, connex))
+  if (! llpemeyer2(image, marqueurs, masque, connex))
   {
     fprintf(stderr, "%s: llpemeyer2 failed\n", argv[0]);
     exit(1);
diff -r 8b1af7363833 src/com/watershedMeyer2lab.c
--- a/src/com/watershedMeyer2lab.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/watershedMeyer2lab.c	Mon Jan 13 15:50:10 2014 +0100
@@ -119,7 +119,7 @@
   {
     if (mode == 0)
     {
-      if (! llpemeyer_llpemeyer2(image, marqueurs, masque, connex))
+      if (! llpemeyer2(image, marqueurs, masque, connex))
       {
 	fprintf(stderr, "%s: llpemeyer2 failed\n", argv[0]);
 	exit(1);
@@ -135,7 +135,7 @@
   {
     if (mode == 0)
     {
-      if (! llpemeyer_llpemeyer3d2(image, marqueurs, masque, connex))
+      if (! llpemeyer3d2(image, marqueurs, masque, connex))
       {
 	fprintf(stderr, "%s: llpemeyer3d2 failed\n", argv[0]);
 	exit(1);
@@ -143,7 +143,7 @@
     }
     else
     {
-      if (! llpemeyer_llpemeyer3d2b(image, marqueurs, masque, connex))
+      if (! llpemeyer3d2b(image, marqueurs, masque, connex))
       {
 	fprintf(stderr, "%s: llpemeyer3d2b failed\n", argv[0]);
 	exit(1);
diff -r 8b1af7363833 src/com/watershedMeyer_regular.c
--- a/src/com/watershedMeyer_regular.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/watershedMeyer_regular.c	Mon Jan 13 15:50:10 2014 +0100
@@ -119,7 +119,7 @@
 
   if ((connex == 4) || (connex == 8))
   {
-    if (! llpemeyer_llpemeyer(image, marqueurs, marqueursfond, masque, connex))
+    if (! llpemeyer(image, marqueurs, marqueursfond, masque, connex))
     {
       fprintf(stderr, "%s: llpemeyer failed\n", argv[0]);
       exit(1);
@@ -127,7 +127,7 @@
   }
   else if ((connex == 6) || (connex == 18) || (connex == 26))
   {
-    if (! llpemeyer_llpemeyer3d(image, marqueurs, marqueursfond, masque, connex))
+    if (! llpemeyer3d(image, marqueurs, marqueursfond, masque, connex))
     {
       fprintf(stderr, "%s: llpemeyer3d failed\n", argv[0]);
       exit(1);
diff -r 8b1af7363833 src/com/watershedthin.c
--- a/src/com/watershedthin.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/watershedthin.c	Mon Jan 13 15:50:10 2014 +0100
@@ -125,7 +125,7 @@
   //printf("lpebiconnexe \n");
   if(parite != 14)
   {
-    if (! llpemeyer_llpemeyerbiconnecte(image, marqueurs, marqueursfond, masque, parite))
+    if (! llpemeyerbiconnecte(image, marqueurs, marqueursfond, masque, parite))
     {
       fprintf(stderr, "%s: llpemeyerbiconnecte failed\n", argv[0]);
       exit(1);
@@ -133,7 +133,7 @@
   }
   else
   {
-    if (! llpemeyer_llpemeyerbiconnecte3d(image, marqueurs, marqueursfond, masque))
+    if (! llpemeyerbiconnecte3d(image, marqueurs, marqueursfond, masque))
     {
       fprintf(stderr, "%s: llpemeyerbiconnecte failed\n", argv[0]);
       exit(1);
diff -r 8b1af7363833 src/com/watershedwithoutline.c
--- a/src/com/watershedwithoutline.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/watershedwithoutline.c	Mon Jan 13 15:50:10 2014 +0100
@@ -129,7 +129,7 @@
 
   if ((connex == 4) || (connex == 8))
   {
-    if (! llpemeyer_llpemeyersansligne(image, marqueurs, marqueursfond, masque, connex, result))
+    if (! llpemeyersansligne(image, marqueurs, marqueursfond, masque, connex, result))
     {
       fprintf(stderr, "%s: llpemeyersansligne failed\n", argv[0]);
       exit(1);
@@ -137,7 +137,7 @@
   }
   else if ((connex == 6) || (connex == 18) || (connex == 26))
   {
-    if (! llpemeyer_llpemeyer3dsansligne(image, marqueurs, marqueursfond, masque, connex, result))
+    if (! llpemeyer3dsansligne(image, marqueurs, marqueursfond, masque, connex, result))
     {
       fprintf(stderr, "%s: llpemeyer3dsansligne failed\n", argv[0]);
       exit(1);
diff -r 8b1af7363833 src/com/watershedwithoutlinelab.c
--- a/src/com/watershedwithoutlinelab.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/watershedwithoutlinelab.c	Mon Jan 13 15:50:10 2014 +0100
@@ -108,7 +108,7 @@
 
   if ((connex == 4) || (connex == 8))
   {
-    if (! llpemeyer_llpemeyersanslignelab(image, marqueurs, masque, connex))
+    if (! llpemeyersanslignelab(image, marqueurs, masque, connex))
     {
       fprintf(stderr, "%s: llpemeyersanslignelab failed\n", argv[0]);
       exit(1);
@@ -116,7 +116,7 @@
   }
   else if ((connex == 6) || (connex == 18) || (connex == 26))
   {
-    if (! llpemeyer_llpemeyer3dsanslignelab(image, marqueurs, masque, connex))
+    if (! llpemeyer3dsanslignelab(image, marqueurs, masque, connex))
     {
       fprintf(stderr, "%s: llpemeyer3dsanslignelab failed\n", argv[0]);
       exit(1);
diff -r 8b1af7363833 src/com/wshedkhalimsky.c
--- a/src/com/wshedkhalimsky.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/com/wshedkhalimsky.c	Mon Jan 13 15:50:10 2014 +0100
@@ -113,7 +113,7 @@
     }
   }
 
-    if (! llpemeyer_llpemeyerkhalimsky(image, marqueurs, marqueursfond, masque))
+    if (! llpemeyerkhalimsky(image, marqueurs, marqueursfond, masque))
     {
       fprintf(stderr, "%s: llpemeyerkhalimsky failed\n", argv[0]);
       exit(1);
diff -r 8b1af7363833 src/lib/BuildLUTRemyThiel.cpp
--- a/src/lib/BuildLUTRemyThiel.cpp	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,450 +0,0 @@
-/*
-  figure9.cpp
-  from the article: " Exact Medial Axis With Euclidean Distance"
-  algorithm figure 9
-
-  Algoritm to compute the table and store it in the file table.txt
-
-  parameter to adjust the table MAXLUTENTRY,Rtarget1 and L1  
-
-  Note: the Columns are adjusted to put the right DT in face of the correct row of the table
-  
-  Written by: Rita Zrour
-  created: 18/04/2004
-  last modified: 29/04/2004
-  
-
-*/
-
-
-#include <algorithm>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <iostream>
-#include <fstream>
-
-
-typedef long int * TabCTg;
-typedef long int * TabDTg;
-typedef int * Tabuff;
-typedef long int * LookUpTable;
-
-
-struct Weighting{
-    int x, y, w,RR;
-};
-
-#define MAXWEIGHTING 100	//determine the numbers of vg (neighbors) that must be entered
-
-struct MaskG {
-    Weighting vg[MAXWEIGHTING];
-    int ng;
-};
-
-
-/* Functions definitions*/
-void ComputeCTg (int L, TabCTg & CTg); 
-int AddWeighting (MaskG *M, int x, int y, int w);
-void ComputeLutCol (long int * CTg, int L, Weighting *vg, int ivg, int Rmaxx, LookUpTable & Lutnew,long int * CTgNew);
-void CompLutMask (long int * CTg,long int * DTg, int L, MaskG * MgL, LookUpTable & LutColumn,int Rknown, int Rtarget,long int * CTgNeww);
-int IsMAg (int x, int y, MaskG *MgL, long int * LutColumn, long int * DTg, int L,int radiusmax);
-void CompSEDT(TabDTg DTg1,int L,int M);
-int RadiusMax(long int * gg,int LL,int MM);
-void PrintLut (FILE *f, MaskG *MgL, LookUpTable & Lut,int L, int Rknown);
-void PrintMgLut (FILE *f, MaskG *M);
-void adjustCTg (int L, TabCTg & CTgg,TabCTg & CTgNew,int Rmaxx);
-
-
-/* Main Function*/
-int libmain()
-{
-    int L1=100;// here L1 is the length of the image
-    int Rknown1=0;
-    int Rtarget1=1370;
-    TabCTg CTg1 = new long int[L1*L1];
-    TabDTg DTg1 = new long int[L1*L1];
-    LookUpTable LutColumn1=new long int[Rtarget1*MAXWEIGHTING];
-    MaskG MgL1;
-    MgL1.ng = 0;
-    TabCTg CTgNew1 = new long int[Rtarget1];
-	
-    FILE *file1;
-	
-    std::ofstream myFile("table.txt"); 
-    if (! myFile) // Always test file open
-    {
-        std::cout << "Error opening output file" << std::endl;
-        return -1;
-    }
-
-    myFile.close();
-
-    
-
-    CompLutMask (CTg1, DTg1, L1, &MgL1, LutColumn1, Rknown1, Rtarget1,CTgNew1);
-    Rknown1 = Rtarget1;
-
-    file1 = fopen ("table.txt", "w");
-    if (file1 == NULL) 
-        printf ("error while opening file\n\n");
-    else 
-    {
-        PrintMgLut (file1, &MgL1);
-        // PrintLut (file1, &MgL1, LutColumn1,L1, Rknown1);
-        printf ("\n\n");
-        fclose (file1);
-    }
-	
-
-    return 0;
-}	// end of main
-
-
-	
-
-/*	Function that compute CTgs*/
-void ComputeCTg (int L, TabCTg & CTg) 
-{
-    int x1,x2;
-    for (x1 = 0; x1 < L; x1++)
-    {
-        for (x2 = 0; x2 <= x1; x2++)
-        {
-            CTg[ x2*L + x1 ] =pow(x1,2)+pow(x2,2);
-        }
-    }
-}
-
-
-/*
- * Add a weigthing in the mask M.
- * Input:  M the generator of the mask, (x,y,w) the weighting.
- * Output: the number of the weighting in the mask.
- */
-
-int AddWeighting (MaskG *M, int x, int y, int w,int RR)
-{
-    int i = M->ng;
-
-    if (i >= MAXWEIGHTING) 
-    {
-        printf ("AddWeighting: weighting number limited to MAXWEIGHTING = %d\n",MAXWEIGHTING);
-        return 0;
-    }
-    if (! (0 <= y && y <= x && 0 < x && 0 < w)) 
-    {
-        printf ("AddWeighting: (x = %d, y = %d, w = %d)\n",x, y, w);
-        printf ("  does not respect 0 <= y <= x, 0 < x, 0 < w\n");
-        return 0;
-    }
-    M->vg[i].x = x;
-    M->vg[i].y = y;
-    M->vg[i].w = w;
-    M->vg[i].RR = RR;
-    M->ng++;
-    return i;
-}
-
-
-/*	Function that compute one Column of lut*/
-void ComputeLutCol (long int * CTg, int L, Weighting *vg, int ivg, int Rmaxx, LookUpTable & Lutnew,long int * CTgNew)
-{
-    int x, y, r1, r2, ra, rb,indice;
-    int count=0;		//this counter is used to put correct CTg in rox of the column
-    LookUpTable Lut=new long int[Rmaxx];
-
-    //Initializes Lut[ivg] and lut column to 0
-    for (int r = 0; r < Rmaxx; r++)   
-    {
-        Lut[r] = 0;
-		
-    }
-
-    for (x = 0; x < L - vg->x; x++)
-    {
-        for (y = 0; y <= x; y++)
-        {
-            //Radius of the ball where p1 is located 
-            r1 = CTg[ y*L + x ]+1 ;
-            // Same for p2 
-            r2 = CTg[ (y+vg->y)*L + x+vg->x ] +1;
-            if ((r1 < Rmaxx) && (r2 > Lut[r1])) 
-            {
-                Lut[r1] = r2;
-            }
-        }
-    }
-	
-    rb = 0;
-    for (ra = 0; ra < Rmaxx; ra++)
-    {
-        if (Lut[ra]!=0)
-        {
-            if (Lut[ra] > rb)
-                rb = Lut[ra];
-            else 
-		Lut[ra] = rb;
-        }
-    }
-
-
-    for (int r = 0; r < Rmaxx; r++)    
-    {
-        Lutnew[ivg*Rmaxx+r] = 0;
-    }
-
-    for (int r = 0; r < Rmaxx; r++)
-    {
-        if (Lut[r]!=0)
-        {
-            count=count+1;
-            indice=CTgNew[count];
-            Lutnew[ivg*Rmaxx+indice]=Lut[r];
-        }
-    }
-}
-
-
-
-/*
- * Full Lut Computation Algorithm with determination of MgLut.
- *
- * Input:  CTg and DTg two images, L the side length
- *			MgL the generator of the Lut mask, LutColumn the look-up
- *         table, Rknown the last verified radius, Rtarget the maximum radius
- *         to be verified and CTgNew used to put the values of the lut column in the correct
- place to be read using distance transform Image
- * Output: MgL and LutColumn are filled with the correct values.
- *
- * To compute MgL and Lut from beginning to the maximum radius allowed with L:
- */
-
-
-void CompLutMask (long int * CTg,long int * DTg, int L, MaskG * MgL, LookUpTable & LutColumn,int Rknown, int Rtarget,long int * CTgNeww)
-{
-    int x, y, p, R, i;
-
-    ComputeCTg (L, CTg);
-    adjustCTg (L, CTg,CTgNeww,Rtarget);
-
-    for (R = Rknown+1; R < Rtarget; R++)
-    {
-        printf ("R = %d / %d\n", R, Rtarget);
-
-        
-        for (x = 0; x < L; x++)
-            for (y = 0; y <= x; y++)
-            {
-                p = y*L + x;
-                if (CTg[p] <= R) 
-                    DTg[p] = 1; 
-                else 
-                    DTg[p] = 0;
-            }
-		
-        // distance map
-        CompSEDT (DTg,L,L);
-
-        for (x = 1; x < L; x++)
-            for (y = 0; y <= x; y++)
-            {
-                p = y*L + x;
-                if ( DTg[p] > 0 && IsMAg (x, y, MgL, LutColumn, DTg, L,Rtarget) )
-                {
-                    printf ("(%2d, %2d, %3d) added for R = %d\n",x, y, CTg[p], R);
-
-                    /* Add a new weighting to MgL */
-                    i = AddWeighting (MgL, x, y, CTg[p],R);
-
-                    /* New column in Lut */
-                    ComputeLutCol (CTg, L, MgL->vg+i, i, Rtarget, LutColumn,CTgNeww);
-				
-                    if (IsMAg (x, y, MgL, LutColumn, DTg, L,Rtarget))
-                    {
-                        printf ("\nComputeAndVerifyLut: ERROR for R = %d\n", R);
-                        return;
-                    }
-                }
-            }
-    }
-}
-
-
-/*This functions require DTg and LutColumn values; x et y are the coordinate of p*/
-
-int IsMAg (int x, int y, MaskG *MgL, long int * Lut, long int * DTg, int L,int radiusmax)
-{
-    int xx, yy, val, i;
-    val = DTg[ y*L + x ];
-
-    for (i = 0; i < MgL->ng ; i++)
-    {
-        xx = x-MgL->vg[i].x;
-        yy = y-MgL->vg[i].y;
-
-        if (0 <= yy && yy <= xx)
-        {
-            if ( DTg[ yy*L + xx ] >= Lut[i*radiusmax+val] )
-                return 0;
-        }
-    }
-
-    return 1;
-}
-
-
-
-/*Function that returns the maximum radius in the distance image*/
-int RadiusMax(long int * gg,int LL,int MM)  //LL=width of image  MM=height of image
-{
-    int i,j;
-    int max=0;
-    for (j=0;j<MM;j++)
-    {
-        for (i=0;i<LL;i++)
-        {
-            if (gg[j*LL+i]>max)
-		max=gg[j*LL+i];
-        }
-    }
-    return max;
-}
-
-
-
-/*Function for the distance map*/
-void CompSEDT(TabDTg DTg1,int L,int M)
-{
-    int i,j,df,db,n;
-    Tabuff buff = new int[L];
-    int w,d,rMax,rStart,rEnd;
-
-    //Forward scan
-    for (j=0;j<M;j++)
-    {
-	df=L;
-        for (i=0;i<L;i++)
-        {
-            if (DTg1[j*L+i]!=0)
-                df=df+1;
-            else 
-                df=0;
-            DTg1[j*L+i]=df*df;
-        }
-    }
-
-
-    //Backward scan
-    for (j=0;j<M;j++)
-    {
-	db=L;
-        for (i=L-1;i>=0;i--)
-        {
-            if (DTg1[j*L+i]!=0)
-                db=db+1;
-            else 
-                db=0;
-            DTg1[j*L+i]=std::min<long int>(DTg1[j*L+i],db*db);
-
-        }
-    }
-
-    //step 2
-    for (i=0;i<L;i++)
-    {
-        for (j=0;j<M;j++)
-        {
-            buff[j]=DTg1[i+j*L];
-        }
-	
-        for (j=0;j<M;j++)
-        {
-            d=buff[j];
-            if(d!=0)
-            {
-                rMax=int(sqrt(d))+1;
-                rStart=std::min(rMax,j);
-                rEnd=std::min(rMax,(M-1-j));
-			
-                for (n=-rStart;n<=rEnd;n++)
-                {
-                    w=buff[j+n]+n*n;
-                    if (w<d)
-                        d=w;
-                }
-            }
-            DTg1[i+j*L]=d;
-        }
-    }
-    free(buff);
-}
-
-
-/*Print a mask M to a file.
- * Input:  f a file, M the generator of a mask.
- * Output: to file f*/
-void PrintMgLut (FILE *f, MaskG *M)
-{
-    int i;
-    fprintf (f, "Weighting MgL1[%d]= ",M->ng);
-    fprintf (f, "{\n");
-    for (i = 0; i < M->ng; i++)
-        fprintf (f, "{%d,%d,%d},\n",M->vg[i].x, M->vg[i].y, M->vg[i].RR);
-    fprintf (f, "\n");
-    fprintf (f, "};\n");
-}
-
-
-
-/*Print the LUT to a file*/
-void PrintLut (FILE *f, MaskG *MgL, LookUpTable & Lut,int L, int Rknown)
-{
-    int i,ra;
-    fprintf (f, "int LutColumn[%d][%d]={\n",Rknown,MgL->ng);
-    // Loop to print lut
-    for (i = 0; i < MgL->ng; i++)
-    {
-        for (ra = 0; ra <Rknown; ra++)
-            fprintf(f,"%5d\n",Lut[i*Rknown+ra]);
-        fprintf (f, "\n\n\n");
-    }
-    fprintf (f, "};\n");
-
-}
-
-
-
-/* Function that puts CTgs values in an increasing order letting each CTg appear just once */
-void adjustCTg (int LL, TabCTg & CTgg,TabCTg & CTgNew,int Rmaxx)
-{
-    int x1,x2,i,a;
-    int count =-1;
-    TabCTg Compare = new long int[Rmaxx];
-
-    for (i = 0; i <= Rmaxx; i++)
-    {
-	Compare[i]=i;
-    }
-	
-    for (i = 0; i <= Rmaxx; i++)
-    {
-        for (x1 = 0; x1 < LL; x1++)
-        {
-            for (x2 = 0; x2 <= x1; x2++)
-            {
-                if (CTgg[ x2*LL + x1 ] ==Compare[i] )
-                {
-                    count=count+1;
-                    CTgNew[count]=Compare[i];
-                    goto stoploops;
-                }
-            }
-		
-        }
-    stoploops:
-	a=1;
-    }
-
-}
-
diff -r 8b1af7363833 src/lib/l2dcollapse.c
--- a/src/lib/l2dcollapse.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/l2dcollapse.c	Mon Jan 13 15:50:10 2014 +0100
@@ -186,7 +186,7 @@
 
   while (!mcrbt_RbtVide(RBT))
   {
-    i = mcrbt_RbtPopMin(RBT);
+    i = RbtPopMin(RBT);
     UnSet(i, EN_RBT);
     x = i % rs; y = i / rs;
     u = Collapse2d(k, x, y);
@@ -337,10 +337,10 @@
   while (!mcrbt_RbtVide(RBT))
   {
     // construit la liste de toutes les paires libres ayant la priorité courante
-    p = mcrbt_RbtMinLevel(RBT); 
-    while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    p = RbtMinLevel(RBT); 
+    while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
     {
-      g = mcrbt_RbtPopMin(RBT);
+      g = RbtPopMin(RBT);
       UnSet(g, EN_RBT);
       xg = g % rs; yg = g / rs;
       f = PaireLibre2d(k, xg, yg);
@@ -350,7 +350,7 @@
 	RlifoPush(&RLIFO, g);
 	Set(g, EN_RLIFO);
       }
-    } // while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    } // while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
 
     for (dir = 0; dir <= 1; dir++) // For all face directions
       for (ori = 0; ori <= 1; ori++) // For both orientations
@@ -549,10 +549,10 @@
   while (!mcrbt_RbtVide(RBT))
   {
     // construit la liste de toutes les paires libres ayant la priorité courante
-    p = mcrbt_RbtMinLevel(RBT); 
-    while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    p = RbtMinLevel(RBT); 
+    while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
     {
-      g = mcrbt_RbtPopMin(RBT);
+      g = RbtPopMin(RBT);
       UnSet(g, EN_RBT);
       xg = g % rs; yg = g / rs;
       f = PaireLibre2d(k, xg, yg);
@@ -562,7 +562,7 @@
 	RlifoPush(&RLIFO, g);
 	Set(g, EN_RLIFO);
       }
-    } // while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    } // while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
 
     for (dir = 0; dir <= 1; dir++) // For all face directions
       for (ori = 0; ori <= 1; ori++) // For both orientations
@@ -1018,10 +1018,10 @@
   while (!mcrbt_RbtVide(RBT))
   {
     // construit la liste de toutes les paires libres ayant la priorité courante
-    p = mcrbt_RbtMinLevel(RBT); 
-    while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    p = RbtMinLevel(RBT); 
+    while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
     {
-      g = mcrbt_RbtPopMin(RBT);
+      g = RbtPopMin(RBT);
       UnSet(g, EN_RBT);
       xg = g % rs; yg = g / rs;
       f = PaireLibre2d(k, xg, yg);
@@ -1031,7 +1031,7 @@
 	RlifoPush(&RLIFO, g);
 	Set(g, EN_RLIFO);
       }
-    } // while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    } // while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
 
     for (dir = 0; dir <= 1; dir++) // For all face directions
       for (ori = 0; ori <= 1; ori++) // For both orientations
@@ -1293,10 +1293,10 @@
   while (!mcrbt_RbtVide(RBT))
   {
     // construit la liste de toutes les paires libres ayant la priorité courante
-    p = mcrbt_RbtMinLevel(RBT); 
-    while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    p = RbtMinLevel(RBT); 
+    while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
     {
-      g = mcrbt_RbtPopMin(RBT);
+      g = RbtPopMin(RBT);
       UnSet(g, EN_RBT);
       xg = g % rs; yg = g / rs;
       f = PaireLibre2d(k, xg, yg);
@@ -1306,7 +1306,7 @@
 	RlifoPush(&RLIFO, g);
 	Set(g, EN_RLIFO);
       }
-    } // while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    } // while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
 
     for (dir = 0; dir <= 1; dir++) // For all face directions
       for (ori = 0; ori <= 1; ori++) // For both orientations
diff -r 8b1af7363833 src/lib/l3dcollapse.c
--- a/src/lib/l3dcollapse.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/l3dcollapse.c	Mon Jan 13 15:50:10 2014 +0100
@@ -178,7 +178,7 @@
 
   while (!mcrbt_RbtVide(RBT))
   {
-    i = mcrbt_RbtPopMin(RBT);
+    i = RbtPopMin(RBT);
     UnSet(i, EN_RBT);
     x = i % rs; y = (i % ps) / rs; z = i / ps;
     u = Collapse3d(k, x, y, z);
@@ -333,10 +333,10 @@
   while (!mcrbt_RbtVide(RBT))
   {
     // construit la liste de toutes les paires libres ayant la priorité courante
-    p = mcrbt_RbtMinLevel(RBT); 
-    while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    p = RbtMinLevel(RBT); 
+    while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
     {
-      g = mcrbt_RbtPopMin(RBT);
+      g = RbtPopMin(RBT);
       UnSet(g, EN_RBT);
       xg = g % rs; yg = (g % ps) / rs; zg = g / ps;
       f = PaireLibre3d(k, xg, yg, zg);
@@ -346,7 +346,7 @@
 	RlifoPush(&RLIFO, g);
 	Set(g, EN_RLIFO);
       }
-    } // while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    } // while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
 
     for (dir = 0; dir <= 2; dir++) // For all face directions
       for (ori = 0; ori <= 1; ori++) // For both orientations
@@ -548,10 +548,10 @@
   while (!mcrbt_RbtVide(RBT))
   {
     // construit la liste de toutes les paires libres ayant la priorité courante
-    p = mcrbt_RbtMinLevel(RBT); 
-    while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    p = RbtMinLevel(RBT); 
+    while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
     {
-      g = mcrbt_RbtPopMin(RBT);
+      g = RbtPopMin(RBT);
       UnSet(g, EN_RBT);
       xg = g % rs; yg = (g % ps) / rs; zg = g / ps;
       f = PaireLibre3d(k, xg, yg, zg);
@@ -561,7 +561,7 @@
 	RlifoPush(&RLIFO, g);
 	Set(g, EN_RLIFO);
       }
-    } // while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    } // while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
 
     for (dir = 0; dir <= 2; dir++) // For all face directions
       for (ori = 0; ori <= 1; ori++) // For both orientations
@@ -1278,10 +1278,10 @@
   while (!mcrbt_RbtVide(RBT))
   {
     // construit la liste de toutes les paires libres ayant la priorité courante
-    p = mcrbt_RbtMinLevel(RBT); 
-    while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    p = RbtMinLevel(RBT); 
+    while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
     {
-      g = mcrbt_RbtPopMin(RBT);
+      g = RbtPopMin(RBT);
       UnSet(g, EN_RBT);
       xg = g % rs; yg = (g % ps) / rs; zg = g / ps;
       f = PaireLibre3d(k, xg, yg, zg);
@@ -1291,7 +1291,7 @@
 	RlifoPush(&RLIFO, g);
 	Set(g, EN_RLIFO);
       }
-    } // while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    } // while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
 
     for (dir = 0; dir <= 2; dir++) // For all face directions
       for (ori = 0; ori <= 1; ori++) // For both orientations
diff -r 8b1af7363833 src/lib/lMSF.c
--- a/src/lib/lMSF.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lMSF.c	Mon Jan 13 15:50:10 2014 +0100
@@ -100,7 +100,7 @@
   }
   
  while(!mcrbt_RbtVide(L)){
-   u = mcrbt_RbtPopMin(L);
+   u = RbtPopMin(L);
 #ifdef DEBUG
    printf("poped arete u no: %d de niveau %d\n",u,F[u]);
 #endif
@@ -194,7 +194,7 @@
   }
   
   while(!mcrbt_RbtVide(L)){
-    u = mcrbt_RbtPopMin(L);
+    u = RbtPopMin(L);
 #ifdef DEBUG
     printf("poped arete u no: %d de niveau %d\n",u,F[u]);
 #endif
@@ -304,7 +304,7 @@
   }
   printf("Initialisation OK \n");
   while(!mcrbt_RbtVide(L)){
-    u = mcrbt_RbtPopMin(L);
+    u = RbtPopMin(L);
 #ifdef DEBUG
     printf("Arete poped F[(%d,%d,%d,%d),%d] = %d\n", u%rs, (u%ps)/rs, (u%vs)/ps, (u%N)/vs, u/N,F[u]); 
 #endif
diff -r 8b1af7363833 src/lib/lattrib.c
--- a/src/lib/lattrib.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1763 +0,0 @@
-/* $Id: lattrib.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* 
-  Common code for files: 
-    lattribarea.c
-    lattribheight.c
-    lattribvol.c
-    lsegreconsheight.c
-*/
-
-//#define DEBUG
-
-#include <stdio.h>
-#include <stdint.h>
-#include <string.h>
-#include <stdlib.h>
-
-#include "mcfah.h"
-#include "mccodimage.h"
-
-#define FILTERED_OUT 0x01
-#define LEAFMIN      0x02
-#define LEAFMAX      0x04
-#define LEAF         (LEAFMIN|LEAFMAX)
-#define LCA1         0x08
-#define LCA2         0x10
-#define LCA          (LCA1|LCA2)
-
-#define NOT_ANALYZED 2000000000
-#define IN_THE_QUEUE 2000000001
-
-/*
-   principe de l'encodage des composantes: 
-   le niveau est code dans les bits 24 a 31
-   il reste donc 24 bits pour coder le numero de la composante, 
-         24
-   soit 2   = 16 megacomposantes par niveau.
-*/
-
-#define ENCODE(y,h) (y|(h<<24))
-#define DECODENUM(y) (y&0x00ffffff)
-#define DECODENIV(y) (y>>24)
-
-/* 
-   macros pour l'acces aux donnees de la structure CompactTree
-*/
-
-#define NBCOMP(h) ((h==0)?(cpct->hc[0]):(cpct->hc[h]-cpct->hc[h-1]))
-#define INDEXCOMP(h,j) ((h==0)?(j):(cpct->hc[h-1]+j))
-#define NBFILS(c) ((c==0)?(cpct->dfils[0]):(cpct->dfils[c]-cpct->dfils[c-1]))
-#define INDEXFILS(c,j) ((c==0)?(j):(cpct->dfils[c-1]+j))
-
-/* ============================================================================== */
-/* 
-  Structure de donnees pour la construction de l'arbre des composantes.
-
-  Les sommets de cet arbre sont les composantes des coupes >=, 
-  a l'exception de celles qui sont egales a une composante d'un niveau inferieur.
-  Il y a donc moins de N sommets (N = nombre de pixels) et de N-1 arcs.
-
-  Une composante (sommet) est representee par deux donnees : 
-  son niveau (sur 8 bits) et son numero dans le niveau (sur 24 bits), 
-  le tout encode dans un entier 32 bits.
-
-  L'arbre est represente par
-  une liste d'arcs (tableaux tete et queue), fleches de la racine vers les feuilles.
-*/
-/* ============================================================================== */
-typedef struct {
-  uint32_t nbmaxarcs;          /* nombre maximum d'arcs */
-  uint32_t nbarcs;             /* nombre effectif d'arcs */
-  uint32_t racine;             /* racine de l'arbre */
-  uint32_t *tete;              /* sommets initiaux des arcs de l'arbre */
-  uint32_t *queue;             /* sommets terminaux des arcs de l'arbre */  
-#ifdef ATTR_SURF
-  int32_t surf_racine;                 /* attribut surface pour la racine */
-  int32_t *surf;                       /* attributs des sommets terminaux des arcs */
-#endif
-#ifdef ATTR_PERIM
-  int32_t *perim;
-#endif 
-#ifdef ATTR_HBORD
-  int32_t *hbord;
-#endif
-#ifdef ATTR_VOL
-  int32_t *vol;
-#endif
-} CompTree;
-/* ============================================================================== */
-
-/* ============================================================================== */
-/* 
-  Structure de donnees compacte pour l'arbre des composantes.
-
-  L'arbre est represente par cinq tableaux:
-  - le tableau 'hc' qui au niveau de gris h, associe le nombre de composantes de 
-    niveau <= h (histogramme cumule). On a donc:
-      nombre de composantes de niveau 0 = hc[0]
-      nombre de composantes de niveau h > 0 = hc[h] - hc[h-1]
-      index derniere composante de niveau h s'il en existe = hc[h] - 1
-  - le tableau 'comp' qui, a l'index i d'une composante, associe le code de la 
-    composante (represente dans 32 bits comme dans la structure CompTree)
-  - le tableau 'pere' qui, a l'index i d'une composante, associe l'index du pere de i
-    (sauf pour la racine qui a pour index 0 et a laquelle est associee 0)
-  - le tableau 'dfils' qui, a l'index i d'une composante, associe l'index(+1) 
-    du dernier fils de i (sauf pour les feuilles)
-  - le tableau 'fils' qui contient les listes de fils
-*/
-/* ============================================================================== */
-#define CPCT_ROOT 0
-typedef struct {
-  uint32_t nbcomp;  /* nombre de composantes */
-  uint32_t *comp;   /* tableau des composantes */
-  uint32_t *pere;   /* tableau representant la relation 'pere' */  
-  uint32_t *dfils;  /* tableau donnant l'index+1 du dernier fils dans le tableau 'fils' */
-  uint32_t *fils;   /* tableau representant, avec le precedent, la relation 'fils' */  
-  uint32_t *hc;     /* histogramme cumule des composantes */
-#ifdef ATTR_SURF
-  int32_t *surf;
-#endif
-#ifdef ATTR_HEIGHT
-  int32_t *height;
-#endif
-#ifdef ATTR_PERIM
-  int32_t *perim; 
-#endif
-#ifdef ATTR_HBORD
-  int32_t *hbord;
-#endif
-#ifdef ATTR_CONTRAST
-  double *contrast;           /* attribut flottant */
-#endif
-#ifdef ATTR_VOL
-  int32_t *vol;
-#endif
-#ifdef ATTR_DYN
-  int32_t *dyn;
-#endif
-  char *flags;          /* 8 booleens pour des usages divers */
-} CompactTree;
-/* ============================================================================== */
-
-/* ======================================================================== */
-/* ======================================================================== */
-/* FONCTIONS POUR LE TRI */
-/* ======================================================================== */
-/* ======================================================================== */
-
-// cle DOUBLE
-
-/* =============================================================== */
-static int32_t d_Partitionner(int32_t *A, double *T, int32_t p, int32_t r)
-/* =============================================================== */
-/*
-  partitionne les elements de A entre l'indice p (compris) et l'indice r (compris)
-  en deux groupes : les elements q tq T[A[q]] <= T[A[p]] et les autres.
-*/
-{
-  int32_t t;
-  double x = T[A[p]];
-  int32_t i = p - 1;
-  int32_t j = r + 1;
-  while (1)
-  {
-    do j--; while (T[A[j]] > x);
-    do i++; while (T[A[i]] < x);
-    if (i < j) { t = A[i]; A[i] = A[j]; A[j] = t; }
-    else return j;
-  } /* while (1) */   
-} /* d_Partitionner() */
-
-/* =============================================================== */
-static int32_t d_PartitionStochastique(int32_t *A, double *T, int32_t p, int32_t r)
-/* =============================================================== */
-/*
-  partitionne les elements de A entre l'indice p (compris) et l'indice r (compris)
-  en deux groupes : les elements k tels que T[A[k]] <= T[A[q]] et les autres, 
-  avec q tire au hasard dans [p,r].
-*/
-{
-  int32_t t, q;
-
-  q = p + (rand() % (r - p + 1));
-  t = A[p];         /* echange A[p] et A[q] */
-  A[p] = A[q]; 
-  A[q] = t;
-  return d_Partitionner(A, T, p, r);
-} /* d_PartitionStochastique() */
-
-/* =============================================================== */
-static void d_TriRapideStochastique (int32_t * A, double *T, int32_t p, int32_t r)
-/* =============================================================== */
-/* 
-  trie les valeurs du tableau A de l'indice p (compris) a l'indice r (compris) 
-  par ordre croissant 
-*/
-{
-  int32_t q; 
-  if (p < r)
-  {
-    q = d_PartitionStochastique(A, T, p, r);
-    d_TriRapideStochastique (A, T, p, q) ;
-    d_TriRapideStochastique (A, T, q+1, r) ;
-  }
-} /* d_TriRapideStochastique() */
-
-// cle INT
-
-/* =============================================================== */
-static int32_t i_Partitionner(int32_t *A, int32_t *T, int32_t p, int32_t r)
-/* =============================================================== */
-/*
-  partitionne les elements de A entre l'indice p (compris) et l'indice r (compris)
-  en deux groupes : les elements q tq T[A[q]] <= T[A[p]] et les autres.
-*/
-{
-  int32_t t;
-  int32_t x = T[A[p]];
-  int32_t i = p - 1;
-  int32_t j = r + 1;
-  while (1)
-  {
-    do j--; while (T[A[j]] > x);
-    do i++; while (T[A[i]] < x);
-    if (i < j) { t = A[i]; A[i] = A[j]; A[j] = t; }
-    else return j;
-  } /* while (1) */   
-} /* i_Partitionner() */
-
-/* =============================================================== */
-static int32_t i_PartitionStochastique(int32_t *A, int32_t *T, int32_t p, int32_t r)
-/* =============================================================== */
-/*
-  partitionne les elements de A entre l'indice p (compris) et l'indice r (compris)
-  en deux groupes : les elements k tels que T[A[k]] <= T[A[q]] et les autres, 
-  avec q tire au hasard dans [p,r].
-*/
-{
-  int32_t t, q;
-
-  q = p + (rand() % (r - p + 1));
-  t = A[p];         /* echange A[p] et A[q] */
-  A[p] = A[q]; 
-  A[q] = t;
-  return i_Partitionner(A, T, p, r);
-} /* i_PartitionStochastique() */
-
-/* =============================================================== */
-static void i_TriRapideStochastique (int32_t * A, int32_t *T, int32_t p, int32_t r)
-/* =============================================================== */
-/* 
-  trie les valeurs du tableau A de l'indice p (compris) a l'indice r (compris) 
-  par ordre croissant 
-*/
-{
-  int32_t q; 
-  if (p < r)
-  {
-    q = i_PartitionStochastique(A, T, p, r);
-    i_TriRapideStochastique (A, T, p, q) ;
-    i_TriRapideStochastique (A, T, q+1, r) ;
-  }
-} /* i_TriRapideStochastique() */
-
-/* ======================================================================== */
-/* ======================================================================== */
-/* CONSTRUCTION ET GESTION DE L'ARBRE DES COMPOSANTES */
-/* ======================================================================== */
-/* ======================================================================== */
-
-/* ==================================== */
-static CompTree * InitCompTree(int32_t nbmaxarcs)
-/* ==================================== */
-{
-  CompTree *ct;
-  ct = (CompTree *)malloc(sizeof(CompTree));
-  if (ct == NULL) return NULL;
-  ct->tete = (uint32_t *)malloc(nbmaxarcs * sizeof(int32_t));
-  if (ct->tete == NULL) return NULL;
-  ct->queue = (uint32_t *)malloc(nbmaxarcs * sizeof(int32_t));
-  if (ct->queue == NULL) return NULL;
-#ifdef ATTR_SURF
-  ct->surf = (int32_t *)malloc(nbmaxarcs * sizeof(int32_t));
-  if (ct->surf == NULL) return NULL;
-#endif
-#ifdef ATTR_PERIM
-  ct->perim = (int32_t *)malloc(nbmaxarcs * sizeof(int32_t));
-  if (ct->perim == NULL) return NULL;
-#endif
-#ifdef ATTR_HBORD
-  ct->hbord = (int32_t *)malloc(nbmaxarcs * sizeof(int32_t));
-  if (ct->hbord == NULL) return NULL;
-#endif
-#ifdef ATTR_VOL
-  ct->vol = (int32_t *)malloc(nbmaxarcs * sizeof(int32_t));
-  if (ct->vol == NULL) return NULL;
-#endif
-  ct->nbmaxarcs = nbmaxarcs;
-  ct->nbarcs = 0;
-  ct->racine = CPCT_ROOT;
-  return ct;
-} /* InitCompTree() */
-
-/* ==================================== */
-static void TermineCompTree(CompTree *ct)
-/* ==================================== */
-{
-  free(ct->tete);
-  free(ct->queue);
-#ifdef ATTR_SURF
-  free(ct->surf);
-#endif
-#ifdef ATTR_PERIM
-  free(ct->perim);
-#endif
-#ifdef ATTR_HBORD
-  free(ct->hbord);
-#endif
-#ifdef ATTR_VOL
-  free(ct->vol);
-#endif
-  free(ct);
-} /* TermineCompTree() */
-
-/* ==================================== */
-static CompactTree * CompTree2CompactTree(CompTree *ct, uint32_t *number_nodes)
-/* ==================================== */
-/* ATTENTION EFFET DE BORD : DETRUIT LA RELATION number_nodes 
-   (number_nodes represente le nombre de composantes par niveau, calcule par flood())
-*/
-{
-  CompactTree *cpct;
-  uint32_t i, n, h, t, th, tn, q, qh, qn;
-  uint32_t nbcomp = ct->nbarcs + 1;
-  uint32_t *nfils;
-
-  cpct = (CompactTree *)malloc(sizeof(CompactTree));
-  if (cpct == NULL) return NULL;
-  cpct->nbcomp = nbcomp;
-  cpct->comp = (uint32_t *)malloc(nbcomp * sizeof(int32_t));
-  if (cpct->comp == NULL) return NULL;
-  cpct->pere = (uint32_t *)malloc(nbcomp * sizeof(int32_t));
-  if (cpct->pere == NULL) return NULL;
-  cpct->dfils = (uint32_t *)malloc(nbcomp * sizeof(int32_t));
-  if (cpct->dfils == NULL) return NULL;
-  cpct->fils = (uint32_t *)malloc(nbcomp * sizeof(int32_t));
-  if (cpct->fils == NULL) return NULL;
-  cpct->hc = (uint32_t *)malloc(256 * sizeof(int32_t));
-  if (cpct->hc == NULL) return NULL;
-#ifdef ATTR_SURF
-  cpct->surf = (int32_t *)malloc(nbcomp * sizeof(int32_t));
-  if (cpct->surf == NULL) return NULL;
-#endif
-#ifdef ATTR_HEIGHT
-  cpct->height = (int32_t *)malloc(nbcomp * sizeof(int32_t));
-  if (cpct->height == NULL) return NULL;
-#endif
-#ifdef ATTR_PERIM
-  cpct->perim = (int32_t *)malloc(nbcomp * sizeof(int32_t));
-  if (cpct->perim == NULL) return NULL;
-#endif
-#ifdef ATTR_HBORD
-  cpct->hbord = (int32_t *)malloc(nbcomp * sizeof(int32_t));
-  if (cpct->hbord == NULL) return NULL;
-#endif
-#ifdef ATTR_CONTRAST
-  cpct->contrast = (double *)malloc(nbcomp * sizeof(double));
-  if (cpct->contrast == NULL) return NULL;
-#endif
-#ifdef ATTR_VOL
-  cpct->vol = (int32_t *)malloc(nbcomp * sizeof(int32_t));
-  if (cpct->vol == NULL) return NULL;
-#endif
-#ifdef ATTR_DYN
-  cpct->dyn = (int32_t *)malloc(nbcomp * sizeof(int32_t));
-  if (cpct->dyn == NULL) return NULL;
-#endif
-  cpct->flags = (char *)calloc(nbcomp, sizeof(char));
-  if (cpct->flags == NULL) return NULL;
-
-  /* calcule l'histogramme cumule hc */
-  n = cpct->hc[0] = number_nodes[0]; 
-  for (i = 1; i < 256; i++) { n += number_nodes[i]; cpct->hc[i] = n; }
-
-  /* construit le tableau des composantes comp */
-  n = 0; h = 0; while (!number_nodes[h]) h++; /* ATTENTION CODE FRAGILE */
-  for (i = 0; i < nbcomp; i++)                /* SUPPOSE CORRECTES LES DONNEES D'ENTREE */
-  {                                           /* PAS DE VERIFICATION */
-    cpct->comp[i] = ENCODE(n,h); 
-    number_nodes[h]--; n++;
-    if (!number_nodes[h]) { n = 0; while (!number_nodes[h]) h++; }
-  } /* for i */
-  
-  /* construit la relation pere */
-  for (i = 0; i < nbcomp-1; i++)
-  {
-    t = ct->tete[i]; q = ct->queue[i];
-    th = DECODENIV(t); tn = DECODENUM(t);
-    qh = DECODENIV(q); qn = DECODENUM(q);
-    cpct->pere[INDEXCOMP(qh,qn)] = INDEXCOMP(th,tn);
-  }
-  q = ct->racine; qh = DECODENIV(q); qn = DECODENUM(q);
-  cpct->pere[INDEXCOMP(qh,qn)] = INDEXCOMP(qh,qn);
-
-  /* construit la relation dfils et fils */
-  nfils = (uint32_t *)calloc(nbcomp, sizeof(int32_t));
-  if (nfils == NULL) return NULL;
-  for (i = 1; i < nbcomp; i++) nfils[cpct->pere[i]] += 1;
-    /* exception : la racine (0) est fille d'elle-meme, cette relation n'est pas comptee */ 
-  cpct->dfils[CPCT_ROOT] = nfils[CPCT_ROOT];
-  for (i = 1; i < nbcomp; i++) cpct->dfils[i] = cpct->dfils[i - 1] + nfils[i];
-  for (i = 1; i < nbcomp; i++)
-  {
-    t = cpct->pere[i]; /* i est fils de t */
-    nfils[t] -= 1;
-    cpct->fils[INDEXFILS(t,nfils[t])] = i;
-  }
-  free(nfils);
-
-  /* transfere les attributs (cas particulier pour la racine) */
-  for (i = 0; i < nbcomp-1; i++)
-  {
-    q = ct->queue[i]; qh = DECODENIV(q); qn = DECODENUM(q);
-#ifdef ATTR_SURF
-    cpct->surf[INDEXCOMP(qh,qn)] = ct->surf[i];
-#endif
-#ifdef ATTR_PERIM
-    cpct->perim[INDEXCOMP(qh,qn)] = ct->perim[i];
-#endif
-#ifdef ATTR_HBORD
-    cpct->hbord[INDEXCOMP(qh,qn)] = ct->hbord[i];
-#endif
-#ifdef ATTR_VOL
-    cpct->vol[INDEXCOMP(qh,qn)] = ct->vol[i];
-#endif
-  }
-#ifdef ATTR_SURF
-  cpct->surf[CPCT_ROOT] = ct->surf_racine;
-#endif
-#ifdef ATTR_PERIM
-  cpct->perim[CPCT_ROOT] = 0;
-#endif
-#ifdef ATTR_HBORD
-  cpct->hbord[CPCT_ROOT] = 0;
-#endif
-#ifdef ATTR_VOL
-  cpct->vol[CPCT_ROOT] = 0;
-#endif  
-  return cpct;
-} /* CompTree2CompactTree() */
-
-/* ==================================== */
-static void ReInitFlags(CompactTree * cpct)
-/* ==================================== */
-{
-  uint32_t nbcomp = cpct->nbcomp;
-  memset(cpct->flags,0,nbcomp);
-} /* ReInitFlags() */
-
-#ifdef ATTR_SURF
-/* ==================================== */
-static int32_t surfrec(CompactTree * cpct, uint32_t som, int32_t *na1)
-/* ==================================== */
-/*
-   Calcule la surface de chacune des composantes, a partir de 
-   l'information stockee dans cpct->surf[i], qui correspond a la 
-   difference de surface entre la composante i et ses filles.
-   Le resultat est provisoirement stocke dans le tableau na1 (indexe par
-   le numero de composante i), pour etre ensuite recopie dans cpct->surf[i].
-*/ 
-{
-  int32_t i, n, j;
-  n = NBFILS(som);
-  if (n == 0) return na1[som] = cpct->surf[som];
-  na1[som] = cpct->surf[som];
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    na1[som] += surfrec(cpct, j, na1);
-  }
-  return na1[som];
-} /* surfrec() */
-#endif
-
-#ifdef ATTR_VOL
-/* ==================================== */
-static int32_t volrec(CompactTree * cpct, uint32_t som, int32_t *na1)
-/* ==================================== */
-/*
-   Attention: pour utiliser cette fonction, il faut avoir 
-   prealablement calcule la surface des composantes (cf. surfrec())
-   et avoir stocke cette information dans cpct->surf[].
-
-   Calcule le volume de chacune des composantes, a partir de 
-   l'information stockee dans cpct->surf[i], qui correspond a la 
-   surface de la composante.
-   Le resultat est provisoirement stocke dans le tableau na1 (indexe par
-   le numero de composante i), pour etre ensuite recopie dans cpct->vol[i].
-*/ 
-{
-  int32_t i, n, j, nb_coupes_eq;
-  n = NBFILS(som);
-  if (n == 0) return na1[som] = cpct->surf[som];
-  na1[som] = cpct->surf[som];
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    nb_coupes_eq = DECODENIV(cpct->comp[j]) - DECODENIV(cpct->comp[som]) - 1;
-    na1[som] += volrec(cpct, j, na1) + (cpct->surf[j] * nb_coupes_eq);
-  }
-  return na1[som];
-} /* volrec() */
-
-/* ==================================== */
-static int32_t volrec_old(CompactTree * cpct, uint32_t som, int32_t *na1)
-/* ==================================== */
-{
-  int32_t i, n, j;
-  n = NBFILS(som);
-  if (n == 0) return na1[som] = cpct->surf[som];
-  na1[som] = cpct->surf[som];
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    na1[som] += volrec_old(cpct, j, na1);
-  }
-  return na1[som];
-} /* volrec_old() */
-#endif
-
-#ifdef ATTR_HEIGHT
-/* ==================================== */
-static int32_t heightrec(CompactTree * cpct, uint32_t som, int32_t *na1)
-/* ==================================== */
-/* retourne le niveau max des descendants de som (ou le niveau de som pour une feuille) */ 
-{
-  int32_t i, n, j, h;
-  n = NBFILS(som);
-  if (n == 0) return na1[som] = DECODENIV(cpct->comp[som]);
-  na1[som] = 0;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    h = heightrec(cpct, j, na1);
-    na1[som] = mcmax(na1[som], h);
-  }
-  return na1[som];
-} /* heightrec() */
-#endif
-
-#ifdef ATTR_PERIM
-/* ==================================== */
-static int32_t perimrec(CompactTree * cpct, uint32_t som, int32_t *nperim)
-/* ==================================== */
-{
-  int32_t i, n, j;
-  n = NBFILS(som);
-  if (n == 0) return nperim[som] = cpct->perim[som];
-  nperim[som] = cpct->perim[som];
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    nperim[som] += perimrec(cpct, j, nperim);
-  }
-  return nperim[som];
-} /* perimrec() */
-#endif
-
-#ifdef ATTR_HBORD
-/* ==================================== */
-static int32_t hbordrec(CompactTree * cpct, uint32_t som, int32_t *nhbord)
-/* ==================================== */
-{
-  int32_t i, n, j;
-  n = NBFILS(som);
-  if (n == 0) return nhbord[som] = cpct->hbord[som];
-  nhbord[som] = cpct->hbord[som];
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    nhbord[som] += hbordrec(cpct, j, nhbord);
-  }
-  return nhbord[som];
-} /* hbordrec() */
-#endif
-
-/* ==================================== */
-static void CalculeAttributs(CompactTree * cpct)
-/* ==================================== */
-{
-  int32_t *na1, *na2, i;
-  uint32_t nbcomp = cpct->nbcomp;
-
-  na1 = (int32_t *)malloc(nbcomp * sizeof(int32_t));
-  na2 = (int32_t *)malloc(nbcomp * sizeof(int32_t));
-#ifdef ATTR_SURF
-  (void)surfrec(cpct, 0, na1);
-  for (i = 0; i < nbcomp; i++) cpct->surf[i] = na1[i];
-#endif
-#ifdef ATTR_VOL
-  if (cpct->surf == NULL)
-  {
-    fprintf(stderr, "CalculeAttributs: VOL ne peut etre calcule dans SURF\n");
-    exit(0);
-  }
-  (void)volrec(cpct, 0, na1);
-  for (i = 0; i < nbcomp; i++) cpct->vol[i] = na1[i];
-#endif
-#ifdef ATTR_HEIGHT
-
-  (void)heightrec(cpct, 0, na1);
-  /* pour la mesure de la hauteur, il faut rajouter la difference de niveau avec le pere */
-  for (i = 1; i < nbcomp; i++) cpct->height[i] = na1[i] 
-	     /* - DECODENIV(cpct->comp[i]) + DECODENIV(cpct->comp[i]) */ /* inutile */
-                                               - DECODENIV(cpct->comp[cpct->pere[i]]) - 1;
-
-  cpct->height[0] = NDG_MAX - NDG_MIN;
-#endif
-#ifdef ATTR_PERIM
-  (void)perimrec(cpct, 0, na1);
-  for (i = 0; i < nbcomp; i++) cpct->perim[i] = na1[i]; 
-#endif
-#ifdef ATTR_HBORD
-  (void)hbordrec(cpct, 0, na2);
-  for (i = 0; i < nbcomp; i++) cpct->hbord[i] = na2[i];  
-#endif
-#ifdef ATTR_CONTRAST
-  for (i = 0; i < nbcomp; i++) cpct->contrast[i] = ((double)(na2[i]))/na1[i];  
-#endif
-  free(na1);
-  free(na2);
-} /* CalculeAttributs() */
-
-#ifdef ATTR_HEIGHT
-/* ==================================== */
-static int32_t FiltreHeightRec(CompactTree * cpct, int32_t som, int32_t h)
-/* ==================================== */
-/*
-  Filtre les sommets de l'arbre selon un critere de hauteur : 
-
-     height(som) >= h
-
-  Un sommet 'som' ne satisfaisant pas le critere est marque FILTERED_OUT.
-  La fonction traite recursivement les fils, et retourne le nombre NNM de sommets non marques dans
-    la descendance (inclus le sommet lui-meme).
-  Un sommet non filtre et dont le NNM de la descendance vaut 0 est marque LEAFMIN. 
-*/
-{
-  int32_t i, n, j, NNM = 0;
-  n = NBFILS(som);
-  if (cpct->height[som] < h) cpct->flags[som] |= FILTERED_OUT;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    NNM += FiltreHeightRec(cpct, j, h);
-  }
-  if (cpct->height[som] >= h)           /* sommet non filtre */
-  {
-    if (NNM == 0) cpct->flags[som] |= LEAFMIN;
-    NNM++;
-  }
-  return NNM;
-} /* FiltreHeightRec() */
-#endif
-
-#ifdef ATTR_SURF
-/* ==================================== */
-static int32_t FiltreSurfRec(CompactTree * cpct, int32_t som, int32_t h)
-/* ==================================== */
-/*
-  Filtre les sommets de l'arbre selon un critere de surface : 
-
-     surf(som) >= h
-
-  Un sommet 'som' ne satisfaisant pas le critere est marque FILTERED_OUT.
-  La fonction traite recursivement les fils, et retourne le nombre NNM de sommets non marques dans
-    la descendance (inclus le sommet lui-meme).
-  Un sommet non filtre et dont le NNM de la descendance vaut 0 est marque LEAFMIN. 
-*/
-{
-  int32_t i, n, j, NNM = 0;
-  n = NBFILS(som);
-  if (cpct->surf[som] < h) cpct->flags[som] |= FILTERED_OUT;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    NNM += FiltreSurfRec(cpct, j, h);
-  }
-  if (cpct->surf[som] >= h)           /* sommet non filtre */
-  {
-    if (NNM == 0) cpct->flags[som] |= LEAFMIN;
-    NNM++;
-  }
-  return NNM;
-} /* FiltreSurfRec() */
-#endif
-
-#ifdef ATTR_VOL
-/* ==================================== */
-static int32_t FiltreVolRec(CompactTree * cpct, int32_t som, int32_t h)
-/* ==================================== */
-/*
-  Filtre les sommets de l'arbre selon un critere de volume : 
-
-     vol(som) >= h
-
-  Un sommet 'som' ne satisfaisant pas le critere est marque FILTERED_OUT.
-  La fonction traite recursivement les fils, et retourne le nombre NNM de sommets non marques dans
-    la descendance (inclus le sommet lui-meme).
-  Un sommet non filtre et dont le NNM de la descendance vaut 0 est marque LEAFMIN. 
-*/
-{
-  int32_t i, n, j, NNM = 0;
-  n = NBFILS(som);
-  if (cpct->vol[som] < h) cpct->flags[som] |= FILTERED_OUT;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    NNM += FiltreVolRec(cpct, j, h);
-  }
-  if (cpct->vol[som] >= h)           /* sommet non filtre */
-  {
-    if (NNM == 0) cpct->flags[som] |= LEAFMIN;
-    NNM++;
-  }
-  return NNM;
-} /* FiltreVolRec() */
-#endif
-
-/* ==================================== */
-static int32_t MaximiseSegmentation(CompactTree * cpct, int32_t som)
-/* ==================================== */
-/*
-  
-*/
-{
-  int32_t i, n, j, f, nf, NF = 0;
-  if (cpct->flags[som] & FILTERED_OUT) return 0;
-  n = NBFILS(som);
-  if (n == 0) return 1;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    if (nf = MaximiseSegmentation(cpct, j)) { f = j; NF += nf; }
-  }
-  if (NF == 0) return 1;
-  if (NF == 1)
-  {
-    cpct->flags[f] |= FILTERED_OUT;
-    cpct->flags[som] |= LEAFMAX;
-    return 1;
-  }
-  return 1 + NF;
-} /*  MaximiseSegmentation() */
-
-#ifdef ATTR_CONTRAST
-/* ==================================== */
-static void Reconstruction(CompactTree * cpct, int32_t som)
-/* ==================================== */
-/*
-  Recherche a partir de la racine, les sommets marques LEAF.
-  A partir de chacun de ces sommets :
-    - remonte en suivant les etiquettes LEAFMAX jusqu'a trouver un sommet marque LEAFMIN,
-    - stocke dans 'branche' le chemin (liste de sommets), dans 'contrast' l'attribut contrast associe a chaque sommet,
-      et dans 'index' les index des sommets (initialises a 0,1,2,3,...)
-    - trie le tableau index sur la cle contraste,
-    - selectionne un sommet M maximum (si plusieurs, ...),
-    - a partir de M, on "redescend" en demarquant les sommets
-*/
-{
-  int32_t i, n, m, j, k, M;
-  double contrast[256];
-  int32_t branche[256];
-  int32_t index[256];
-
-  if (!(cpct->flags[som] & LEAF)) /* remonte l'arbre pour trouver une LEAF */ 
-  {
-    n = NBFILS(som);
-    for (i = 0; i < n; i++) 
-    {
-      j = INDEXFILS(som, i);
-      j = cpct->fils[j];
-      Reconstruction(cpct, j);
-    }
-  }
-  else /* on a trouve une LEAF */
-  {
-    m = 0;  /* m indexe le tableau contrast */
-    k = som;
-    while (!(cpct->flags[k] & LEAFMIN))
-    {
-      contrast[m] = cpct->contrast[k];
-      branche[m] = k;
-      m++;
-      n = NBFILS(k); /* on va chercher le fils qui est marque LEAF */
-      for (i = 0; i < n; i++) 
-      {
-        j = INDEXFILS(k, i);
-        j = cpct->fils[j];
-        if (cpct->flags[j] & LEAF) break;
-      }
-      k = j;
-#ifdef PARANO
-      if (i >= n) fprintf(stderr, "Reconstruction : ERREUR INATTENDUE\n");
-#endif
-    }
-    contrast[m] = cpct->contrast[k];
-    branche[m] = k;
-    m++;    
-
-#ifdef DEBUGRECONS
-    printf("Reconstruction Sommet %d\n", som);
-    for (i = 0; i < m; i++) printf("%d %d %g\n", i, branche[i], contrast[i]);
-#endif
-
-    /* trie le tableau index sur la cle contraste */
-    for (i = 0; i < m; i++) index[i] = i;
-    d_TriRapideStochastique (index, contrast, 0, m-1);
-
-#ifdef DEBUGRECONS
-    printf("Apres tri : \n");
-    for (i = 0; i < m; i++) printf("%d %d %g\n", index[i], branche[index[i]], contrast[index[i]]);
-#endif
-
-    /* selectionne un sommet M maximum (SI PLUSIEURS, ... CHOIX ARBITRAIRE), */
-    M = branche[index[m-1]];
-
-    /* a partir de M, on "redescend" en demarquant les sommets */
-    cpct->flags[M] &= ~FILTERED_OUT;
-    cpct->flags[M] |= LEAFMAX;
-    k = cpct->pere[M];
-    while (cpct->flags[k] & LEAFMAX)
-    {
-      cpct->flags[k] &= ~LEAFMAX;
-      cpct->flags[k] &= ~FILTERED_OUT;
-      k = cpct->pere[k];
-    }
-  } /* else (on a trouve une LEAF) */
-} /*  Reconstruction() */
-#endif
-
-/* ==================================== */
-static int32_t NbLeafs(CompactTree * cpct, int32_t som)
-/* ==================================== */
-/*
-  Recherche a partir du sommet som, les sommets marques LEAF.
-  Retourne le nombre de ces sommets.
-*/
-{
-  int32_t i, j, k, n;
-
-  if (!(cpct->flags[som] & LEAF)) /* remonte l'arbre pour trouver une LEAF */ 
-  {
-    n = NBFILS(som);
-    k = 0; 
-    for (i = 0; i < n; i++) 
-    {
-      j = INDEXFILS(som, i);
-      j = cpct->fils[j];
-      k += NbLeafs(cpct, j);
-    }
-    return k;
-  }
-  else /* (on a trouve une LEAF) */
-    return 1;
-} /* NbLeafs() */
-
-/* ==================================== */
-static void RecupereImageFiltree(CompactTree * cpct,           
-       uint32_t *STATUS,
-       int32_t rs, int32_t N, 
-       uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t i, h;
-  uint32_t c, comp;
-  for (i = 0; i < N; i++) 
-  {
-    h = ORI[i];
-    c = STATUS[i];
-    comp = INDEXCOMP(h,c);
-    while (cpct->flags[comp] == FILTERED_OUT) comp = cpct->pere[comp];
-    ORI[i] = DECODENIV(cpct->comp[comp]);
-  }  
-} /* RecupereImageFiltree() */
-
-/* ==================================== */
-static void RecupereSegmentation(CompactTree * cpct,           
-       uint32_t *STATUS,
-       int32_t rs, int32_t N, 
-       uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t i, h;
-  uint32_t c, comp;
-  for (i = 0; i < N; i++) 
-  {
-    h = ORI[i];
-    c = STATUS[i];
-    comp = INDEXCOMP(h,c);
-    while (cpct->flags[comp] & FILTERED_OUT) 
-    {
-#ifdef PARANO
-      if (comp == cpct->pere[comp])       
-        fprintf(stderr, "RecupereSegmentation: la racine a ete eliminee\n");
-#endif
-      comp = cpct->pere[comp];
-    }
-    if (cpct->flags[comp] & LEAF) ORI[i] = NDG_MAX; else ORI[i] = NDG_MIN;
-  }  
-} /* RecupereSegmentation() */
-
-/* ==================================== */
-static void TermineCompactTree(CompactTree *cpct)
-/* ==================================== */
-{
-  free(cpct->comp);
-  free(cpct->pere);
-  free(cpct->dfils);
-  free(cpct->fils);
-  free(cpct->hc);
-#ifdef ATTR_SURF
-  free(cpct->surf);
-#endif
-#ifdef ATTR_HEIGHT
-  free(cpct->height);
-#endif
-#ifdef ATTR_PERIM
-  free(cpct->perim);
-#endif
-#ifdef ATTR_HBORD
-  free(cpct->hbord);
-#endif
-#ifdef ATTR_CONTRAST
-  free(cpct->contrast);
-#endif
-#ifdef ATTR_VOL
-  free(cpct->vol);
-#endif
-#ifdef ATTR_DYN
-  free(cpct->dyn);
-#endif
-
-  free(cpct->flags);
-  free(cpct);
-} /* TermineCompactTree() */
-
-/* ==================================== */
-static void AfficheCompTree(CompTree *ct)
-/* ==================================== */
-{
-  int32_t i;
-  printf("===========================\n");
-  printf("nombre max arcs = %d\n", ct->nbmaxarcs);
-  printf("nombre arcs = %d\n", ct->nbarcs);
-  printf("racine = C%d,%d\n", DECODENIV(ct->racine), DECODENUM(ct->racine));
-  printf("===========================\n");
-  for (i = 0; i < ct->nbarcs; i++)
-    printf("C%d,%d --> C%d,%d\n", 
-           DECODENIV(ct->tete[i]), DECODENUM(ct->tete[i]), 
-           DECODENIV(ct->queue[i]), DECODENUM(ct->queue[i]));
-  printf("===========================\n");
-} /* AfficheCompTree() */
-
-/* ==================================== */
-static void AfficheCompactTree(CompactTree *cpct)
-/* ==================================== */
-{
-  uint32_t i, j, n, f;
-  printf("===========================\n");
-  printf("nombre composantes = %d\n", cpct->nbcomp);
-  printf("===========================\n");
-  for (i = 0; i < cpct->nbcomp; i++)
-  {
-    printf("comp[%d] = C%d,%d ", i, DECODENIV(cpct->comp[i]), DECODENUM(cpct->comp[i]));
-#ifdef ATTR_SURF
-    printf("surf = %d  ", cpct->surf[i]);
-#endif
-#ifdef ATTR_HEIGHT
-    printf("height = %d  ", cpct->height[i]);
-#endif
-#ifdef ATTR_VOL
-    printf("vol = %d  ", cpct->vol[i]);
-#endif
-#ifdef ATTR_PERIM
-    printf("perim = %d  ", cpct->perim[i]);
-#endif
-#ifdef ATTR_HBORD
-    printf("hbord = %d  ", cpct->hbord[i]);
-#endif
-#ifdef ATTR_CONTRAST
-    printf("contrast = %g ",cpct->contrast[i]);
-#endif
-#ifdef ATTR_DYN
-    printf("dynamique = %d ",cpct->dyn[i]);
-#endif
-    printf("fils = [ ");
-    n = NBFILS(i);
-    for (j = 0; j < n; j++)
-    {
-      f = INDEXFILS(i,j);
-      f = cpct->fils[f];
-      printf("C%d,%d ", DECODENIV(cpct->comp[f]), DECODENUM(cpct->comp[f]), f);
-    }
-    printf("] ");
-    if (cpct->flags[i] & FILTERED_OUT) printf(" - OUT");
-    if (cpct->flags[i] & LEAFMIN) printf(" - LEAFMIN");
-    if (cpct->flags[i] & LEAFMAX) printf(" - LEAFMAX");
-    printf("\n");
-  }
-  printf("===========================\n");
-  for (i = 0; i < cpct->nbcomp; i++)
-    printf("pere[%d] = %d\n", i, cpct->pere[i]);
-  printf("===========================\n");
-} /* AfficheCompactTree() */
-
-/* ==================================== */
-static void AfficheImaComp(CompactTree * cpct,           
-       uint32_t *STATUS,
-       int32_t rs, int32_t N, 
-       uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t i, h;
-  uint32_t c, comp;
-  for (i = 0; i < N; i++) 
-  {
-    h = ORI[i];
-    c = STATUS[i];
-    printf("C%d,%d\t", h, c);
-    if ((i % rs) == (rs - 1)) printf("\n");
-  }  
-} /* AfficheImaComp() */
-
-/* ==================================== */
-static void WriteCompactTree(CompactTree *cpct, char * filename)
-/* ==================================== */
-{
-  uint32_t i, j, n, f;
-  FILE * fd = NULL;
-  char buf[256];
-
-  fd = fopen(filename,"w");
-  if (!fd)
-  {
-    fprintf(stderr, "WriteCompactTree: cannot open file: %s\n", filename);
-    exit(0);
-  }
-
-  fprintf(fd, "%d %d\n", cpct->nbcomp, cpct->nbcomp-1);
-  fprintf(fd, "noms sommets\n");
-  for (i = 0; i < cpct->nbcomp; i++)
-  {
-    sprintf(buf, "C%d,%d", DECODENIV(cpct->comp[i]), DECODENUM(cpct->comp[i]));
-    fprintf(fd, "%d %s\n", i, buf);
-  }
-  fprintf(fd, "arcs\n");
-  for (i = 1; i < cpct->nbcomp; i++)
-    fprintf(fd, "%d %d\n", cpct->pere[i], i);
-  fclose(fd);
-} /* WriteCompactTree() */
-
-/* ==================================== */
-static int32_t LeafCount(CompactTree *cpct)
-/* ==================================== */
-{
-  uint32_t i, f = 0;
-  for (i = 0; i < cpct->nbcomp; i++)
-    if ((NBFILS(i)) == 0) f++;
-  return f;
-} /* LeafCount() */
-
-/* ==================================== */
-static int32_t LeafMark(CompactTree *cpct)
-/* ==================================== */
-{
-  uint32_t i, f = 0;
-  for (i = 0; i < cpct->nbcomp; i++)
-    if ((NBFILS(i)) == 0) { f++; cpct->flags[i] |= LEAF; }
-  return f;
-} /* LeafMark() */
-
-/* ==================================== */
-static int32_t NbFilsNonFiltres(CompactTree * cpct, int32_t som)
-/* ==================================== */
-/*
-  retourne le nombre de fils de 'som' non marques FILTERED_OUT.
-*/
-{
-  int32_t i, n, j, NNM = 0;
-  n = NBFILS(som);
-  if (n == 0) 
-    return 0;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    if (!(cpct->flags[j] & FILTERED_OUT)) NNM++;
-    else if (NbFilsNonFiltres(cpct, j)>=1) NNM++;
-  }
-  return NNM;
-} /* NbFilsNonFiltres() */
-
-/* ==================================== */
-static void AjouteArc(CompTree *ct, uint32_t i, uint32_t j 
-#ifdef ATTR_SURF
-               , int32_t surf
-#endif
-#ifdef ATTR_PERIM
-               , int32_t perim
-#endif
-#ifdef ATTR_HBORD
-               , int32_t hbord
-#endif
-              )
-/* ==================================== */
-{
-  if (ct->nbarcs >= ct->nbmaxarcs)
-  {
-    fprintf(stderr, "AjouteArc : structure CompTree saturee (%d arcs)\n", ct->nbarcs);
-    exit(0);
-  }
-  ct->tete[ct->nbarcs] = i;
-  ct->queue[ct->nbarcs] = j;
-#ifdef ATTR_SURF
-  ct->surf[ct->nbarcs] = surf;
-#endif
-#ifdef ATTR_PERIM
-  ct->perim[ct->nbarcs] = perim;
-#endif
-#ifdef ATTR_HBORD
-  ct->hbord[ct->nbarcs] = hbord;
-#endif
-  ct->nbarcs += 1;
-} /* AjouteArc() */
-
-/* ==================================== */
-static int32_t contrib_perim(int32_t p, uint8_t *ORI, uint32_t *STATUS, int32_t rs, int32_t N, int32_t incr_vois)
-/* ==================================== */
-{ /* calcule la contribution du point p au perimetre de la composante */
-  int32_t q, k, nv = 0;
-
-  for (k = 0; k < 8; k += incr_vois) /* compte le nombre nv de voisins deja traites */
-  {
-    q = voisin(p, k, rs, N);
-    if ((q != -1) && (ORI[q] >= ORI[p]) && (STATUS[q] < NOT_ANALYZED)) nv++;
-  } /* for (k = 0; k < 8; k += incr_vois) */
-
-  return 4 - 2 * nv;
-}
-
-
-/* ==================================== */
-static int32_t contrib_perimb(int32_t p, uint8_t *ORI, uint32_t *STATUS, int32_t rs, int32_t N, int32_t connex)
-/* ==================================== */
-{ /* calcule la contribution du point p au perimetre de la composante */
-  int32_t q, k, nv = 0;
-
-  for (k = 0; k < 6; k ++) /* compte le nombre nv de voisins deja traites */
-  {
-    q = voisin6b(p, k, rs, N, connex);
-    if ((q != -1) && (ORI[q] >= ORI[p]) && (STATUS[q] < NOT_ANALYZED)) nv++;
-  } /* for (k = 0; k < 8; k += incr_vois) */
-
-  return 4 - 2 * nv;
-}
-
-
-/* ==================================== */
-static int32_t contrib_hbord(int32_t p, uint8_t *ORI, uint32_t *STATUS, int32_t rs, int32_t N, int32_t incr_vois)
-/* ==================================== */
-{ /* calcule la contribution du point p au hbord de la composante */
-  int32_t q, k, h = 0;
-
-  for (k = 0; k < 8; k += incr_vois)
-  {
-    q = voisin(p, k, rs, N);
-    if (q != -1) h += (ORI[p] - ORI[q]);
-  } /* for (k = 0; k < 8; k += incr_vois) */
-
-  return h;
-}
-
-
-/* ==================================== */
-static int32_t contrib_hbordb(int32_t p, uint8_t *ORI, uint32_t *STATUS, int32_t rs, int32_t N, int32_t connex)
-/* ==================================== */
-{ /* calcule la contribution du point p au hbord de la composante */
-  int32_t q, k, h = 0;
-
-  for (k = 0; k < 6; k ++)
-  {
-    q = voisin6b(p, k, rs, N, connex);
-    if (q != -1) h += (ORI[p] - ORI[q]);
-  } /* for (k = 0; k < 8; k += incr_vois) */
-
-  return h;
-}
-
-
-
-/* ==================================== */
-static int32_t flood(int32_t h,                 /* niveau a inonder */
-          Fah *FAH, 
-          uint32_t *STATUS,         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-	                                /* en sortie, contient le numero de la comp. de niveau h */
-                                        /* qui contient le pixel */
-          uint32_t *number_nodes,   /* nombre de composantes par niveau */
-          uint8_t *node_at_level, /* tableau de booleens */
-          CompTree * tree,              /* l'arbre en construction */
-          int32_t incr_vois,                /* = 1 pour la 8-connexite, 
-                                           = 2 pour la 4-connexite */ 
-          int32_t rs, int32_t N, 
-          uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t p, q, k, m, i, j;
-#ifdef ATTR_SURF
-  int32_t surf = 0;
-#endif
-#ifdef ATTR_PERIM
-  int32_t perim = 0;
-#endif
-#ifdef ATTR_HBORD
-  int32_t hbord = 0;
-#endif
-
-#ifdef DEBUGFLOOD
-  printf("debut flood niveau %d\n", h);
-#endif
-
-  node_at_level[h] = 1; /* CORRECTION BUG: LIGNE AJOUTEE LE 02/08/00 */
-  while (!FahVideNiveau(FAH, h))               /* first step : propagation */
-  {                                            /* ======================== */
-    p = FahPopNiveau(FAH, h);
-    STATUS[p] = number_nodes[h];
-#ifdef DEBUGFLOOD
-    printf("STATUS[p] %d\n", STATUS[p]);
-#endif
-    for (k = 0; k < 8; k += incr_vois)
-    {
-      q = voisin(p, k, rs, N);
-      if ((q != -1) && (STATUS[q] == NOT_ANALYZED))
-      {
-        FahPush(FAH, q, ORI[q]);
-        STATUS[q] = IN_THE_QUEUE;
-        node_at_level[ORI[q]] = 1;
-        if (ORI[q] > ORI[p])
-	{
-          m = ORI[q];
-          do 
-          {
-#ifdef PARANO
-            if ((m < 0) || (m > 255))
-            {
-              fprintf(stderr, "flood: mauvais niveau : %d ; ORI[q] = %d\n", m, ORI[q]);
-              exit(0);
-            }
-#endif
-            m = flood(m, FAH, STATUS, number_nodes, node_at_level, tree, incr_vois, rs, N, ORI); 
-          } while ((m != h) && (m >= 0));
-	} /* if (ORI[q] > ORI[p]) */
-      } /* if ((q != -1) && (STATUS[q] == NOT_ANALYZED)) */
-    } /* for (k = 0; k < 8; k += incr_vois) */
-#ifdef ATTR_SURF
-    surf += 1;
-#endif
-#ifdef ATTR_PERIM
-    perim += contrib_perim(p, ORI, STATUS, rs, N, incr_vois);
-#endif
-#ifdef ATTR_HBORD
-    hbord += contrib_hbord(p, ORI, STATUS, rs, N, incr_vois);
-#endif
-  } /* while (!FahVideNiveau(FAH, h)) */
-#ifdef DEBUGFLOOD
-  printf("retour flood niveau %d\n", h);
-#endif
-  number_nodes[h] += 1;
-
-  m = h - 1;                                    /* second step : define the father */
-  while ((m >= 0) && (!node_at_level[m])) m--;  /* =============================== */
-  i = number_nodes[h] - 1;
-  if (m >= 0)
-  {
-    j = number_nodes[m];
-#ifdef DEBUGFLOOD
-    printf("AjouteArc (%d %d) (%d %d)\n", m, j, h, i);
-#endif
-    AjouteArc(tree, ENCODE(j,m), ENCODE(i,h)    /* definit Cm,j comme le pere de Ch,i */
-#ifdef ATTR_SURF
-              , surf
-#endif
-#ifdef ATTR_PERIM
-              , perim
-#endif
-#ifdef ATTR_HBORD
-              , hbord
-#endif
-             ); 
-  } /* if (m >= 0) */
-  else
-  {
-#ifdef DEBUGFLOOD
-    printf("DefinitRacine (%d %d)\n", h, i);
-#endif
-    tree->racine = ENCODE(i,h);                /* Ch,i est racine */
-#ifdef ATTR_SURF
-    tree->surf_racine = surf;
-#endif
-
-  }
-  node_at_level[h] = 0;
-#ifdef DEBUGFLOOD
-  printf("fin flood niveau %d, retourne %d\n", h, m);
-#endif
-  return m;
-} /* flood() */
-
-
-/* ==================================== */
-static int32_t floodb(int32_t h,                 /* niveau a inonder */
-          Fah *FAH, 
-          uint32_t *STATUS,         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-	                                /* en sortie, contient le numero de la comp. de niveau h */
-                                        /* qui contient le pixel */
-          uint32_t *number_nodes,   /* nombre de composantes par niveau */
-          uint8_t *node_at_level, /* tableau de booleens */
-          CompTree * tree,              /* l'arbre en construction */
-          int32_t connex,                   /* = 0 pour première case vide, 
-                                           = 1 pour la translation */ 
-          int32_t rs, int32_t N, 
-          uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t p, q, k, m, i, j;
-  const int32_t incr_voisin = 1;
-#ifdef ATTR_SURF
-  int32_t surf = 0;
-#endif
-#ifdef ATTR_PERIM
-  int32_t perim = 0;
-#endif
-#ifdef ATTR_HBORD
-  int32_t hbord = 0;
-#endif
-
-#ifdef DEBUGFLOOD
-  printf("debut flood niveau %d\n", h);
-#endif
-
-  node_at_level[h] = 1; /* CORRECTION BUG: LIGNE AJOUTEE LE 02/08/00 */
-  while (!FahVideNiveau(FAH, h))               /* first step : propagation */
-  {                                            /* ======================== */
-    p = FahPopNiveau(FAH, h);
-    STATUS[p] = number_nodes[h];
-#ifdef DEBUGFLOOD
-    printf("STATUS[p] %d\n", STATUS[p]);
-#endif
-    for (k = 0; k < 6; k ++)
-    {
-      q = voisin6b(p, k, rs, N, connex);
-      if ((q != -1) && (STATUS[q] == NOT_ANALYZED))
-      {
-        FahPush(FAH, q, ORI[q]);
-        STATUS[q] = IN_THE_QUEUE;
-        node_at_level[ORI[q]] = 1;
-        if (ORI[q] > ORI[p])
-	{
-          m = ORI[q];
-          do 
-          {
-#ifdef PARANO
-            if ((m < 0) || (m > 255))
-            {
-              fprintf(stderr, "flood: mauvais niveau : %d ; ORI[q] = %d\n", m, ORI[q]);
-              exit(0);
-            }
-#endif
-            m = floodb(m, FAH, STATUS, number_nodes, node_at_level, tree, connex, rs, N, ORI); 
-          } while ((m != h) && (m >= 0));
-	} /* if (ORI[q] > ORI[p]) */
-      } /* if ((q != -1) && (STATUS[q] == NOT_ANALYZED)) */
-    } /* for (k = 0; k < 6; k++) */
-#ifdef ATTR_SURF
-    surf += 1;
-#endif
-#ifdef ATTR_PERIM
-    perim += contrib_perimb(p, ORI, STATUS, rs, N, connex);
-#endif
-#ifdef ATTR_HBORD
-    hbord += contrib_hbordb(p, ORI, STATUS, rs, N, connex);
-#endif
-  } /* while (!FahVideNiveau(FAH, h)) */
-#ifdef DEBUGFLOOD
-  printf("retour flood niveau %d\n", h);
-#endif
-  number_nodes[h] += 1;
-
-  m = h - 1;                                    /* second step : define the father */
-  while ((m >= 0) && (!node_at_level[m])) m--;  /* =============================== */
-  i = number_nodes[h] - 1;
-  if (m >= 0)
-  {
-    j = number_nodes[m];
-#ifdef DEBUGFLOOD
-    printf("AjouteArc (%d %d) (%d %d)\n", m, j, h, i);
-#endif
-    AjouteArc(tree, ENCODE(j,m), ENCODE(i,h)    /* definit Cm,j comme le pere de Ch,i */
-#ifdef ATTR_SURF
-              , surf
-#endif
-#ifdef ATTR_PERIM
-              , perim
-#endif
-#ifdef ATTR_HBORD
-              , hbord
-#endif
-             ); 
-  } /* if (m >= 0) */
-  else
-  {
-#ifdef DEBUGFLOOD
-    printf("DefinitRacine (%d %d)\n", h, i);
-#endif
-    tree->racine = ENCODE(i,h);                /* Ch,i est racine */
-#ifdef ATTR_SURF
-    tree->surf_racine = surf;
-#endif
-
-  }
-  node_at_level[h] = 0;
-#ifdef DEBUGFLOOD
-  printf("fin flood niveau %d, retourne %d\n", h, m);
-#endif
-  return m;
-} /* floodb() */
-
-
-
-/* ==================================== */
-static int32_t flood3d(
-          int32_t h,                        /* niveau a inonder */
-          Fah *FAH, 
-          uint32_t *STATUS,         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-	                                /* en sortie, contient le numero de la comp. de niveau h */
-                                        /* qui contient le pixel */
-          uint32_t *number_nodes,   /* nombre de composantes par niveau */
-          uint8_t *node_at_level, /* tableau de booleens */
-          CompTree * tree,              /* l'arbre en construction */
-          int32_t connex,
-          int32_t rs, int32_t ps, int32_t N, 
-          uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t p, q, k, m, i, j;
-#ifdef ATTR_SURF
-  int32_t surf = 0;
-#endif
-#ifdef ATTR_PERIM
-  int32_t perim = 0;
-#endif
-#ifdef ATTR_HBORD
-  int32_t hbord = 0;
-#endif
-
-#ifdef DEBUGFLOOD
-  printf("debut flood3d niveau %d\n", h);
-#endif
-
-  node_at_level[h] = 1; /* CORRECTION BUG: LIGNE AJOUTEE LE 02/08/00 */
-  while (!FahVideNiveau(FAH, h))               /* first step : propagation */
-  {                                            /* ======================== */
-    p = FahPopNiveau(FAH, h);
-    STATUS[p] = number_nodes[h];
-#ifdef DEBUGFLOOD
-    printf("STATUS[p] %d\n", STATUS[p]);
-#endif
-
-    switch (connex)
-    {
-      case 6:
-        for (k = 0; k <= 10; k += 2)   /* parcourt les 6 voisins */
-        {
-          q = voisin6(p, k, rs, ps, N);
-          if ((q != -1) && (STATUS[q] == NOT_ANALYZED))
-          {
-            FahPush(FAH, q, ORI[q]);
-            STATUS[q] = IN_THE_QUEUE;
-            node_at_level[ORI[q]] = 1;
-            if (ORI[q] > ORI[p])
-	    {
-              m = ORI[q];
-              do 
-              {
-#ifdef PARANO
-                if ((m < 0) || (m > 255))
-                {
-                  fprintf(stderr, "flood3d: mauvais niveau : %d ; ORI[q] = %d\n", m, ORI[q]);
-                  exit(0);
-                }
-#endif
-                m = flood3d(m, FAH, STATUS, number_nodes, node_at_level, tree, connex, rs, ps, N, ORI); 
-              } while ((m != h) && (m >= 0));
-	    } /* if (ORI[q] > ORI[p]) */
-          } /* if ((q != -1) && (STATUS[q] == NOT_ANALYZED)) */
-        } /* for (...) */
-        break;
-      case 18:
-        for (k = 0; k < 18; k++)   /* parcourt les 18 voisins */
-        {
-          q = voisin18(p, k, rs, ps, N);
-          if ((q != -1) && (STATUS[q] == NOT_ANALYZED))
-          {
-            FahPush(FAH, q, ORI[q]);
-            STATUS[q] = IN_THE_QUEUE;
-            node_at_level[ORI[q]] = 1;
-            if (ORI[q] > ORI[p])
-	    {
-              m = ORI[q];
-              do 
-              {
-#ifdef PARANO
-                if ((m < 0) || (m > 255))
-                {
-                  fprintf(stderr, "flood3d: mauvais niveau : %d ; ORI[q] = %d\n", m, ORI[q]);
-                  exit(0);
-                }
-#endif
-                m = flood3d(m, FAH, STATUS, number_nodes, node_at_level, tree, connex, rs, ps, N, ORI); 
-              } while ((m != h) && (m >= 0));
-	    } /* if (ORI[q] > ORI[p]) */
-          } /* if ((q != -1) && (STATUS[q] == NOT_ANALYZED)) */
-        } /* for (...) */
-        break;
-      case 26:
-        for (k = 0; k < 26; k++)   /* parcourt les 26 voisins */
-        {
-          q = voisin26(p, k, rs, ps, N);
-          if ((q != -1) && (STATUS[q] == NOT_ANALYZED))
-          {
-            FahPush(FAH, q, ORI[q]);
-            STATUS[q] = IN_THE_QUEUE;
-            node_at_level[ORI[q]] = 1;
-            if (ORI[q] > ORI[p])
-	    {
-              m = ORI[q];
-              do 
-              {
-#ifdef PARANO
-                if ((m < 0) || (m > 255))
-                {
-                  fprintf(stderr, "flood3d: mauvais niveau : %d ; ORI[q] = %d\n", m, ORI[q]);
-                  exit(0);
-                }
-#endif
-                m = flood3d(m, FAH, STATUS, number_nodes, node_at_level, tree, connex, rs, ps, N, ORI); 
-              } while ((m != h) && (m >= 0));
-	    } /* if (ORI[q] > ORI[p]) */
-          } /* if ((q != -1) && (STATUS[q] == NOT_ANALYZED)) */
-        } /* for (...) */
-        break;
-      default:
-        fprintf(stderr, "flood3d: mauvaise connexite: %d\n", connex);
-        exit(0);
-    } /* switch (connex) */
-
-#ifdef ATTR_SURF
-    surf += 1;
-#endif
-  } /* while (!FahVideNiveau(FAH, h)) */
-#ifdef DEBUGFLOOD
-  printf("retour flood3d niveau %d\n", h);
-#endif
-  number_nodes[h] += 1;
-
-  m = h - 1;                                    /* second step : define the father */
-  while ((m >= 0) && (!node_at_level[m])) m--;  /* =============================== */
-  i = number_nodes[h] - 1;
-  if (m >= 0)
-  {
-    j = number_nodes[m];
-#ifdef DEBUGFLOOD
-    printf("AjouteArc (%d %d) (%d %d)\n", m, j, h, i);
-#endif
-    AjouteArc(tree, ENCODE(j,m), ENCODE(i,h)    /* definit Cm,j comme le pere de Ch,i */
-#ifdef ATTR_SURF
-              , surf
-#endif
-#ifdef ATTR_PERIM
-              , perim
-#endif
-#ifdef ATTR_HBORD
-              , hbord
-#endif
-             ); 
-  } /* if (m >= 0) */
-  else
-  {
-#ifdef DEBUGFLOOD
-    printf("DefinitRacine (%d %d)\n", h, i);
-#endif
-    tree->racine = ENCODE(i,h);                /* Ch,i est racine */
-#ifdef ATTR_SURF
-    tree->surf_racine = surf;
-#endif
-  }
-  node_at_level[h] = 0;
-#ifdef DEBUGFLOOD
-  printf("fin flood3d niveau %d, retourne %d\n", h, m);
-#endif
-  return m;
-} /* flood3d() */
-
-/* ==================================== */
-static int32_t LowestCommonAncestor(
-  CompactTree * cpct,
-  int32_t argc,
-  int32_t *argv,
-  uint8_t d)
-/* Retourne le plus proche commun ancetre des cellules de la liste (argc, argv)
-   dont le niveau est > d, ou -1 s'il n'existe pas. 
-   Utilise le champ "flags". 
-   
-*/
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "LowestCommonAncestor"
-{
-  int32_t x, i, lca, NoComAnc;
-  if (argc <= 0) return -1;
-  if (argc == 1) return argv[0];
-
-  x = argv[0];      /* index de la premiere cellule */
-  do
-  {
-    cpct->flags[x] |= LCA1;     /* marque LCA1 tous les ancetres de x plus hauts que d */
-    x = cpct->pere[x];
-  } while ((x != CPCT_ROOT) && (DECODENIV(cpct->comp[x]) > d));
-  
-  for (i = 1; i < argc; i++)   /* boucle pour les autres cellules */
-  {
-    x = argv[i];
-    NoComAnc = 1;              /* pas d'ancetre commun trouve */
-    do
-    {                          /* remonte les ancetres de x sans depasser d */
-      if (cpct->flags[x] & LCA1)  /* on a un ancetre commun */
-      {
-        NoComAnc = 0; 
-      	cpct->flags[x] |= LCA2;   /* on le marque LCA2 */
-      	break;                 /* on arrete la remontee (sort du do while) */
-      }
-      else
-        x = cpct->pere[x];     /* on continue la remontee */
-    } while ((x != CPCT_ROOT) && (DECODENIV(cpct->comp[x]) > d));
-    if (NoComAnc) break;       /* pas d'AC: on sort aussi du for */
-  } /* for (i = 1; i < argc; i++) */
-
-  x = argv[0];        /* index de la premiere cellule */
-  do
-  {                   /* derniere remontee: demarque et repere le lca */
-    if (cpct->flags[x] & LCA2) lca = x;
-    cpct->flags[x] &= ~LCA;
-    x = cpct->pere[x];
-  }  while ((x != CPCT_ROOT) && (DECODENIV(cpct->comp[x]) > d));
-  
-  for (i = 1; i < argc; i++)   /* boucle pour les autres cellules */
-  {
-    x = argv[i];
-    do
-    { cpct->flags[x] &= ~LCA;
-      x = cpct->pere[x];     /* on continue la remontee */
-    } while ((x != CPCT_ROOT) && (DECODENIV(cpct->comp[x]) > d));
-  } /* for (i = 1; i < argc; i++) */
-
-#ifdef DEBUGLCA
-printf("%s(", F_NAME);
-for (i = 0; i < argc; i++) printf(" %d ", argv[i]);
-printf(") -> ");
-if (NoComAnc) printf("NIL\n"); else printf("%d\n", lca);
-#endif
-
-  if (NoComAnc)                /* pas d'ancetre commun */
-    return -1;
-  else
-    return lca;
-} /* LowestCommonAncestor() */
-
-/* ==================================== */
-static int32_t LowComAnc(
-  CompactTree * cpct,
-  int32_t c1,
-  int32_t c2)
-/* Retourne le plus proche commun ancetre des cellules c1,c2
-   Utilise le champ "flags". 
-*/
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "LowComAnc"
-{
-  int32_t x, i, lca = -1;
-
-  x = c1; do
-  {
-    cpct->flags[x] |= LCA1;     /* marque LCA1 tous les ancetres de x */
-    x = cpct->pere[x];
-  } while (x != CPCT_ROOT);
-  cpct->flags[x] |= LCA1;       /* marque aussi la racine */
-
-  x = c2; do
-  {                          /* remonte les ancetres de x */
-    if (cpct->flags[x] & LCA1) { lca = x; break; }
-    x = cpct->pere[x];
-  } while (x != CPCT_ROOT);
-  if ((lca == -1) && (cpct->flags[x] & LCA1)) lca = x;
-
-  x = c1; do
-  {                   /* derniere remontee: demarque */
-    cpct->flags[x] &= ~LCA1;
-    x = cpct->pere[x];
-  }  while (x != CPCT_ROOT);
-  cpct->flags[x] &= ~LCA1;       /* demarque aussi la racine */
-#ifdef PARANO
-  if (lca == -1)
-  {
-    fprintf(stderr, "%s: lca not found\n", F_NAME);
-    exit(0);
-  }
-#endif
-  return lca;
-} /* LowComAnc() */
-
-/* ==================================== */
-static int32_t Ancestor(CompactTree * cpct, int32_t c1, int32_t c2)
-/* Teste si la composante c1 est ancetre de la composante c2
-*/
-/* ==================================== */
-{
-  do
-  {
-    if (c1 == c2) return 1;
-    c2 = cpct->pere[c2];
-  } while (c2 != CPCT_ROOT);
-  return 0;
-} /* Ancestor() */
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
diff -r 8b1af7363833 src/lib/lbdigitalline.cxx
--- a/src/lib/lbdigitalline.cxx	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lbdigitalline.cxx	Mon Jan 13 15:50:10 2014 +0100
@@ -13,8 +13,6 @@
 }
 */
 
-#include <algorithm>
-
 #include <lbdigitalline.h>
 
 Reco::Reco()  { Init(); }
@@ -213,10 +211,10 @@
   Z ming = a*U[1].x+b*U[1].y;
   Z maxg = ming;
 
-  for (int i = 1; i <= nU; i++) { ming = std::min(ming,a*U[i].x+b*U[i].y);
-                                  maxg = std::max(maxg,a*U[i].x+b*U[i].y); }
-  for (int i = 1; i <= nL; i++) { ming = std::min(ming,a*L[i].x+b*L[i].y);
-                                  maxg = std::max(maxg,a*L[i].x+b*L[i].y); }
+  for (int i = 1; i <= nU; i++) { ming = min(ming,a*U[i].x+b*U[i].y);
+                                  maxg = max(maxg,a*U[i].x+b*U[i].y); }
+  for (int i = 1; i <= nL; i++) { ming = min(ming,a*L[i].x+b*L[i].y);
+                                  maxg = max(maxg,a*L[i].x+b*L[i].y); }
   n=0;
 
   while ( maxg-ming < b-1 )
diff -r 8b1af7363833 src/lib/lblob.c
--- a/src/lib/lblob.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,213 +0,0 @@
-/* $Id: lblob.c,v 1.1.1.1 2008-11-25 08:01:40 mcouprie Exp $ */
-/* 
-   Simulation d'objets topologiques vivants: les blobs
-
-   Michel Couprie - mai 2000
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mcutil.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcxbib.h>
-#include <mclifo.h>
-#include <mctopo.h>
-#include <mcprobas.h>
-#include <lblob.h>
-
-#define DSURF 30
-#define DPERIM 10
-
-/* ==================================== */
-static int32_t contrib_perim(int32_t p, uint8_t *ORI, int32_t rs, int32_t N, int32_t incr_vois)
-/* ==================================== */
-{ /* calcule la contribution du point p au perimetre de la composante */
-  int32_t q, k, nv = 0;
-
-  for (k = 0; k < 8; k += incr_vois) /* compte le nombre nv de voisins */
-  {
-    q = voisin(p, k, rs, N);
-    if ((q != -1) && ORI[q]) nv++;
-  } /* for (k = 0; k < 8; k += incr_vois) */
-
-  return 4 - 2 * nv;
-}
-
-/* ==================================== */
-int32_t lblob(struct xvimage *image, int32_t nitermax)
-/* ==================================== */
-{
-  register int32_t x, y;              /* index muet de pixel */
-  register int32_t i, k;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille plan */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *EMPILE;
-#define NBBUTTONS2D  7
-#define NBLIGBUTT2D  2
-#define BOXWIDTH    70
-#define BOXHEIGHT   20
-  char * ButtonStrings[NBLIGBUTT2D][NBBUTTONS2D];
-  int32_t xx, yy;
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT2D;
-  int32_t Width = rs;
-  int32_t ImageHeight = cs;
-  int32_t ImageWidth = rs;
-  int32_t eventtype;
-  Lifo * LIFO;
-  int32_t r;
-  int32_t niter;
-  int32_t surface;
-  int32_t perimetre;
-  int32_t osurf; 
-  int32_t operim;
-  int32_t dsurf = DSURF;
-  int32_t dperim = DPERIM;
-  int32_t cp;
-
-  LIFO = CreeLifoVide(N);
-  if (LIFO == NULL)
-  {   fprintf(stderr, "lblob() : CreeLifoVide failed\n");
-      return 0;
-  }
-
-  EMPILE = (uint8_t *)calloc(N, sizeof(char));
-  if (EMPILE == NULL)
-  {   fprintf(stderr, "lblob() : calloc failed\n");
-      return 0;
-  }
-
-  /* calcul de la surface initiale */
-  surface = 0;
-  for (x = 0; x < N; x++) if (SOURCE[x]) surface++;
-  osurf = surface;
-
-  /* calcul du perimetre initial */
-  perimetre = 0;
-  for (x = 0; x < N; x++)
-    if (SOURCE[x])
-    {
-      EMPILE[x] = 255;
-      perimetre += contrib_perim(x, EMPILE, rs, N, 2);
-    }  
-  operim = perimetre;
-  memset(EMPILE, 0, N);
-
-printf("surface: %d ; perimetre: %d\n", surface, perimetre);
-
-  if (BoxWidth * NBBUTTONS2D > Width) Width = BoxWidth * NBBUTTONS2D;
-  
-  InitGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  /* send output to the screen */
-  for (x = 0; x < N; x++)
-  {
-    ColToBlack();
-    if (SOURCE[x]) Point(x%rs, x/rs);
-  }
-
-  FlushGraphics();  
-
-  /* empile initialement les points simples */
-
-  for (x = 0; x < N; x++)
-    if (pdestr4(SOURCE, x, rs, N) || pconstr4(SOURCE, x, rs, N))
-    {
-      LifoPush(LIFO, x);
-      EMPILE[x] = 1;
-    }
-
-  /* ===================================================================== */
-  /*                            BOUCLE PRINCIPALE                          */
-  /* ===================================================================== */
-  niter = 0;
-  while(niter < nitermax)
-  {
-    if ((niter % 1000) == 0)
-    {
-      /* send output to the screen */
-      for (x = 0; x < N; x++)
-      {
-        if (SOURCE[x]) ColToWhite(); else ColToBlack();
-        Point(x%rs, x/rs);
-      }
-      FlushGraphics();  
-    }
-    niter++;
-
-    /* echange l'element en haut de pile avec un element choisi aleatoirement */
-    r = Random(0, LIFO->Sp-1);
-    i = LIFO->Pts[LIFO->Sp-1];
-    LIFO->Pts[LIFO->Sp-1] = LIFO->Pts[r];
-    LIFO->Pts[r] = i;
-
-    /* depile, change la couleur du point, et empile les points simples non empiles du voisinage */
-    x = LifoPop(LIFO);
-    EMPILE[x] = 0;
-    /*  printf("POP x = %d,%d\n", x%rs, x/rs);
-        { char dummy[64]; scanf("%s", dummy); } */
-    yy = x / rs;
-    if (pdestr4(SOURCE, x, rs, N) && (nbvoisc4(SOURCE, x, rs, N) > 1))
-    {
-      cp = contrib_perim(x, SOURCE, rs, N, 2);
-      if (!((surface > osurf - dsurf) && (Prob() >= ((double)yy) / cs)))
-      { LifoPush(LIFO, x); EMPILE[x] = 1; goto Skip; }
-      if ( ((cp > 0) && (perimetre <= operim - dperim)) ||
-           ((cp < 0) && (perimetre >= operim + dperim)) )
-      { LifoPush(LIFO, x); EMPILE[x] = 1; goto Skip; }
-      SOURCE[x] = 0;
-      surface--;
-      perimetre -= cp;
-      ColToBlack();
-      Point(x%rs, x/rs);
-      for (k = 0; k < 8; k += 1)  /* parcourt les voisins en 8-connexite */
-      {
-        y = voisin(x, k, rs, N);
-        if ((y != -1) && (!EMPILE[y]))
-        { 
-          LifoPush(LIFO, y);
-          EMPILE[y] = 1;
-        }
-      } /* for k */
-      LifoPush(LIFO, x);
-      EMPILE[x] = 1;
-    }
-    else if (pconstr4(SOURCE, x, rs, N) && (nbvois8(SOURCE, x, rs, N) > 1))
-    {
-      cp = contrib_perim(x, SOURCE, rs, N, 2);
-      if (!((surface < osurf + dsurf) && (Prob() < ((double)yy) / cs)))
-      { LifoPush(LIFO, x); EMPILE[x] = 1; goto Skip; }
-      if ( ((cp < 0) && (perimetre <= operim - dperim)) ||
-           ((cp > 0) && (perimetre >= operim + dperim)) )
-      { LifoPush(LIFO, x); EMPILE[x] = 1; goto Skip; }
-
-      SOURCE[x] = 255;
-      surface++;
-      perimetre += cp;
-      ColToWhite();
-      Point(x%rs, x/rs);
-      for (k = 0; k < 8; k += 1)  /* parcourt les voisins en 8-connexite */
-      {
-        y = voisin(x, k, rs, N);
-        if ((y != -1) && (!EMPILE[y]))
-        { 
-          LifoPush(LIFO, y);
-          EMPILE[y] = 1;
-        }
-      } /* for k */
-      LifoPush(LIFO, x);
-      EMPILE[x] = 1;
-    }
-Skip:;
-  }
-
-  free(EMPILE);
-  return(1);
-} /* lblob() */
diff -r 8b1af7363833 src/lib/lccv._notused_c
--- a/src/lib/lccv._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,215 +0,0 @@
-/* $Id: lccv.c,v 1.1.1.1 2008-11-25 08:01:42 mcouprie Exp $ */
-/* 
-   Operateur de calcul du carre du coefficient de variation du niveau de gris
-   dans le voisinage d'un point
-
-   Operateur de calcul de l'ecart-type du niveau de gris
-   dans le voisinage d'un point
-
-   Calcul a partir des moments d'ordre 0, 1 et 2:
-
-     moyenne = m1 / m0
-     variance = (m2 / m0) - (m1*m1 / (m0*m0))
-     ecart-type = sqrt(variance)
-     ccv = variance / (moyenne * moyenne)
-
-   Michel Couprie - avril 1998 
- 
-   Modif: decembre 1999 (ajout ecart-type)
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <math.h>
-#include <mccodimage.h>
-#include <mcutil.h>
-#include <lccv.h>
-
-/* ==================================== */
-int32_t lccv(struct xvimage *f, struct xvimage *m)
-/* m : masque representant le voisinage */
-/* ==================================== */
-{
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t i, j;           /* index muet */
-  register int32_t k, l;           /* index muet */
-  int32_t rs = rowsize(f);         /* taille ligne */
-  int32_t cs = colsize(f);         /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  int32_t rsm = rowsize(m);        /* taille ligne masque */
-  int32_t csm = colsize(m);        /* taille colonne masque */
-  int32_t Nm = rsm * csm;          /* taille masque */
-  int32_t xc = rsm/2, yc = csm/2;  /* coordonnees du "centre" du masque */
-  uint8_t *M = UCHARDATA(m);
-  uint8_t *F = UCHARDATA(f);
-  uint8_t *H;                    /* image de travail */
-  uint8_t sup;
-  int32_t nptb;                    /* nombre de points de l'e.s. */
-  int32_t *tab_es_x;               /* liste des coord. x des points de l'e.s. */
-  int32_t *tab_es_y;               /* liste des coord. y des points de l'e.s. */
-  int32_t c;
-  double m0, m1, m2, M1;
-
-  if (depth(f) != 1) 
-  {
-    fprintf(stderr, "lccv: cette version ne traite pas les images volumiques\n");
-    return 0;
-  }
-
-  H = (uint8_t *)calloc(1,N*sizeof(char));
-  if (H == NULL)
-  {  
-     fprintf(stderr,"lccv() : malloc failed for H\n");
-     return(0);
-  }
-
-  for (x = 0; x < N; x++) H[x] = F[x];
-
-  nptb = 0;
-  for (i = 0; i < Nm; i += 1)
-    if (M[i])
-      nptb += 1;
-
-  tab_es_x = (int32_t *)calloc(1,nptb * sizeof(int32_t));
-  tab_es_y = (int32_t *)calloc(1,nptb * sizeof(int32_t));
-  if ((tab_es_x == NULL) || (tab_es_y == NULL))
-  {  
-     fprintf(stderr,"lccv() : malloc failed for tab_es\n");
-     return(0);
-  }
-
-  k = 0;
-  for (j = 0; j < csm; j += 1)
-    for (i = 0; i < rsm; i += 1)
-      if (M[j * rsm + i])
-      {
-         tab_es_x[k] = i;
-         tab_es_y[k] = j;
-         k += 1;
-      }
-
-  /* calcul du ccv en chaque point */
-
-  m0 = (double)nptb;
-
-  for (y = 0; y < cs; y++)
-  for (x = 0; x < rs; x++)
-  {
-    m1 = m2 = 0.0;
-    for (c = 0; c < nptb ; c += 1)
-    {
-      l = y + tab_es_y[c] - yc;
-      k = x + tab_es_x[c] - xc; 
-      if ((l >= 0) && (l < cs) && (k >= 0) && (k < rs))
-      {
-        M1 = (double)H[l * rs + k]; 
-        m1 += M1;
-        m2 += M1 * M1;
-      }
-    }
-    F[y * rs + x] = (uint8_t)(100 * ((m2 * m0 / (m1 * m1)) - 1.0));
-  }
-
-  free(H);
-  free(tab_es_x);
-  free(tab_es_y);
-  return 1;
-} /* lccv() */
-
-/* ==================================== */
-int32_t lecarttype(struct xvimage *f, struct xvimage *m)
-/* m : masque representant le voisinage */
-/* ==================================== */
-{
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t i, j;           /* index muet */
-  register int32_t k, l;           /* index muet */
-  int32_t rs = rowsize(f);         /* taille ligne */
-  int32_t cs = colsize(f);         /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  int32_t rsm = rowsize(m);        /* taille ligne masque */
-  int32_t csm = colsize(m);        /* taille colonne masque */
-  int32_t Nm = rsm * csm;          /* taille masque */
-  int32_t xc = rsm/2, yc = csm/2;  /* coordonnees du "centre" du masque */
-  uint8_t *M = UCHARDATA(m);
-  uint8_t *F = UCHARDATA(f);
-  uint8_t *H;                    /* image de travail */
-  uint8_t sup;
-  int32_t nptb;                    /* nombre de points de l'e.s. */
-  int32_t *tab_es_x;               /* liste des coord. x des points de l'e.s. */
-  int32_t *tab_es_y;               /* liste des coord. y des points de l'e.s. */
-  int32_t c;
-  double m0, m1, m2, M1;
-
-  if (depth(f) != 1) 
-  {
-    fprintf(stderr, "lecarttype: cette version ne traite pas les images volumiques\n");
-    return 0;
-  }
-
-  H = (uint8_t *)calloc(1,N*sizeof(char));
-  if (H == NULL)
-  {  
-     fprintf(stderr,"lecarttype() : malloc failed for H\n");
-     return(0);
-  }
-
-  for (x = 0; x < N; x++) H[x] = F[x];
-
-  nptb = 0;
-  for (i = 0; i < Nm; i += 1)
-    if (M[i])
-      nptb += 1;
-
-  tab_es_x = (int32_t *)calloc(1,nptb * sizeof(int32_t));
-  tab_es_y = (int32_t *)calloc(1,nptb * sizeof(int32_t));
-  if ((tab_es_x == NULL) || (tab_es_y == NULL))
-  {  
-     fprintf(stderr,"lecarttype() : malloc failed for tab_es\n");
-     return(0);
-  }
-
-  k = 0;
-  for (j = 0; j < csm; j += 1)
-    for (i = 0; i < rsm; i += 1)
-      if (M[j * rsm + i])
-      {
-         tab_es_x[k] = i;
-         tab_es_y[k] = j;
-         k += 1;
-      }
-
-  /* calcul de l'ecart-type en chaque point */
-
-  m0 = (double)nptb;
-
-  for (y = 0; y < cs; y++)
-  for (x = 0; x < rs; x++)
-  {
-    m1 = m2 = 0.0;
-    for (c = 0; c < nptb ; c += 1)
-    {
-      l = y + tab_es_y[c] - yc;
-      k = x + tab_es_x[c] - xc; 
-      if ((l >= 0) && (l < cs) && (k >= 0) && (k < rs))
-      {
-        M1 = (double)H[l * rs + k]; 
-        m1 += M1;
-        m2 += M1 * M1;
-      }
-    }
-    F[y * rs + x] = (uint8_t)(sqrt((m2 / m0) - (m1 * m1) / (m0 * m0)));
-  }
-
-  free(H);
-  free(tab_es_x);
-  free(tab_es_y);
-  return 1;
-} /* lecarttype() */
-
-
-
diff -r 8b1af7363833 src/lib/lclick.c
--- a/src/lib/lclick.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1493 +0,0 @@
-/* $Id: lclick.c,v 1.1.1.1 2008-11-25 08:01:40 mcouprie Exp $ */
-/* 
-   Operateur interactif de visualisation 2D et 3D
-   et de specification de marqueurs
-
-   Michel Couprie - decembre 1999
-
-   Versions definies dans ce fichier:
-
-     lclick2d : genere un tableau image labels au format pgm (int32_t) - permet des labels differents
-     lclicklist : genere une liste de points values
-     lclick3d : idem lclicklist, avec 3 vues 
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mcutil.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcxbib.h>
-#include <mclifo.h>
-#include <lclick.h>
-
-/* ==================================== */
-int32_t lclick2d(struct xvimage *image, struct xvimage *lab, int32_t zoom)
-/* ==================================== */
-{
-  register int32_t x;              /* index muet de pixel */
-  int32_t i, k;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t d = depth(image);        /* nb. plans */
-  int32_t N = d * n;               /* taille image */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  uint32_t *LAB = ULONGDATA(lab);
-  int32_t curlab = 1;
-  int32_t incr = 0;
-  int32_t iplan = 0;
-  int32_t incrplan = 1;
-#define NBBUTTONS2D  7
-#define NBLIGBUTT2D  2
-#define BOXWIDTH    70
-#define BOXHEIGHT   20
-  char * ButtonStrings[NBLIGBUTT2D][NBBUTTONS2D];
-  int32_t xx, yy;
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT2D;
-  int32_t Width = rs;
-  int32_t ImageHeight = cs;
-  int32_t ImageWidth = rs;
-  int32_t eventtype;
-
-  if (zoom)
-  {
-    Height += cs;
-    Width += rs;
-    ImageHeight += cs;
-    ImageWidth += rs;
-  }
-
-  if (BoxWidth * NBBUTTONS2D > Width) Width = BoxWidth * NBBUTTONS2D;
-  
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT2D; i++) 
-    for (k = 0; k < NBBUTTONS2D; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], "LABEL");
-  sprintf(ButtonStrings[0][1], "%d", curlab);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "INCR ");
-  strcpy(ButtonStrings[0][5], "UNDO ");
-  strcpy(ButtonStrings[0][6], "QUIT ");
-
-  strcpy(ButtonStrings[1][0], " PLAN");
-  sprintf(ButtonStrings[1][1], "%d", iplan);
-  sprintf(ButtonStrings[1][2], " +%d", incrplan);
-  sprintf(ButtonStrings[1][3], " -%d", incrplan);
-  strcpy(ButtonStrings[1][4], "  ++ ");
-  strcpy(ButtonStrings[1][5], "  -- ");
-  strcpy(ButtonStrings[1][6], "     ");
-
-/* ===========================================================
-    affichage : 
-   ===========================================================
-
-    <------- rs ------>     
-    ------------------- .
-    |                 | .
-    |                 | .
-    |                 | .
-    |      image      | cs
-    |                 | .
-    |                 | .
-    |                 | .
-    --------------------------------------------------
-    |LABEL | 111  |  +   |  -   | AUTO | UNDO | QUIT |        BoxHeight
-    --------------------------------------------------
-    | PLAN | 111  | +1   | -1   |  ++  |  --  |      |        BoxHeight
-    --------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-ReDisplayImage:
-
-  /* send output to the screen */
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-  {
-    if (LAB[x])    
-      Color(MC_RED);
-    else
-      Color(SOURCE[x]/4);
-    if (zoom)
-    {
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point((x%n)%rs, (x%n)/rs);
-  }
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS2D, BoxHeight * NBLIGBUTT2D);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT2D; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS2D; k++) 
-    {
-      Line(k * BoxWidth, ImageHeight + i*BoxHeight, k*BoxWidth, ImageHeight + (i+1)*BoxHeight);
-      String(k * BoxWidth + 3, ImageHeight + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  FlushGraphics();  
-
-NextEvent:
-  eventtype = WaitEvent(&xx, &yy);
-  switch(eventtype)
-  {
-    case KeyPress: 
-      switch(xx)
-      {
-        case key_q: goto Terminate;
-      }
-      break;
-    
-    case ButtonPress:
-      break;
-
-    case ButtonRelease: goto NextEvent;
-
-    case EnterNotify: goto ReDisplay;
-
-    default: printf("type : %d ; x = %d ; y = %d\n", eventtype, xx, yy); break;
-
-  } /* switch(eventtype) */
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight))
-  {
-    if (zoom)
-    {
-      xx /= 2;
-      yy /= 2;
-    }
-    x = iplan * n + yy * rs + xx;
-
-    if (LAB[x]) 
-    {
-      LAB[x] = 0;
-    }
-    else
-    {
-      LAB[x] = curlab;
-      if (incr) 
-      {
-        curlab++;
-        sprintf(ButtonStrings[0][1], "%d", curlab);
-      }
-    }
-    if (LAB[x])    
-      Color(MC_RED);
-    else
-      Color(SOURCE[x]/4);
-    if (zoom)
-    {
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point((x%n)%rs, (x%n)/rs);
-    goto ReDisplay;
-  }
-
-  xx /= BoxWidth;
-  yy -= ImageHeight;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: curlab++;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 3: curlab--;
-                      if (curlab < 1) curlab = 1;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 4: if (incr) 
-                      {
-                        incr = 0; 
-                        sprintf(ButtonStrings[0][4], "%s", "INCR ");
-		      }
-                      else
-		      { 
-                        incr = 1;
-                        sprintf(ButtonStrings[0][4], "%s", "IDEM ");
-		      }
-                      break;
-              case 5: for (x = 0; x < N; x++) LAB[x] = 0;
-                      goto ReDisplayImage;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: iplan++;
-                      if (iplan > d-1) iplan = d-1;
-                      sprintf(ButtonStrings[1][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 3: iplan--;
-                      if (iplan < 0) iplan = 0;
-                      sprintf(ButtonStrings[1][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 4: if (incrplan == 1) incrplan = 5; else incrplan += 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplayImage;
-              case 5: if (incrplan == 5) incrplan = 1; else if (incrplan > 5) incrplan -= 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplayImage;
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    default: goto ReDisplayImage;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-  return(1);
-} /* lclick2d() */
-
-/* ==================================== */
-int32_t lclicklist(struct xvimage *image, uint32_t *LAB, int32_t *VLAB, int32_t *nlabs, int32_t zoom)
-/* ==================================== */
-{
-  register int32_t x;              /* index muet de pixel */
-  int32_t i, k;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t d = depth(image);        /* nb. plans */
-  int32_t N = d * n;               /* taille image */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  int32_t curlab = 1;
-  int32_t incr = 0;
-  int32_t iplan = 0;
-  int32_t incrplan = 1;
-#define NBBUTTONS 7
-#define NBLIGBUTT 2
-#define BOXWIDTH 70
-#define BOXHEIGHT 20
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int32_t xx, yy;
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT;
-  int32_t Width = rs;
-  int32_t ImageHeight = cs;
-  int32_t ImageWidth = rs;
-  int32_t eventtype;
-
-  *nlabs = 0;
-
-  if (zoom)
-  {
-    Height += cs;
-    Width += rs;
-    ImageHeight += cs;
-    ImageWidth += rs;
-  }
-
-  if (BoxWidth * NBBUTTONS > Width) Width = BoxWidth * NBBUTTONS;
-  
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], "LABEL");
-  sprintf(ButtonStrings[0][1], "%d", curlab);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "INCR ");
-  strcpy(ButtonStrings[0][5], "UNDO ");
-  strcpy(ButtonStrings[0][6], "QUIT ");
-
-  strcpy(ButtonStrings[1][0], " PLAN");
-  sprintf(ButtonStrings[1][1], "%d", iplan);
-  sprintf(ButtonStrings[1][2], " +%d", incrplan);
-  sprintf(ButtonStrings[1][3], " -%d", incrplan);
-  strcpy(ButtonStrings[1][4], "  ++ ");
-  strcpy(ButtonStrings[1][5], "  -- ");
-  strcpy(ButtonStrings[1][6], "     ");
-
-/* ===========================================================
-    affichage : 
-   ===========================================================
-
-    <------- rs ------>     
-    ------------------- .
-    |                 | .
-    |                 | .
-    |                 | .
-    |      image      | cs
-    |                 | .
-    |                 | .
-    |                 | .
-    --------------------------------------------------
-    |LABEL | 111  |  +   |  -   | AUTO | UNDO | QUIT |        BoxHeight
-    --------------------------------------------------
-    | PLAN | 111  | +1   | -1   |  ++  |  --  |      |        BoxHeight
-    --------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-ReDisplayImage:
-
-  /* send output to the screen */
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-  {
-    for (i = 0; i < *nlabs; i++) /* devient lourd s'il y a beaucoup de points ... */
-      if (LAB[i] == x) break;
-    if (i < *nlabs)
-      Color(MC_RED);
-    else
-      Color(SOURCE[x]/4);
-    if (zoom)
-    {
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point((x%n)%rs, (x%n)/rs);
-  }
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, ImageHeight + i * BoxHeight, k * BoxWidth, ImageHeight + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, ImageHeight + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  FlushGraphics();  
-
-NextEvent:
-  eventtype = WaitEvent(&xx, &yy);
-  switch(eventtype)
-  {
-    case KeyPress: 
-      switch(xx)
-      {
-        case key_q: goto Terminate;
-      }
-
-    case ButtonPress:
-    break;
-
-    case ButtonRelease: goto NextEvent;
-
-    case EnterNotify: goto ReDisplay;
-
-    default: printf("type : %d ; x = %d ; y = %d\n", eventtype, xx, yy); break;
-
-  } /* switch(eventtype) */
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight))
-  {
-    if (zoom)
-    {
-      xx /= 2;
-      yy /= 2;
-    }
-    x = iplan * n + yy * rs + xx;
-
-    LAB[*nlabs] = x;
-    VLAB[*nlabs] = curlab;
-    if (incr) 
-    {
-      curlab++;
-      sprintf(ButtonStrings[0][1], "%d", curlab);
-    }
-    *nlabs += 1;
-
-    Color(MC_RED);
-    if (zoom)
-    {
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point((x%n)%rs, (x%n)/rs);
-    goto ReDisplay;
-  }
-
-  xx /= BoxWidth;
-  yy -= ImageHeight;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: curlab++;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 3: curlab--;
-                      if (curlab < 1) curlab = 1;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 4: if (incr) 
-                      {
-                        incr = 0; 
-                        sprintf(ButtonStrings[0][4], "%s", "INCR ");
-		      }
-                      else
-		      { 
-                        incr = 1;
-                        sprintf(ButtonStrings[0][4], "%s", "IDEM ");
-		      }
-                      break;
-              case 5: *nlabs = 0;
-                      goto ReDisplayImage;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: iplan += incrplan;
-                      if (iplan > d-1) iplan = d-1;
-                      sprintf(ButtonStrings[1][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 3: iplan -= incrplan;
-                      if (iplan < 0) iplan = 0;
-                      sprintf(ButtonStrings[1][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 4: if (incrplan == 1) incrplan = 5; else incrplan += 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplayImage;
-              case 5: if (incrplan == 5) incrplan = 1; else if (incrplan > 5) incrplan -= 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplayImage;
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    default: goto ReDisplayImage;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-
-  return(1);
-} /* lclicklist() */
-
-
-/* ==================================== */
-void SetRange(uint8_t *SOURCE, int32_t rs, int32_t n, int32_t xr, int32_t yr, int32_t zr, 
-              int32_t xc, int32_t yc, int32_t zc, int32_t *inf, int32_t *sup)
-/* ==================================== */
-{
-  int32_t i, j, k, t;
-  if (zr > zc) {t = zr; zr = zc; zc = t;} 
-  if (yr > yc) {t = yr; yr = yc; yc = t;} 
-  if (xr > xc) {t = xr; xr = xc; xc = t;} 
-  *inf = *sup = SOURCE[zr * n + yr * rs + xr];
-  for (k = zr; k <= zc; k++)
-  for (j = yr; j <= yc; j++)
-  for (i = xr; i <= xc; i++)
-  {
-    t = SOURCE[k * n + j * rs + i];
-    if (t > *sup) *sup = t;
-    else if (t < *inf) *inf = t;
-  }
-} /* SetRange() */
-
-#define VAL_PROPAG 255
-#define VAL_NULLE   0
-
-/* ==================================== */
-void InitPropag(uint8_t *PROPAG, int32_t rs, int32_t n, int32_t xr, int32_t yr, int32_t zr, 
-              int32_t xc, int32_t yc, int32_t zc)
-/* ==================================== */
-{
-  int32_t i, j, k, t;
-  if (zr > zc) {t = zr; zr = zc; zc = t;} 
-  if (yr > yc) {t = yr; yr = yc; yc = t;} 
-  if (xr > xc) {t = xr; xr = xc; xc = t;} 
-  for (k = zr; k <= zc; k++)
-  for (j = yr; j <= yc; j++)
-  for (i = xr; i <= xc; i++)
-  {
-    PROPAG[k * n + j * rs + i] = VAL_PROPAG;
-  }
-} /* InitPropag() */
-
-/* ==================================== */
-void Propagate(uint8_t *SOURCE, uint8_t *PROPAG, int32_t rs, int32_t n, int32_t N, 
-               int32_t connex, int32_t infrange, int32_t suprange, int32_t tolinf, int32_t tolsup, int32_t radius)
-/* ==================================== */
-{
-  Lifo * LIFO1, * LIFO2, * LIFOtmp;
-  int32_t p, q, k, s;
-  double range;
-  int32_t niter;
-
-  if (suprange < infrange) return;
-
-  suprange += tolsup;
-  infrange -= tolinf;
-
-  LIFO1 = CreeLifoVide(N/2);
-  LIFO2 = CreeLifoVide(N/2); /* ATTENTION: peut etre insuffisant dans des cas tres rares */
-  if ((LIFO1 == NULL) || (LIFO2 == NULL))
-  { 
-    fprintf(stderr, "Propagate() : CreeLifoVide failed\n");
-    exit(0);
-  }
-
-  /* init la lifo1 avec les points de la zone marquee */
-  for (p = 0; p < N; p++)
-    if (PROPAG[p])      
-      LifoPush(LIFO1, p);
-
-  /* boucle : propagation largeur d'abord */
-  switch (connex)
-  {
-    case 6:
-      niter = 0;
-      while ((! LifoVide(LIFO1)) && (niter < radius))
-      {
-        while (! LifoVide(LIFO1))
-        {
-          p = LifoPop(LIFO1);
-          for (k = 0; k <= 10; k += 2) /* parcourt les 6 voisins */
-          {
-            q = voisin6(p, k, rs, n, N);
-            if ((q != -1) && (PROPAG[q] == 0))
-            {
-              s = SOURCE[q];
-              if ((s >= infrange) && (s <= suprange))
- 	      {
-                PROPAG[q] = VAL_PROPAG;
-                LifoPush(LIFO2, q);
- 	      }
- 	    }
-          }
-        } /* while (! LifoVide(LIFO1)) */
-        niter++;
-        LIFOtmp = LIFO1; LIFO1 = LIFO2; LIFO2 = LIFOtmp;
-      } /* while (! LifoVide(LIFO1)) */
-      break;
-  } /* switch (connex) */
-
-  LifoTermine(LIFO1);
-  LifoTermine(LIFO2);
-  
-} /* Propagate() */
-
-/* ==================================== */
-int32_t lclick3d(struct xvimage *image, uint32_t *LAB, int32_t *VLAB, int32_t *nlabs, int32_t zoom)
-/* ==================================== */
-{
-  register int32_t x, y, z;        /* index muet */
-  int32_t i, k;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t d = depth(image);        /* nb. plans */
-  int32_t N = d * n;               /* taille image */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  int32_t curlab = 1;
-  int32_t incr = 0;
-  int32_t incrplan = 1;
-#define NBBUTTONS3D  7
-#define NBLIGBUTT3D  3
-#define BOXWIDTH  70
-#define BOXHEIGHT 20
-#define MARGE     10
-  char * ButtonStrings[NBLIGBUTT3D][NBBUTTONS3D];
-  int32_t xx, yy;
-  int32_t button;
-  int32_t xref = rs / 2; /* coordonnees du point de reference */
-  int32_t yref = cs / 2;
-  int32_t zref = d  / 2;
-  int32_t xclick = xref; /* coordonnees du dernier point clique' */
-  int32_t yclick = yref;
-  int32_t zclick = zref;
-  char var = 'z'; /* axe normal au plan de la vue principale */
-  int32_t eventtype;
-  int32_t spot = 1;
-  char coordrefstring[128];
-  char coordclickstring[128];
-  char valclickstring[128];
-  char valrangestring[128];
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  /* dimensions totales */
-  int32_t Height = cs + MARGE + d + BoxHeight * NBLIGBUTT3D;
-  int32_t Width = rs + MARGE + d;
-  /* dimensions du panneau image */
-  int32_t ImagePannelHeight = cs + MARGE + d;
-  int32_t ImagePannelWidth = rs + MARGE + d;
-  /* dimensions image "centrale" */
-  int32_t ImageHeight = cs;
-  int32_t ImageWidth = rs;  
-  /* dimensions image "droite" */
-  int32_t ImageRightWidth = d;  
-  /* dimensions image "bas" */
-  int32_t ImageBottomHeight = d;
-  /* variables pour la "baguette magique" */
-  int32_t suprange = -1, infrange = 0;
-  int32_t tolinf = 0;
-  int32_t tolsup = 0;
-  int32_t radius = 0;
-  struct xvimage *propag;
-  uint8_t *PROPAG;        /* l'image pour la baguette */
-  int32_t connex = 6;
-#define FIELD_COOR 0
-#define FIELD_TOLP 1
-#define FIELD_TOLM 2
-#define FIELD_RAD  3
-  int32_t selfield = 0;
-
-  propag = allocimage(NULL, rs, cs, d, VFF_TYP_1_BYTE);
-  if (propag == NULL)
-  {   fprintf(stderr,"click3d() : allocimage failed for PROPAG\n");
-      return 0;
-  }
-  PROPAG = UCHARDATA(propag);
-  memset(PROPAG, 0, N);
-
-  coordclickstring[0] = '\0';
-  valclickstring[0] = '\0';
-  valrangestring[0] = '\0';
-
-  *nlabs = 0;
-
-  if (zoom)
-  {
-    Height += cs + d;
-    Width += rs + d;
-    ImagePannelHeight += cs + d;
-    ImagePannelWidth += rs + d;
-    ImageHeight += cs;
-    ImageWidth += rs;
-    ImageBottomHeight += d;
-    ImageRightWidth += d;
-  }
-
-  if (BoxWidth * NBBUTTONS3D > Width) Width = BoxWidth * NBBUTTONS3D;
-  
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT3D; i++) 
-    for (k = 0; k < NBBUTTONS3D; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], "LABEL");
-  sprintf(ButtonStrings[0][1], "%d", curlab);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "INCR ");
-  strcpy(ButtonStrings[0][5], "UNDO ");
-  strcpy(ButtonStrings[0][6], "QUIT ");
-
-  sprintf(ButtonStrings[1][0], "  %c ", 'z');
-  sprintf(ButtonStrings[1][1], "%d", zref);
-  sprintf(ButtonStrings[1][2], " +%d", incrplan);
-  sprintf(ButtonStrings[1][3], " -%d", incrplan);
-  strcpy(ButtonStrings[1][4], "  ++ ");
-  strcpy(ButtonStrings[1][5], "  -- ");
-  strcpy(ButtonStrings[1][6], "SPOT ");
-
-  strcpy(ButtonStrings[2][0], "PROPAG");
-  strcpy(ButtonStrings[2][1], " SET ");
-  strcpy(ButtonStrings[2][2], " TOL-");
-  strcpy(ButtonStrings[2][3], " TOL+");
-  strcpy(ButtonStrings[2][4], " RAD ");
-  strcpy(ButtonStrings[2][5], "CLEAR");
-  strcpy(ButtonStrings[2][6], "SAVE ");
-
-/* ===========================================================
-    affichage : 
-   ===========================================================
-
-    <------- rs ------>      <---- d ---->
-    ------------------- ^    -------------
-    |                 | .    |           |
-    |                 | .    |           |
-    |                 | .    |           |
-    |      image      | cs   |           |
-    |                 | .    |           |
-    |                 | .    |           |
-    |                 | .    |           |
-    ------------------- v    -------------
-    ------------------- ^
-    |                 | .     1,2,3
-    |                 | d
-    |                 | .
-    |                 | .
-    ------------------- v  
-    --------------------------------------------------
-    |LABEL | 111  |  +   |  -   | AUTO | UNDO | QUIT |        BoxHeight
-    --------------------------------------------------
-    |  z   | 111  | +1   | -1   |  ++  |  --  | SPOT |        BoxHeight
-    --------------------------------------------------
-    |PROPAG | SET  | TOL- | TOL+ | RAD  |CLEAR | SAVE |        BoxHeight
-    --------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-ReDisplayImage:
-
-  /* send output to the screen */
-
-  /* ================================================================= */
-  /* image "centrale" (projection x,y) */
-  /* ================================================================= */
-  if (zoom)
-  {
-    for (y = 0; y < cs; y++) for (x = 0; x < rs; x++)
-    {
-      Color(SOURCE[zref * n + y * rs + x]/4);
-      Rectangle(2*x, 2*y, 1, 1);
-    }
-  } /* if (zoom) */
-  else
-    for (y = 0; y < cs; y++) for (x = 0; x < rs; x++)
-    {
-      Color(SOURCE[zref * n + y * rs + x]/4);
-      Point(x, y);
-    }
-
-  Color(MC_RED);
-  x = xref;
-  if (var == 'x')
-  {
-    if (zoom)
-    {
-      for (y = 0; y < cs; y++)
-        Rectangle(2*x, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-      for (y = 0; y < cs; y++)
-        Point(x, y);
-  } /* if (var == 'x') */
-  else
-  {
-    if (zoom)
-    {
-      for (y = 0; y < 5; y++) Rectangle(2*x, 2*y, 1, 1);
-      for (y = cs - 5; y < cs; y++) Rectangle(2*x, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (y = 0; y < 5; y++) Point(x, y);
-      for (y = cs - 5; y < cs; y++) Point(x, y);
-    }
-  } /* else if (var == 'x') */
-
-  y = yref;
-  if (var == 'y')
-  {
-    if (zoom)
-    {
-      for (x = 0; x < rs; x++)
-        Rectangle(2*x, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-      for (x = 0; x < rs; x++)
-        Point(x, y);
-  } /* if (var == 'x') */
-  else
-  {
-    if (zoom)
-    {
-      for (x = 0; x < 5; x++) Rectangle(2*x, 2*y, 1, 1);
-      for (x = rs - 5; x < rs; x++) Rectangle(2*x, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (x = 0; x < 5; x++) Point(x, y);
-      for (x = rs - 5; x < rs; x++) Point(x, y);
-    }
-  } /* else if (var == 'y') */
-
-  Color(MC_GREEN);
-  for (i = 0; i < *nlabs; i++) 
-    if (LAB[i] / n == zref)
-    {
-      if (zoom)
-        Rectangle(2*(LAB[i]%rs), 2*((LAB[i]%n)/rs), 1, 1);
-      else
-        Point((LAB[i]%rs), ((LAB[i]%n)/rs));
-    }
-
-  if (spot)
-  {
-    if (zoom)
-    {
-      Rectangle(2*xref - 10, 2 * yref, 20, 1);
-      Rectangle(2*xref, 2 * yref - 10, 1, 20);
-    }
-    else
-    {
-      Line(xref - 5, yref, xref + 5, yref);
-      Line(xref, yref - 5, xref, yref + 5);
-    }
-  }
-
-  /* Baguette Magique */
-  if (suprange >= infrange)
-  {
-    Color(MC_BLUE);
-    if (zoom)
-    {
-      for (y = 0; y < cs; y++) for (x = 0; x < rs; x++) 
-        if (PROPAG[zref * n + y * rs + x]) Rectangle(2*x, 2*y, 1, 1);
-    }
-    else
-    {
-      for (y = 0; y < cs; y++) for (x = 0; x < rs; x++)
-        if (PROPAG[zref * n + y * rs + x]) Point(x, y);
-    }
-  } /* Baguette Magique */
-
-  /* ================================================================= */
-  /* image droite (projection y,z) */
-  /* ================================================================= */
-  if (zoom)
-  {
-    for (y = 0; y < cs; y++) for (z = 0; z < d; z++)
-    {
-      Color(SOURCE[z * n + y * rs + xref]/4);
-      Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-    }
-  } /* if (zoom) */
-  else
-    for (y = 0; y < cs; y++) for (z = 0; z < d; z++)
-    {
-      Point(ImageWidth + MARGE + z, y);
-      Color(SOURCE[z * n + y * rs + xref]/4);
-    }
-
-  Color(MC_RED);
-  z = zref;
-  if (var == 'z')
-  {
-    if (zoom)
-    {
-      for (y = 0; y < cs; y++)
-        Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-      for (y = 0; y < cs; y++)
-        Point(ImageWidth + MARGE + z, y);
-  } /* if (var == 'z') */
-  else
-  {
-    if (zoom)
-    {
-      for (y = 0; y < 5; y++) Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-      for (y = cs - 5; y < cs; y++) Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (y = 0; y < 5; y++) Point(ImageWidth + MARGE + z, y);
-      for (y = cs - 5; y < cs; y++) Point(ImageWidth + MARGE + z, y);
-    }
-  } /* else if (var == 'z') */
-
-  y = yref;
-  if (var == 'y')
-  {
-    if (zoom)
-    {
-      for (z = 0; z < d; z++)
-        Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (z = 0; z < d; z++)
-        Point(ImageWidth + MARGE + z, y);
-    }
-  } /* if (var == 'y') */
-  else
-  {
-    if (zoom)
-    {
-      for (z = 0; z < 5; z++) Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-      for (z = d-5; z < d; z++) Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (z = 0; z < 5; z++) Point(ImageWidth + MARGE + z, y);
-      for (z = d-5; z < d; z++) Point(ImageWidth + MARGE + z, y);
-    }
-  } /* else if (var == 'y') */
-
-  Color(MC_GREEN);
-  for (i = 0; i < *nlabs; i++) 
-    if (LAB[i] % rs == xref)
-    {
-      if (zoom)
-        Rectangle(ImageWidth + MARGE + 2*(LAB[i]/n), 2*((LAB[i]%n)/rs), 1, 1);
-      else
-        Point(ImageWidth + MARGE + (LAB[i]/n), ((LAB[i]%n)/rs));
-    }
-
-  if (spot)
-  {
-    if (zoom)
-    {
-      Rectangle(ImageWidth + MARGE + 2*zref - 10, 2 * yref, 20, 1);
-      Rectangle(ImageWidth + MARGE + 2*zref, 2 * yref - 10, 1, 20);
-    }
-    else
-    {
-      Line(ImageWidth + MARGE + zref - 5, yref, ImageWidth + MARGE + zref + 5, yref);
-      Line(ImageWidth + MARGE + zref, yref - 5, ImageWidth + MARGE + zref, yref + 5);
-    }
-  }
-
-  /* Baguette Magique */
-  if (suprange >= infrange)
-  {
-    Color(MC_BLUE);
-    if (zoom)
-    {
-      for (y = 0; y < cs; y++) for (z = 0; z < d; z++)
-        if (PROPAG[z * n + y * rs + xref]) Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-    }
-    else
-    {
-      for (y = 0; y < cs; y++) for (z = 0; z < d; z++)
-        if (PROPAG[z * n + y * rs + xref]) Point(ImageWidth + MARGE + z, y);
-    }
-  } /* Baguette Magique */
-
-  /* ================================================================= */
-  /* image bas (projection x,z) */
-  /* ================================================================= */
-  if (zoom)
-  {
-    for (x = 0; x < rs; x++) for (z = 0; z < d; z++)
-    {
-      Color(SOURCE[z * n + yref * rs + x]/4);
-      Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-    }
-  } /* if (zoom) */
-  else
-    for (x = 0; x < rs; x++) for (z = 0; z < d; z++)
-    {
-      Color(SOURCE[z * n + yref * rs + x]/4);
-      Point(x, ImageHeight + MARGE + z);
-    }
-
-  Color(MC_RED);
-  x = xref;
-  if (var == 'x')
-  {
-    if (zoom)
-    {
-      for (z = 0; z < d; z++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (z = 0; z < d; z++) Point(x, ImageHeight + MARGE + z);
-    }
-  } /* if (var == 'x') */
-  else
-  {
-    if (zoom)
-    {
-      for (z = 0; z < 5; z++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-      for (z = d-5; z < d; z++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (z = 0; z < 5; z++) Point(x, ImageHeight + MARGE + z);
-      for (z = d-5; z < d; z++) Point(x, ImageHeight + MARGE + z);
-    }
-  } /* else if (var == 'x') */
-
-  z = zref;
-  if (var == 'z')
-  {
-    if (zoom)
-    {
-      for (x = 0; x < rs; x++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (x = 0; x < rs; x++) Point(x, ImageHeight + MARGE + z);
-    }
-  } /* if (var == 'z') */
-  else
-  {
-    if (zoom)
-    {
-      for (x = 0; x < 5; x++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-      for (x = rs-5; x < rs; x++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (x = 0; x < 5; x++) Point(x, ImageHeight + MARGE + z);
-      for (x = rs-5; x < rs; x++) Point(x, ImageHeight + MARGE + z);
-    }
-  } /* else if (var == 'z') */
-
-  Color(MC_GREEN);
-  for (i = 0; i < *nlabs; i++) 
-    if ((LAB[i] % n) / rs == yref)
-    {
-      if (zoom)
-        Rectangle(2*(LAB[i]%rs), ImageHeight + MARGE + 2*(LAB[i]/n), 1, 1);
-      else
-        Point((LAB[i]%rs), ImageHeight + MARGE + (LAB[i]/n));
-    }
-
-  if (spot)
-  {
-    if (zoom)
-    {
-      Rectangle(2*xref - 10, ImageHeight + MARGE + 2 * zref, 20, 1);
-      Rectangle(2*xref, ImageHeight + MARGE + 2 * zref - 10, 1, 20);
-    }
-    else
-    {
-      Line(xref - 5, ImageHeight + MARGE + zref, xref + 5, ImageHeight + MARGE + zref);
-      Line(xref, ImageHeight + MARGE + zref - 5, xref, ImageHeight + MARGE + zref + 5);
-    }
-  }
-
-  /* Baguette Magique */
-  if (suprange >= infrange)
-  {
-    Color(MC_BLUE);
-    if (zoom)
-    {
-      for (x = 0; x < rs; x++) for (z = 0; z < d; z++)  
-        if (PROPAG[z * n + yref * rs + x]) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-    }
-    else
-    {
-      for (x = 0; x < rs; x++) for (z = 0; z < d; z++)
-        if (PROPAG[z * n + yref * rs + x]) Point(x, ImageHeight + MARGE + z);
-    }
-  } /* Baguette Magique */
-
-  ColToBlack();
-  FRectangle(ImageWidth, ImageHeight, 
-	     mcmax(ImagePannelWidth,Width) - ImageWidth, ImagePannelHeight - ImageHeight);
-  ColToWhite();
-  sprintf(coordrefstring, "%d,%d,%d", xref, yref, zref);
-  String(ImageWidth + 2 * MARGE, ImageHeight + BoxHeight + MARGE, coordrefstring);
-  String(ImageWidth + 2 * MARGE, ImageHeight+(2*BoxHeight) + MARGE, coordclickstring);
-  String(ImageWidth + 2 * MARGE, ImageHeight+(3*BoxHeight) + MARGE, valclickstring);
-  String(ImageWidth + 2 * MARGE, ImageHeight+(4*BoxHeight) + MARGE, valrangestring);
-
-  /* ================================================================= */
-  /* ================================================================= */
-ReDisplay:
-  /* ================================================================= */
-  /* ================================================================= */
-
-  ColToWhite();
-  FRectangle(0, ImagePannelHeight, BoxWidth * NBBUTTONS3D, BoxHeight * NBLIGBUTT3D);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT3D; i++) 
-  {
-    Line(0, ImagePannelHeight + i * BoxHeight, Width, ImagePannelHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS3D; k++) 
-    {
-      Line(k * BoxWidth, ImagePannelHeight + i * BoxHeight, k * BoxWidth, ImagePannelHeight + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, ImagePannelHeight + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  FlushGraphics();  
-
-NextEvent:
-  eventtype = WaitAnyEvent(&xx, &yy, &button);
-  switch(eventtype)
-  {
-    case KeyPress: 
-      switch(xx)
-      {
-        case key_q: goto Terminate;
-        case key_p: /* action CUTPLANE */
-	            if (var == 'z')
-	            {
-                      for (x = 0; x < rs; x++)
-                        for (y = 0; y < cs; y++)
-                          SOURCE[zref * n + y * rs + x] = 0;
-                    } else
-	            if (var == 'y')
-	            {
-                      for (x = 0; x < rs; x++)
-                        for (z = 0; z < d; z++)
-                          SOURCE[z * n + yref * rs + x] = 0;
-                    }
-	            if (var == 'x')
-	            {
-                      for (z = 0; z < d; z++)
-                        for (y = 0; y < cs; y++)
-                          SOURCE[z * n + y * rs + xref] = 0;
-                    }
-                    goto ReDisplayImage;
-        case key_l: /* action LABEL */
-                    LAB[*nlabs] = zclick * n + yclick * rs + xclick;
-                    VLAB[*nlabs] = curlab;
-                    *nlabs += 1;
-                    if (incr)
-                    {
-                      curlab++;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                    }
-                    goto ReDisplayImage;
-        case key_c: /* action CLEAR */
-                    memset(PROPAG, VAL_NULLE, N);
-                    suprange = -1;
-                    valrangestring[0] = '\0';
-                    tolinf = tolsup = 0;
-                    radius = 0;
-                    sprintf(ButtonStrings[2][2], "-%d", tolinf);
-                    sprintf(ButtonStrings[2][3], "+%d", tolsup);
-                    sprintf(ButtonStrings[2][4], "R%d", radius);
-                    goto ReDisplayImage;
-        case key_m: /* action PROPAG */
-                    Propagate(SOURCE, PROPAG, rs, n, N, connex, 
-                              infrange, suprange, tolinf, tolsup, radius);
-                    goto ReDisplayImage;
-        case key_s: /* action SETRANGE */
-                    SetRange(SOURCE, rs, n, xref, yref, zref, 
-                               xclick, yclick, zclick, &infrange, &suprange);
-                    InitPropag(PROPAG, rs, n, xref, yref, zref, xclick, yclick, zclick);
-                    sprintf(valrangestring, "%d-%d", infrange-tolinf, suprange+tolsup);
-                    goto ReDisplayImage;
-        case key_r: xref = xclick; yref = yclick; zref = zclick; goto ReDisplayImage;
-        case key_x: 
-           var = 'x'; 
-           sprintf(ButtonStrings[1][0], "  %c ", var);
-           sprintf(ButtonStrings[1][1], "%d", xref);
-           goto ReDisplayImage;
-        case key_y: 
-           var = 'y'; 
-           sprintf(ButtonStrings[1][0], "  %c ", var);
-           sprintf(ButtonStrings[1][1], "%d", yref);
-           goto ReDisplayImage;
-        case key_z: 
-           var = 'z'; 
-           sprintf(ButtonStrings[1][0], "  %c ", var);
-           sprintf(ButtonStrings[1][1], "%d", zref);
-           goto ReDisplayImage;
-        case left:
-        case Left:
-          switch (selfield)
-	  {
-	  case FIELD_COOR:  
-           switch (var)
-	   {
-             case 'x': zref--; break;
-             case 'y': xref--; break;
-             case 'z': xref--; break;
-	   }
-           goto ReDisplayImage;
-	  case FIELD_TOLM: 
-           tolinf -= incrplan;
-           sprintf(ButtonStrings[2][2], "-%d", tolinf);
-           break;
-	  case FIELD_TOLP: 
-           tolsup -= incrplan; if (tolsup < 0) tolsup = 0;
-           sprintf(ButtonStrings[2][2], "+%d", tolsup);
-           break;
-	  } /* switch (selfield) */
-        case right:
-        case Right:
-           switch (var)
-	   {
-             case 'x': zref++; break;
-             case 'y': xref++; break;
-             case 'z': xref++; break;
-	   }
-           goto ReDisplayImage;
-        case up:
-        case Up:
-           switch (var)
-	   {
-             case 'x': yref--; break;
-             case 'y': zref--; break;
-             case 'z': yref--; break;
-	   }
-           goto ReDisplayImage;
-        case Down:
-        case down:
-           switch (var)
-	   {
-             case 'x': yref++; break;
-             case 'y': zref++; break;
-             case 'z': yref++; break;
-	   }
-           goto ReDisplayImage;
-      }
-
-    case ButtonPress:
-    break;
-
-    case ButtonRelease: goto NextEvent;
-
-    case EnterNotify: goto ReDisplay;
-
-    default: printf("type : %d ; x = %d ; y = %d\n", eventtype, xx, yy); break;
-
-  } /* switch(eventtype) */
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight))
-  {  /* click dans l'image "principale" */
-    if (zoom)
-    {
-      xx /= 2;
-      yy /= 2;
-    }
-    xclick = xx; yclick = yy; zclick = zref;  
-    x = zclick * n + yclick * rs + xclick;
-    sprintf(coordclickstring, "%d,%d,%d", xclick, yclick, zclick);
-    sprintf(valclickstring, "%d", SOURCE[x]);
-    
-    goto ReDisplayImage;
-  } /* if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight)) */
-  else
-  if ((xx >= ImageWidth+MARGE) && (yy >= 0) && 
-      (xx < ImageWidth+MARGE+ImageRightWidth) && (yy < ImageHeight))
-  {  /* click dans l'image "droite" */
-    xx -= (ImageWidth+MARGE);
-    if (zoom)
-    {
-      xx /= 2;
-      yy /= 2;
-    }
-    xclick = xref; yclick = yy; zclick = xx;  
-    x = zclick * n + yclick * rs + xclick;
-    sprintf(coordclickstring, "%d,%d,%d", xclick, yclick, zclick);
-    sprintf(valclickstring, "%d", SOURCE[x]);
-    
-    goto ReDisplayImage;
-  }
-  else
-  if ((xx >= 0) && (yy >= ImageHeight+MARGE) && 
-      (xx < ImageWidth) && (yy < ImageHeight+MARGE+ImageBottomHeight))
-  {  /* click dans l'image "bas" */
-    yy -= (ImageHeight+MARGE);
-    if (zoom)
-    {
-      xx /= 2;
-      yy /= 2;
-    }
-    xclick = xx; yclick = yref; zclick = yy;  
-    x = zclick * n + yclick * rs + xclick;
-    sprintf(coordclickstring, "%d,%d,%d", xclick, yclick, zclick);
-    sprintf(valclickstring, "%d", SOURCE[x]);
-    
-    goto ReDisplayImage;
-  }
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImagePannelWidth) && (yy < ImagePannelHeight))
-    goto ReDisplayImage;
-
-  xx /= BoxWidth;
-  yy -= ImagePannelHeight;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: /* bouton LABEL */
-                      LAB[*nlabs] = zclick * n + yclick * rs + xclick;
-                      VLAB[*nlabs] = curlab;
-                      *nlabs += 1;
-                      if (incr)
-                      {
-                        curlab++;
-                        sprintf(ButtonStrings[0][1], "%d", curlab);
-                      }
-                      goto ReDisplayImage;
-              case 1: break;
-              case 2: curlab++;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 3: curlab--;
-                      if (curlab < 1) curlab = 1;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 4: if (incr) 
-                      {
-                        incr = 0; 
-                        sprintf(ButtonStrings[0][4], "%s", "INCR ");
-		      }
-                      else
-		      { 
-                        incr = 1;
-                        sprintf(ButtonStrings[0][4], "%s", "IDEM ");
-		      }
-                      break;
-              case 5: *nlabs = 0;
-                      goto ReDisplayImage;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: selfield = FIELD_COOR;
-                      if (var == 'x') var = 'y'; 
-                      else if (var == 'y') var = 'z'; 
-                      else if (var == 'z') var = 'x'; 
-                      sprintf(ButtonStrings[1][0], "  %c ", var);
-                      if (var == 'x') 
-                        sprintf(ButtonStrings[1][1], "%d", xref);
-		      else if (var == 'y') 
-                        sprintf(ButtonStrings[1][1], "%d", yref);
-		      else if (var == 'z') 
-                        sprintf(ButtonStrings[1][1], "%d", zref);
-                      goto ReDisplayImage;
-              case 1: break;
-              case 2: if (var == 'x') 
-                      {
-                        xref += incrplan;
-                        if (xref > rs-1) xref = rs-1;
-                        sprintf(ButtonStrings[1][1], "%d", xref);
-		      } else
-                      if (var == 'y') 
-                      {
-                        yref += incrplan;
-                        if (yref > cs-1) yref = cs-1;
-                        sprintf(ButtonStrings[1][1], "%d", yref);
-		      } else
-                      if (var == 'z') 
-                      {
-                        zref += incrplan;
-                        if (zref > d-1) zref = d-1;
-                        sprintf(ButtonStrings[1][1], "%d", zref);
-		      }
-                      goto ReDisplayImage;
-              case 3: if (var == 'x') 
-                      {
-                        xref -= incrplan;
-                        if (xref < 0) xref = 0;
-                        sprintf(ButtonStrings[1][1], "%d", xref);
-		      } else
-                      if (var == 'y') 
-                      {
-                        yref -= incrplan;
-                        if (yref < 0) yref = 0;
-                        sprintf(ButtonStrings[1][1], "%d", yref);
-		      } else
-                      if (var == 'z') 
-                      {
-                        zref -= incrplan;
-                        if (zref < 0) zref = 0;
-                        sprintf(ButtonStrings[1][1], "%d", zref);
-		      }
-                      goto ReDisplayImage;
-              case 4: if (incrplan == 1) incrplan = 5; else incrplan += 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplay;
-              case 5: if (incrplan == 5) incrplan = 1; else if (incrplan > 5) incrplan -= 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplay;
-              case 6: if (spot) spot = 0; else spot = 1;
-                      goto ReDisplayImage;
-            } /* switch(xx) */
-            break;
-    case 2: switch(xx)
-            {
-              case 0: Propagate(SOURCE, PROPAG, rs, n, N, connex, 
-                                infrange, suprange, tolinf, tolsup, radius);
-                      goto ReDisplayImage;
-              case 1: SetRange(SOURCE, rs, n, xref, yref, zref, 
-                               xclick, yclick, zclick, &infrange, &suprange);
-                      InitPropag(PROPAG, rs, n, xref, yref, zref, xclick, yclick, zclick);
-                      sprintf(valrangestring, "%d-%d", infrange-tolinf, suprange+tolsup);
-                      goto ReDisplayImage;
-              case 2: selfield = FIELD_TOLM;
-                      if (button == MC_LEFTBUTTON) tolinf++; else tolinf+=10;
-                      sprintf(ButtonStrings[2][2], "-%d", tolinf);
-                      break;
-              case 3: selfield = FIELD_TOLP;
-                      if (button == MC_LEFTBUTTON) tolsup++; else tolsup+=10;
-                      sprintf(ButtonStrings[2][3], "+%d", tolsup);
-                      break;
-              case 4: selfield = FIELD_RAD;
-                      if (button == MC_LEFTBUTTON) radius++; else radius+=10;
-                      sprintf(ButtonStrings[2][4], "R%d", radius);
-                      break;
-
-
-              case 5: memset(PROPAG, VAL_NULLE, N);
-                      suprange = -1;
-                      valrangestring[0] = '\0';
-                      radius = tolinf = tolsup = 0;
-                      sprintf(ButtonStrings[2][2], "-%d", tolinf);
-                      sprintf(ButtonStrings[2][3], "+%d", tolsup);
-                      sprintf(ButtonStrings[2][4], "R%d", radius);
-                      goto ReDisplayImage;
-              case 6: writeimage(propag, "propag.pgm");
-                      break;
-            } /* switch(xx) */
-            break;
-    default: goto ReDisplayImage;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-  freeimage(propag);
-
-  return(1);
-} /* lclick3d() */
-
diff -r 8b1af7363833 src/lib/lclick.c.sav1
--- a/src/lib/lclick.c.sav1	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1221 +0,0 @@
-/* 
-   Operateur interactif de visualisation 2D et 3D
-   et de specification de marqueurs
-
-   Michel Couprie - decembre 1999
-
-   Versions definies dans ce fichier:
-
-     lclick2d : genere un tableau image labels au format pgm (long) - permet des labels differents
-     lclicklist : genere une liste de points values
-     lclick3d : idem lclicklist, avec 3 vues 
-*/
-
-#include <stdio.h>
-#include <mcutil.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcxbib.h>
-#include <lclick.h>
-
-/* ==================================== */
-int lclick2d(struct xvimage *image, struct xvimage *lab, int zoom)
-/* ==================================== */
-{
-  register int x;              /* index muet de pixel */
-  int i, k;
-  int rs = rowsize(image);     /* taille ligne */
-  int cs = colsize(image);     /* taille colonne */
-  int n = rs * cs;             /* taille plan */
-  int d = depth(image);        /* nb. plans */
-  int N = d * n;               /* taille image */
-  unsigned char *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  unsigned long *LAB = ULONGDATA(lab);
-  int curlab = 1;
-  int incr = 0;
-  int iplan = 0;
-  int incrplan = 1;
-#define NBBUTTONS 7
-#define NBLIGBUTT 2
-#define BOXWIDTH 70
-#define BOXHEIGHT 20
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int xx, yy;
-  int BoxWidth = BOXWIDTH;
-  int BoxHeight = BOXHEIGHT;
-  int Height = cs + BoxHeight * NBLIGBUTT;
-  int Width = rs;
-  int ImageHeight = cs;
-  int ImageWidth = rs;
-  char *name1, *name;          /* pour les noms des images originale et resultat */
-  int eventtype;
-
-  if (zoom)
-  {
-    Height += cs;
-    Width += rs;
-    ImageHeight += cs;
-    ImageWidth += rs;
-  }
-
-  if (BoxWidth * NBBUTTONS > Width) Width = BoxWidth * NBBUTTONS;
-  
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)malloc(16);
-
-  strcpy(ButtonStrings[0][0], "LABEL");
-  sprintf(ButtonStrings[0][1], "%d", curlab);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "INCR ");
-  strcpy(ButtonStrings[0][5], "UNDO ");
-  strcpy(ButtonStrings[0][6], "QUIT ");
-
-  strcpy(ButtonStrings[1][0], " PLAN");
-  sprintf(ButtonStrings[1][1], "%d", iplan);
-  sprintf(ButtonStrings[1][2], " +%d", incrplan);
-  sprintf(ButtonStrings[1][3], " -%d", incrplan);
-  strcpy(ButtonStrings[1][4], "  ++ ");
-  strcpy(ButtonStrings[1][5], "  -- ");
-  strcpy(ButtonStrings[1][6], "     ");
-
-/* ===========================================================
-    affichage : 
-   ===========================================================
-
-    <------- rs ------>     
-    ------------------- .
-    |                 | .
-    |                 | .
-    |                 | .
-    |      image      | cs
-    |                 | .
-    |                 | .
-    |                 | .
-    --------------------------------------------------
-    |LABEL | 111  |  +   |  -   | AUTO | UNDO | QUIT |        BoxHeight
-    --------------------------------------------------
-    | PLAN | 111  | +1   | -1   |  ++  |  --  |      |        BoxHeight
-    --------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-ReDisplayImage:
-
-  /* send output to the screen */
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-  {
-    if (LAB[x])    
-      Color(MC_RED);
-    else
-      Color(SOURCE[x]/4);
-    if (zoom)
-    {
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point((x%n)%rs, (x%n)/rs);
-  }
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, ImageHeight + i*BoxHeight, k*BoxWidth, ImageHeight + (i+1)*BoxHeight);
-      String(k * BoxWidth + 3, ImageHeight + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  FlushGraphics();  
-
-NextEvent:
-  eventtype = WaitEvent(&xx, &yy);
-  switch(eventtype)
-  {
-    case KeyPress: 
-      switch(xx)
-      {
-        case key_q: goto Terminate;
-      }
-
-    case ButtonPress:
-    break;
-
-    case ButtonRelease: goto NextEvent;
-
-    case EnterNotify: goto ReDisplay;
-
-    default: printf("type : %d ; x = %d ; y = %d\n", eventtype, xx, yy); break;
-
-  } /* switch(eventtype) */
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight))
-  {
-    if (zoom)
-    {
-      xx /= 2;
-      yy /= 2;
-    }
-    x = iplan * n + yy * rs + xx;
-
-    if (LAB[x]) 
-    {
-      LAB[x] = 0;
-    }
-    else
-    {
-      LAB[x] = curlab;
-      if (incr) 
-      {
-        curlab++;
-        sprintf(ButtonStrings[0][1], "%d", curlab);
-      }
-    }
-    if (LAB[x])    
-      Color(MC_RED);
-    else
-      Color(SOURCE[x]/4);
-    if (zoom)
-    {
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point((x%n)%rs, (x%n)/rs);
-    goto ReDisplay;
-  }
-
-  xx /= BoxWidth;
-  yy -= ImageHeight;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: curlab++;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 3: curlab--;
-                      if (curlab < 1) curlab = 1;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 4: if (incr) 
-                      {
-                        incr = 0; 
-                        sprintf(ButtonStrings[0][4], "%s", "INCR ");
-		      }
-                      else
-		      { 
-                        incr = 1;
-                        sprintf(ButtonStrings[0][4], "%s", "IDEM ");
-		      }
-                      break;
-              case 5: for (x = 0; x < N; x++) LAB[x] = 0;
-                      goto ReDisplayImage;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: iplan++;
-                      if (iplan > d-1) iplan = d-1;
-                      sprintf(ButtonStrings[1][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 3: iplan--;
-                      if (iplan < 0) iplan = 0;
-                      sprintf(ButtonStrings[1][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 4: if (incrplan == 1) incrplan = 5; else incrplan += 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplayImage;
-              case 5: if (incrplan == 5) incrplan = 1; else if (incrplan > 5) incrplan -= 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplayImage;
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    default: goto ReDisplayImage;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-
-  /* ---------------------------------------------------------- */
-  /* fabrique le nom de l'image resultat */
-  /* ---------------------------------------------------------- */
-
-  name1 = image->name; 
-  if (name1 == NULL) name1 = "?";
-  name = (char *)malloc(strlen(name1) + strlen("click2d()") + 1);
-  if (name == NULL)
-  {   fprintf(stderr,"click2d() : malloc failed for name\n");
-      return 0;
-  }
-  strcpy(name, "click2d(");
-  strcat(name, name1);
-  strcat(name, ")");
-  if (name1 != NULL) free(lab->name);
-  lab->name = name;
-
-  return(1);
-} /* lclick2d() */
-
-/* ==================================== */
-int lclicklist(struct xvimage *image, unsigned long *LAB, long *VLAB, int *nlabs, int zoom)
-/* ==================================== */
-{
-  register int x;              /* index muet de pixel */
-  int i, k;
-  int rs = rowsize(image);     /* taille ligne */
-  int cs = colsize(image);     /* taille colonne */
-  int n = rs * cs;             /* taille plan */
-  int d = depth(image);        /* nb. plans */
-  int N = d * n;               /* taille image */
-  unsigned char *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  int curlab = 1;
-  int incr = 0;
-  int iplan = 0;
-  int incrplan = 1;
-#define NBBUTTONS 7
-#define NBLIGBUTT 2
-#define BOXWIDTH 70
-#define BOXHEIGHT 20
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int xx, yy;
-  int BoxWidth = BOXWIDTH;
-  int BoxHeight = BOXHEIGHT;
-  int Height = cs + BoxHeight * NBLIGBUTT;
-  int Width = rs;
-  int ImageHeight = cs;
-  int ImageWidth = rs;
-  char *name1, *name;          /* pour les noms des images originale et resultat */
-  int eventtype;
-
-  *nlabs = 0;
-
-  if (zoom)
-  {
-    Height += cs;
-    Width += rs;
-    ImageHeight += cs;
-    ImageWidth += rs;
-  }
-
-  if (BoxWidth * NBBUTTONS > Width) Width = BoxWidth * NBBUTTONS;
-  
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)malloc(16);
-
-  strcpy(ButtonStrings[0][0], "LABEL");
-  sprintf(ButtonStrings[0][1], "%d", curlab);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "INCR ");
-  strcpy(ButtonStrings[0][5], "UNDO ");
-  strcpy(ButtonStrings[0][6], "QUIT ");
-
-  strcpy(ButtonStrings[1][0], " PLAN");
-  sprintf(ButtonStrings[1][1], "%d", iplan);
-  sprintf(ButtonStrings[1][2], " +%d", incrplan);
-  sprintf(ButtonStrings[1][3], " -%d", incrplan);
-  strcpy(ButtonStrings[1][4], "  ++ ");
-  strcpy(ButtonStrings[1][5], "  -- ");
-  strcpy(ButtonStrings[1][6], "     ");
-
-/* ===========================================================
-    affichage : 
-   ===========================================================
-
-    <------- rs ------>     
-    ------------------- .
-    |                 | .
-    |                 | .
-    |                 | .
-    |      image      | cs
-    |                 | .
-    |                 | .
-    |                 | .
-    --------------------------------------------------
-    |LABEL | 111  |  +   |  -   | AUTO | UNDO | QUIT |        BoxHeight
-    --------------------------------------------------
-    | PLAN | 111  | +1   | -1   |  ++  |  --  |      |        BoxHeight
-    --------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-ReDisplayImage:
-
-  /* send output to the screen */
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-  {
-    for (i = 0; i < *nlabs; i++) /* devient lourd s'il y a beaucoup de points ... */
-      if (LAB[i] == x) break;
-    if (i < *nlabs)
-      Color(MC_RED);
-    else
-      Color(SOURCE[x]/4);
-    if (zoom)
-    {
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point((x%n)%rs, (x%n)/rs);
-  }
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, ImageHeight + i * BoxHeight, k * BoxWidth, ImageHeight + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, ImageHeight + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  FlushGraphics();  
-
-NextEvent:
-  eventtype = WaitEvent(&xx, &yy);
-  switch(eventtype)
-  {
-    case KeyPress: 
-      switch(xx)
-      {
-        case key_q: goto Terminate;
-      }
-
-    case ButtonPress:
-    break;
-
-    case ButtonRelease: goto NextEvent;
-
-    case EnterNotify: goto ReDisplay;
-
-    default: printf("type : %d ; x = %d ; y = %d\n", eventtype, xx, yy); break;
-
-  } /* switch(eventtype) */
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight))
-  {
-    if (zoom)
-    {
-      xx /= 2;
-      yy /= 2;
-    }
-    x = iplan * n + yy * rs + xx;
-
-    LAB[*nlabs] = x;
-    VLAB[*nlabs] = curlab;
-    if (incr) 
-    {
-      curlab++;
-      sprintf(ButtonStrings[0][1], "%d", curlab);
-    }
-    *nlabs += 1;
-
-    Color(MC_RED);
-    if (zoom)
-    {
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point((x%n)%rs, (x%n)/rs);
-    goto ReDisplay;
-  }
-
-  xx /= BoxWidth;
-  yy -= ImageHeight;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: curlab++;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 3: curlab--;
-                      if (curlab < 1) curlab = 1;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 4: if (incr) 
-                      {
-                        incr = 0; 
-                        sprintf(ButtonStrings[0][4], "%s", "INCR ");
-		      }
-                      else
-		      { 
-                        incr = 1;
-                        sprintf(ButtonStrings[0][4], "%s", "IDEM ");
-		      }
-                      break;
-              case 5: *nlabs = 0;
-                      goto ReDisplayImage;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: iplan += incrplan;
-                      if (iplan > d-1) iplan = d-1;
-                      sprintf(ButtonStrings[1][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 3: iplan -= incrplan;
-                      if (iplan < 0) iplan = 0;
-                      sprintf(ButtonStrings[1][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 4: if (incrplan == 1) incrplan = 5; else incrplan += 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplayImage;
-              case 5: if (incrplan == 5) incrplan = 1; else if (incrplan > 5) incrplan -= 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplayImage;
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    default: goto ReDisplayImage;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-
-  return(1);
-} /* lclicklist() */
-
-/* ==================================== */
-int lclick3d(struct xvimage *image, unsigned long *LAB, long *VLAB, int *nlabs, int zoom)
-/* ==================================== */
-{
-  register int x, y, z;        /* index muet */
-  int i, k;
-  int rs = rowsize(image);     /* taille ligne */
-  int cs = colsize(image);     /* taille colonne */
-  int n = rs * cs;             /* taille plan */
-  int d = depth(image);        /* nb. plans */
-  int N = d * n;               /* taille image */
-  unsigned char *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  int curlab = 1;
-  int incr = 0;
-  int incrplan = 1;
-#define NBBUTTONS  7
-#define NBLIGBUTT  2
-#define BOXWIDTH  70
-#define BOXHEIGHT 20
-#define MARGE     10
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int xx, yy;
-  int xref = rs / 2;
-  int yref = cs / 2;
-  int zref = d / 2;
-  int xclick = xref;
-  int yclick = yref;
-  int zclick = zref;
-  char var = 'z';
-  int eventtype;
-  int spot = 1;
-  char coordrefstring[128];
-  char coordclickstring[128];
-  char valclickstring[128];
-  int BoxWidth = BOXWIDTH;
-  int BoxHeight = BOXHEIGHT;
-  /* dimensions totales */
-  int Height = cs + MARGE + d + BoxHeight * NBLIGBUTT;
-  int Width = rs + MARGE + d;
-  /* dimensions du panneau image */
-  int ImagePannelHeight = cs + MARGE + d;
-  int ImagePannelWidth = rs + MARGE + d;
-  /* dimensions image "centrale" */
-  int ImageHeight = cs;
-  int ImageWidth = rs;  
-  /* dimensions image "droite" */
-  int ImageRightWidth = d;  
-  /* dimensions image "bas" */
-  int ImageBottomHeight = d;
-
-  char *name1, *name;          /* pour les noms des images originale et resultat */
-
-  coordclickstring[0] = '\0';
-  valclickstring[0] = '\0';
-
-  *nlabs = 0;
-
-  if (zoom)
-  {
-    Height += cs + d;
-    Width += rs + d;
-    ImagePannelHeight += cs + d;
-    ImagePannelWidth += rs + d;
-    ImageHeight += cs;
-    ImageWidth += rs;
-    ImageBottomHeight += d;
-    ImageRightWidth += d;
-  }
-
-  if (BoxWidth * NBBUTTONS > Width) Width = BoxWidth * NBBUTTONS;
-  
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)malloc(16);
-
-  strcpy(ButtonStrings[0][0], "LABEL");
-  sprintf(ButtonStrings[0][1], "%d", curlab);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "INCR ");
-  strcpy(ButtonStrings[0][5], "UNDO ");
-  strcpy(ButtonStrings[0][6], "QUIT ");
-
-  sprintf(ButtonStrings[1][0], "  %c ", 'z');
-  sprintf(ButtonStrings[1][1], "%d", zref);
-  sprintf(ButtonStrings[1][2], " +%d", incrplan);
-  sprintf(ButtonStrings[1][3], " -%d", incrplan);
-  strcpy(ButtonStrings[1][4], "  ++ ");
-  strcpy(ButtonStrings[1][5], "  -- ");
-  strcpy(ButtonStrings[1][6], "SPOT ");
-
-/* ===========================================================
-    affichage : 
-   ===========================================================
-
-    <------- rs ------>      <---- d ---->
-    ------------------- ^    -------------
-    |                 | .    |           |
-    |                 | .    |           |
-    |                 | .    |           |
-    |      image      | cs   |           |
-    |                 | .    |           |
-    |                 | .    |           |
-    |                 | .    |           |
-    ------------------- v    -------------
-    ------------------- ^
-    |                 | .     1,2,3
-    |                 | d
-    |                 | .
-    |                 | .
-    ------------------- v  
-    --------------------------------------------------
-    |LABEL | 111  |  +   |  -   | AUTO | UNDO | QUIT |        BoxHeight
-    --------------------------------------------------
-    |  z   | 111  | +1   | -1   |  ++  |  --  | SPOT |        BoxHeight
-    --------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-ReDisplayImage:
-
-  /* send output to the screen */
-
-  /* ================================================================= */
-  /* image "centrale" (projection x,y) */
-  /* ================================================================= */
-  if (zoom)
-  {
-    for (y = 0; y < cs; y++) for (x = 0; x < rs; x++)
-    {
-      Color(SOURCE[zref * n + y * rs + x]/4);
-      Rectangle(2*x, 2*y, 1, 1);
-    }
-  } /* if (zoom) */
-  else
-    for (y = 0; y < cs; y++) for (x = 0; x < rs; x++)
-    {
-      Color(SOURCE[zref * n + y * rs + x]/4);
-      Point(x, y);
-    }
-
-  Color(MC_RED);
-  x = xref;
-  if (var == 'x')
-  {
-    if (zoom)
-    {
-      for (y = 0; y < cs; y++)
-        Rectangle(2*x, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-      for (y = 0; y < cs; y++)
-        Point(x, y);
-  } /* if (var == 'x') */
-  else
-  {
-    if (zoom)
-    {
-      for (y = 0; y < 5; y++) Rectangle(2*x, 2*y, 1, 1);
-      for (y = cs - 5; y < cs; y++) Rectangle(2*x, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (y = 0; y < 5; y++) Point(x, y);
-      for (y = cs - 5; y < cs; y++) Point(x, y);
-    }
-  } /* else if (var == 'x') */
-
-  y = yref;
-  if (var == 'y')
-  {
-    if (zoom)
-    {
-      for (x = 0; x < rs; x++)
-        Rectangle(2*x, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-      for (x = 0; x < rs; x++)
-        Point(x, y);
-  } /* if (var == 'x') */
-  else
-  {
-    if (zoom)
-    {
-      for (x = 0; x < 5; x++) Rectangle(2*x, 2*y, 1, 1);
-      for (x = rs - 5; x < rs; x++) Rectangle(2*x, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (x = 0; x < 5; x++) Point(x, y);
-      for (x = rs - 5; x < rs; x++) Point(x, y);
-    }
-  } /* else if (var == 'y') */
-
-  Color(MC_GREEN);
-  for (i = 0; i < *nlabs; i++) 
-    if (LAB[i] / n == zref)
-    {
-      if (zoom)
-        Rectangle(2*(LAB[i]%rs), 2*((LAB[i]%n)/rs), 1, 1);
-      else
-        Point((LAB[i]%rs), ((LAB[i]%n)/rs));
-    }
-
-  if (spot)
-  {
-    if (zoom)
-    {
-      Rectangle(2*xref - 10, 2 * yref, 20, 1);
-      Rectangle(2*xref, 2 * yref - 10, 1, 20);
-    }
-    else
-    {
-      Line(xref - 5, yref, xref + 5, yref);
-      Line(xref, yref - 5, xref, yref + 5);
-    }
-  }
-
-  /* ================================================================= */
-  /* image droite (projection y,z) */
-  /* ================================================================= */
-  if (zoom)
-  {
-    for (y = 0; y < cs; y++) for (z = 0; z < d; z++)
-    {
-      Color(SOURCE[z * n + y * rs + xref]/4);
-      Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-    }
-  } /* if (zoom) */
-  else
-    for (y = 0; y < cs; y++) for (z = 0; z < d; z++)
-    {
-      Point(ImageWidth + MARGE + z, y);
-      Color(SOURCE[z * n + y * rs + xref]/4);
-    }
-
-  Color(MC_RED);
-  z = zref;
-  if (var == 'z')
-  {
-    if (zoom)
-    {
-      for (y = 0; y < cs; y++)
-        Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-      for (y = 0; y < cs; y++)
-        Point(ImageWidth + MARGE + z, y);
-  } /* if (var == 'z') */
-  else
-  {
-    if (zoom)
-    {
-      for (y = 0; y < 5; y++) Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-      for (y = cs - 5; y < cs; y++) Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (y = 0; y < 5; y++) Point(ImageWidth + MARGE + z, y);
-      for (y = cs - 5; y < cs; y++) Point(ImageWidth + MARGE + z, y);
-    }
-  } /* else if (var == 'z') */
-
-  y = yref;
-  if (var == 'y')
-  {
-    if (zoom)
-    {
-      for (z = 0; z < d; z++)
-        Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (z = 0; z < d; z++)
-        Point(ImageWidth + MARGE + z, y);
-    }
-  } /* if (var == 'y') */
-  else
-  {
-    if (zoom)
-    {
-      for (z = 0; z < 5; z++) Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-      for (z = d-5; z < d; z++) Rectangle(ImageWidth + MARGE + 2*z, 2*y, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (z = 0; z < 5; z++) Point(ImageWidth + MARGE + z, y);
-      for (z = d-5; z < d; z++) Point(ImageWidth + MARGE + z, y);
-    }
-  } /* else if (var == 'y') */
-
-  Color(MC_GREEN);
-  for (i = 0; i < *nlabs; i++) 
-    if (LAB[i] % rs == xref)
-    {
-      if (zoom)
-        Rectangle(ImageWidth + MARGE + 2*(LAB[i]/n), 2*((LAB[i]%n)/rs), 1, 1);
-      else
-        Point(ImageWidth + MARGE + (LAB[i]/n), ((LAB[i]%n)/rs));
-    }
-
-  if (spot)
-  {
-    if (zoom)
-    {
-      Rectangle(ImageWidth + MARGE + 2*zref - 10, 2 * yref, 20, 1);
-      Rectangle(ImageWidth + MARGE + 2*zref, 2 * yref - 10, 1, 20);
-    }
-    else
-    {
-      Line(ImageWidth + MARGE + zref - 5, yref, ImageWidth + MARGE + zref + 5, yref);
-      Line(ImageWidth + MARGE + zref, yref - 5, ImageWidth + MARGE + zref, yref + 5);
-    }
-  }
-
-  /* ================================================================= */
-  /* image bas (projection x,z) */
-  /* ================================================================= */
-  if (zoom)
-  {
-    for (x = 0; x < rs; x++) for (z = 0; z < d; z++)
-    {
-      Color(SOURCE[z * n + yref * rs + x]/4);
-      Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-    }
-  } /* if (zoom) */
-  else
-    for (x = 0; x < rs; x++) for (z = 0; z < d; z++)
-    {
-      Color(SOURCE[z * n + yref * rs + x]/4);
-      Point(x, ImageHeight + MARGE + z);
-    }
-
-  Color(MC_RED);
-  x = xref;
-  if (var == 'x')
-  {
-    if (zoom)
-    {
-      for (z = 0; z < d; z++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (z = 0; z < d; z++) Point(x, ImageHeight + MARGE + z);
-    }
-  } /* if (var == 'x') */
-  else
-  {
-    if (zoom)
-    {
-      for (z = 0; z < 5; z++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-      for (z = d-5; z < d; z++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (z = 0; z < 5; z++) Point(x, ImageHeight + MARGE + z);
-      for (z = d-5; z < d; z++) Point(x, ImageHeight + MARGE + z);
-    }
-  } /* else if (var == 'x') */
-
-  z = zref;
-  if (var == 'z')
-  {
-    if (zoom)
-    {
-      for (x = 0; x < rs; x++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (x = 0; x < rs; x++) Point(x, ImageHeight + MARGE + z);
-    }
-  } /* if (var == 'z') */
-  else
-  {
-    if (zoom)
-    {
-      for (x = 0; x < 5; x++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-      for (x = rs-5; x < rs; x++) Rectangle(2*x, ImageHeight + MARGE + 2*z, 1, 1);
-    } /* if (zoom) */
-    else
-    {
-      for (x = 0; x < 5; x++) Point(x, ImageHeight + MARGE + z);
-      for (x = rs-5; x < rs; x++) Point(x, ImageHeight + MARGE + z);
-    }
-  } /* else if (var == 'z') */
-
-  Color(MC_GREEN);
-  for (i = 0; i < *nlabs; i++) 
-    if ((LAB[i] % n) / rs == yref)
-    {
-      if (zoom)
-        Rectangle(2*(LAB[i]%rs), ImageHeight + MARGE + 2*(LAB[i]/n), 1, 1);
-      else
-        Point((LAB[i]%rs), ImageHeight + MARGE + (LAB[i]/n));
-    }
-
-  if (spot)
-  {
-    if (zoom)
-    {
-      Rectangle(2*xref - 10, ImageHeight + MARGE + 2 * zref, 20, 1);
-      Rectangle(2*xref, ImageHeight + MARGE + 2 * zref - 10, 1, 20);
-    }
-    else
-    {
-      Line(xref - 5, ImageHeight + MARGE + zref, xref + 5, ImageHeight + MARGE + zref);
-      Line(xref, ImageHeight + MARGE + zref - 5, xref, ImageHeight + MARGE + zref + 5);
-    }
-  }
-
-  ColToBlack();
-  FRectangle(ImageWidth, ImageHeight, 
-    max(ImagePannelWidth,Width) - ImageWidth, ImagePannelHeight - ImageHeight);
-  ColToWhite();
-  sprintf(coordrefstring, "%d,%d,%d", xref, yref, zref);
-  String(ImageWidth + 2 * MARGE, ImageHeight + BoxHeight + MARGE, coordrefstring);
-  String(ImageWidth + 2 * MARGE, ImageHeight+(2*BoxHeight) + MARGE, coordclickstring);
-  String(ImageWidth + 2 * MARGE, ImageHeight+(3*BoxHeight) + MARGE, valclickstring);
-
-  /* ================================================================= */
-  /* ================================================================= */
-ReDisplay:
-  /* ================================================================= */
-  /* ================================================================= */
-
-  ColToWhite();
-  FRectangle(0, ImagePannelHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImagePannelHeight + i * BoxHeight, Width, ImagePannelHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, ImagePannelHeight + i * BoxHeight, k * BoxWidth, ImagePannelHeight + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, ImagePannelHeight + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  FlushGraphics();  
-
-NextEvent:
-  eventtype = WaitEvent(&xx, &yy);
-  switch(eventtype)
-  {
-    case KeyPress: 
-      switch(xx)
-      {
-        case key_q: goto Terminate;
-        case key_r: xref = xclick; yref = yclick; zref = zclick; goto ReDisplayImage;
-        case key_x: 
-           var = 'x'; 
-           sprintf(ButtonStrings[1][0], "  %c ", var);
-           sprintf(ButtonStrings[1][1], "%d", xref);
-           goto ReDisplayImage;
-        case key_y: 
-           var = 'y'; 
-           sprintf(ButtonStrings[1][0], "  %c ", var);
-           sprintf(ButtonStrings[1][1], "%d", yref);
-           goto ReDisplayImage;
-        case key_z: 
-           var = 'z'; 
-           sprintf(ButtonStrings[1][0], "  %c ", var);
-           sprintf(ButtonStrings[1][1], "%d", zref);
-           goto ReDisplayImage;
-        case left:
-        case Left:
-           switch (var)
-	   {
-             case 'x': zref--; break;
-             case 'y': xref--; break;
-             case 'z': xref--; break;
-	   }
-           goto ReDisplayImage;
-        case right:
-        case Right:
-           switch (var)
-	   {
-             case 'x': zref++; break;
-             case 'y': xref++; break;
-             case 'z': xref++; break;
-	   }
-           goto ReDisplayImage;
-        case up:
-        case Up:
-           switch (var)
-	   {
-             case 'x': yref--; break;
-             case 'y': zref--; break;
-             case 'z': yref--; break;
-	   }
-           goto ReDisplayImage;
-        case Down:
-        case down:
-           switch (var)
-	   {
-             case 'x': yref++; break;
-             case 'y': zref++; break;
-             case 'z': yref++; break;
-	   }
-           goto ReDisplayImage;
-      }
-
-    case ButtonPress:
-    break;
-
-    case ButtonRelease: goto NextEvent;
-
-    case EnterNotify: goto ReDisplay;
-
-    default: printf("type : %d ; x = %d ; y = %d\n", eventtype, xx, yy); break;
-
-  } /* switch(eventtype) */
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight))
-  {  /* click dans l'image "principale" */
-    if (zoom)
-    {
-      xx /= 2;
-      yy /= 2;
-    }
-    xclick = xx; yclick = yy; zclick = zref;  
-    x = zclick * n + yclick * rs + xclick;
-    sprintf(coordclickstring, "%d,%d,%d", xclick, yclick, zclick);
-    sprintf(valclickstring, "%d", SOURCE[x]);
-    
-    goto ReDisplayImage;
-  } /* if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight)) */
-  else
-  if ((xx >= ImageWidth+MARGE) && (yy >= 0) && 
-      (xx < ImageWidth+MARGE+ImageRightWidth) && (yy < ImageHeight))
-  {  /* click dans l'image "droite" */
-    xx -= (ImageWidth+MARGE);
-    if (zoom)
-    {
-      xx /= 2;
-      yy /= 2;
-    }
-    xclick = xref; yclick = yy; zclick = xx;  
-    x = zclick * n + yclick * rs + xclick;
-    sprintf(coordclickstring, "%d,%d,%d", xclick, yclick, zclick);
-    sprintf(valclickstring, "%d", SOURCE[x]);
-    
-    goto ReDisplayImage;
-  }
-  else
-  if ((xx >= 0) && (yy >= ImageHeight+MARGE) && 
-      (xx < ImageWidth) && (yy < ImageHeight+MARGE+ImageBottomHeight))
-  {  /* click dans l'image "bas" */
-    yy -= (ImageHeight+MARGE);
-    if (zoom)
-    {
-      xx /= 2;
-      yy /= 2;
-    }
-    xclick = xx; yclick = yref; zclick = yy;  
-    x = zclick * n + yclick * rs + xclick;
-    sprintf(coordclickstring, "%d,%d,%d", xclick, yclick, zclick);
-    sprintf(valclickstring, "%d", SOURCE[x]);
-    
-    goto ReDisplayImage;
-  }
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImagePannelWidth) && (yy < ImagePannelHeight))
-    goto ReDisplayImage;
-
-  xx /= BoxWidth;
-  yy -= ImagePannelHeight;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: LAB[*nlabs] = zref * n + yref * rs + xref;
-                      VLAB[*nlabs] = curlab;
-                      *nlabs += 1;
-                      if (incr)
-                      {
-                        curlab++;
-                        sprintf(ButtonStrings[0][1], "%d", curlab);
-                        goto ReDisplay;
-                      }
-                      break;
-              case 1: break;
-              case 2: curlab++;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 3: curlab--;
-                      if (curlab < 1) curlab = 1;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 4: if (incr) 
-                      {
-                        incr = 0; 
-                        sprintf(ButtonStrings[0][4], "%s", "INCR ");
-		      }
-                      else
-		      { 
-                        incr = 1;
-                        sprintf(ButtonStrings[0][4], "%s", "IDEM ");
-		      }
-                      break;
-              case 5: *nlabs = 0;
-                      goto ReDisplayImage;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: if (var == 'x') var = 'y'; 
-                      else if (var == 'y') var = 'z'; 
-                      else if (var == 'z') var = 'x'; 
-                      sprintf(ButtonStrings[1][0], "  %c ", var);
-                      if (var == 'x') 
-                        sprintf(ButtonStrings[1][1], "%d", xref);
-		      else if (var == 'y') 
-                        sprintf(ButtonStrings[1][1], "%d", yref);
-		      else if (var == 'z') 
-                        sprintf(ButtonStrings[1][1], "%d", zref);
-                      goto ReDisplayImage;
-              case 1: break;
-              case 2: if (var == 'x') 
-                      {
-                        xref += incrplan;
-                        if (xref > rs-1) xref = rs-1;
-                        sprintf(ButtonStrings[1][1], "%d", xref);
-		      } else
-                      if (var == 'y') 
-                      {
-                        yref += incrplan;
-                        if (yref > cs-1) yref = cs-1;
-                        sprintf(ButtonStrings[1][1], "%d", yref);
-		      } else
-                      if (var == 'z') 
-                      {
-                        zref += incrplan;
-                        if (zref > d-1) zref = d-1;
-                        sprintf(ButtonStrings[1][1], "%d", zref);
-		      }
-                      goto ReDisplayImage;
-              case 3: if (var == 'x') 
-                      {
-                        xref -= incrplan;
-                        if (xref < 0) xref = 0;
-                        sprintf(ButtonStrings[1][1], "%d", xref);
-		      } else
-                      if (var == 'y') 
-                      {
-                        yref -= incrplan;
-                        if (yref < 0) yref = 0;
-                        sprintf(ButtonStrings[1][1], "%d", yref);
-		      } else
-                      if (var == 'z') 
-                      {
-                        zref -= incrplan;
-                        if (zref < 0) zref = 0;
-                        sprintf(ButtonStrings[1][1], "%d", zref);
-		      }
-                      goto ReDisplayImage;
-              case 4: if (incrplan == 1) incrplan = 5; else incrplan += 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplay;
-              case 5: if (incrplan == 5) incrplan = 1; else if (incrplan > 5) incrplan -= 5;
-                      sprintf(ButtonStrings[1][2], " +%d", incrplan);
-                      sprintf(ButtonStrings[1][3], " -%d", incrplan);
-                      goto ReDisplay;
-              case 6: if (spot) spot = 0; else spot = 1;
-                      goto ReDisplayImage;
-            } /* switch(xx) */
-            break;
-    default: goto ReDisplayImage;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-
-  return(1);
-} /* lclick3d() */
diff -r 8b1af7363833 src/lib/lcrop.c
--- a/src/lib/lcrop.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lcrop.c	Mon Jan 13 15:50:10 2014 +0100
@@ -434,7 +434,7 @@
 #undef F_NAME
 #define F_NAME "lenframe"
 {
-  index_t rs, cs, ds, ps, N, x, y, z, nb, n;
+  index_t rs, cs, ds, ps, N, x, y, nb, n;
   index_t rs2, cs2, ds2, ps2, N2;
   struct xvimage * imageout;
 
@@ -1073,3 +1073,110 @@
   if (ds == 1) return lcrop(in, xmin, ymin, w, h);
   else return lcrop3d(in, xmin, ymin, zmin, w, h, p);
 } // lautocrop()
+
+/* =============================================================== */
+void lautocrop2(struct xvimage *in, double seuil, index_t *Xmin, index_t *Ymin, index_t *Zmin, index_t *w, index_t *h, index_t *p)
+/* =============================================================== */
+#undef F_NAME
+#define F_NAME "lautocrop2"
+{
+  index_t x, y, z, n;
+  index_t xmin, xmax, ymin, ymax, zmin, zmax;
+  index_t rs, cs, ds, ps, N, nb;
+
+  assert(tsize(in) == 1);
+
+  rs = rowsize(in);
+  cs = colsize(in);
+  ps = rs * cs;
+  ds = depth(in);
+  N = ds * ps;
+  nb = nbands(in);
+  xmin = rs; xmax = 0; 
+  ymin = cs; ymax = 0; 
+  zmin = ds; zmax = 0; 
+
+  if (datatype(in) == VFF_TYP_1_BYTE)
+  {
+    uint8_t *I = UCHARDATA(in);
+    for (n = 0; n < nb; n++)
+    for (z = 0; z < ds; z++)
+    for (y = 0; y < cs; y++)
+    for (x = 0; x < rs; x++)
+      if ((double)(I[n*N + z*ps + y*rs + x]) > seuil)
+    {
+      if (z < zmin) zmin = z; if (z > zmax) zmax = z; 
+      if (y < ymin) ymin = y; if (y > ymax) ymax = y; 
+      if (x < xmin) xmin = x; if (x > xmax) xmax = x; 
+    }
+  }
+  else if (datatype(in) == VFF_TYP_4_BYTE)
+  {
+    int32_t *I = SLONGDATA(in);
+    for (n = 0; n < nb; n++)
+    for (z = 0; z < ds; z++)
+    for (y = 0; y < cs; y++)
+    for (x = 0; x < rs; x++)
+      if ((double)(I[n*N + z*ps + y*rs + x]) > seuil)
+    {
+      if (z < zmin) zmin = z; if (z > zmax) zmax = z; 
+      if (y < ymin) ymin = y; if (y > ymax) ymax = y; 
+      if (x < xmin) xmin = x; if (x > xmax) xmax = x; 
+    }
+  }
+  else if (datatype(in) == VFF_TYP_FLOAT)
+  {
+    float *I = FLOATDATA(in);
+    for (n = 0; n < nb; n++)
+    for (z = 0; z < ds; z++)
+    for (y = 0; y < cs; y++)
+    for (x = 0; x < rs; x++)
+      if ((double)(I[n*N + z*ps + y*rs + x]) > seuil)
+    {
+      if (z < zmin) zmin = z; if (z > zmax) zmax = z; 
+      if (y < ymin) ymin = y; if (y > ymax) ymax = y; 
+      if (x < xmin) xmin = x; if (x > xmax) xmax = x; 
+    }
+  }
+  else if (datatype(in) == VFF_TYP_DOUBLE)
+  {
+    double *I = DOUBLEDATA(in);
+    for (n = 0; n < nb; n++)
+    for (z = 0; z < ds; z++)
+    for (y = 0; y < cs; y++)
+    for (x = 0; x < rs; x++)
+      if (I[n*N + z*ps + y*rs + x] > seuil)
+    {
+      if (z < zmin) zmin = z; if (z > zmax) zmax = z; 
+      if (y < ymin) ymin = y; if (y > ymax) ymax = y; 
+      if (x < xmin) xmin = x; if (x > xmax) xmax = x; 
+    }
+  }
+  else if (datatype(in) == VFF_TYP_COMPLEX)
+  {
+    fcomplex *I = COMPLEXDATA(in);
+    for (n = 0; n < nb; n++)
+    for (z = 0; z < ds; z++)
+    for (y = 0; y < cs; y++)
+    for (x = 0; x < rs; x++)
+      if (((double)(I[n*N + z*ps + y*rs + x].re) > seuil) && 
+	  ((double)(I[n*N + z*ps + y*rs + x].im) > seuil))
+    {
+      if (z < zmin) zmin = z; if (z > zmax) zmax = z; 
+      if (y < ymin) ymin = y; if (y > ymax) ymax = y; 
+      if (x < xmin) xmin = x; if (x > xmax) xmax = x; 
+    }
+  }
+  else
+  {
+    fprintf(stderr, "%s : bad data type\n", F_NAME);
+    return;
+  }
+
+  *Xmin = xmin;
+  *Ymin = ymin;
+  *Zmin = zmin;
+  *w = xmax - xmin + 1;
+  *h = ymax - ymin + 1;
+  *p = zmax - zmin + 1;
+} // lautocrop2()
diff -r 8b1af7363833 src/lib/lderiche.c
--- a/src/lib/lderiche.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lderiche.c	Mon Jan 13 15:50:10 2014 +0100
@@ -90,7 +90,7 @@
 #define DIRMAX  31
 
 /* ==================================== */
-void lderiche_derichegen(double *x,               /* image a traiter */
+void derichegen(double *x,               /* image a traiter */
                 int32_t M,                   /* taille ligne */
                 int32_t N,                   /* taille colonne */
                 double *y1,              /* zone temporaire de la taille d'une colonne */
@@ -159,10 +159,10 @@
       y[m+M*n] = y1[m] + y2[m];
   }
 
-} /* lderiche_derichegen() */
+} /* derichegen() */
 
 /* ==================================== */
-int32_t lderiche_lderiche(struct xvimage *image, double alpha, int32_t function, double l)
+int32_t lderiche(struct xvimage *image, double alpha, int32_t function, double l)
 /* ==================================== */
 /*
     alpha : parametre (1/taille) du filtre
@@ -263,9 +263,9 @@
       b1 = b3 = 2 * e_a;
       b2 = b4 = - e_2a;
 
-      lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im1,
+      derichegen(Imd, rs, cs, buf1, buf2, Im1,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im2,
+      derichegen(Imd, rs, cs, buf1, buf2, Im2,
                  a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
 
       if (datatype(image) == VFF_TYP_1_BYTE)
@@ -317,9 +317,9 @@
       b1 = b3 = 2 * e_a;
       b2 = b4 = - e_2a;
 
-      lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im1,
+      derichegen(Imd, rs, cs, buf1, buf2, Im1,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im2,
+      derichegen(Imd, rs, cs, buf1, buf2, Im2,
                  a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
 
       if (datatype(image) == VFF_TYP_1_BYTE)
@@ -374,9 +374,9 @@
       b1 = b3 = 2 * e_a;
       b2 = b4 = - e_2a;
 
-      lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im1,
+      derichegen(Imd, rs, cs, buf1, buf2, Im1,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im2,
+      derichegen(Imd, rs, cs, buf1, buf2, Im2,
                  a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
 
       if (datatype(image) == VFF_TYP_1_BYTE)
@@ -416,9 +416,9 @@
       b1 = b3 = 2 * e_a;
       b2 = b4 = - e_2a;
 
-      lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im1,
+      derichegen(Imd, rs, cs, buf1, buf2, Im1,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im2,
+      derichegen(Imd, rs, cs, buf1, buf2, Im2,
                  a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
 
       if (datatype(image) == VFF_TYP_1_BYTE)
@@ -452,7 +452,7 @@
       b1 = b3 = 2 * e_a;
       b2 = b4 = - e_2a;
 
-      lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im1,
+      derichegen(Imd, rs, cs, buf1, buf2, Im1,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
 
       if (datatype(image) == VFF_TYP_1_BYTE)
@@ -497,7 +497,7 @@
       b3 = 2 * e_a;
       b4 = - e_2a;
 
-      lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im1,
+      derichegen(Imd, rs, cs, buf1, buf2, Im1,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
 
 
@@ -539,7 +539,7 @@
       b1 = 2 * e_a;
       b2 = - e_2a;
 
-      lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im1,
+      derichegen(Imd, rs, cs, buf1, buf2, Im1,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
 
 
@@ -646,9 +646,9 @@
   b3 = 0;
   b4 = 0;
 
-  lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im1,
+  derichegen(Imd, rs, cs, buf1, buf2, Im1,
              a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-  lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im2,
+  derichegen(Imd, rs, cs, buf1, buf2, Im2,
              a5, a6, a7, a8, a1, a2, a3, a4, b3, b4, b1, b2);
 
   for (i = 0; i < N; i++)
@@ -673,7 +673,6 @@
 
 
 /* ==================================== */
-static
 void deriche3dgen(double *f,               /* image a traiter */
                 int32_t rs,                  /* taille ligne */
                 int32_t cs,                  /* taille colonne */
@@ -779,7 +778,7 @@
 } /* deriche3dgen() */
 
 /* ==================================== */
-int32_t lderiche3d_lderiche3d(struct xvimage *image, double alpha, int32_t function, double l)
+int32_t lderiche3d(struct xvimage *image, double alpha, int32_t function, double l)
 /* ==================================== */
 /*
     alpha : parametre (1/taille) du filtre
@@ -790,7 +789,7 @@
                4 = lisseur
 */
 #undef F_NAME
-#define F_NAME "lderiche3d_lderiche3d"
+#define F_NAME "lderiche3d"
 { 
   int32_t i;
   int32_t rs = rowsize(image);
@@ -1075,7 +1074,6 @@
 }
 
 /* ==================================== */
-static
 void deriche3dgenb(uint8_t *f,     /* image a traiter */
                 int32_t rs,                  /* taille ligne */
                 int32_t cs,                  /* taille colonne */
@@ -1182,7 +1180,7 @@
 } /* deriche3dgenb() */
 
 /* ==================================== */
-int32_t lderiche_llisseurrec3d(struct xvimage *image, double alpha)
+int32_t llisseurrec3d(struct xvimage *image, double alpha)
 /* ==================================== */
 /*
     alpha : parametre (1/taille) du filtre
@@ -1265,7 +1263,7 @@
 { 
   double dummy;
   if (depth(image) == 1)
-    return lderiche_lderiche(image, alpha, 0, dummy);
+    return lderiche(image, alpha, 0, dummy);
   else
     return lderiche3d(image, alpha, 0, dummy);
 } // lgradientcd()
@@ -1278,7 +1276,7 @@
 { 
   double dummy;
   if (depth(image) == 1)
-    return lderiche_lderiche(image, alpha, 4, dummy);
+    return lderiche(image, alpha, 4, dummy);
   else
     return lderiche3d(image, alpha, 4, dummy);
 } // lgaussianfilter()
diff -r 8b1af7363833 src/lib/lderiche.simple.c
--- a/src/lib/lderiche.simple.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,203 +0,0 @@
-/* $Id: lderiche.simple.c,v 1.1.1.1 2008-11-25 08:01:40 mcouprie Exp $ */
-/****************************************************************
-*
-* Routine Name: lderiche - library call for deriche
-*
-* Purpose:     Filtre lineaire general recursif de Deriche
-*
-* Input:       Image en niveau de gris
-* Output:      Image en niveau de gris
-* Written By:  Michel Couprie - janvier 1998
-*
-****************************************************************/
-
-/* 
-le filtre lineaire recursif general de Deriche est defini par :
-   x : le signal a filtrer
-   y : le signal resultat
-   y1, y2, r : resultats intermediaires
-   alpha : parametre donnant la "taille" du filtre
-   a1..8 : parametres calcules a partir de alpha, differents selon les applications
-   b1..2 : parametres calcules a partir de alpha, differents selon les applications
-
-   y1[m,n] = a1 x[m,n] + a2 x[m,n-1] + b1 y1[m,n-1] + b2 y1[m,n-2]
-     x[m,-1] = 0
-     y1[m,-2] = y1[m,-1] = 0
-   y2[m,n] = a3 x[m,n+1] + a4 x[m,n+2] + b1 y2[m,n+1] + b2 y2[m,n+2]
-     x[m,N] = x[m,N+1] = 0
-     y2[m,N] = y2[m,N+1] = 0
-   r[m,n] = y1[m,n] + y2[m,n]
-
-   y1[m,n] = a5 r[m,n] + a6 r[m-1,n] + b1 y1[m-1,n] + b2 y1[m-2,n]
-     r[-1,n] = 0
-     y1[-2,n] = y1[-1,n] = 0
-   y2[m,n] = a7 r[m+1,n] + a8 r[m+2,n] + b1 y2[m+1,n] + b2 y2[m+2,n]
-     r[M,n] = r[M+1,n] = 0
-     y2[M,n] = y2[M+1,n] = 0
-   y[m,n] = y1[m,n] + y2[m,n]
-*/
-
-#include <mccodimage.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdio.h>
-#include <stdlib.h>
-#ifdef HP
-#define _INCLUDE_XOPEN_SOURCE
-#endif
-#include <math.h>
-#include <mcutil.h>
-/*
-#define DEBUG
-*/
-
-#define EPSILON 1E-20
-
-#define abs(X) (X>=0?X:-(X))
-
-/* ==================================== */
-static
-void derichegen(double *x,               /* image a traiter */
-                int32_t M,                   /* taille ligne */
-                int32_t N,                   /* taille colonne */
-                double *y1, double *y2, double *y,
-                double a1, double a2, double a3, double a4, 
-                double a5, double a6, double a7, double a8, 
-                double b1, double b2)
-/* ==================================== */
-{
-  int32_t n, m;
-
-  for (m = 0; m < M; m++)
-  {
-    y1[0] = a1 * x[m+M*0];
-    y1[1] = a1 * x[m+M*1] + a2 * x[m+M*0] + b1 * y1[0];
-    for (n = 2; n < N; n++)
-      y1[n] = a1*x[m+M*n] + a2*x[m+M*(n-1)] + b1*y1[n-1] + b2*y1[n-2];
-
-    y2[N-1] = 0;
-    y2[N-2] = a3 * x[m+M*(N-1)] + b1 * y2[N-1];
-    for (n = N-3; n >= 0; n--)
-      y2[n] = a3*x[m+M*(n+1)] + a4*x[m+M*(n+2)] + b1*y2[n+1] + b2*y2[n+2];
-
-    for (n = 0; n < N; n++)
-      y[m+M*n] = y1[n] + y2[n];
-  }
-
-  for (n = 0; n < N; n++) 
-  {
-    y1[0] = a5 * y[0+M*n];
-    y1[1] = a5 * y[1+M*n] + a6 * y[0+M*n] + b1 * y1[0];
-    for (m = 2; m < M; m++)
-      y1[m] = a5 * y[m+M*n] + a6 * y[m-1+M*n] + b1 * y1[m-1] + b2 * y1[m-2];
-
-    y2[M-1] = 0;
-    y2[M-2] = a7 * y[M-1+M*n] + b1 * y2[M-1];
-    for (m = M-3; m >= 0; m--)
-      y2[m] = a7 * y[m+1+M*n] + a8 * y[m+2+M*n] + b1 * y2[m+1] + b2 * y2[m+2];
-
-    for (m = 0; m < M; m++)
-      y[m+M*n] = y1[m] + y2[m];
-  }
-#ifdef DEBUG
-printf("derichegen\n");
-/*
-for (n = 0; n < N; n++) printf("");
-printf("\n");
-*/
-#endif
-
-} /* derichegen() */
-
-/* ==================================== */
-static
-int32_t lderiche(struct xvimage *image, double alpha)
-/* ==================================== */
-/*
-    alpha : parametre (1/taille) du filtre
-*/
-{ 
-  int32_t i, j;
-  uint8_t *ima = UCHARDATA(image);
-  int32_t rs = image->row_size;
-  int32_t cs = image->col_size;
-  int32_t N = rs * cs;
-  double *Im1;    /* image intermediaire */
-  double *Im2;    /* image intermediaire */
-  double *Imd;    /* image intermediaire */
-  double *buf1;   /* buffer ligne ou colonne */
-  double *buf2;   /* buffer ligne ou colonne */
-  double k;       /* constante de normalisation pour le lisseur */
-  double kp;      /* constante de normalisation pour le derivateur */
-  double e_a;     /* stocke exp(-alpha) */
-  double e_2a;    /* stocke exp(-2alpha) */
-  double a1, a2, a3, a4, a5, a6, a7, a8, b1, b2;
-  double t1, t2;
-  double lmax, lmin;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lderiche: cette version ne traite pas les images volumiques\n");
-    exit(0);
-  }
-
-  Im1 = (double *)calloc(1,N * sizeof(double));
-  Im2 = (double *)calloc(1,N * sizeof(double));
-  Imd = (double *)calloc(1,N * sizeof(double));
-  buf1 = (double *)calloc(1,mcmax(rs, cs) * sizeof(double));
-  buf2 = (double *)calloc(1,mcmax(rs, cs) * sizeof(double));
-  if ((Im1==NULL) || (Im2==NULL) || (Imd==NULL) || (buf1==NULL) || (buf2==NULL))
-  {   printf("lderiche() : malloc failed\n");
-      return(0);
-  }
-
-  for (i = 0; i < N; i++) Imd[i] = (double)ima[i];
-
-  e_a = exp(- alpha);
-  e_2a = exp(- 2.0 * alpha);
-  k = 1.0 - e_a;
-  k = - k * k / e_a;
-  kp = 1.0 - e_a;
-  kp = kp * kp / (1.0 + (2 * alpha * e_a) - e_2a);
-
-#ifdef DEBUG
-printf("alpha = %g , e_a = %g , e_2a = %g , k = %g\n", alpha, e_a, e_2a, k);
-#endif
-
-  /* valeurs de parametres pour filtre lisseur-derivateur */
-  a1 = k;
-  a2 = k * e_a * (alpha - 1.0);
-  a3 = k * e_a * (alpha + 1.0);
-  a4 = - k * e_2a;
-  a5 = 0.0;
-  a6 = kp * e_a;
-  a7 = - kp * e_a;
-  a8 = 0;
-  b1 = 2 * e_a;
-  b2 = - e_2a;
-
-  derichegen(Imd, rs, cs, buf1, buf2, Im1,
-             a1, a2, a3, a4, a5, a6, a7, a8, b1, b2);
-  derichegen(Imd, rs, cs, buf1, buf2, Im2,
-             a5, a6, a7, a8, a1, a2, a3, a4, b1, b2);
-
-  for (i = 0; i < N; i++)
-  {
-    t1 = Im1[i];
-    t2 = Im2[i];
-    t2 = sqrt((t1 * t1) + (t2 * t2));
-    if (t2 <= 255.0)
-      ima[i] = (uint8_t)t2;
-    else
-      ima[i] = 255;
-  }
-
-  free(Im1);
-  free(Im2);
-  free(Imd);
-  free(buf1);
-  free(buf2);
-
-  return 1;
-}
-
diff -r 8b1af7363833 src/lib/lderiche3d.c
--- a/src/lib/lderiche3d.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,557 +0,0 @@
-/* $Id: lderiche3d.c,v 1.1.1.1 2008-11-25 08:01:40 mcouprie Exp $ */
-/****************************************************************
-*
-* Routine Name: lderiche3d - library call for deriche3d
-*
-* Purpose:     Filtre lineaire general recursif de Deriche en 3D
-*
-* Input:       Image en niveau de gris 3D
-* Output:      Image en niveau de gris 3D
-* Written By:  Michel Couprie - mars 2000
-*
-****************************************************************/
-
-#include <sys/types.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#ifdef HP
-#define _INCLUDE_XOPEN_SOURCE
-#endif
-#include <math.h>
-#include <mccodimage.h>
-#include <mcutil.h>
-#include <lderiche3d.h>
-/*
-#define DEBUG
-*/
-
-#define EPSILON 1E-20
-#define DIRMAX  31
-
-/* ==================================== */
-static
-void deriche3dgen(double *f,               /* image a traiter */
-                int32_t rs,                  /* taille ligne */
-                int32_t cs,                  /* taille colonne */
-                int32_t ds,                  /* nombre plans */
-                double *g1,              /* zone temporaire de taille max(rs,cs,ds) */
-                double *g2,              /* zone temporaire de taille max(rs,cs,ds) */
-                double *g,               /* stocke un resultat temporaire, puis le resultat final */ 
-                double a1, double a2, double a3, double a4, double b1, double b2,   /* param. dir. z */
-                double a5, double a6, double a7, double a8, double b3, double b4,   /* param. dir. y */
-                double a9, double a10, double a11, double a12, double b5, double b6 /* param. dir. x */
-               )
-/* ==================================== */
-{
-  int32_t x, y, z, ps = rs * cs;
-
-  for (y = 0; y < cs; y++)     /* filtrage dans la direction z (f -> g) */
-  for (x = 0; x < rs; x++)
-  {
-    /* filtre causal en z */
-#ifdef BORD_ZERO
-    g1[0] = a1 * f[x+rs*y+ps*0];
-    g1[1] = a1 * f[x+rs*y+ps*1] + a2 * f[x+rs*y+ps*0] + b1 * g1[0];
-#else
-    g1[0] = ((a1 + a2) / (1.0 - b1 - b2)) * f[x+rs*y+ps*0];
-    g1[1] = a1 * f[x+rs*y+ps*1] + a2 * f[x+rs*y+ps*0] + (b1 + b2) * g1[0];
-#endif
-    for (z = 2; z < ds; z++)
-      g1[z] = a1*f[x+rs*y+ps*z] + a2*f[x+rs*y+ps*(z-1)] + b1*g1[z-1] + b2*g1[z-2];
-
-    /* filtre anticausal en z */
-#ifdef BORD_ZERO
-    g2[ds-1] = 0;
-    g2[ds-2] = a3 * f[x+rs*y+ps*(ds-1)] + b1 * g2[ds-1];
-#else
-    g2[ds-1] = ((a3 + a4) / (1.0 - b1 - b2)) * f[x+rs*y+ps*(ds-1)];
-    g2[ds-2] = (a3 + a4) * f[x+rs*y+ps*(ds-1)] + (b1 + b2) * g2[ds-1];
-#endif
-    for (z = ds-3; z >= 0; z--)
-      g2[z] = a3*f[x+rs*y+ps*(z+1)] + a4*f[x+rs*y+ps*(z+2)] + b1*g2[z+1] + b2*g2[z+2];
-
-    for (z = 0; z < ds; z++)
-      g[x+rs*y+ps*z] = g1[z] + g2[z];
-  }
-
-  for (z = 0; z < ds; z++)     /* filtrage dans la direction y (g -> g) */
-  for (x = 0; x < rs; x++)
-  {
-    /* filtre causal en y */
-#ifdef BORD_ZERO
-    g1[0] = a5 * g[x+rs*0+ps*z];
-    g1[1] = a5 * g[x+rs*1+ps*z] + a6 * g[x+rs*0+ps*z] + b3 * g1[0];
-#else
-    g1[0] = ((a5 + a6) / (1.0 - b3 - b4)) * g[x+rs*0+ps*z];
-    g1[1] = a5 * g[x+rs*1+ps*z] + a6 * g[x+rs*0+ps*z] + (b3 + b4) * g1[0];
-#endif
-    for (y = 2; y < cs; y++)
-      g1[y] = a5*g[x+rs*y+ps*z] + a6*g[x+rs*(y-1)+ps*z] + b3*g1[y-1] + b4*g1[y-2];
-
-    /* filtre anticausal en y */
-#ifdef BORD_ZERO
-    g2[cs-1] = 0;
-    g2[cs-2] = a7 * g[x+rs*(cs-1)+ps*z] + b3 * g2[cs-1];
-#else
-    g2[cs-1] = ((a7 + a8) / (1.0 - b3 - b4)) * g[x+rs*(cs-1)+ps*z];
-    g2[cs-2] = (a7 + a8) * g[x+rs*(cs-1)+ps*z] + (b3 + b4) * g2[cs-1];
-#endif
-    for (y = cs-3; y >= 0; y--)
-      g2[y] = a7*g[x+rs*(y+1)+ps*z] + a8*g[x+rs*(y+2)+ps*z] + b3*g2[y+1] + b4*g2[y+2];
-
-    for (y = 0; y < cs; y++)
-      g[x+rs*y+ps*z] = g1[y] + g2[y];
-  }
-
-  for (z = 0; z < ds; z++)     /* filtrage dans la direction x (g -> g) */
-  for (y = 0; y < cs; y++)
-  {
-    /* filtre causal en x */
-#ifdef BORD_ZERO
-    g1[0] = a9 * g[0+rs*y+ps*z];
-    g1[1] = a9 * g[1+rs*y+ps*z] + a10 * g[0+rs*y+ps*z] + b5 * g1[0];
-#else
-    g1[0] = ((a9 + a10) / (1.0 - b5 - b6)) * g[0+rs*y+ps*z];
-    g1[1] = a9 * g[1+rs*y+ps*z] + a10 * g[0+rs*y+ps*z] + (b5 + b6) * g1[0];
-#endif
-    for (x = 2; x < rs; x++)
-      g1[x] = a9 * g[x+rs*y+ps*z] + a10 * g[x-1+rs*y+ps*z] + b5 * g1[x-1] + b6 * g1[x-2];
-
-    /* filtre anticausal en x */
-#ifdef BORD_ZERO
-    g2[rs-1] = 0;
-    g2[rs-2] = a11 * g[rs-1+rs*y+ps*z] + b5 * g2[rs-1];
-#else
-    g2[rs-1] = ((a11 + a12) / (1.0 - b5 - b6)) * g[rs-1+rs*y+ps*z];
-    g2[rs-2] = (a11 + a12) * g[rs-1+rs*y+ps*z] + (b5 + b6) * g2[rs-1];
-#endif
-    for (x = rs-3; x >= 0; x--)
-      g2[x] = a11 * g[x+1+rs*y+ps*z] + a12 * g[x+2+rs*y+ps*z] + b5 * g2[x+1] + b6 * g2[x+2];
-
-    for (x = 0; x < rs; x++)
-      g[x+rs*y+ps*z] = g1[x] + g2[x];
-  }
-
-} /* deriche3dgen() */
-
-/* ==================================== */
-int32_t lderiche3d(struct xvimage *image, double alpha, int32_t function, double l)
-/* ==================================== */
-/*
-    alpha : parametre (1/taille) du filtre
-    function : 0 = module du gradient lisse'
-               1 = direction du gradient lisse' 
-               2 = laplacien (normalise - 127 represente le 0)
-               3 = f - l * laplacien(f)
-               4 = lisseur
-*/
-{ 
-  int32_t i, j;
-  uint8_t *ima = UCHARDATA(image);
-  int32_t rs = rowsize(image);
-  int32_t cs = colsize(image);
-  int32_t ds = depth(image);
-  int32_t ps = rs * cs;
-  int32_t N = ps * ds;
-  double *Im1;    /* image intermediaire */
-  double *Im2;    /* image intermediaire */
-  double *Im3;    /* image intermediaire */
-  double *Imd;    /* image intermediaire */
-  double *buf1;   /* buffer ligne ou colonne */
-  double *buf2;   /* buffer ligne ou colonne */
-  double k;       /* constante de normalisation pour le lisseur */
-  double kp;      /* constante de normalisation pour le derivateur */
-  double kpp;     /* constante de normalisation pour le laplacien */
-  double e_a;     /* stocke exp(-alpha) */
-  double e_2a;    /* stocke exp(-2alpha) */
-  double a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12;
-  double b1, b2, b3, b4, b5, b6;
-  double t1, t2, t3;
-  double lmax, lmin, sbuf;
-
-  Im1 = (double *)calloc(1,N * sizeof(double));
-  Imd = (double *)calloc(1,N * sizeof(double));
-  if ((Im1==NULL) || (Imd==NULL))
-  {   fprintf(stderr,"lderiche3d() : malloc failed\n");
-      return(0);
-  }
-  if (function == 0)
-  {
-    Im2 = (double *)calloc(1,N * sizeof(double));
-    Im3 = (double *)calloc(1,N * sizeof(double));
-    if ((Im2==NULL) || (Im3==NULL))
-    {   fprintf(stderr,"lderiche3d() : malloc failed\n");
-        return(0);
-    }
-  }
-  sbuf = mcmax((mcmax(rs,cs)),ds);
-  buf1 = (double *)calloc(1,sbuf * sizeof(double));
-  buf2 = (double *)calloc(1,sbuf * sizeof(double));
-  if ((buf1==NULL) || (buf2==NULL))
-  {   fprintf(stderr,"lderiche3d() : malloc failed\n");
-      return(0);
-  }
-
-  for (i = 0; i < N; i++) Imd[i] = (double)ima[i];
-
-  e_a = exp(- alpha);
-  e_2a = exp(- 2.0 * alpha);
-  k = 1.0 - e_a;
-  k = k * k / (1.0 + (2 * alpha * e_a) - e_2a);
-  kp = 1.0 - e_a;
-  kp = - kp * kp / e_a;
-  kpp = (1.0 - e_2a) / (2 * alpha * e_a);
-
-#ifdef DEBUG
-printf("alpha = %g , e_a = %g , e_2a = %g , k = %g\n", alpha, e_a, e_2a, k);
-#endif
-
-  switch (function)
-  {
-    case 0: /* module du gradient lisse' */
-
-      /* valeurs de parametres pour filtre lisseur-derivateur */
-      a1 = k;                         /* lisseur */
-      a2 = k * e_a * (alpha - 1.0);
-      a3 = k * e_a * (alpha + 1.0);
-      a4 = - k * e_2a;
-
-      a5 = 0.0;                       /* derivateur */
-      a6 = kp * e_a;
-      a7 = - kp * e_a;
-      a8 = 0.0;
-
-      b1 = 2 * e_a;
-      b2 = - e_2a;
-
-      deriche3dgen(Imd, rs, cs, ds, buf1, buf2, Im1,
-                   a5, a6, a7, a8, b1, b2,           /* derive en x */
-                   a1, a2, a3, a4, b1, b2,           /* lisse en y */
-                   a1, a2, a3, a4, b1, b2);          /* lisse en z */
-
-      deriche3dgen(Imd, rs, cs, ds, buf1, buf2, Im2,
-                   a1, a2, a3, a4, b1, b2,           /* lisse en x */
-                   a5, a6, a7, a8, b1, b2,           /* derive en y */
-                   a1, a2, a3, a4, b1, b2);          /* lisse en z */
-
-      deriche3dgen(Imd, rs, cs, ds, buf1, buf2, Im3,
-                   a1, a2, a3, a4, b1, b2,           /* lisse en x */
-                   a1, a2, a3, a4, b1, b2,           /* lisse en y */
-                   a5, a6, a7, a8, b1, b2);          /* derive en z */
-
-      for (i = 0; i < N; i++)
-      {
-        t1 = Im1[i];
-        t2 = Im2[i];
-        t3 = Im3[i];
-        t2 = sqrt((t1 * t1) + (t2 * t2) + (t3 * t3));
-        if (t2 <= 255.0)
-          ima[i] = (uint8_t)t2;
-        else
-          ima[i] = 255;
-      }
-      break;
-
-    case 1:  /* direction du gradient lisse' */
-        fprintf(stderr, "Not Yet Implemented\n");
-        return 0;
-
-    case 2:  /* laplacien lisse' */
-
-      /* valeurs de parametres pour filtre lisseur-laplacien */
-      a1 = k;
-      a2 = k * e_a * (alpha - 1.0);
-      a3 = k * e_a * (alpha + 1.0);
-      a4 = - k * e_2a;
-      a5 = 1.0;
-      a6 = - e_a * (kpp * alpha + 1.0);
-      a7 = e_a * (1.0 - kpp * alpha);
-      a8 = - e_2a;
-      b1 = b3 = 2 * e_a;
-      b2 = b4 = - e_2a;
-      fprintf(stderr, "Not Yet Implemented\n");
-      /*
-      deriche3dgen(Imd, rs, cs, buf1, buf2, Im1,
-                 a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      deriche3dgen(Imd, rs, cs, buf1, buf2, Im2,
-                 a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
-
-
-      lmin = lmax = 0.0;
-      for (i = 0; i < N; i++)
-      {
-        Im1[i] = t2 = - (Im1[i] + Im2[i]);
-        if (t2 > lmax) lmax = t2;
-        if (t2 < lmin) lmin = t2;
-      }        
-      lmax = max(lmax, -lmin);
-      for (i = 0; i < N; i++)      
-        ima[i] = 127 + (uint8_t)(Im1[i] * 128.0 / lmax);
-      */
-      break;
-
-    case 3:  /* f - l * laplacien(f) */
-
-      /* valeurs de parametres pour filtre lisseur-laplacien */
-      a1 = k;
-      a2 = k * e_a * (alpha - 1.0);
-      a3 = k * e_a * (alpha + 1.0);
-      a4 = - k * e_2a;
-
-      a5 = 1.0;
-      a6 = - e_a * (kpp * alpha + 1.0);
-      a7 = e_a * (1.0 - kpp * alpha);
-      a8 = - e_2a;
-
-      b1 = b3 = 2 * e_a;
-      b2 = b4 = - e_2a;
-      fprintf(stderr, "Not Yet Implemented\n");
-      /*
-      deriche3dgen(Imd, rs, cs, buf1, buf2, Im1,
-                 a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      deriche3dgen(Imd, rs, cs, buf1, buf2, Im2,
-                 a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
-
-      for (i = 0; i < N; i++)      
-      {
-        t1 = -(Im1[i] + Im2[i]);
-        t2 = (double)(ima[i]) - l * t1;
-        if (t2 < 0.0) t2 = 0.0;
-        if (t2 > 255.0) t2 = 255.0;
-        ima[i] = (uint8_t)floor(t2);
-      }
-      */
-      break;
-
-    case 4:  /* lisseur */
-
-      a1 = k;
-      a2 = k * e_a * (alpha - 1.0);
-      a3 = k * e_a * (alpha + 1.0);
-      a4 = - k * e_2a;
-
-      b1 = 2 * e_a;
-      b2 = - e_2a;
-
-      deriche3dgen(Imd, rs, cs, ds, buf1, buf2, Im1,
-                   a1, a2, a3, a4, b1, b2,           /* lisse en x */
-                   a1, a2, a3, a4, b1, b2,           /* lisse en y */
-                   a1, a2, a3, a4, b1, b2);          /* lisse en z */
-
-      for (i = 0; i < N; i++)      
-      {
-        t1 =  Im1[i];
-        if (t1 < 0.0) t1 = 0.0;
-        if (t1 > 255.0) t1 = 255.0;
-        ima[i] = (uint8_t)floor(t1);
-      }
-      break;
-
-      default: 
-        fprintf(stderr, "lderiche3d : fonction %d inexistante ; utiliser : \n", function);
-        fprintf(stderr, "  0 : module du gradient lisse'\n");
-        fprintf(stderr, "  1 : direction du gradient lisse'\n");
-        fprintf(stderr, "  2 : laplacien lisse'\n");
-        fprintf(stderr, "  3 : f - l * laplacien(f)\n");
-        fprintf(stderr, "  4 : lisseur\n");
-        return 0;
-  } /* switch (function) */
-
-
-  free(Im1);
-  free(Imd);
-  if (function == 1)
-  {
-    free(Im2);
-    free(Im3);
-  }
-  free(buf1);
-  free(buf2);
-  return 1;
-}
-
-/* ==================================== */
-static
-void deriche3dgenb(uint8_t *f,     /* image a traiter */
-                int32_t rs,                  /* taille ligne */
-                int32_t cs,                  /* taille colonne */
-                int32_t ds,                  /* nombre plans */
-                double *g1,              /* zone temporaire de taille max(rs,cs,ds) */
-                double *g2,              /* zone temporaire de taille max(rs,cs,ds) */
-                double *g,               /* stocke un resultat temporaire, puis le resultat final */ 
-                double a1, double a2, double a3, double a4, double b1, double b2,   /* param. dir. z */
-                double a5, double a6, double a7, double a8, double b3, double b4,   /* param. dir. y */
-                double a9, double a10, double a11, double a12, double b5, double b6 /* param. dir. x */
-               )
-/* ==================================== */
-//  traite directement une image d'entiers
-{
-  int32_t x, y, z, ps = rs * cs;
-
-  for (y = 0; y < cs; y++)     /* filtrage dans la direction z (f -> g) */
-  for (x = 0; x < rs; x++)
-  {
-    /* filtre causal en z */
-#ifdef BORD_ZERO
-    g1[0] = a1 * (double)(f[x+rs*y+ps*0]);
-    g1[1] = a1 * (double)(f[x+rs*y+ps*1]) + a2 * (double)(f[x+rs*y+ps*0]) + b1 * g1[0];
-#else
-    g1[0] = ((a1 + a2) / (1.0 - b1 - b2)) * (double)(f[x+rs*y+ps*0]);
-    g1[1] = a1 * (double)(f[x+rs*y+ps*1]) + a2 * (double)(f[x+rs*y+ps*0]) + (b1 + b2) * g1[0];
-#endif
-    for (z = 2; z < ds; z++)
-      g1[z] = a1*(double)(f[x+rs*y+ps*z]) + a2*(double)(f[x+rs*y+ps*(z-1)]) + b1*g1[z-1] + b2*g1[z-2];
-
-    /* filtre anticausal en z */
-#ifdef BORD_ZERO
-    g2[ds-1] = 0;
-    g2[ds-2] = a3 * (double)(f[x+rs*y+ps*(ds-1)]) + b1 * g2[ds-1];
-#else
-    g2[ds-1] = ((a3 + a4) / (1.0 - b1 - b2)) * (double)(f[x+rs*y+ps*(ds-1)]);
-    g2[ds-2] = (a3 + a4) * (double)(f[x+rs*y+ps*(ds-1)]) + (b1 + b2) * g2[ds-1];
-#endif
-    for (z = ds-3; z >= 0; z--)
-      g2[z] = a3*(double)(f[x+rs*y+ps*(z+1)]) + a4*(double)(f[x+rs*y+ps*(z+2)]) + b1*g2[z+1] + b2*g2[z+2];
-
-    for (z = 0; z < ds; z++)
-      g[x+rs*y+ps*z] = g1[z] + g2[z];
-  }
-
-  for (z = 0; z < ds; z++)     /* filtrage dans la direction y (g -> g) */
-  for (x = 0; x < rs; x++)
-  {
-    /* filtre causal en y */
-#ifdef BORD_ZERO
-    g1[0] = a5 * g[x+rs*0+ps*z];
-    g1[1] = a5 * g[x+rs*1+ps*z] + a6 * g[x+rs*0+ps*z] + b3 * g1[0];
-#else
-    g1[0] = ((a5 + a6) / (1.0 - b3 - b4)) * g[x+rs*0+ps*z];
-    g1[1] = a5 * g[x+rs*1+ps*z] + a6 * g[x+rs*0+ps*z] + (b3 + b4) * g1[0];
-#endif
-    for (y = 2; y < cs; y++)
-      g1[y] = a5*g[x+rs*y+ps*z] + a6*g[x+rs*(y-1)+ps*z] + b3*g1[y-1] + b4*g1[y-2];
-
-    /* filtre anticausal en y */
-#ifdef BORD_ZERO
-    g2[cs-1] = 0;
-    g2[cs-2] = a7 * g[x+rs*(cs-1)+ps*z] + b3 * g2[cs-1];
-#else
-    g2[cs-1] = ((a7 + a8) / (1.0 - b3 - b4)) * g[x+rs*(cs-1)+ps*z];
-    g2[cs-2] = (a7 + a8) * g[x+rs*(cs-1)+ps*z] + (b3 + b4) * g2[cs-1];
-#endif
-    for (y = cs-3; y >= 0; y--)
-      g2[y] = a7*g[x+rs*(y+1)+ps*z] + a8*g[x+rs*(y+2)+ps*z] + b3*g2[y+1] + b4*g2[y+2];
-
-    for (y = 0; y < cs; y++)
-      g[x+rs*y+ps*z] = g1[y] + g2[y];
-  }
-
-  for (z = 0; z < ds; z++)     /* filtrage dans la direction x (g -> g) */
-  for (y = 0; y < cs; y++)
-  {
-    /* filtre causal en x */
-#ifdef BORD_ZERO
-    g1[0] = a9 * g[0+rs*y+ps*z];
-    g1[1] = a9 * g[1+rs*y+ps*z] + a10 * g[0+rs*y+ps*z] + b5 * g1[0];
-#else
-    g1[0] = ((a9 + a10) / (1.0 - b5 - b6)) * g[0+rs*y+ps*z];
-    g1[1] = a9 * g[1+rs*y+ps*z] + a10 * g[0+rs*y+ps*z] + (b5 + b6) * g1[0];
-#endif
-    for (x = 2; x < rs; x++)
-      g1[x] = a9 * g[x+rs*y+ps*z] + a10 * g[x-1+rs*y+ps*z] + b5 * g1[x-1] + b6 * g1[x-2];
-
-    /* filtre anticausal en x */
-#ifdef BORD_ZERO
-    g2[rs-1] = 0;
-    g2[rs-2] = a11 * g[rs-1+rs*y+ps*z] + b5 * g2[rs-1];
-#else
-    g2[rs-1] = ((a11 + a12) / (1.0 - b5 - b6)) * g[rs-1+rs*y+ps*z];
-    g2[rs-2] = (a11 + a12) * g[rs-1+rs*y+ps*z] + (b5 + b6) * g2[rs-1];
-#endif
-    for (x = rs-3; x >= 0; x--)
-      g2[x] = a11 * g[x+1+rs*y+ps*z] + a12 * g[x+2+rs*y+ps*z] + b5 * g2[x+1] + b6 * g2[x+2];
-
-    for (x = 0; x < rs; x++)
-      g[x+rs*y+ps*z] = g1[x] + g2[x];
-  }
-
-} /* deriche3dgenb() */
-
-/* ==================================== */
-int32_t lderiche3d_llisseurrec3d(struct xvimage *image, double alpha)
-/* ==================================== */
-/*
-    alpha : parametre (1/taille) du filtre
-*/
-{ 
-  int32_t i, j;
-  uint8_t *ima = UCHARDATA(image);
-  int32_t rs = rowsize(image);
-  int32_t cs = colsize(image);
-  int32_t ds = depth(image);
-  int32_t ps = rs * cs;
-  int32_t N = ps * ds;
-  double *Im1;    /* image intermediaire */
-  double *buf1;   /* buffer ligne ou colonne */
-  double *buf2;   /* buffer ligne ou colonne */
-  double k;       /* constante de normalisation pour le lisseur */
-  double kp;      /* constante de normalisation pour le derivateur */
-  double kpp;     /* constante de normalisation pour le laplacien */
-  double e_a;     /* stocke exp(-alpha) */
-  double e_2a;    /* stocke exp(-2alpha) */
-  double a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12;
-  double b1, b2, b3, b4, b5, b6;
-  double t1, t2, t3;
-  double lmax, lmin;
-
-  Im1 = (double *)calloc(1,N * sizeof(double));
-  if (Im1==NULL)
-  {   fprintf(stderr,"lderiche3d() : malloc failed\n");
-      return(0);
-  }
-  buf1 = (double *)calloc(1,mcmax(mcmax(rs,cs),ds) * sizeof(double));
-  buf2 = (double *)calloc(1,mcmax(mcmax(rs,cs),ds) * sizeof(double));
-  if ((buf1==NULL) || (buf2==NULL))
-  {   fprintf(stderr,"lderiche3d() : malloc failed\n");
-      return(0);
-  }
-
-  e_a = exp(- alpha);
-  e_2a = exp(- 2.0 * alpha);
-  k = 1.0 - e_a;
-  k = k * k / (1.0 + (2 * alpha * e_a) - e_2a);
-  kp = 1.0 - e_a;
-  kp = - kp * kp / e_a;
-  kpp = (1.0 - e_2a) / (2 * alpha * e_a);
-
-#ifdef DEBUG
-printf("alpha = %g , e_a = %g , e_2a = %g , k = %g\n", alpha, e_a, e_2a, k);
-#endif
-
-  a1 = k;
-  a2 = k * e_a * (alpha - 1.0);
-  a3 = k * e_a * (alpha + 1.0);
-  a4 = - k * e_2a;
-  b1 = 2 * e_a;
-  b2 = - e_2a;
-
-  deriche3dgenb(ima, rs, cs, ds, buf1, buf2, Im1,
-                a1, a2, a3, a4, b1, b2,           /* lisse en x */
-                a1, a2, a3, a4, b1, b2,           /* lisse en y */
-                a1, a2, a3, a4, b1, b2);          /* lisse en z */
-
-  for (i = 0; i < N; i++)      
-  {
-    t1 =  Im1[i];
-    if (t1 < 0.0) t1 = 0.0;
-    if (t1 > 255.0) t1 = 255.0;
-    ima[i] = (uint8_t)floor(t1);
-  }
-
-  free(Im1);
-  free(buf1);
-  free(buf2);
-  return 1;
-} /* llisseurrec3d() */
-
diff -r 8b1af7363833 src/lib/ldiZenzo.c
--- a/src/lib/ldiZenzo.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/ldiZenzo.c	Mon Jan 13 15:50:10 2014 +0100
@@ -141,19 +141,19 @@
       b1 = b3 = 2 * e_a;
       b2 = b4 = - e_2a;
 
-      lderiche_derichegen(ImR, rs, cs, buf1, buf2, ImRx,
+      derichegen(ImR, rs, cs, buf1, buf2, ImRx,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      lderiche_derichegen(ImR, rs, cs, buf1, buf2, ImRy,
+      derichegen(ImR, rs, cs, buf1, buf2, ImRy,
                  a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
 
-      lderiche_derichegen(ImV, rs, cs, buf1, buf2, ImVx,
+      derichegen(ImV, rs, cs, buf1, buf2, ImVx,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      lderiche_derichegen(ImV, rs, cs, buf1, buf2, ImVy,
+      derichegen(ImV, rs, cs, buf1, buf2, ImVy,
                  a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
 
-      lderiche_derichegen(ImB, rs, cs, buf1, buf2, ImBx,
+      derichegen(ImB, rs, cs, buf1, buf2, ImBx,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      lderiche_derichegen(ImB, rs, cs, buf1, buf2, ImBy,
+      derichegen(ImB, rs, cs, buf1, buf2, ImBy,
                  a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
 
       for (i = 0; i < N; i++)
@@ -289,19 +289,19 @@
       b1 = b3 = 2 * e_a;
       b2 = b4 = - e_2a;
 
-      lderiche_derichegen(ImR, rs, cs, buf1, buf2, ImRx,
+      derichegen(ImR, rs, cs, buf1, buf2, ImRx,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      lderiche_derichegen(ImR, rs, cs, buf1, buf2, ImRy,
+      derichegen(ImR, rs, cs, buf1, buf2, ImRy,
                  a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
 
-      lderiche_derichegen(ImV, rs, cs, buf1, buf2, ImVx,
+      derichegen(ImV, rs, cs, buf1, buf2, ImVx,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      lderiche_derichegen(ImV, rs, cs, buf1, buf2, ImVy,
+      derichegen(ImV, rs, cs, buf1, buf2, ImVy,
                  a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
 
-      lderiche_derichegen(ImB, rs, cs, buf1, buf2, ImBx,
+      derichegen(ImB, rs, cs, buf1, buf2, ImBx,
                  a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-      lderiche_derichegen(ImB, rs, cs, buf1, buf2, ImBy,
+      derichegen(ImB, rs, cs, buf1, buf2, ImBy,
                  a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
 
       for (i = 0; i < N; i++)
diff -r 8b1af7363833 src/lib/ldilatbin3d.c
--- a/src/lib/ldilatbin3d.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,247 +0,0 @@
-/* $Id: ldilatbin3d.c,v 1.1.1.1 2008-11-25 08:01:42 mcouprie Exp $ */
-/* operateurs de dilatation et d'erosion morphologique 3D */
-
-#include <stdio.h>
-#include <stdint.h>
-
-#include "mccodimage.h"
-
-/* ==================================== */
-int32_t ldilatbin3d_ldilatbin3d(struct xvimage *f, struct xvimage *m, int32_t xc, int32_t yc, int32_t zc)
-/*
-   Operateur de dilatation binaire 3D par un element structurant 
-   de taille quelconque
-
-   ATTENTION: l'element structurant doit etre CONNEXE et REFLEXIF
-
-   Michel Couprie - decembre 1999 
-*/
-/* m : masque representant l'element structurant */
-/* xc, yc, zc : coordonnees de l'origine de l'element structurant */
-/* ==================================== */
-{
-  int32_t x, y, z, v, w;              /* index muet */
-  register int32_t i, j, k, l, n, o;  /* index muet */
-  int32_t rs = rowsize(f);         /* taille ligne */
-  int32_t cs = colsize(f);         /* taille colonne */
-  int32_t ds = depth(f);           /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  int32_t rsm = rowsize(m);        /* taille ligne masque */
-  int32_t csm = colsize(m);        /* taille colonne masque */
-  int32_t dsm = depth(m);          /* nb plans masque */
-  int32_t psm = rsm * csm;         /* taille plan masque */
-  int32_t Nm = psm * dsm;          /* taille masque */
-  uint8_t *M = UCHARDATA(m);
-  uint8_t *F = UCHARDATA(f);
-  uint8_t *H;                    /* image de travail */
-  int32_t nptb;                    /* nombre de points de l'e.s. */
-  int32_t *tab_es_x;               /* liste des coord. x des points de l'e.s. */
-  int32_t *tab_es_y;               /* liste des coord. y des points de l'e.s. */
-  int32_t *tab_es_z;               /* liste des coord. z des points de l'e.s. */
-  int32_t c;
-  int32_t frontiere;
-
-  if (!M[zc * psm + yc * rsm + xc]) /* l'element structurant N'est PAS reflexif */
-  {
-    fprintf(stderr, "ldilatbin3d: l'element structurant doit etre reflexif\n");
-    return 0;
-  }
-
-  H = (uint8_t *)calloc(1,N*sizeof(char));
-  if (H == NULL)
-  {  
-     fprintf(stderr,"ldilatbin3d() : malloc failed for H\n");
-     return(0);
-  }
-
-  memcpy(H, F, N);
-
-  nptb = 0;
-  for (i = 0; i < Nm; i += 1)
-    if (M[i])
-      nptb += 1;
-
-  tab_es_x = (int32_t *)calloc(1,nptb * sizeof(int32_t));
-  tab_es_y = (int32_t *)calloc(1,nptb * sizeof(int32_t));
-  tab_es_z = (int32_t *)calloc(1,nptb * sizeof(int32_t));
-  if ((tab_es_x == NULL) || (tab_es_y == NULL) || (tab_es_z == NULL))
-  {  
-     fprintf(stderr,"ldilatbin3d() : malloc failed for tab_es\n");
-     return(0);
-  }
-
-  l = 0;
-  for (k = 0; k < dsm; k += 1)
-    for (j = 0; j < csm; j += 1)
-      for (i = 0; i < rsm; i += 1)
-        if (M[k * psm + j * rsm + i])
-        {
-          tab_es_x[l] = i;
-          tab_es_y[l] = j;
-          tab_es_z[l] = k;
-          l += 1;
-        }
-
-  for (z = 0; z < ds; z++)
-  for (y = 0; y < cs; y++)
-  for (x = 0; x < rs; x++)
-  {
-    /* verifie si (x,y,z) est un point de la frontiere de l'objet */
-    w = z * ps + y * rs + x;
-    if (H[w])
-    {
-      frontiere = 0;
-      for (l = 0; l <= 10; l += 2) /* parcourt les 6 voisins */
-      {
-        v = voisin6(w, l, rs, ps, N);
-        if ((v != -1) && (!H[v])) { frontiere = 1; break; }
-      } /* for l... */
-
-      if (!frontiere) 
-        F[w] = NDG_MAX;
-      else
-      {
-        for (c = 0; c < nptb ; c += 1)
-        {
-          o = z + tab_es_z[c] - zc;
-          n = y + tab_es_y[c] - yc;
-          l = x + tab_es_x[c] - xc; 
-          if ((o >= 0) && (o < ds) && 
-              (n >= 0) && (n < cs) && 
-              (l >= 0) && (l < rs))
-	    F[o * ps + n * rs + l] = NDG_MAX;
-        }
-      }
-    }
-  }
-
-  free(H);
-  free(tab_es_x);
-  free(tab_es_y);
-  free(tab_es_z);
-  return 1;
-} /* ldilatbin3d() */
-
-/* ==================================== */
-int32_t lerosbin3d(struct xvimage *f, struct xvimage *m, int32_t xc, int32_t yc, int32_t zc)
-/*
-   Operateur d'erosion binaire 3D par un element structurant 
-   de taille quelconque
-
-   ATTENTION: l'element structurant doit etre CONNEXE et REFLEXIF
-
-   Michel Couprie - decembre 1999 
-*/
-/* m : masque representant l'element structurant */
-/* xc, yc, zc : coordonnees de l'origine de l'element structurant */
-/* ==================================== */
-{
-  int32_t x, y, z, v, w;              /* index muet */
-  register int32_t i, j, k, l, n, o;  /* index muet */
-  int32_t rs = rowsize(f);         /* taille ligne */
-  int32_t cs = colsize(f);         /* taille colonne */
-  int32_t ds = depth(f);           /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  int32_t rsm = rowsize(m);        /* taille ligne masque */
-  int32_t csm = colsize(m);        /* taille colonne masque */
-  int32_t dsm = depth(m);          /* nb plans masque */
-  int32_t psm = rsm * csm;         /* taille plan masque */
-  int32_t Nm = psm * dsm;          /* taille masque */
-  uint8_t *M = UCHARDATA(m);
-  uint8_t *F = UCHARDATA(f);
-  uint8_t *H;                    /* image de travail */
-  uint8_t sup;
-  int32_t nptb;                    /* nombre de points de l'e.s. */
-  int32_t *tab_es_x;               /* liste des coord. x des points de l'e.s. */
-  int32_t *tab_es_y;               /* liste des coord. y des points de l'e.s. */
-  int32_t *tab_es_z;               /* liste des coord. z des points de l'e.s. */
-  int32_t c;
-  int32_t frontiere;
-
-  if (!M[zc * psm + yc * rsm + xc]) /* l'element structurant N'est PAS reflexif */
-  {
-    fprintf(stderr, "lerosbin3d: l'element structurant doit etre reflexif\n");
-    return 0;
-  }
-
-  H = (uint8_t *)calloc(1,N*sizeof(char));
-  if (H == NULL)
-  {  
-     fprintf(stderr,"lerosbin3d() : malloc failed for H\n");
-     return(0);
-  }
-
-  memcpy(H, F, N);
-
-  nptb = 0;
-  for (i = 0; i < Nm; i += 1)
-    if (M[i])
-      nptb += 1;
-
-  tab_es_x = (int32_t *)calloc(1,nptb * sizeof(int32_t));
-  tab_es_y = (int32_t *)calloc(1,nptb * sizeof(int32_t));
-  tab_es_z = (int32_t *)calloc(1,nptb * sizeof(int32_t));
-  if ((tab_es_x == NULL) || (tab_es_y == NULL) || (tab_es_z == NULL))
-  {  
-     fprintf(stderr,"lerosbin3d() : malloc failed for tab_es\n");
-     return(0);
-  }
-
-  l = 0;
-  for (k = 0; k < dsm; k += 1)
-    for (j = 0; j < csm; j += 1)
-      for (i = 0; i < rsm; i += 1)
-        if (M[k * psm + j * rsm + i])
-        {
-          tab_es_x[l] = i;
-          tab_es_y[l] = j;
-          tab_es_z[l] = k;
-          l += 1;
-        }
-
-  for (z = 0; z < ds; z++)
-  for (y = 0; y < cs; y++)
-  for (x = 0; x < rs; x++)
-  {
-    /* verifie si (x,y,z) est un point de la frontiere du fond */
-    w = z * ps + y * rs + x;
-    if (!H[w])
-    {
-      frontiere = 0;
-      for (l = 0; l <= 10; l += 2) /* parcourt les 6 voisins */
-      {
-        v = voisin6(w, l, rs, ps, N);
-        if ((v != -1) && (H[v])) { frontiere = 1; break; }
-      } /* for l... */
-
-      if (!frontiere) 
-        F[w] = NDG_MIN;
-      else
-      {
-        for (c = 0; c < nptb ; c += 1)
-        {
-          o = z + tab_es_z[c] - zc;
-          n = y + tab_es_y[c] - yc;
-          l = x + tab_es_x[c] - xc; 
-          if ((o >= 0) && (o < ds) && 
-              (n >= 0) && (n < cs) && 
-              (l >= 0) && (l < rs))
-	    F[o * ps + n * rs + l] = NDG_MIN;
-        }
-      }
-    }
-  }
-
-  free(H);
-  free(tab_es_x);
-  free(tab_es_y);
-  free(tab_es_z);
-  return 1;
-} /* lerosbin3d() */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
diff -r 8b1af7363833 src/lib/ldilateros3d.c
--- a/src/lib/ldilateros3d.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/ldilateros3d.c	Mon Jan 13 15:50:10 2014 +0100
@@ -45,7 +45,7 @@
 #include <ldilateros3d.h>
 
 /* ==================================== */
-int32_t ldilateros3d_ldilatbin3d(struct xvimage *f, struct xvimage *m, int32_t xc, int32_t yc, int32_t zc)
+int32_t ldilatbin3d(struct xvimage *f, struct xvimage *m, int32_t xc, int32_t yc, int32_t zc)
 /*
    Operateur de dilatation binaire 3D par un element structurant 
    de taille quelconque
diff -r 8b1af7363833 src/lib/ldisplay._notused_c
--- a/src/lib/ldisplay._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,235 +0,0 @@
-/* $Id: ldisplay.c,v 1.1.1.1 2008-11-25 08:01:41 mcouprie Exp $ */
-/* visualisation des pixels et de leurs valeurs */
-/* Michel Couprie - juin 1999 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcxbib.h>
-#include <lclick.h>
-
-/* ==================================== */
-int32_t lclick(struct xvimage *image, struct xvimage *lab, int32_t zoom)
-/* ==================================== */
-{
-  register int32_t x;              /* index muet de pixel */
-  int32_t i, k;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t d = depth(image);        /* nb. plans */
-  int32_t N = d * n;               /* taille image */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  uint32_t *LAB = ULONGDATA(lab);
-  int32_t curlab = 1;
-  int32_t incr = 0;
-  int32_t iplan = 0;
-#define NBBUTTONS 7
-#define NBLIGBUTT 2
-#define BOXWIDTH 70
-#define BOXHEIGHT 20
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int32_t xx, yy;
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT;
-  int32_t Width = rs;
-  int32_t ImageHeight = cs;
-  int32_t ImageWidth = rs;
-
-  if (zoom)
-  {
-    Height += cs;
-    Width += rs;
-    ImageHeight += cs;
-    ImageWidth += rs;
-  }
-
-  if (BoxWidth * NBBUTTONS > Width) Width = BoxWidth * NBBUTTONS;
-  
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], "LABEL");
-  sprintf(ButtonStrings[0][1], "%d", curlab);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "INCR ");
-  strcpy(ButtonStrings[0][5], "UNDO ");
-  strcpy(ButtonStrings[0][6], "QUIT ");
-
-  strcpy(ButtonStrings[1][0], " PLAN");
-  sprintf(ButtonStrings[1][1], "%d", iplan);
-  strcpy(ButtonStrings[1][2], "  +  ");
-  strcpy(ButtonStrings[1][3], "  -  ");
-  strcpy(ButtonStrings[1][4], "     ");
-  strcpy(ButtonStrings[1][5], "     ");
-  strcpy(ButtonStrings[1][6], "     ");
-
-/* ===========================================================
-    affichage : 
-   ===========================================================
-
-    <------- rs ------>     
-    ------------------- .
-    |                 | .
-    |                 | .
-    |                 | .
-    |      image      | cs
-    |                 | .
-    |                 | .
-    |                 | .
-    --------------------------------------------------
-    |LABEL | 111  |  +   |  -   | AUTO | UNDO | QUIT |        BoxHeight
-    --------------------------------------------------
-    | PLAN | 111  |  +   |  -   |      |      |      |        BoxHeight
-    --------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-ReDisplayImage:
-
-  /* send output to the screen */
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-  {
-    if (LAB[x])    
-      Color(MC_RED);
-    else
-      Color(SOURCE[x]/4);
-    if (zoom)
-    {
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point((x%n)%rs, (x%n)/rs);
-  }
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, ImageHeight + i * BoxHeight, k * BoxWidth, ImageHeight + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, ImageHeight + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  FlushGraphics();  
-
-  WaitMouseEvent(&xx, &yy);
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight))
-  {
-    if (zoom)
-    {
-      xx /= 2;
-      yy /= 2;
-    }
-    x = iplan * n + yy * rs + xx;
-
-    if (LAB[x]) 
-    {
-      LAB[x] = 0;
-    }
-    else
-    {
-      LAB[x] = curlab;
-      if (incr) 
-      {
-        curlab++;
-        sprintf(ButtonStrings[0][1], "%d", curlab);
-      }
-    }
-    if (LAB[x])    
-      Color(MC_RED);
-    else
-      Color(SOURCE[x]/4);
-    if (zoom)
-    {
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-    }
-    else
-      Point((x%n)%rs, (x%n)/rs);
-    goto ReDisplay;
-  }
-
-  xx /= BoxWidth;
-  yy -= ImageHeight;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: curlab++;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 3: curlab--;
-                      if (curlab < 1) curlab = 1;
-                      sprintf(ButtonStrings[0][1], "%d", curlab);
-                      break;
-              case 4: if (incr) 
-                      {
-                        incr = 0; 
-                        sprintf(ButtonStrings[0][4], "%s", "INCR ");
-		      }
-                      else
-		      { 
-                        incr = 1;
-                        sprintf(ButtonStrings[0][4], "%s", "IDEM ");
-		      }
-                      break;
-              case 5: for (x = 0; x < N; x++) LAB[x] = 0;
-                      goto ReDisplayImage;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: iplan++;
-                      if (iplan > d-1) iplan = d-1;
-                      sprintf(ButtonStrings[1][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 3: iplan--;
-                      if (iplan < 0) iplan = 0;
-                      sprintf(ButtonStrings[1][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 4: break;
-              case 5: break;
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    default: goto ReDisplayImage;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-  return(1);
-}
-
diff -r 8b1af7363833 src/lib/ldisplay3d._notused_c
--- a/src/lib/ldisplay3d._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,236 +0,0 @@
-/* $Id: ldisplay3d.c,v 1.1.1.1 2008-11-25 08:01:40 mcouprie Exp $ */
-/* affichage d'une image 3d par projection de voxels */
-/* Michel Couprie - septembre 1997 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcxbib.h>
-#include <lseuili.h>
-
-/* ==================================== */
-int32_t lseuili(struct xvimage *image)
-/* ==================================== */
-{
-  register int32_t i;              /* index muet */
-  int32_t k;                       /* index muet */
-  register int32_t x;              /* index muet de pixel */
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t d = depth(image);        /* nb plans */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *TEMP;
-  
-
-  int32_t Height = cs + ;
-  int32_t Width = rs;
-  
-  InitGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], " INF ");
-  sprintf(ButtonStrings[0][1], "%d", seuilinf);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "  1  ");
-  strcpy(ButtonStrings[0][5], "  5  ");
-  strcpy(ButtonStrings[0][6], "     ");
-
-  strcpy(ButtonStrings[1][0], " SUP ");
-  sprintf(ButtonStrings[1][1], "%d", seuilsup);
-  strcpy(ButtonStrings[1][2], "  +  ");
-  strcpy(ButtonStrings[1][3], "  -  ");
-  strcpy(ButtonStrings[1][4], " 10  ");
-  strcpy(ButtonStrings[1][5], " 20  ");
-  strcpy(ButtonStrings[1][6], "     ");
-
-  strcpy(ButtonStrings[2][0], " PLAN");
-  sprintf(ButtonStrings[2][1], "%d", iplan);
-  strcpy(ButtonStrings[2][2], "  +  ");
-  strcpy(ButtonStrings[2][3], "  -  ");
-  strcpy(ButtonStrings[2][4], "     ");
-  strcpy(ButtonStrings[2][5], "  OK ");
-  strcpy(ButtonStrings[2][6], " QUIT");
-
-  TEMP = (uint8_t *)calloc(1,N * sizeof(char));
-  if (TEMP == NULL)
-  {   fprintf(stderr, "lseuili() : malloc failed for TEMP\n");
-      return(0);
-  }
-
-ReSeuil:
-  for (x = 0; x < N; x++)
-    if ((SOURCE[x] >= seuilinf) && (SOURCE[x] <= seuilsup))
-      TEMP[x] = 255;
-    else
-      TEMP[x] = 0;
-
-/*
-    affichage : 
-
-    <------- rs ------>     
-    ------------------- .
-    |                 | .
-    |                 | .
-    |                 | .
-    |      image      | cs
-    |                 | .
-    |                 | .
-    |                 | .
-    -------------------------------------------------
-    | inf  | 111  |  +   |  -   |  1   |  5  |      | BoxHeight
-    -------------------------------------------------
-    | sup  | 111  |  +   |  -   |  10  |  20 |      | BoxHeight
-    -------------------------------------------------
-    | plan | 111  |  +   |  -   |      |  OK | QUIT | BoxHeight
-    -------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-ReDisplayImage:
-
-  FRectangle(0, 0, rs, cs);
-  ColToWhite();
-
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-    if (TEMP[x])    
-      Point((x%n)%rs, (x%n)/rs);
-  /* send output to the screen */
-  ColToBlack();
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, cs, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, cs + i * BoxHeight, Width, cs + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, cs + i * BoxHeight, k * BoxWidth, cs + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, cs + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  switch (increment)
-  {
-    case 1: FRectangle(4 * BoxWidth, cs, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, cs + BoxHeight - 2, ButtonStrings[0][4]);
-            ColToBlack();
-            break;
-    case 5: FRectangle(5 * BoxWidth, cs, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, cs + BoxHeight - 2, ButtonStrings[0][5]);
-            ColToBlack();
-            break;
-   case 10: FRectangle(4 * BoxWidth, cs + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, cs + 2*BoxHeight - 2, ButtonStrings[1][4]);
-            ColToBlack();
-            break;
-   case 20: FRectangle(5 * BoxWidth, cs + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, cs + 2*BoxHeight - 2, ButtonStrings[1][5]);
-            ColToBlack();
-            break;
-  } /* switch (increment) */
-
-  FlushGraphics();  
-
-  WaitMouseEvent(&xx, &yy);
-
-  xx /= BoxWidth;
-  yy -= cs;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: seuilinf += increment;
-                      if (seuilinf > NDG_MAX) seuilinf = NDG_MAX;
-                      sprintf(ButtonStrings[0][1], "%d", seuilinf);
-                      break;
-              case 3: seuilinf -= increment;
-                      if (seuilinf < NDG_MIN) seuilinf = NDG_MIN;
-                      sprintf(ButtonStrings[0][1], "%d", seuilinf);
-                      break;
-              case 4: increment = 1;
-                      break;
-              case 5: increment = 5;
-                      break;
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: seuilsup += increment;
-                      if (seuilsup > NDG_MAX) seuilsup = NDG_MAX;
-                      sprintf(ButtonStrings[1][1], "%d", seuilsup);
-                      break;
-              case 3: seuilsup -= increment;
-                      if (seuilsup < NDG_MIN) seuilsup = NDG_MIN;
-                      sprintf(ButtonStrings[1][1], "%d", seuilsup);
-                      break;
-              case 4: increment = 10;
-                      break;
-              case 5: increment = 20;
-                      break;
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    case 2: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: iplan++;
-                      if (iplan > d-1) iplan = d-1;
-                      sprintf(ButtonStrings[2][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 3: iplan--;
-                      if (iplan < 0) iplan = 0;
-                      sprintf(ButtonStrings[2][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 4: increment = 1000000;
-                      break;
-              case 5: goto ReSeuil;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-
-  for (x = 0; x < N; x++) SOURCE[x] = TEMP[x];
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      free(ButtonStrings[i][k]);
-  free(TEMP);
-  return(1);
-}
-
diff -r 8b1af7363833 src/lib/ldror_char.cxx
--- a/src/lib/ldror_char.cxx	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/ldror_char.cxx	Mon Jan 13 15:50:10 2014 +0100
@@ -225,7 +225,7 @@
     a=colsize%2;
     b=rowsize%2;
 
-    if (std::min(rowsize/2, colsize/2)==1)
+    if (min(rowsize/2, colsize/2)==1)
     {
         //cout << "On est dans une feuille" << endl;
         p = 0;
diff -r 8b1af7363833 src/lib/lfiltrestopo.c
--- a/src/lib/lfiltrestopo.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lfiltrestopo.c	Mon Jan 13 15:50:10 2014 +0100
@@ -646,9 +646,9 @@
           return 0;
         }
         ndes = p_despics(image, connexmin);
-        if (! lhtkern_lhtkernu(image, copy, connexmin))
+        if (! lhtkernu(image, copy, connexmin))
         {
-          fprintf(stderr, "%s: lhtkern_lhtkernu failed\n", F_NAME);
+          fprintf(stderr, "%s: lhtkernu failed\n", F_NAME);
           return 0;
         }
       } while (ndes);
@@ -663,7 +663,7 @@
         ndes = p_despuits(image, connexmin);
         if (! lhtkern(image, copy, connexmin))
         {
-          fprintf(stderr, "%s: lhtkern_lhtkern failed\n", F_NAME);
+          fprintf(stderr, "%s: lhtkern failed\n", F_NAME);
          return 0;
         }
       } while (ndes);
@@ -719,9 +719,9 @@
         return 0;
       }
       ndes = p_deslambdapics(image, connexmin, lambdapics);
-      if (! lhtkern_lhtkernu(image, copy, connexmin))
+      if (! lhtkernu(image, copy, connexmin))
       {
-        fprintf(stderr, "%s: lhtkern_lhtkernu failed\n", F_NAME);
+        fprintf(stderr, "%s: lhtkernu failed\n", F_NAME);
         return 0;
       }
       subimage(copy, image);
@@ -735,7 +735,7 @@
       ndes += p_deslambdapuits(image, connexmin, lambdapuits);
       if (! lhtkern(image, save, connexmin))
       {
-        fprintf(stderr, "%s: lhtkern_lhtkern failed\n", F_NAME);
+        fprintf(stderr, "%s: lhtkern failed\n", F_NAME);
         return 0;
       }
       subimage(image, copy);
@@ -794,9 +794,9 @@
         return 0;
       }
       ndes = p_deslambdapics(image, connexmin, lambdapics);
-      if (! lhtkern_lhtkernu(image, copy, connexmin))
+      if (! lhtkernu(image, copy, connexmin))
       {
-        fprintf(stderr, "%s: lhtkern_lhtkernu failed\n", F_NAME);
+        fprintf(stderr, "%s: lhtkernu failed\n", F_NAME);
         return 0;
       }
       memcpy(UCHARDATA(copy), UCHARDATA(image), N);
@@ -809,7 +809,7 @@
       ndes += p_deslambdapuits(image, connexmin, lambdapuits);
       if (! lhtkern(image, copy, connexmin))
       {
-        fprintf(stderr, "%s: lhtkern_lhtkern failed\n", F_NAME);
+        fprintf(stderr, "%s: lhtkern failed\n", F_NAME);
         return 0;
       }
       if (ndes) memcpy(UCHARDATA(copy), UCHARDATA(image), N);
@@ -862,9 +862,9 @@
         return 0;
       }
       ndes = p_despics(image, connexmin);
-      if (! lhtkern_lhtkernu(image, copy, connexmin))
+      if (! lhtkernu(image, copy, connexmin))
       {
-        fprintf(stderr, "%s: lhtkern_lhtkernu failed\n", F_NAME);
+        fprintf(stderr, "%s: lhtkernu failed\n", F_NAME);
         return 0;
       }
       memcpy(UCHARDATA(copy), UCHARDATA(image), N);
@@ -877,7 +877,7 @@
       ndes += p_despuits(image, connexmin);
       if (! lhtkern(image, copy, connexmin))
       {
-        fprintf(stderr, "%s: lhtkern_lhtkern failed\n", F_NAME);
+        fprintf(stderr, "%s: lhtkern failed\n", F_NAME);
         return 0;
       }
       if (ndes) memcpy(UCHARDATA(copy), UCHARDATA(image), N);
@@ -928,7 +928,7 @@
       ndes = p_despuits(image, connexmin);
       if (! lhtkern(image, copy, connexmin))
       {
-        fprintf(stderr, "%s: lhtkern_lhtkern failed\n", F_NAME);
+        fprintf(stderr, "%s: lhtkern failed\n", F_NAME);
         return 0;
       }
       if (ndes) memcpy(UCHARDATA(copy), UCHARDATA(image), N);
@@ -977,9 +977,9 @@
         return 0;
       }
       ndes = p_despics(image, connexmin);
-      if (! lhtkern_lhtkernu(image, copy, connexmin))
+      if (! lhtkernu(image, copy, connexmin))
       {
-        fprintf(stderr, "%s: lhtkern_lhtkernu failed\n", F_NAME);
+        fprintf(stderr, "%s: lhtkernu failed\n", F_NAME);
         return 0;
       }
       if (ndes) memcpy(UCHARDATA(copy), UCHARDATA(image), N);
diff -r 8b1af7363833 src/lib/lfusreg._notused_c
--- a/src/lib/lfusreg._notused_c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lfusreg._notused_c	Mon Jan 13 15:50:10 2014 +0100
@@ -93,8 +93,8 @@
 /* ==================================== */
 {
   uint8_t *F = UCHARDATA(img);
-  uint32_t *ML = ULONGDATA(mrq);
-  uint32_t *R = ULONGDATA(result);
+  uint32_t *ML = SLONGDATA(mrq);
+  uint32_t *R = SLONGDATA(result);
   uint32_t rs, cs, N;
   Fahd * FAHD;
   Fus * FUS;
diff -r 8b1af7363833 src/lib/lgeodesic.c
--- a/src/lib/lgeodesic.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lgeodesic.c	Mon Jan 13 15:50:10 2014 +0100
@@ -59,20 +59,57 @@
 /* dilatation geodesique de g sous f */
 /* g : image marqueur */
 /* f : image masque */
-/* connex : 4 ou 8 */
+/* connex : 4 ou 8 (2d) ou 6 ou 18 ou 26 (3d) */
 /* niter : nombre d'iterations (ou -1 pour saturation) */
 /* resultat dans g */
 /* ==================================== */
 #undef F_NAME 
 #define F_NAME "lgeodilat"
 {
-  int32_t nbchang, iter;
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(g);         /* taille ligne */
-  int32_t cs = colsize(g);         /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
+  COMPARE_SIZE(f, g);
+  ACCEPTED_TYPES3(f, VFF_TYP_1_BYTE, VFF_TYP_2_BYTE, VFF_TYP_4_BYTE);
+  ACCEPTED_TYPES3(g, VFF_TYP_1_BYTE, VFF_TYP_2_BYTE, VFF_TYP_4_BYTE);
+  if (datatype(f) != datatype(g))
+  {
+    fprintf(stderr, "%s: bad image type(s)\n", F_NAME);
+    return 0;
+  }
+
+    if (depth(f) == 1) 
+    {
+      if (datatype(f) == VFF_TYP_1_BYTE) return lgeodilat2d(g, f, connex, niter);
+      if (datatype(f) == VFF_TYP_2_BYTE) return lgeodilat2d_short(g, f, connex, niter);
+      if (datatype(f) == VFF_TYP_4_BYTE) return lgeodilat2d_long(g, f, connex, niter);
+    }
+    if (datatype(f) == VFF_TYP_1_BYTE) return lgeodilat3d(g, f, connex, niter);
+    if (datatype(f) == VFF_TYP_2_BYTE) return lgeodilat3d_short(g, f, connex, niter);
+    if (datatype(f) == VFF_TYP_4_BYTE) return lgeodilat3d_long(g, f, connex, niter);
+    return 1;
+} // lgeodilat()
+
+/* ==================================== */
+int32_t lgeodilat2d(
+        struct xvimage *g,
+        struct xvimage *f,
+        int32_t connex,
+        int32_t niter) 
+/* dilatation geodesique de g sous f */
+/* g : image marqueur */
+/* f : image masque */
+/* connex : 4 ou 8 */
+/* niter : nombre d'iterations (ou -1 pour saturation) */
+/* resultat dans g */
+/* ==================================== */
+#undef F_NAME 
+#define F_NAME "lgeodilat2d"
+{
+  index_t nbchang, iter;
+  index_t x;                       /* index muet de pixel */
+  index_t y;                       /* index muet (generalement un voisin de x) */
+  index_t k;                       /* index muet */
+  index_t rs = rowsize(g);         /* taille ligne */
+  index_t cs = colsize(g);         /* taille colonne */
+  index_t N = rs * cs;             /* taille image */
   uint8_t *G = UCHARDATA(g);      /* l'image marqueur */
   uint8_t *F = UCHARDATA(f);      /* l'image masque */
   uint8_t *H;                     /* image de travail */
@@ -186,10 +223,286 @@
   FifoTermine(FIFO[1]);
   IndicsTermine();
   return 1;
-} /* lgeodilat() */
+} /* lgeodilat2d() */
 
 /* ==================================== */
-int32_t lgeodesic_lreconsdilat(
+int32_t lgeodilat2d_short(
+        struct xvimage *g,
+        struct xvimage *f,
+        int32_t connex,
+        int32_t niter) 
+/* dilatation geodesique de g sous f */
+/* g : image marqueur */
+/* f : image masque */
+/* connex : 4 ou 8 */
+/* niter : nombre d'iterations (ou -1 pour saturation) */
+/* resultat dans g */
+/* ==================================== */
+#undef F_NAME 
+#define F_NAME "lgeodilat2d_short"
+{
+  index_t nbchang, iter;
+  index_t x;                       /* index muet de pixel */
+  index_t y;                       /* index muet (generalement un voisin de x) */
+  index_t k;                       /* index muet */
+  index_t rs = rowsize(g);         /* taille ligne */
+  index_t cs = colsize(g);         /* taille colonne */
+  index_t N = rs * cs;             /* taille image */
+  int16_t *G = SSHORTDATA(g);      /* l'image marqueur */
+  int16_t *F = SSHORTDATA(f);      /* l'image masque */
+  int16_t *H;                      /* image de travail */
+  int16_t *temp;
+  int16_t sup;
+  Fifo * FIFO[2];
+  int32_t incr_vois;
+
+  switch (connex)
+  {
+    case 4: incr_vois = 2; break;
+    case 8: incr_vois = 1; break;
+  } /* switch (connex) */
+
+  if ((rowsize(f) != rs) || (colsize(f) != cs))
+  {
+    fprintf(stderr, "%s: incompatible sizes\n", F_NAME);
+    return 0;
+  }
+
+  if (depth(f) != 1) 
+  {
+    fprintf(stderr, "%s: only works for 2d images\n", F_NAME);
+    return 0;
+  }
+
+  FIFO[0] = CreeFifoVide(N);
+  FIFO[1] = CreeFifoVide(N);
+  if ((FIFO[0] == NULL) || (FIFO[1] == NULL))
+  {   fprintf(stderr,"%s : CreeFifoVide failed\n", F_NAME);
+      return(0);
+  }
+
+  IndicsInit(N);
+
+  for (x = 0; x < N; x++)      /* mise en fifo initiale de tous les points */    
+  {
+    FifoPush(FIFO[1], x);
+    Set(x, 1);
+  }
+
+  H = (int16_t *)calloc(1,N*sizeof(int16_t));
+  if (H == NULL)
+  {   fprintf(stderr,"%s : malloc failed for H\n", F_NAME);
+      return(0);
+  }
+
+  for (x = 0; x < N; x++)      /* force G à être <= F */    
+    if (G[x] > F[x]) G[x] = F[x];
+
+  iter = 0;
+  do
+  {
+    iter += 1;
+    nbchang = 0;
+    while (! FifoVide(FIFO[iter % 2]))
+    {
+      x = FifoPop(FIFO[iter % 2]);
+      UnSet(x, iter % 2);
+      sup = G[x];
+      for (k = 0; k < 8; k += incr_vois)
+      {
+        y = voisin(x, k, rs, N);
+        if ((y != -1) && (G[y] > sup)) sup = G[y];
+      } /* for k */
+
+      sup = mcmin(sup, F[x]);
+      if (G[x] != sup) /* changement: on enregistre x ainsi que ses voisins */
+      {
+        nbchang += 1;
+        if (! IsSet(x, (iter + 1) % 2))
+        {
+          FifoPush(FIFO[(iter + 1) % 2], x);
+          Set(x, (iter + 1) % 2);
+	}
+        for (k = 0; k < 8; k += 1)
+        {
+          y = voisin(x, k, rs, N);
+          if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
+          {
+            FifoPush(FIFO[(iter + 1) % 2], y);
+            Set(y, (iter + 1) % 2);
+          }
+        } /* for k */
+      }
+      H[x] = sup;
+
+    } /* while ! FifoVide */
+    
+    /* echange les roles de G et H */
+    temp = G;
+    G = H;
+    H = temp;
+
+#ifdef VERBOSE
+    printf("iteration %d, nbchang %d\n", iter, nbchang);
+#endif
+  } while (((niter == -1) || (iter < niter)) && (nbchang != 0));
+
+  /* remet le resultat dans g si necessaire */
+  if (G != SSHORTDATA(g))
+  {
+    for (x = 0; x < N; x++)
+      (SSHORTDATA(g))[x] = G[x];
+    free(G);
+  }
+  else
+    free(H);
+
+  FifoTermine(FIFO[0]);
+  FifoTermine(FIFO[1]);
+  IndicsTermine();
+  return 1;
+} /* lgeodilat2d_short() */
+
+/* ==================================== */
+int32_t lgeodilat2d_long(
+        struct xvimage *g,
+        struct xvimage *f,
+        int32_t connex,
+        int32_t niter) 
+/* dilatation geodesique de g sous f */
+/* g : image marqueur */
+/* f : image masque */
+/* connex : 4 ou 8 */
+/* niter : nombre d'iterations (ou -1 pour saturation) */
+/* resultat dans g */
+/* ==================================== */
+#undef F_NAME 
+#define F_NAME "lgeodilat2d_long"
+{
+  index_t nbchang, iter;
+  index_t x;                       /* index muet de pixel */
+  index_t y;                       /* index muet (generalement un voisin de x) */
+  index_t k;                       /* index muet */
+  index_t rs = rowsize(g);         /* taille ligne */
+  index_t cs = colsize(g);         /* taille colonne */
+  index_t N = rs * cs;             /* taille image */
+  int32_t *G = SLONGDATA(g);      /* l'image marqueur */
+  int32_t *F = SLONGDATA(f);      /* l'image masque */
+  int32_t *H;                     /* image de travail */
+  int32_t *temp;
+  int32_t sup;
+  Fifo * FIFO[2];
+  int32_t incr_vois;
+
+  switch (connex)
+  {
+    case 4: incr_vois = 2; break;
+    case 8: incr_vois = 1; break;
+  } /* switch (connex) */
+
+  if ((rowsize(f) != rs) || (colsize(f) != cs))
+  {
+    fprintf(stderr, "%s: incompatible sizes\n", F_NAME);
+    return 0;
+  }
+
+  if (depth(f) != 1) 
+  {
+    fprintf(stderr, "%s: only works for 2d images\n", F_NAME);
+    return 0;
+  }
+
+  FIFO[0] = CreeFifoVide(N);
+  FIFO[1] = CreeFifoVide(N);
+  if ((FIFO[0] == NULL) || (FIFO[1] == NULL))
+  {   fprintf(stderr,"%s : CreeFifoVide failed\n", F_NAME);
+      return(0);
+  }
+
+  IndicsInit(N);
+
+  for (x = 0; x < N; x++)      /* mise en fifo initiale de tous les points */    
+  {
+    FifoPush(FIFO[1], x);
+    Set(x, 1);
+  }
+
+  H = (int32_t *)calloc(1,N*sizeof(int32_t));
+  if (H == NULL)
+  {   fprintf(stderr,"%s : malloc failed for H\n", F_NAME);
+      return(0);
+  }
+
+  for (x = 0; x < N; x++)      /* force G à être <= F */    
+    if (G[x] > F[x]) G[x] = F[x];
+
+  iter = 0;
+  do
+  {
+    iter += 1;
+    nbchang = 0;
+    while (! FifoVide(FIFO[iter % 2]))
+    {
+      x = FifoPop(FIFO[iter % 2]);
+      UnSet(x, iter % 2);
+      sup = G[x];
+      for (k = 0; k < 8; k += incr_vois)
+      {
+        y = voisin(x, k, rs, N);
+        if ((y != -1) && (G[y] > sup)) sup = G[y];
+      } /* for k */
+
+      sup = mcmin(sup, F[x]);
+      if (G[x] != sup) /* changement: on enregistre x ainsi que ses voisins */
+      {
+        nbchang += 1;
+        if (! IsSet(x, (iter + 1) % 2))
+        {
+          FifoPush(FIFO[(iter + 1) % 2], x);
+          Set(x, (iter + 1) % 2);
+	}
+        for (k = 0; k < 8; k += 1)
+        {
+          y = voisin(x, k, rs, N);
+          if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
+          {
+            FifoPush(FIFO[(iter + 1) % 2], y);
+            Set(y, (iter + 1) % 2);
+          }
+        } /* for k */
+      }
+      H[x] = sup;
+
+    } /* while ! FifoVide */
+    
+    /* echange les roles de G et H */
+    temp = G;
+    G = H;
+    H = temp;
+
+#ifdef VERBOSE
+    printf("iteration %d, nbchang %d\n", iter, nbchang);
+#endif
+  } while (((niter == -1) || (iter < niter)) && (nbchang != 0));
+
+  /* remet le resultat dans g si necessaire */
+  if (G != SLONGDATA(g))
+  {
+    for (x = 0; x < N; x++)
+      (SLONGDATA(g))[x] = G[x];
+    free(G);
+  }
+  else
+    free(H);
+
+  FifoTermine(FIFO[0]);
+  FifoTermine(FIFO[1]);
+  IndicsTermine();
+  return 1;
+} /* lgeodilat2d_long() */
+
+/* ==================================== */
+int32_t lreconsdilat(
         struct xvimage *g,
         struct xvimage *f,
         int32_t connex) 
@@ -218,13 +531,13 @@
 #undef F_NAME 
 #define F_NAME "lgeoeros"
 {
-  int32_t nbchang, iter;
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(g);         /* taille ligne */
-  int32_t cs = colsize(g);         /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
+  index_t nbchang, iter;
+  index_t x;                       /* index muet de pixel */
+  index_t y;                       /* index muet (generalement un voisin de x) */
+  index_t k;                       /* index muet */
+  index_t rs = rowsize(g);         /* taille ligne */
+  index_t cs = colsize(g);         /* taille colonne */
+  index_t N = rs * cs;             /* taille image */
   uint8_t *G = UCHARDATA(g);      /* l'image marqueur (au dessus de f) */
   uint8_t *F = UCHARDATA(f);      /* l'image masque */
   uint8_t *H;                     /* image de travail */
@@ -344,9 +657,9 @@
 int32_t ldeletecomp(
         struct xvimage *f,
         int32_t connex,
-        int32_t x, 
-        int32_t y, 
-        int32_t z) 
+        index_t x, 
+        index_t y, 
+        index_t z) 
 /* supprime la composante connexe de f (image binaire) 
    qui contient le point (x,y,z) */
 /* connex : 4, 8 (en 2D), 6, 18, 26 (en 3D) */
@@ -355,14 +668,14 @@
 #undef F_NAME 
 #define F_NAME "ldeletecomp"
 {
-  int32_t i;                       /* index muet de pixel */
-  int32_t j;                       /* index muet (generalement un voisin de x) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(f);         /* taille ligne */
-  int32_t cs = colsize(f);         /* taille colonne */
-  int32_t ds = depth(f);           /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
+  index_t i;                       /* index muet de pixel */
+  index_t j;                       /* index muet (generalement un voisin de x) */
+  index_t k;                       /* index muet */
+  index_t rs = rowsize(f);         /* taille ligne */
+  index_t cs = colsize(f);         /* taille colonne */
+  index_t ds = depth(f);           /* nb plans */
+  index_t ps = rs * cs;            /* taille plan */
+  index_t N = ps * ds;             /* taille image */
   uint8_t *F = UCHARDATA(f);
   Fifo * FIFO;
   int32_t incr_vois;
@@ -487,9 +800,9 @@
 int32_t lselectcomp(
         struct xvimage *f,
         int32_t connex,
-        int32_t x, 
-        int32_t y, 
-        int32_t z) 
+        index_t x, 
+        index_t y, 
+        index_t z) 
 /* extrait la composante connexe de f (image binaire) 
    qui contient le point (x,y,z) */
 /* connex : 4, 8 (en 2D), 6, 18, 26 (en 3D) */
@@ -498,14 +811,14 @@
 #undef F_NAME 
 #define F_NAME "lselectcomp"
 {
-  int32_t i;                       /* index muet de pixel */
-  int32_t j;                       /* index muet (generalement un voisin de x) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(f);         /* taille ligne */
-  int32_t cs = colsize(f);         /* taille colonne */
-  int32_t ds = depth(f);           /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
+  index_t i;                       /* index muet de pixel */
+  index_t j;                       /* index muet (generalement un voisin de x) */
+  index_t k;                       /* index muet */
+  index_t rs = rowsize(f);         /* taille ligne */
+  index_t cs = colsize(f);         /* taille colonne */
+  index_t ds = depth(f);           /* nb plans */
+  index_t ps = rs * cs;            /* taille plan */
+  index_t N = ps * ds;             /* taille image */
   uint8_t *F = UCHARDATA(f);
   Fifo * FIFO;
   int32_t incr_vois;
@@ -643,15 +956,15 @@
 #undef F_NAME 
 #define F_NAME "lgeodilat3d"
 {
-  int32_t nbchang, iter;
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(g);         /* taille ligne */
-  int32_t cs = colsize(g);         /* taille colonne */
-  int32_t d = depth(g);            /* nombre plans */           
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
+  index_t nbchang, iter;
+  index_t x;                       /* index muet de pixel */
+  index_t y;                       /* index muet (generalement un voisin de x) */
+  index_t k;                       /* index muet */
+  index_t rs = rowsize(g);         /* taille ligne */
+  index_t cs = colsize(g);         /* taille colonne */
+  index_t d = depth(g);            /* nombre plans */           
+  index_t n = rs * cs;             /* taille plan */
+  index_t N = n * d;               /* taille image */
   uint8_t *G = UCHARDATA(g);      /* l'image marqueur */
   uint8_t *F = UCHARDATA(f);      /* l'image masque */
   uint8_t *H;                     /* image de travail */
@@ -852,7 +1165,455 @@
 } // lgeodilat3d(
 
 /* ==================================== */
-int32_t lgeodesic_lreconsdilat3d(
+int32_t lgeodilat3d_short(
+        struct xvimage *g,
+        struct xvimage *f,
+        int32_t connex,
+        int32_t niter) 
+/* reconstruction de g sous f */
+/* g : image marqueur */
+/* f : image masque */
+/* connex : 6 ou 18 ou 26 */
+/* niter : nombre d'iterations (ou -1 pour saturation) */
+/* resultat dans g */
+/* ==================================== */
+#undef F_NAME 
+#define F_NAME "lgeodilat3d_short"
+{
+  index_t nbchang, iter;
+  index_t x;                       /* index muet de pixel */
+  index_t y;                       /* index muet (generalement un voisin de x) */
+  index_t k;                       /* index muet */
+  index_t rs = rowsize(g);         /* taille ligne */
+  index_t cs = colsize(g);         /* taille colonne */
+  index_t d = depth(g);            /* nombre plans */           
+  index_t n = rs * cs;             /* taille plan */
+  index_t N = n * d;               /* taille image */
+  int16_t *G = SSHORTDATA(g);      /* l'image marqueur */
+  int16_t *F = SSHORTDATA(f);      /* l'image masque */
+  int16_t *H;                      /* image de travail */
+  int16_t *temp;
+  int16_t sup;
+  Fifo * FIFO[2];
+
+  if ((rowsize(f) != rs) || (colsize(f) != cs) || (depth(f) != d))
+  {
+    fprintf(stderr, "%s: incompatible sizes\n", F_NAME);
+    return 0;
+  }
+
+  FIFO[0] = CreeFifoVide(N);
+  FIFO[1] = CreeFifoVide(N);
+  if ((FIFO[0] == NULL) || (FIFO[1] == NULL))
+  {   fprintf(stderr,"%s : CreeFifoVide failed\n", F_NAME);
+      return(0);
+  }
+
+  IndicsInit(N);
+
+  for (x = 0; x < N; x++)      /* mise en fifo initiale de tous les points */    {
+    FifoPush(FIFO[1], x);
+    Set(x, 1);
+  }
+
+  H = (int16_t *)calloc(1,N*sizeof(int16_t));
+  if (H == NULL)
+  {   fprintf(stderr,"%s : malloc failed for H\n", F_NAME);
+      return(0);
+  }
+
+  for (x = 0; x < N; x++)      /* force G à être <= F */    
+    if (G[x] > F[x]) G[x] = F[x];
+
+  if (connex == 26)
+  {
+    iter = 0;
+    do
+    {
+      iter += 1;
+      nbchang = 0;
+      while (! FifoVide(FIFO[iter % 2]))
+      {
+        x = FifoPop(FIFO[iter % 2]);
+        UnSet(x, iter % 2);
+        sup = G[x];
+        for (k = 0; k < 26; k += 1)
+        {
+          y = voisin26(x, k, rs, n, N);
+          if ((y != -1) && (G[y] > sup)) sup = G[y];
+        } /* for k */
+  
+        sup = mcmin(sup, F[x]);
+        if (G[x] != sup)
+        {  /* changement: on enregistre x ainsi que ses voisins */
+          nbchang += 1;
+          if (! IsSet(x, (iter + 1) % 2))
+          {
+            FifoPush(FIFO[(iter + 1) % 2], x);
+            Set(x, (iter + 1) % 2);
+  	  }
+          for (k = 0; k < 26; k += 1)
+          {
+            y = voisin26(x, k, rs, n, N);
+            if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
+            {
+              FifoPush(FIFO[(iter + 1) % 2], y);
+              Set(y, (iter + 1) % 2);
+            }
+          } /* for k */
+        }
+        H[x] = sup;
+      } /* while ! FifoVide */
+      temp = G; /* echange les roles de G et H */
+      G = H;
+      H = temp;
+#ifdef VERBOSE
+      printf("iteration %d, nbchang %d\n", iter, nbchang);
+#endif
+    } while (((niter == -1) || (iter < niter)) && (nbchang != 0));
+  }
+  else if (connex == 18)
+  {
+    iter = 0;
+    do
+    {
+      iter += 1;
+      nbchang = 0;
+      while (! FifoVide(FIFO[iter % 2]))
+      {
+        x = FifoPop(FIFO[iter % 2]);
+        UnSet(x, iter % 2);
+        sup = G[x];
+        for (k = 0; k < 18; k += 1)
+        {
+          y = voisin18(x, k, rs, n, N);
+          if ((y != -1) && (G[y] > sup)) sup = G[y];
+        } /* for k */
+  
+        sup = mcmin(sup, F[x]);
+        if (G[x] != sup)
+        {  /* changement: on enregistre x ainsi que ses voisins */
+          nbchang += 1;
+          if (! IsSet(x, (iter + 1) % 2))
+          {
+            FifoPush(FIFO[(iter + 1) % 2], x);
+            Set(x, (iter + 1) % 2);
+  	  }
+          for (k = 0; k < 18; k += 1)
+          {
+            y = voisin18(x, k, rs, n, N);
+            if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
+            {
+              FifoPush(FIFO[(iter + 1) % 2], y);
+              Set(y, (iter + 1) % 2);
+            }
+          } /* for k */
+        }
+        H[x] = sup;
+      } /* while ! FifoVide */
+      temp = G; /* echange les roles de G et H */
+      G = H;
+      H = temp;
+#ifdef VERBOSE
+      printf("iteration %d, nbchang %d\n", iter, nbchang);
+#endif
+    } while (((niter == -1) || (iter < niter)) && (nbchang != 0));
+  }
+  else if (connex == 6)
+  {
+    iter = 0;
+    do
+    {
+      iter += 1;
+      nbchang = 0;
+      while (! FifoVide(FIFO[iter % 2]))
+      {
+        x = FifoPop(FIFO[iter % 2]);
+        UnSet(x, iter % 2);
+        sup = G[x];
+        for (k = 0; k <= 10; k += 2)
+        {
+          y = voisin6(x, k, rs, n, N);
+          if ((y != -1) && (G[y] > sup)) sup = G[y];
+        } /* for k */
+  
+        sup = mcmin(sup, F[x]);
+        if (G[x] != sup)
+        {  /* changement: on enregistre x ainsi que ses voisins */
+          nbchang += 1;
+          if (! IsSet(x, (iter + 1) % 2))
+          {
+            FifoPush(FIFO[(iter + 1) % 2], x);
+            Set(x, (iter + 1) % 2);
+  	  }
+          for (k = 0; k <= 10; k += 2)
+          {
+            y = voisin6(x, k, rs, n, N);
+            if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
+            {
+              FifoPush(FIFO[(iter + 1) % 2], y);
+              Set(y, (iter + 1) % 2);
+            }
+          } /* for k */
+        }
+        H[x] = sup;
+      } /* while ! FifoVide */
+      temp = G; /* echange les roles de G et H */
+      G = H;
+      H = temp;
+#ifdef VERBOSE
+      printf("iteration %d, nbchang %d\n", iter, nbchang);
+#endif
+    } while (((niter == -1) || (iter < niter)) && (nbchang != 0));
+  }
+  else 
+  {
+    fprintf(stderr, "%s: bad connexity\n", F_NAME);
+    return 0;
+  }
+
+  /* remet le resultat dans g si necessaire */
+  if (G != SSHORTDATA(g))
+  {
+    for (x = 0; x < N; x++)
+      (SSHORTDATA(g))[x] = G[x];
+    free(G);
+  }
+  else
+    free(H);
+
+  FifoTermine(FIFO[0]);
+  FifoTermine(FIFO[1]);
+  IndicsTermine();
+  return 1;
+} // lgeodilat3d_short(
+
+/* ==================================== */
+int32_t lgeodilat3d_long(
+        struct xvimage *g,
+        struct xvimage *f,
+        int32_t connex,
+        int32_t niter) 
+/* reconstruction de g sous f */
+/* g : image marqueur */
+/* f : image masque */
+/* connex : 6 ou 18 ou 26 */
+/* niter : nombre d'iterations (ou -1 pour saturation) */
+/* resultat dans g */
+/* ==================================== */
+#undef F_NAME 
+#define F_NAME "lgeodilat3d_long"
+{
+  index_t nbchang, iter;
+  index_t x;                       /* index muet de pixel */
+  index_t y;                       /* index muet (generalement un voisin de x) */
+  index_t k;                       /* index muet */
+  index_t rs = rowsize(g);         /* taille ligne */
+  index_t cs = colsize(g);         /* taille colonne */
+  index_t d = depth(g);            /* nombre plans */           
+  index_t n = rs * cs;             /* taille plan */
+  index_t N = n * d;               /* taille image */
+  int32_t *G = SLONGDATA(g);      /* l'image marqueur */
+  int32_t *F = SLONGDATA(f);      /* l'image masque */
+  int32_t *H;                     /* image de travail */
+  int32_t *temp;
+  int32_t sup;
+  Fifo * FIFO[2];
+
+  if ((rowsize(f) != rs) || (colsize(f) != cs) || (depth(f) != d))
+  {
+    fprintf(stderr, "%s: incompatible sizes\n", F_NAME);
+    return 0;
+  }
+
+  FIFO[0] = CreeFifoVide(N);
+  FIFO[1] = CreeFifoVide(N);
+  if ((FIFO[0] == NULL) || (FIFO[1] == NULL))
+  {   fprintf(stderr,"%s : CreeFifoVide failed\n", F_NAME);
+      return(0);
+  }
+
+  IndicsInit(N);
+
+  for (x = 0; x < N; x++)      /* mise en fifo initiale de tous les points */    {
+    FifoPush(FIFO[1], x);
+    Set(x, 1);
+  }
+
+  H = (int32_t *)calloc(1,N*sizeof(int32_t));
+  if (H == NULL)
+  {   fprintf(stderr,"%s : malloc failed for H\n", F_NAME);
+      return(0);
+  }
+
+  for (x = 0; x < N; x++)      /* force G à être <= F */    
+    if (G[x] > F[x]) G[x] = F[x];
+
+  if (connex == 26)
+  {
+    iter = 0;
+    do
+    {
+      iter += 1;
+      nbchang = 0;
+      while (! FifoVide(FIFO[iter % 2]))
+      {
+        x = FifoPop(FIFO[iter % 2]);
+        UnSet(x, iter % 2);
+        sup = G[x];
+        for (k = 0; k < 26; k += 1)
+        {
+          y = voisin26(x, k, rs, n, N);
+          if ((y != -1) && (G[y] > sup)) sup = G[y];
+        } /* for k */
+  
+        sup = mcmin(sup, F[x]);
+        if (G[x] != sup)
+        {  /* changement: on enregistre x ainsi que ses voisins */
+          nbchang += 1;
+          if (! IsSet(x, (iter + 1) % 2))
+          {
+            FifoPush(FIFO[(iter + 1) % 2], x);
+            Set(x, (iter + 1) % 2);
+  	  }
+          for (k = 0; k < 26; k += 1)
+          {
+            y = voisin26(x, k, rs, n, N);
+            if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
+            {
+              FifoPush(FIFO[(iter + 1) % 2], y);
+              Set(y, (iter + 1) % 2);
+            }
+          } /* for k */
+        }
+        H[x] = sup;
+      } /* while ! FifoVide */
+      temp = G; /* echange les roles de G et H */
+      G = H;
+      H = temp;
+#ifdef VERBOSE
+      printf("iteration %d, nbchang %d\n", iter, nbchang);
+#endif
+    } while (((niter == -1) || (iter < niter)) && (nbchang != 0));
+  }
+  else if (connex == 18)
+  {
+    iter = 0;
+    do
+    {
+      iter += 1;
+      nbchang = 0;
+      while (! FifoVide(FIFO[iter % 2]))
+      {
+        x = FifoPop(FIFO[iter % 2]);
+        UnSet(x, iter % 2);
+        sup = G[x];
+        for (k = 0; k < 18; k += 1)
+        {
+          y = voisin18(x, k, rs, n, N);
+          if ((y != -1) && (G[y] > sup)) sup = G[y];
+        } /* for k */
+  
+        sup = mcmin(sup, F[x]);
+        if (G[x] != sup)
+        {  /* changement: on enregistre x ainsi que ses voisins */
+          nbchang += 1;
+          if (! IsSet(x, (iter + 1) % 2))
+          {
+            FifoPush(FIFO[(iter + 1) % 2], x);
+            Set(x, (iter + 1) % 2);
+  	  }
+          for (k = 0; k < 18; k += 1)
+          {
+            y = voisin18(x, k, rs, n, N);
+            if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
+            {
+              FifoPush(FIFO[(iter + 1) % 2], y);
+              Set(y, (iter + 1) % 2);
+            }
+          } /* for k */
+        }
+        H[x] = sup;
+      } /* while ! FifoVide */
+      temp = G; /* echange les roles de G et H */
+      G = H;
+      H = temp;
+#ifdef VERBOSE
+      printf("iteration %d, nbchang %d\n", iter, nbchang);
+#endif
+    } while (((niter == -1) || (iter < niter)) && (nbchang != 0));
+  }
+  else if (connex == 6)
+  {
+    iter = 0;
+    do
+    {
+      iter += 1;
+      nbchang = 0;
+      while (! FifoVide(FIFO[iter % 2]))
+      {
+        x = FifoPop(FIFO[iter % 2]);
+        UnSet(x, iter % 2);
+        sup = G[x];
+        for (k = 0; k <= 10; k += 2)
+        {
+          y = voisin6(x, k, rs, n, N);
+          if ((y != -1) && (G[y] > sup)) sup = G[y];
+        } /* for k */
+  
+        sup = mcmin(sup, F[x]);
+        if (G[x] != sup)
+        {  /* changement: on enregistre x ainsi que ses voisins */
+          nbchang += 1;
+          if (! IsSet(x, (iter + 1) % 2))
+          {
+            FifoPush(FIFO[(iter + 1) % 2], x);
+            Set(x, (iter + 1) % 2);
+  	  }
+          for (k = 0; k <= 10; k += 2)
+          {
+            y = voisin6(x, k, rs, n, N);
+            if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
+            {
+              FifoPush(FIFO[(iter + 1) % 2], y);
+              Set(y, (iter + 1) % 2);
+            }
+          } /* for k */
+        }
+        H[x] = sup;
+      } /* while ! FifoVide */
+      temp = G; /* echange les roles de G et H */
+      G = H;
+      H = temp;
+#ifdef VERBOSE
+      printf("iteration %d, nbchang %d\n", iter, nbchang);
+#endif
+    } while (((niter == -1) || (iter < niter)) && (nbchang != 0));
+  }
+  else 
+  {
+    fprintf(stderr, "%s: bad connexity\n", F_NAME);
+    return 0;
+  }
+
+  /* remet le resultat dans g si necessaire */
+  if (G != SLONGDATA(g))
+  {
+    for (x = 0; x < N; x++)
+      (SLONGDATA(g))[x] = G[x];
+    free(G);
+  }
+  else
+    free(H);
+
+  FifoTermine(FIFO[0]);
+  FifoTermine(FIFO[1]);
+  IndicsTermine();
+  return 1;
+} // lgeodilat3d_long(
+
+/* ==================================== */
+int32_t lreconsdilat3d(
         struct xvimage *g,
         struct xvimage *f,
         int32_t connex) 
@@ -881,15 +1642,15 @@
 #undef F_NAME 
 #define F_NAME "lgeoeros3d"
 {
-  int32_t nbchang, iter;
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(g);         /* taille ligne */
-  int32_t cs = colsize(g);         /* taille colonne */
-  int32_t d = depth(g);            /* nombre plans */           
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
+  index_t nbchang, iter;
+  index_t x;                       /* index muet de pixel */
+  index_t y;                       /* index muet (generalement un voisin de x) */
+  index_t k;                       /* index muet */
+  index_t rs = rowsize(g);         /* taille ligne */
+  index_t cs = colsize(g);         /* taille colonne */
+  index_t d = depth(g);            /* nombre plans */           
+  index_t n = rs * cs;             /* taille plan */
+  index_t N = n * d;               /* taille image */
   uint8_t *G = UCHARDATA(g);      /* l'image marqueur */
   uint8_t *F = UCHARDATA(f);      /* l'image masque */
   uint8_t *H;                     /* image de travail */
@@ -1090,7 +1851,7 @@
 } // lgeoeros3d(
 
 /* ==================================== */
-int32_t lgeodesic_lreconseros3d(
+int32_t lreconseros3d(
         struct xvimage *g,
         struct xvimage *f,
         int32_t connex) 
@@ -1114,12 +1875,12 @@
 #undef F_NAME 
 #define F_NAME "lamont"
 {
-  int32_t i, j, k;                 /* index muet de pixel */
-  int32_t rs = rowsize(f);         /* taille ligne */
-  int32_t cs = colsize(f);         /* taille colonne */
-  int32_t ds = depth(f);           /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
+  index_t i, j, k;                 /* index muet de pixel */
+  index_t rs = rowsize(f);         /* taille ligne */
+  index_t cs = colsize(f);         /* taille colonne */
+  index_t ds = depth(f);           /* nb plans */
+  index_t ps = rs * cs;            /* taille plan */
+  index_t N = ps * ds;             /* taille image */
   int32_t *F = SLONGDATA(f);
   uint8_t *M = UCHARDATA(m);
   Fifo * FIFO;
diff -r 8b1af7363833 src/lib/lgradinf.c
--- a/src/lib/lgradinf.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,48 +0,0 @@
-/* $Id: lgradinf.c,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-/* gradient inf */
-/* Michel Couprie - aout 1996 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mctopo.h>
-
-/* ==================================== */
-int32_t lgradinf(struct xvimage *image)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t *pt;
-  int32_t rs = image->row_size;
-  int32_t cs = image->col_size;
-  int32_t N = rs * cs;
-  uint8_t *imagetmp;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lgradinf: cette version ne traite pas les images volumiques\n");
-    exit(0);
-  }
-
-  imagetmp = (uint8_t *)calloc(1,N*sizeof(char));
-  if (imagetmp == NULL)
-  {   printf("lgradinf() : malloc failed\n");
-      return(0);
-  }
-
-  /* ---------------------------------------------------------- */
-  /* calcul du resultat */
-  /* ---------------------------------------------------------- */
-  
-  pt = UCHARDATA(image);
-  for (i = 0; i < N; i++)
-    imagetmp[i] = pt[i] - beta8m(pt, i, rs, N);
-
-  for (i = 0; i < N; i++)
-    pt[i] = imagetmp[i];
-
-  free(imagetmp);
-  return 1;
-}
diff -r 8b1af7363833 src/lib/lgradinf3d._notused_c
--- a/src/lib/lgradinf3d._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-/* $Id: lgradinf3d.c,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-/* gradient inf 3d */
-/* Michel Couprie - juillet 1997 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mctopo.h>
-
-/* ==================================== */
-int32_t lgradinf3d(struct xvimage *image)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t *pt;
-  int32_t rs = rowsize(image);
-  int32_t cs = colsize(image);
-  int32_t d = depth(image);
-  int32_t n = rs * cs;
-  int32_t N = d * n;
-  uint8_t *imagetmp;
-
-  imagetmp = (uint8_t *)calloc(1,N*sizeof(char));
-  if (imagetmp == NULL)
-  {   printf("lgradinf3d() : malloc failed\n");
-      return(0);
-  }
-
-  /* ---------------------------------------------------------- */
-  /* calcul du resultat */
-  /* ---------------------------------------------------------- */
-  
-  pt = UCHARDATA(image);
-  for (i = 0; i < N; i++)
-    imagetmp[i] = pt[i] - beta26m(pt, i, rs, n, N);
-
-  for (i = 0; i < N; i++)
-    pt[i] = imagetmp[i];
-
-  free(imagetmp);
-  return 1;
-}
diff -r 8b1af7363833 src/lib/lgradsup.c
--- a/src/lib/lgradsup.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,49 +0,0 @@
-/* $Id: lgradsup.c,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-/* gradient sup */
-/* Michel Couprie - octobre 1996 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mctopo.h>
-
-/* ==================================== */
-int32_t lgradsup(
-        struct xvimage *image)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t *pt;
-  int32_t rs = image->row_size;
-  int32_t cs = image->col_size;
-  int32_t N = rs * cs;
-  uint8_t *imagetmp;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lgradsup: cette version ne traite pas les images volumiques\n");
-    exit(0);
-  }
-
-  imagetmp = (uint8_t *)calloc(1,N*sizeof(char));
-  if (imagetmp == NULL)
-  {   printf("lgradsup() : malloc failed\n");
-      return(0);
-  }
-
-  /* ---------------------------------------------------------- */
-  /* calcul du resultat */
-  /* ---------------------------------------------------------- */
-  
-  pt = UCHARDATA(image);
-  for (i = 0; i < N; i++)
-    imagetmp[i] = beta8p(pt, i, rs, N) -  pt[i];
-
-  for (i = 0; i < N; i++)
-    pt[i] = imagetmp[i];
-
-  free(imagetmp);
-  return 1;
-}
diff -r 8b1af7363833 src/lib/lhthiniso.c
--- a/src/lib/lhthiniso.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lhthiniso.c	Mon Jan 13 15:50:10 2014 +0100
@@ -223,7 +223,6 @@
 } /* lhthiniso_RbtInsertAux() */
 
 /* ==================================== */
-static
 void LeftRotate(
   Rbt * T, RbtElt * x)
 /* ==================================== */
@@ -248,7 +247,6 @@
 } /* LeftRotate() */
 
 /* ==================================== */
-static
 void RightRotate(
   Rbt * T, RbtElt * x)
 /* ==================================== */
diff -r 8b1af7363833 src/lib/lhtkern.c
--- a/src/lib/lhtkern.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lhtkern.c	Mon Jan 13 15:50:10 2014 +0100
@@ -105,7 +105,6 @@
 */
 
 /* ==================================== */
-static
 int32_t testabaisse4(uint8_t *F, int32_t x, int32_t rs, int32_t N)
 /* ==================================== */
 {
@@ -129,7 +128,6 @@
 } /* testabaisse4() */
 
 /* ==================================== */
-static
 int32_t testabaisse8(uint8_t *F, int32_t x, int32_t rs, int32_t N)
 /* ==================================== */
 {
@@ -153,7 +151,6 @@
 } /* testabaisse8() */
 
 /* ==================================== */
-static
 int32_t testeleve4(uint8_t *F, int32_t x, int32_t rs, int32_t N)
 /* ==================================== */
 {
@@ -177,7 +174,6 @@
 } /* testeleve4() */
 
 /* ==================================== */
-static
 int32_t testeleve8(uint8_t *F, int32_t x, int32_t rs, int32_t N)
 /* ==================================== */
 {
@@ -362,7 +358,7 @@
 } /* lhtkern() */
 
 /* ==================================== */
-int32_t lhtkern_lhtkernu(struct xvimage *image, struct xvimage *imagecond, int32_t connex)
+int32_t lhtkernu(struct xvimage *image, struct xvimage *imagecond, int32_t connex)
 /* ==================================== */
 #undef F_NAME
 #define F_NAME "lhtkernu"
@@ -1615,7 +1611,7 @@
 } /* testniveleve8() */
 
 /* ==================================== */
-int32_t lhtkern_llvkern(struct xvimage *image, struct xvimage *imagecond, int32_t connex)
+int32_t llvkern(struct xvimage *image, struct xvimage *imagecond, int32_t connex)
 /* ==================================== */
 #undef F_NAME
 #define F_NAME "llvkern"
diff -r 8b1af7363833 src/lib/lhtkernu.c
--- a/src/lib/lhtkernu.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,405 +0,0 @@
-/* $Id: lhtkernu.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* operateur de calcul du noyau de homotopique par elevation */
-/* methode: saturation avec politique 4-directionnelle 
-   utilise 4 fifo */
-/* Michel Couprie -  avril 1997 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcfifo.h>
-#include <mctopo.h>
-#include <mcindic.h>
-#ifdef PERF
-#include <mcchrono.h>
-#endif
-#include <llabelextrema.h>
-#include <lhtkernu.h>
-
-#define EN_FIFO       0
-#define MAXI          1
-#define PARANO
-/*
-#define DEBUG
-*/
-
-/* ==================================== */
-static
-int32_t testeleve4(uint8_t *SOURCE, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t modifie = 0;
-
-#ifdef DEBUG
-printf("testeleve : point %d (%d %d), val = %d\n", x, x%rs, x/rs, SOURCE[x]);
-#endif
-
-  while (pconstr4(SOURCE,x,rs,N)) 
-  { 
-    modifie = 1; 
-    SOURCE[x] = alpha8p(SOURCE,x,rs,N);  /* alpha8p : sic */
-  }
-
-#ifdef DEBUG
-if (modifie) printf("========> ELEVE : %d\n", SOURCE[x]);
-#endif
-
-  return modifie;
-} /* testeleve4() */
-
-
-/* ==================================== */
-static
-int32_t testeleve8(uint8_t *SOURCE, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t modifie = 0;
-
-#ifdef DEBUG
-printf("testeleve : point %d (%d %d), val = %d\n", x, x%rs, x/rs, SOURCE[x]);
-#endif
-
-  while (pconstr8(SOURCE,x,rs,N)) 
-  { 
-    modifie = 1; 
-    SOURCE[x] = alpha8p(SOURCE,x,rs,N); 
-  }
-
-#ifdef DEBUG
-if (modifie) printf("========> ELEVE : %d\n", SOURCE[x]);
-#endif
-
-  return modifie;
-} /* testeleve8() */
-
-/* ==================================== */
-void testmaxi4(uint8_t *SOURCE, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t k, y;
-
-  for (k = 0; k < 8; k += 2)               /* parcourt les voisins en 4-connexite */
-  {                                        /* pour voir s'il existe un maximum */
-    y = voisin(x, k, rs, N);               /* au niveau atteint par x */
-    if ((y != -1) && (IsSet(y, MAXI)) && (SOURCE[y] == SOURCE[x])) 
-    { 
-      Set(x, MAXI); 
-      break; 
-    }
-  } /* for k */
-} /* testmaxi() */
-
-/* ==================================== */
-void testmaxi8(uint8_t *SOURCE, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t k, y;
-
-  for (k = 0; k < 8; k += 1)               /* parcourt les voisins en 8-connexite */
-  {                                        /* pour voir s'il existe un maximum */
-    y = voisin(x, k, rs, N);               /* au niveau atteint par x */
-    if ((y != -1) && (IsSet(y, MAXI)) && (SOURCE[y] == SOURCE[x])) 
-    { 
-      Set(x, MAXI); 
-      break; 
-    }
-  } /* for k */
-} /* testmaxi8() */
-
-/* ==================================== */
-static
-void empilevoisins(int32_t x, int32_t rs, int32_t N, Fifo *FIFOna, Fifo *FIFOea, Fifo *FIFOsa, Fifo *FIFOoa)
-/* ==================================== */
-{
-  int32_t y;
-
-  y = voisin(x, NORD, rs, N);
-  if ((y!=-1) && !IsSet(y,MAXI) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOna, y); Set(y, EN_FIFO); }
-  y = voisin(x, NORD+1, rs, N);
-  if ((y!=-1) && !IsSet(y,MAXI) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOna, y); Set(y, EN_FIFO); }
-  y = voisin(x, EST, rs, N);
-  if ((y!=-1) && !IsSet(y,MAXI) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOea, y); Set(y, EN_FIFO); }
-  y = voisin(x, EST+1, rs, N);
-  if ((y!=-1) && !IsSet(y,MAXI) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOea, y); Set(y, EN_FIFO); }
-  y = voisin(x, SUD, rs, N);
-  if ((y!=-1) && !IsSet(y,MAXI) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOsa, y); Set(y, EN_FIFO); }
-  y = voisin(x, SUD+1, rs, N);
-  if ((y!=-1) && !IsSet(y,MAXI) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOsa, y); Set(y, EN_FIFO); }
-  y = voisin(x, OUEST, rs, N);
-  if ((y!=-1) && !IsSet(y,MAXI) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOoa, y); Set(y, EN_FIFO); }
-  y = voisin(x, OUEST+1, rs, N);
-  if ((y!=-1) && !IsSet(y,MAXI) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOoa, y); Set(y, EN_FIFO); }
-} /* empilevoisins() */
-
-/* ==================================== */
-int32_t lhtkernu_lhtkernu(struct xvimage *image, int32_t nitermax, int32_t connex)
-/* ==================================== */
-{ 
-  int32_t i;
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  int32_t z;                       /* index muet (generalement un voisin de y) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *lab;
-  uint32_t *M;            /* l'image d'etiquettes de composantes connexes */
-  int32_t nmaxima;                 /* nombre de maxima differents */
-  int32_t niter;                   /* nombre d'iterations effectuees (4 directions) */
-  Fifo * FIFOn;
-  Fifo * FIFOs;
-  Fifo * FIFOe;
-  Fifo * FIFOo;
-  Fifo * FIFOna;
-  Fifo * FIFOsa;
-  Fifo * FIFOea;
-  Fifo * FIFOoa;
-  Fifo * FIFOtmp;
-#ifdef PERF
-  chrono chrono1;
-#endif
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lhtkernu: cette version ne traite pas les images volumiques\n");
-    exit(0);
-  }
-
-#ifdef PERF  
-  start_chrono(&chrono1);  /* pour l'analyse de performances */
-#endif
-
-  lab = allocimage(NULL, rs, cs, 1, VFF_TYP_4_BYTE);
-  if (lab == NULL)
-  {   
-    fprintf(stderr, "lhtkernu: allocimage failed\n");
-    return 0;
-  }
-  M = ULONGDATA(lab);
-
-  if (!llabelextrema(image, connex, LABMAX, lab, &nmaxima))
-  {   
-    fprintf(stderr, "lhtkernu: llabelextrema failed\n");
-    return 0;
-  }
-
-  IndicsInit(N);
-
-  FIFOn = CreeFifoVide(N/2);
-  FIFOs = CreeFifoVide(N/2);
-  FIFOe = CreeFifoVide(N/2);
-  FIFOo = CreeFifoVide(N/2);
-  if ((FIFOn == NULL) && (FIFOs == NULL) && (FIFOe == NULL) && (FIFOo == NULL))
-  {   fprintf(stderr, "lhtkernu() : CreeFifoVide failed\n");
-      return(0);
-  }
-
-  /* ================================================ */
-  /*                  DEBUT ALGO                      */
-  /* ================================================ */
-
-  /* ========================================================= */
-  /*   INITIALISATION DES FIFOs: empile les voisins des maxima */
-  /* ========================================================= */
-
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] != 0)                  /* le pixel appartient a un maximum */
-    {
-        Set(x, MAXI);
-        y = voisin(x, NORD, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOn, y); Set(y, EN_FIFO); }
-        y = voisin(x, NORD+1, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOn, y); Set(y, EN_FIFO); }
-        y = voisin(x, EST, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOe, y); Set(y, EN_FIFO); }
-        y = voisin(x, EST+1, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOe, y); Set(y, EN_FIFO); }
-        y = voisin(x, SUD, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOs, y); Set(y, EN_FIFO); }
-        y = voisin(x, SUD+1, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOs, y); Set(y, EN_FIFO); }
-        y = voisin(x, OUEST, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOo, y); Set(y, EN_FIFO); }
-        y = voisin(x, OUEST+1, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOo, y); Set(y, EN_FIFO); }
-    } /* if (M[x] != 0) */
-  } /* for x */
-
-  freeimage(lab);
-
-  FIFOna = CreeFifoVide(N/4);
-  FIFOsa = CreeFifoVide(N/4);
-  FIFOea = CreeFifoVide(N/4);
-  FIFOoa = CreeFifoVide(N/4);
-  if ((FIFOna == NULL) && (FIFOsa == NULL) && (FIFOea == NULL) && (FIFOoa == NULL))
-  {   fprintf(stderr, "lhtkernu() : CreeFifoVide failed\n");
-      return(0);
-  }
-
-  /* ================================================ */
-  /*                  DEBUT SATURATION                */
-  /* ================================================ */
-
-  niter = 0;
-
-if (connex == 4)  
-{
-  while (! (FifoVide(FIFOn) && FifoVide(FIFOe) && FifoVide(FIFOs) && FifoVide(FIFOo))
-          && ((nitermax == 0) || (niter < nitermax))
-        )
-  {
-    niter++;
-    while (! FifoVide(FIFOn))
-    {
-      x = FifoPop(FIFOn);
-      UnSet(x, EN_FIFO);
-      if (testeleve4(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-      {
-        testmaxi4(SOURCE, x, rs, N);            /* reactualise l'image MAXI */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-      } /* if (testeleve4(SOURCE, x, rs, N)) */
-    } /* while (! FifoVide(FIFOn)) */
-
-    while (! FifoVide(FIFOs))
-    {
-      x = FifoPop(FIFOs);
-      UnSet(x, EN_FIFO);
-      if (testeleve4(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-      {
-        testmaxi4(SOURCE, x, rs, N);            /* reactualise l'image MAXI */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-      } /* if (testeleve4(SOURCE, x, rs, N)) */
-    } /* while (! FifoVide(FIFOs)) */
-
-    while (! FifoVide(FIFOe))
-    {
-      x = FifoPop(FIFOe);
-      UnSet(x, EN_FIFO);
-      if (testeleve4(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-      {
-        testmaxi4(SOURCE, x, rs, N);            /* reactualise l'image MAXI */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-      } /* if (testeleve4(SOURCE, x, rs, N)) */
-    } /* while (! FifoVide(FIFOe)) */
-
-    while (! FifoVide(FIFOo))
-    {
-      x = FifoPop(FIFOo);
-      UnSet(x, EN_FIFO);
-      if (testeleve4(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-      {
-        testmaxi4(SOURCE, x, rs, N);            /* reactualise l'image MAXI */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-      } /* if (testeleve4(SOURCE, x, rs, N)) */
-    } /* while (! FifoVide(FIFOo)) */
-
-    FIFOtmp = FIFOn; FIFOn = FIFOna; FIFOna = FIFOtmp;
-    FIFOtmp = FIFOe; FIFOe = FIFOea; FIFOea = FIFOtmp;
-    FIFOtmp = FIFOs; FIFOs = FIFOsa; FIFOsa = FIFOtmp;
-    FIFOtmp = FIFOo; FIFOo = FIFOoa; FIFOoa = FIFOtmp;
-
-  } /* while (! (FifoVide(FIFOn) && FifoVide(FIFOe) && FifoVide(FIFOs) && FifoVide(FIFOo))) */
-}
-
-else /* connex == 8 */
-
-{
-  while (! (FifoVide(FIFOn) && FifoVide(FIFOe) && FifoVide(FIFOs) && FifoVide(FIFOo))
-          && ((nitermax == 0) || (niter < nitermax))
-        )
-  {
-    niter++;
-    while (! FifoVide(FIFOn))
-    {
-      x = FifoPop(FIFOn);
-      UnSet(x, EN_FIFO);
-      if (testeleve8(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-      {
-        testmaxi8(SOURCE, x, rs, N);            /* reactualise l'image MAXI */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-      } /* if (testeleve8(SOURCE, x, rs, N)) */
-    } /* while (! FifoVide(FIFOn)) */
-
-    while (! FifoVide(FIFOs))
-    {
-      x = FifoPop(FIFOs);
-      UnSet(x, EN_FIFO);
-      if (testeleve8(SOURCE, x, rs, N))        /* modifie l'image le cas echeant */
-      {
-        testmaxi8(SOURCE, x, rs, N);           /* reactualise l'image MAXI */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-      } /* if (testeleve8(SOURCE, x, rs, N)) */
-    } /* while (! FifoVide(FIFOs)) */
-
-    while (! FifoVide(FIFOe))
-    {
-      x = FifoPop(FIFOe);
-      UnSet(x, EN_FIFO);
-      if (testeleve8(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-      {
-        testmaxi8(SOURCE, x, rs, N);            /* reactualise l'image MAXI */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-      } /* if (testeleve8(SOURCE, x, rs, N)) */
-    } /* while (! FifoVide(FIFOe)) */
-
-    while (! FifoVide(FIFOo))
-    {
-      x = FifoPop(FIFOo);
-      UnSet(x, EN_FIFO);
-      if (testeleve8(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-      {
-        testmaxi8(SOURCE, x, rs, N);            /* reactualise l'image MAXI */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-      } /* if (testeleve8(SOURCE, x, rs, N)) */
-    } /* while (! FifoVide(FIFOo)) */
-
-    FIFOtmp = FIFOn; FIFOn = FIFOna; FIFOna = FIFOtmp;
-    FIFOtmp = FIFOe; FIFOe = FIFOea; FIFOea = FIFOtmp;
-    FIFOtmp = FIFOs; FIFOs = FIFOsa; FIFOsa = FIFOtmp;
-    FIFOtmp = FIFOo; FIFOo = FIFOoa; FIFOoa = FIFOtmp;
-
-  } /* while (! (FifoVide(FIFOn) && FifoVide(FIFOe) && FifoVide(FIFOs) && FifoVide(FIFOo))) */
-}
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FifoTermine(FIFOn);
-  FifoTermine(FIFOe);
-  FifoTermine(FIFOs);
-  FifoTermine(FIFOo);
-  FifoTermine(FIFOna);
-  FifoTermine(FIFOea);
-  FifoTermine(FIFOsa);
-  FifoTermine(FIFOoa);
-
-#ifdef PERF
-  save_time(N, read_chrono(&chrono1), "lhtkernu", image->name);    
-#endif
-  return(1);
-}
-/* -library_code_end */
diff -r 8b1af7363833 src/lib/llpemeyer.c
--- a/src/lib/llpemeyer.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/llpemeyer.c	Mon Jan 13 15:50:10 2014 +0100
@@ -70,8 +70,7 @@
 #define EN_FAH   0
 
 /* ==================================== */
-static
-int32_t NotIn(int32_t e, int32_t *list, int32_t n)                       
+int32_t llpemeyer_NotIn(int32_t e, int32_t *list, int32_t n)                       
 /* ==================================== */
 {
 /* renvoie 1 si e n'est pas dans list, 0 sinon */
@@ -81,10 +80,10 @@
   while (n > 0)
     if (list[--n] == e) return 0;
   return 1;
-} /* NotIn() */
+} /* llpemeyer_NotIn() */
 
 /* ==================================== */
-int32_t llpemeyer_llpemeyer(
+int32_t llpemeyer(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
@@ -119,7 +118,7 @@
 #endif
 
   if (depth(image) != 1) 
-    return llpemeyer_llpemeyer3d(image, marqueurs, marqueursfond, masque, connex);
+    return llpemeyer3d(image, marqueurs, marqueursfond, masque, connex);
 
   ACCEPTED_TYPES1(image, VFF_TYP_1_BYTE);
   ACCEPTED_TYPES1(marqueurs, VFF_TYP_1_BYTE);
@@ -265,7 +264,7 @@
     for (k = 0; k < 8; k += incr_vois)
     {
       y = voisin(x, k, rs, N);
-      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
       {
         etiqcc[ncc] = M[y];        
         ncc += 1;
@@ -310,7 +309,7 @@
 } // llpemeyer()
 
 /* ==================================== */
-int32_t llpemeyer_llpemeyer2(
+int32_t llpemeyer2(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *masque,
@@ -339,7 +338,7 @@
   index_t nlabels;
 
   if (depth(image) != 1) 
-    return llpemeyer_llpemeyer3d2(image, marqueurs, masque, connex);
+    return llpemeyer3d2(image, marqueurs, masque, connex);
 
   ACCEPTED_TYPES1(image, VFF_TYP_1_BYTE);
   ACCEPTED_TYPES1(marqueurs, VFF_TYP_4_BYTE);
@@ -409,7 +408,7 @@
     for (k = 0; k < 8; k += incr_vois)
     {
       y = voisin(x, k, rs, N);
-      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
       {
         etiqcc[ncc] = M[y];        
         ncc += 1;
@@ -465,7 +464,7 @@
 #undef F_NAME
 #define F_NAME "llpemeyer2lab"
 {
-  return llpemeyer_llpemeyer2(image, marqueurs, masque, connex);
+  return llpemeyer2(image, marqueurs, masque, connex);
 } // llpemeyer2lab()
 
 /* ==================================== */
@@ -481,7 +480,7 @@
 #undef F_NAME
 #define F_NAME "llpemeyer2lab_nomask"
 {
-  return llpemeyer_llpemeyer2(image, marqueurs, NULL, connex);
+  return llpemeyer2(image, marqueurs, NULL, connex);
 } // llpemeyer2lab_nomask()
 
 /* ==================================== */
@@ -609,7 +608,7 @@
     for (k = 0; k < 8; k += incr_vois)
     {
       y = voisin(x, k, rs, N);
-      if ((y != -1) && (M[y] != 0) && NotIn(M[y], etiqcc, ncc)) 
+      if ((y != -1) && (M[y] != 0) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
       {
         etiqcc[ncc] = M[y];        
         ncc += 1;
@@ -640,7 +639,7 @@
 } // llpemeyer3()
 
  /* ==================================== */
- int32_t llpemeyer_llpemeyerkhalimsky(
+ int32_t llpemeyerkhalimsky(
          struct xvimage *image,
          struct xvimage *marqueurs,
          struct xvimage *marqueursfond,
@@ -840,7 +839,7 @@
      for (k = 0; k < n; k++) /* parcourt les eventuels theta-voisins */
      {
        y = tab[k];
-       if ((M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+       if ((M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
        {
          etiqcc[ncc] = M[y];        
          ncc += 1;
@@ -888,7 +887,7 @@
  } /* llpemeyerkhalimsky() */
 
 /* ==================================== */
-int32_t llpemeyer_llpemeyersansligne(
+int32_t llpemeyersansligne(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
@@ -1109,7 +1108,7 @@
     for (k = 0; k < 8; k += incr_vois)
     {
       y = voisin(x, k, rs, N);
-      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
       {
         etiqcc[ncc] = M[y];        
         ncc += 1;
@@ -1141,7 +1140,7 @@
 } // llpemeyersansligne()
 
 /* ==================================== */
-int32_t llpemeyer_llpemeyersanslignelab(
+int32_t llpemeyersanslignelab(
         struct xvimage *image,
         struct xvimage *marqueurs, // marqueur initial et resultat
         struct xvimage *masque,
@@ -1259,7 +1258,7 @@
     for (k = 0; k < 8; k += incr_vois)
     {
       y = voisin(x, k, rs, N);
-      if ((y != -1) && (M[y] != 0) && NotIn(M[y], etiqcc, ncc)) 
+      if ((y != -1) && (M[y] != 0) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
       {
         etiqcc[ncc] = M[y];        
         ncc += 1;
@@ -1302,12 +1301,12 @@
    H. Talbot  2011/02/10
    ====================================*/
 {
-    return llpemeyer_llpemeyer2(image, marqueurs, NULL, connex);
+    return llpemeyer2(image, marqueurs, NULL, connex);
 }
    
 
 /* ==================================== */
-int32_t llpemeyer_llpemeyer3d(
+int32_t llpemeyer3d(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
@@ -1511,7 +1510,7 @@
         for (k = 0; k <= 10; k += 2)
         {
           y = voisin6(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -1522,7 +1521,7 @@
         for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
         {
           y = voisin18(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -1533,7 +1532,7 @@
         for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
         {
           y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -1606,7 +1605,7 @@
 } /* llpemeyer3d() */
 
 /* ==================================== */
-int32_t llpemeyer_llpemeyer3dsansligne(
+int32_t llpemeyer3dsansligne(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
@@ -1852,7 +1851,7 @@
         for (k = 0; k <= 10; k += 2)
         {
           y = voisin6(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -1863,7 +1862,7 @@
         for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
         {
           y = voisin18(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -1874,7 +1873,7 @@
         for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
         {
           y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -1934,7 +1933,7 @@
 } /* llpemeyer3dsansligne() */
 
 /* ==================================== */
-int32_t llpemeyer_llpemeyer3dsanslignelab(
+int32_t llpemeyer3dsanslignelab(
         struct xvimage *image,
         struct xvimage *marqueurs, // entree-sortie
         struct xvimage *masque,
@@ -2062,7 +2061,7 @@
         for (k = 0; k <= 10; k += 2)
         {
           y = voisin6(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2073,7 +2072,7 @@
         for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
         {
           y = voisin18(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2084,7 +2083,7 @@
         for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
         {
           y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2144,7 +2143,7 @@
 } /* llpemeyer3dsanslignelab() */
 
 /* ==================================== */
-int32_t llpemeyer_llpemeyer3d2(
+int32_t llpemeyer3d2(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *masque,
@@ -2256,7 +2255,7 @@
         for (k = 0; k <= 10; k += 2)
         {
           y = voisin6(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2267,7 +2266,7 @@
         for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
         {
           y = voisin18(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2278,7 +2277,7 @@
         for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
         {
           y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2352,7 +2351,7 @@
 } /* llpemeyer3d2() */
 
 /* ==================================== */
-int32_t llpemeyer_llpemeyer3d2b(
+int32_t llpemeyer3d2b(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *masque,
@@ -2497,7 +2496,7 @@
         for (k = 0; k <= 10; k += 2)
         {
           y = voisin6(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] <= nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] <= nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2508,7 +2507,7 @@
         for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
         {
           y = voisin18(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] <= nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] <= nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2519,7 +2518,7 @@
         for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
         {
           y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] <= nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] <= nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2734,7 +2733,7 @@
         for (k = 0; k <= 10; k += 2)
         {
           y = voisin6(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2745,7 +2744,7 @@
         for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
         {
           y = voisin18(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2756,7 +2755,7 @@
         for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
         {
           y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
@@ -2819,7 +2818,7 @@
 } /* llpemeyer3d3() */
 
 /* ==================================== */
-int32_t llpemeyer_llpemeyerbiconnecte(
+int32_t llpemeyerbiconnecte(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
@@ -3026,7 +3025,7 @@
     for (k = 0; k < 6; k += incr_vois)
     {
       y = voisin6b(x, k, rs, N, parite);
-      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
       {
         etiqcc[ncc] = M[y];        
         ncc += 1;
@@ -3072,7 +3071,7 @@
 
 
 /* ==================================== */
-int32_t llpemeyer_llpemeyerbiconnecte3d(
+int32_t llpemeyerbiconnecte3d(
         struct xvimage *image,
         struct xvimage *marqueurs,
         struct xvimage *marqueursfond,
@@ -3244,7 +3243,7 @@
     {
       y = voisin14b(x, k, rs, n, N);
       assert(y < N);     // sinon on innonde en dehors de l'image
-      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer_NotIn(M[y], etiqcc, ncc)) 
       {
 	etiqcc[ncc] = M[y];        	
 	ncc += 1;
diff -r 8b1af7363833 src/lib/llpemeyer3d._obsolete_c
--- a/src/lib/llpemeyer3d._obsolete_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,247 +0,0 @@
-/* $Id: llpemeyer3d.c,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-OBSOLETE - VOIR llpemeyer.c
-
-/* operateur de calcul de la ligne de partage des eaux en 3D (6-voisinage)*/
-/* utilise une File d'Attente Hierarchique */
-/*
-   d'apres "Un algorithme optimal de ligne de partage des eaux"
-           F. Meyer - actes du 8eme congres AFCET - Lyon-Villeurbanne
-           1991 
-   variante de la section VI (ligne d'epaisseur 1 pixel)
-*/
-/* Michel Couprie - juillet 1997 */
-
-#define PARANO                 /* even paranoid people have ennemies */
-#define VERBOSE
-
-/*
-#define TRACEPUSHINIT
-*/
-#define TRACEPUSH
-#define TRACEPOP
-#define TRACEMARQUE
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcfah.h>
-#include <mcindic.h>
-#include <mcchrono.h>
-#include <llpemeyer3d.h>
-
-#define EN_FAH   0
-
-/* ==================================== */
-int32_t NotIn(int32_t e, int32_t *list, int32_t n)                       
-/* ==================================== */
-{
-/* renvoie 1 si e n'est pas dans list, 0 sinon */
-/* e : l'element a rechercher */
-/* list : la liste (tableau d'entiers) */
-/* n : le nombre d'elements dans la liste */
-  while (n > 0)
-    if (list[--n] == e) return 0;
-  return 1;
-} /* NotIn() */
-
-/* ==================================== */
-int32_t llpemeyer3d(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        int32_t trace)
-/* ==================================== */
-{
-  register int32_t i;                       /* index muet */
-  register int32_t x;                       /* index muet de pixel */
-  register int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t w;                       /* index muet (generalement un voisin de x) */
-  register int32_t k;                       /* index muet */
-  int32_t j;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t d = depth(image);        /* nb plans */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *B = UCHARDATA(marqueurs);       /* l'image de marqueurs */
-  uint32_t *M;             /* l'image d'etiquettes */
-  int32_t nlabels;                 /* nombre de labels differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  chrono chrono1;
-  int32_t tracedate = 0;
-  int32_t etiqcc[6];
-  int32_t ncc;  
-
-  if ((rowsize(marqueurs) != rs) || (colsize(marqueurs) != cs))
-  {
-    fprintf(stderr, "llpemeyer3d: incompatible image sizes\n");
-    return 0;
-  }
-
-  /* pour l'analyse de performances */
-  start_chrono(&chrono1);
-
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "llpemeyer3d() : CreeFah failed\n");
-      return(0);
-  }
-
-  /* ================================================ */
-  /* CREATION DES LABELS INITIAUX                     */
-  /* ================================================ */
-
-  M = (uint32_t *)calloc(N, sizeof(int32_t));
-  if (M == NULL)
-  {   fprintf(stderr, "llpemeyer3d() : calloc failed\n");
-      return(0);
-  }
-  nlabels = 0;
-
-  for (x = 0; x < N; x++)
-  {
-    if (B[x] && (M[x] == 0))
-    {
-      nlabels += 1;
-      M[x] = nlabels;
-      FahPush(FAH, x, 0);
-      while (! FahVide(FAH))
-      {
-        w = FahPop(FAH);
-        for (k = 0; k <= 10; k += 2)
-        {
-          y = voisin6(w, k, rs, n, N);
-          if ((y != -1) && (M[y] == 0) && (B[y] == B[w]))
-          {
-            M[y] = nlabels;
-            FahPush(FAH, y, 0);
-          } /* if y ... */
-        } /* for k ... */
-      } /* while (! FahVide(FAH)) */
-    } /* if (M[x] == 0) */
-  } /* for (x = 0; x < N; x++) */
-
-  /* ================================================ */
-  /* INITIALISATION DE LA FAH                         */
-  /* ================================================ */
-
-  FahFlush(FAH);
-  FahPush(FAH, -1, 0);   /* force la creation du niveau 0 dans la Fah. */
-                         /* NECESSAIRE pour eviter la creation prematuree */
-                         /* de la file d'urgence */ 
-
-  for (x = 0; x < N; x++)
-  {
-    if (B[x])            /* on va empiler les voisins des regions marquees */
-    {
-      for (k = 0; k <= 10; k += 2)
-      {
-        y = voisin6(x, k, rs, n, N);
-        if ((y != -1) && !B[y] && !IsSet(y, EN_FAH))
-        {            
-          FahPush(FAH, y, SOURCE[y]);
-          Set(y, EN_FAH);
-#ifdef TRACEPUSHINIT
-          if (trace) printf("%d: empile point %d (%d,%d) au niveau %d\n", 
-                             tracedate++, y, y%rs, y/rs, SOURCE[y]);
-#endif
-
-        }
-      } /* for (k = 0; k < 8; k += 2) */
-    } /* if (B[x]) */
-  } /* for (x = 0; x < N; x++) */
-
-  x = FahPop(FAH);
-#ifdef PARANO
-  if (x != -1)
-  {   
-     fprintf(stderr,"lpemeyer3d() : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n");
-     return(0);
-  }
-#endif
-
-  /* ================================================ */
-  /* INONDATION                                       */
-  /* ================================================ */
-
-  nlabels += 1;          /* cree le label pour les points de la LPE */
-  while (! FahVide(FAH))
-  {
-    x = FahPop(FAH);
-    UnSet(x, EN_FAH);
-
-#ifdef TRACEPOP
-    if (trace) 
-    {
-      printf("%d: POP point %d (%d,%d) ; niveau %d\n", 
-              tracedate++, x, x%rs, x/rs, SOURCE[x]);
-    }
-#endif
-
-    ncc = 0;
-    for (k = 0; k <= 10; k += 2)
-    {
-      y = voisin6(x, k, rs, n, N);
-      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-      {
-        etiqcc[ncc] = M[y];        
-        ncc += 1;
-      }
-    } /* for k */
-
-    if (ncc == 1)
-    {
-      M[x] = etiqcc[0];
-#ifdef TRACEMARQUE
-          if (trace) printf("%d: marque point %d (%d,%d) label %d\n", 
-                             tracedate++, x, x%rs, x/rs, M[x]);
-#endif
-      for (k = 0; k <= 10; k += 2)
-      {
-        y = voisin6(x, k, rs, n, N);     
-        if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)))
-        {
-          FahPush(FAH, y, SOURCE[y]);
-          Set(y, EN_FAH);
-#ifdef TRACEPUSH
-          if (trace) printf("%d: empile point %d (%d,%d) au niveau %d\n", 
-                             tracedate++, y, y%rs, y/rs, SOURCE[y]);
-#endif
-        } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-      } /* for k */
-    } 
-    else 
-    if (ncc > 1)
-    {
-      M[x] = nlabels;
-#ifdef TRACEMARQUE
-          if (trace) printf("%d: marque point %d (%d,%d) label LPE\n", 
-                             tracedate++, x, x%rs, x/rs);
-#endif
-    }
-  } /* while (! FahVide(FAH)) */
-  /* FIN PROPAGATION */
-
-  for (x = 0; x < N; x++)
-  {
-    if ((M[x] == nlabels) || (M[x] == 0)) SOURCE[x] = 255; else SOURCE[x] = 0;
-  }
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FahTermine(FAH);
-  free(M);
-
-  /* pour l'analyse de performances */
-  save_time(N, read_chrono(&chrono1), "llpemeyer3d", image->name);    
-  return(1);
-}
-
diff -r 8b1af7363833 src/lib/llpemeyer4d.c
--- a/src/lib/llpemeyer4d.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/llpemeyer4d.c	Mon Jan 13 15:50:10 2014 +0100
@@ -60,8 +60,7 @@
 #define EN_FAH   0
 
 /* ==================================== */
-static
-int32_t NotIn(int32_t e, int32_t *list, int32_t n)                       
+int32_t llpemeyer4d_NotIn(int32_t e, int32_t *list, int32_t n)                       
 /* ==================================== */
 {
 /* renvoie 1 si e n'est pas dans list, 0 sinon */
@@ -272,7 +271,7 @@
         for (k = 0; k < 8; k ++)
         {
           y = voisin4D8(x, k, rs, n, N, Nt);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
+          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && llpemeyer4d_NotIn(M[y], etiqcc, ncc)) 
           {
             etiqcc[ncc] = M[y];        
             ncc += 1;
diff -r 8b1af7363833 src/lib/llpemeyer_regular.c
--- a/src/lib/llpemeyer_regular.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,2014 +0,0 @@
-/* $Id: llpemeyer_regular.c,v 1.1.1.1 2008-11-25 08:01:41 mcouprie Exp $ */
-/* 
-   Operateur de calcul de la ligne de partage des eaux
-   d'apres "Un algorithme optimal de ligne de partage des eaux"
-           F. Meyer - actes du 8eme congres AFCET - Lyon-Villeurbanne
-           1991 
-   variante de la section VI (ligne d'epaisseur 1 pixel)
-
-   Utilise une File d'Attente Hierarchique.
-
-   Michel Couprie - juin 1997 
-
-   Update janvier 2000 : generation d'una animation (flag ANIMATE)
-   Update janvier 2001 : mise a jour 2D-3D 
-   Update juin 2004  : "écriture" d'une version sans ligne
-*/
-
-/*
-*/
-//#define ANIMATE
-
-#define PARANO                 /* even paranoid people have ennemies */
-#define VERBOSE
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcfah.h>
-#include <mcindic.h>
-#include <llpemeyer.h>
-#include <mckhalimsky2d.h>
-
-#define EN_FAH   0
-
-/* ==================================== */
-static
-int32_t NotIn(int32_t e, int32_t *list, int32_t n)                       
-/* ==================================== */
-{
-/* renvoie 1 si e n'est pas dans list, 0 sinon */
-/* e : l'element a rechercher */
-/* list : la liste (tableau d'entiers) */
-/* n : le nombre d'elements dans la liste */
-  while (n > 0)
-    if (list[--n] == e) return 0;
-  return 1;
-} /* NotIn() */
-
-/* ==================================== */
-int32_t llpemeyer_regular_llpemeyer(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque,
-        int32_t connex)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "llpemeyer"
-{
-  register int32_t i;                       /* index muet */
-  register int32_t x;                       /* index muet de pixel */
-  register int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t w;                       /* index muet (generalement un voisin de x) */
-  register int32_t k;                       /* index muet */
-  int32_t j;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *B = UCHARDATA(marqueurs);       /* l'image de marqueurs */
-  uint8_t *BF;                             /* l'image de marqueurs du fond */
-  uint8_t *MA;                             /* l'image de masque */
-  uint32_t *M;             /* l'image d'etiquettes */
-  int32_t nlabels;                 /* nombre de labels differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  int32_t etiqcc[4];
-  int32_t ncc;  
-  int32_t incr_vois;
-#ifdef ANIMATE
-  int32_t curlev = -1, nimage = 0; 
-  char imname[128];
-  struct xvimage *animimage;
-  uint8_t *A;
-#endif
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "%s: cette version ne traite pas les images volumiques\n", F_NAME);
-    exit(0);
-  }
-
-  if ((rowsize(marqueurs) != rs) || (colsize(marqueurs) != cs))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-
-  if (marqueursfond && ((rowsize(marqueursfond) != rs) || (colsize(marqueursfond) != cs)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (masque && ((rowsize(masque) != rs) || (colsize(masque) != cs)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (masque) MA = UCHARDATA(masque);
-  if (marqueursfond) BF = UCHARDATA(marqueursfond);
-
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "%s : CreeFah failed\n", F_NAME);
-      return(0);
-  }
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-    default: 
-      fprintf(stderr, "%s: mauvaise connexite: %d\n", F_NAME, connex);
-      return 0;
-  } /* switch (connex) */    
-
-  /* ================================================ */
-  /* CREATION DES LABELS INITIAUX                     */
-  /* ================================================ */
-
-  M = (uint32_t *)calloc(N, sizeof(int32_t));
-  if (M == NULL)
-  {   fprintf(stderr, "%s : calloc failed\n", F_NAME);
-      return(0);
-  }
-  nlabels = 0;
-
-  if (marqueursfond)
-  {
-    nlabels += 1;                 /* tous les marqueurs du fond ont le meme label (1) */
-    for (x = 0; x < N; x++)
-    {
-      if (BF[x] && (M[x] == 0) && (!masque || MA[x]))
-      {
-        M[x] = nlabels;
-        FahPush(FAH, x, 0);
-        while (! FahVide(FAH))
-        {
-          w = FahPop(FAH);
-          for (k = 0; k < 8; k += incr_vois)
-          {
-            y = voisin(w, k, rs, N);
-            if ((y != -1) &&  BF[y] && (M[y] == 0) && (!masque || MA[y]))
-            {
-              M[y] = nlabels;
-              FahPush(FAH, y, 0);
-            } /* if y ... */
-          } /* for k ... */
-        } /* while (! FahVide(FAH)) */
-      } /* if (M[x] == 0) */
-    } /* for (x = 0; x < N; x++) */
-  } /* if (marqueursfond) */
-
-  for (x = 0; x < N; x++)
-  {
-    if (B[x] && (M[x] == 0) && (!masque || MA[x]))
-    {
-      nlabels += 1;
-      M[x] = nlabels;
-      FahPush(FAH, x, 0);
-      while (! FahVide(FAH))
-      {
-        w = FahPop(FAH);
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if ((y != -1) &&  B[y] && (M[y] == 0) && (!masque || MA[y]))
-          {
-            M[y] = nlabels;
-            FahPush(FAH, y, 0);
-          } /* if y ... */
-        } /* for k ... */
-      } /* while (! FahVide(FAH)) */
-    } /* if (M[x] == 0) */
-  } /* for (x = 0; x < N; x++) */
-
-  /* ================================================ */
-  /* INITIALISATION DE LA FAH                         */
-  /* ================================================ */
-
-  FahFlush(FAH);
-  FahPush(FAH, -1, 0);   /* force la creation du niveau 0 dans la Fah. */
-                         /* NECESSAIRE pour eviter la creation prematuree */
-                         /* de la file d'urgence */ 
-
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] && (!masque || MA[x]))            /* on va empiler les voisins des regions marquees */
-    {
-      for (k = 0; k < 8; k += incr_vois)
-      {
-        y = voisin(x, k, rs, N);
-        if ((y != -1) && !M[y] && !IsSet(y, EN_FAH))
-        {        
-          FahPush(FAH, y, F[y]);
-          Set(y, EN_FAH);
-        }
-      } /* for (k = 0; k < 8; k += 2) */
-    } /* if (M[x]) */
-  } /* for (x = 0; x < N; x++) */
-
-  x = FahPop(FAH);
-#ifdef PARANO
-  if (x != -1)
-  {   
-     fprintf(stderr,"%s : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n", F_NAME);
-     return(0);
-  }
-#endif
-
-  /* ================================================ */
-  /* INONDATION                                       */
-  /* ================================================ */
-
-#ifdef ANIMATE
-  animimage = copyimage(image);
-  A = UCHARDATA(animimage);
-#endif
-  nlabels += 1;          /* cree le label pour les points de la LPE */
-  while (! FahVide(FAH))
-  {
-    x = FahPop(FAH);
-    UnSet(x, EN_FAH);
-#ifdef ANIMATE
-    if (F[x] > curlev)
-    {
-      printf("Niveau %d\n", F[x]);
-      sprintf(imname, "anim%03d.pgm", nimage); nimage++;
-      for (y = 0; y < N; y++)
-        if ((M[y] == nlabels) || (M[y] == 0)) A[y] = 255; else A[y] = 0;
-      writeimage(animimage, imname);
-      curlev = F[x];
-    }
-#endif
-
-    ncc = 0;
-    for (k = 0; k < 8; k += incr_vois)
-    {
-      y = voisin(x, k, rs, N);
-      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-      {
-        etiqcc[ncc] = M[y];        
-        ncc += 1;
-      }
-    } /* for k */
-
-    if (ncc == 1)
-    {
-      M[x] = etiqcc[0];
-      for (k = 0; k < 8; k += incr_vois)
-      {
-        y = voisin(x, k, rs, N);     
-        if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-        {          
-          FahPush(FAH, y, F[y]); 
-          Set(y, EN_FAH);
-        } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-      } /* for k */
-    } 
-    else 
-    if (ncc > 1)
-    {
-      M[x] = nlabels;
-    }
-
-  } /* while (! FahVide(FAH)) */
-  /* FIN PROPAGATION */
-
-  for (x = 0; x < N; x++)
-  {
-    if ((M[x] == nlabels) || (M[x] == 0)) F[x] = 255; else F[x] = 0;
-  }
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FahTermine(FAH);
-  free(M);
-  return(1);
-} /*  /* llpemeyer() */
-
-/* ==================================== */
-int32_t llpemeyer_regular_llpemeyer2(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *masque,
-        int32_t connex)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "llpemeyer2"
-{
-  register int32_t i;                       /* index muet */
-  register int32_t x;                       /* index muet de pixel */
-  register int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t w;                       /* index muet (generalement un voisin de x) */
-  register int32_t k;                       /* index muet */
-  int32_t j;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);  /* l'image de depart */
-  uint32_t *M = ULONGDATA(marqueurs);   /* l'image de marqueurs */
-  uint8_t *MA;                         /* l'image de masque */
-  Fah * FAH;                                 /* la file d'attente hierarchique */
-  int32_t etiqcc[4];
-  int32_t ncc;  
-  int32_t incr_vois;
-  int32_t nlabels;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "%s: cette version ne traite pas les images volumiques\n", F_NAME);
-    exit(0);
-  }
-
-  if ((rowsize(marqueurs) != rs) || (colsize(marqueurs) != cs))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (masque && ((rowsize(masque) != rs) || (colsize(masque) != cs)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (masque) MA = UCHARDATA(masque);
-
-  if (datatype(marqueurs) != VFF_TYP_4_BYTE)
-  {
-    fprintf(stderr, "%s: marker image must be uint32_t\n", F_NAME);
-    return 0;
-  }
-
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "%s : CreeFah failed\n", F_NAME);
-      return(0);
-  }
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-    default: 
-      fprintf(stderr, "%s: mauvaise connexite: %d\n", F_NAME, connex);
-      return 0;
-  } /* switch (connex) */    
-
-  nlabels = 0;
-  for (x = 0; x < N; x++) if (M[x] > nlabels) nlabels = M[x];
-
-  /* ================================================ */
-  /* INITIALISATION DE LA FAH                         */
-  /* ================================================ */
-
-  FahFlush(FAH);
-  FahPush(FAH, -1, 0);   /* force la creation du niveau 0 dans la Fah. */
-                         /* NECESSAIRE pour eviter la creation prematuree */
-                         /* de la file d'urgence */ 
-
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] && (!masque || MA[x]))            /* on va empiler les voisins des regions marquees */
-    {
-      for (k = 0; k < 8; k += incr_vois)
-      {
-        y = voisin(x, k, rs, N);
-        if ((y != -1) && !M[y] && !IsSet(y, EN_FAH))
-        {        
-          FahPush(FAH, y, F[y]);
-          Set(y, EN_FAH);
-        }
-      } /* for (k = 0; k < 8; k += 2) */
-    } /* if (M[x]) */
-  } /* for (x = 0; x < N; x++) */
-
-  x = FahPop(FAH);
-#ifdef PARANO
-  if (x != -1)
-  {   
-     fprintf(stderr,"%s : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n", F_NAME);
-     return(0);
-  }
-#endif
-
-  /* ================================================ */
-  /* INONDATION                                       */
-  /* ================================================ */
-
-  nlabels += 1;          /* cree le label pour les points de la LPE */
-  while (! FahVide(FAH))
-  {
-    x = FahPop(FAH);
-    UnSet(x, EN_FAH);
-
-    ncc = 0;
-    for (k = 0; k < 8; k += incr_vois)
-    {
-      y = voisin(x, k, rs, N);
-      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-      {
-        etiqcc[ncc] = M[y];        
-        ncc += 1;
-      }
-    } /* for k */
-
-    if (ncc == 1)
-    {
-      M[x] = etiqcc[0];
-      for (k = 0; k < 8; k += incr_vois)
-      {
-        y = voisin(x, k, rs, N);     
-        if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-        {          
-          FahPush(FAH, y, F[y]); 
-          Set(y, EN_FAH);
-        } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-      } /* for k */
-    } 
-    else 
-    if (ncc > 1)
-    {
-      M[x] = nlabels;
-    }
-  } /* while (! FahVide(FAH)) */
-  /* FIN PROPAGATION */
-
-  for (x = 0; x < N; x++)
-  {
-    if ((M[x] == nlabels) || (M[x] == 0)) F[x] = 255; else F[x] = 0;
-  }
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FahTermine(FAH);
-  return(1);
-} /*  /* llpemeyer2() */
-
- /* ==================================== */
- int32_t llpemeyer_regular_llpemeyerkhalimsky(
-         struct xvimage *image,
-         struct xvimage *marqueurs,
-         struct xvimage *marqueursfond,
-         struct xvimage *masque)
- /* ==================================== */
-#undef F_NAME
-#define F_NAME "llpemeyerkhalimsky"
- /* 
- Pour forcer la lpe a passer par des elements de rang < 2,
- l'image "image" doit avoir ete generee a partir de Z2
- en utilisant la  strategie Max pour passer dans la grille de Khalimsky.
- De plus, les elements de rang 0 et 1, a ndg egal, ont une priorite 
- superieure a celle des elements de rang 2.
- */
-
- {
-   register int32_t i;                       /* index muet */
-   register int32_t x;                       /* index muet de pixel */
-   register int32_t y;                       /* index muet (generalement un voisin de x) */
-   register int32_t w;                       /* index muet (generalement un voisin de x) */
-   register int32_t k;                       /* index muet */
-   int32_t j;
-   int32_t rs = rowsize(image);     /* taille ligne */
-   int32_t cs = colsize(image);     /* taille colonne */
-   int32_t N = rs * cs;             /* taille image */
-   uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-   uint8_t *B = UCHARDATA(marqueurs);       /* l'image de marqueurs */
-   uint8_t *BF;                             /* l'image de marqueurs du fond */
-   uint8_t *MA;                             /* l'image de masque */
-   uint32_t *M;             /* l'image d'etiquettes */
-   int32_t nlabels;                 /* nombre de labels differents */
-   Fah * FAH;                   /* la file d'attente hierarchique */
-   int32_t etiqcc[4];
-   int32_t ncc;  
-   int32_t tab[27]; 
-   int32_t n;
-
-   if (depth(image) != 1) 
-   {
-     fprintf(stderr, "%s: cette version ne traite pas les images volumiques\n", F_NAME);
-     exit(0);
-   }
-
-   if ((rowsize(marqueurs) != rs) || (colsize(marqueurs) != cs))
-   {
-     fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-     return 0;
-   }
-
-   if (marqueursfond && ((rowsize(marqueursfond) != rs) || (colsize(marqueursfond) != cs)))
-   {
-     fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-     return 0;
-   }
-   if (marqueursfond) BF = UCHARDATA(marqueursfond);
-   if (masque && ((rowsize(masque) != rs) || (colsize(masque) != cs)))
-   {
-     fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-     return 0;
-   }
-   if (masque) MA = UCHARDATA(masque);
-
-   IndicsInit(N);
-   FAH = CreeFahVide(N+1);
-   if (FAH == NULL)
-   {   fprintf(stderr, "%s() : CreeFah failed\n", F_NAME);
-       return(0);
-   }
-
-   /* ================================================ */
-   /* CREATION DES LABELS INITIAUX                     */
-   /* ================================================ */
-
-   M = (uint32_t *)calloc(N, sizeof(int32_t));
-   if (M == NULL)
-   {   fprintf(stderr, "%s() : calloc failed\n", F_NAME);
-       return(0);
-   }
-   nlabels = 0;
-
-   if (marqueursfond)
-   {
-     nlabels += 1;                 /* tous les marqueurs du fond ont le meme label (1) */
-     for (x = 0; x < N; x++)
-     {
-       if (BF[x] && (M[x] == 0) && (!masque || MA[x]))
-       {
-         M[x] = nlabels;
-         FahPush(FAH, x, 0);
-         while (! FahVide(FAH))
-         {
-           w = FahPop(FAH);
-           Thetacarre2d(rs, cs, w%rs, w/rs, tab, &n);
-           for (k = 0; k < n; k++) /* parcourt les eventuels theta-voisins */
-           {
-             y = tab[k];
-             if (BF[y] && (M[y] == 0) && (!masque || MA[y]))
-             {
-               M[y] = nlabels;
-               FahPush(FAH, y, 0);
-             } /* if y ... */
-           } /* for k ... */
-         } /* while (! FahVide(FAH)) */
-       } /* if (M[x] == 0) */
-     } /* for (x = 0; x < N; x++) */
-   } /* if (marqueursfond) */
-
-   for (x = 0; x < N; x++)
-   {
-     if (B[x] && (M[x] == 0) && (!masque || MA[x]))
-     {
-       nlabels += 1;
-       M[x] = nlabels;
-       FahPush(FAH, x, 0);
-       while (! FahVide(FAH))
-       {
-         w = FahPop(FAH);
-         Thetacarre2d(rs, cs, w%rs, w/rs, tab, &n);
-         for (k = 0; k < n; k++) /* parcourt les eventuels theta-voisins */
-         {
-           y = tab[k];
-           if (B[y] && (M[y] == 0) && (!masque || MA[y]))
-           {
-             M[y] = nlabels;
-             FahPush(FAH, y, 0);
-           } /* if y ... */
-         } /* for k ... */
-       } /* while (! FahVide(FAH)) */
-     } /* if (M[x] == 0) */
-   } /* for (x = 0; x < N; x++) */
-
-   /* ================================================ */
-   /* INITIALISATION DE LA FAH                         */
-   /* ================================================ */
-
-   FahFlush(FAH);
-   FahPush(FAH, -1, 0);   /* force la creation du niveau 0 dans la Fah. */
-                          /* NECESSAIRE pour eviter la creation prematuree */
-                          /* de la file d'urgence */ 
-
-   for (x = 0; x < N; x++)
-   {
-     if (M[x] && (!masque || MA[x]))            /* on va empiler les voisins des regions marquees */
-     {
-       Thetacarre2d(rs, cs, x%rs, x/rs, tab, &n);
-       for (k = 0; k < n; k++) /* parcourt les eventuels theta-voisins */
-       {
-         y = tab[k]; 
-         if (!M[y] && !IsSet(y, EN_FAH))
-         { 
-           if (CARRE(y%rs,y/rs))           
-           FahPush(FAH, y, F[y]*2);
-           else FahPush(FAH, y, F[y]*2+1); //plus grande priorite pour les elements de rang <2
-           Set(y, EN_FAH);
-         }
-       } /* for (k = 0; k < 8; k += 2) */
-     } /* if (M[x]) */
-   } /* for (x = 0; x < N; x++) */
-
-   x = FahPop(FAH);
- #ifdef PARANO
-   if (x != -1)
-   {   
-      fprintf(stderr,"%s : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n", F_NAME);
-      return(0);
-   }
- #endif
-
-   /* ================================================ */
-   /* INONDATION                                       */
-   /* ================================================ */
-
-   nlabels += 1;          /* cree le label pour les points de la LPE */
-   while (! FahVide(FAH))
-   {
-     x = FahPop(FAH);
-     UnSet(x, EN_FAH);
-
-     ncc = 0;
-     Thetacarre2d(rs, cs, x%rs, x/rs, tab, &n);
-     for (k = 0; k < n; k++) /* parcourt les eventuels theta-voisins */
-     {
-       y = tab[k];
-       if ((M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-       {
-         etiqcc[ncc] = M[y];        
-         ncc += 1;
-       }
-     } /* for k */
-
-     if (ncc == 1)
-     {
-       M[x] = etiqcc[0];
-       Thetacarre2d(rs, cs, x%rs, x/rs, tab, &n);
-       for (k = 0; k < n; k++) /* parcourt les eventuels theta-voisins */
-       {
-         y = tab[k];
-         if ((M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-         {
-           if (CARRE(y%rs,y/rs))    
-           FahPush(FAH, y, F[y]*2);
-           else FahPush(FAH, y, F[y]*2+1); // priorite superieure pour les element de rang <2
-           Set(y, EN_FAH);
-         } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-       } /* for k */
-     } 
-     else 
-     if (ncc > 1)
-     {
-       M[x] = nlabels;
-     }
-
-   } /* while (! FahVide(FAH)) */
-   /* FIN PROPAGATION */
-
-   for (x = 0; x < N; x++)
-   {
-     if ((M[x] == nlabels) || (M[x] == 0)) F[x] = 255; else F[x] = 0;
-   }
-
-   /* ================================================ */
-   /* UN PEU DE MENAGE                                 */
-   /* ================================================ */
-
-   IndicsTermine();
-   FahTermine(FAH);
-   free(M);
-   return(1);
- } /* llpemeyerkhalimsky() */
-
-/* ==================================== */
-int32_t llpemeyer_regular_llpemeyersansligne(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque,
-        int32_t connex,
-        struct xvimage *result	
-)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "llpemeyersansligne"
-{
-  register int32_t i;                       /* index muet */
-  register int32_t x;                       /* index muet de pixel */
-  register int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t w;                       /* index muet (generalement un voisin de x) */
-  register int32_t k;                       /* index muet */
-  int32_t j;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *B = UCHARDATA(marqueurs);       /* l'image de marqueurs */
-  uint8_t *BF;                             /* l'image de marqueurs du fond */
-  uint8_t *MA;                             /* l'image de masque */
-  uint32_t *M;             /* l'image d'etiquettes */
-  int32_t nlabels;                 /* nombre de labels differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  int32_t etiqcc[4];
-  int32_t ncc;  
-  int32_t incr_vois;
-#ifdef ANIMATE
-  int32_t curlev = -1, nimage = 0; 
-  char imname[128];
-  struct xvimage *animimage;
-  uint8_t *A;
-#endif
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "%s: cette version ne traite pas les images volumiques\n", F_NAME);
-    exit(0);
-  }
-
-  if (datatype(result) != VFF_TYP_4_BYTE) 
-  {
-    fprintf(stderr, "%s: le resultat doit etre de type VFF_TYP_4_BYTE\n", F_NAME);
-    return 0;
-  }
-
-  if ((rowsize(marqueurs) != rs) || (colsize(marqueurs) != cs))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-
-  if (marqueursfond && ((rowsize(marqueursfond) != rs) || (colsize(marqueursfond) != cs)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (masque && ((rowsize(masque) != rs) || (colsize(masque) != cs)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (masque) MA = UCHARDATA(masque);
-  if (marqueursfond) BF = UCHARDATA(marqueursfond);
-
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "%s : CreeFah failed\n", F_NAME);
-      return(0);
-  }
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-    default: 
-      fprintf(stderr, "%s: mauvaise connexite: %d\n", F_NAME, connex);
-      return 0;
-  } /* switch (connex) */    
-
-  /* ================================================ */
-  /* CREATION DES LABELS INITIAUX                     */
-  /* ================================================ */
-
-  M = ULONGDATA(result);
-  memset(M, 0, N*sizeof(int32_t));
-  nlabels = 0;
-
-  if (marqueursfond)
-  {
-    nlabels += 1;                 /* tous les marqueurs du fond ont le meme label (1) */
-    for (x = 0; x < N; x++)
-    {
-      if (BF[x] && (M[x] == 0) && (!masque || MA[x]))
-      {
-        M[x] = nlabels;
-        FahPush(FAH, x, 0);
-        while (! FahVide(FAH))
-        {
-          w = FahPop(FAH);
-          for (k = 0; k < 8; k += incr_vois)
-          {
-            y = voisin(w, k, rs, N);
-            if ((y != -1) &&  BF[y] && (M[y] == 0) && (!masque || MA[y]))
-            {
-              M[y] = nlabels;
-              FahPush(FAH, y, 0);
-            } /* if y ... */
-          } /* for k ... */
-        } /* while (! FahVide(FAH)) */
-      } /* if (M[x] == 0) */
-    } /* for (x = 0; x < N; x++) */
-  } /* if (marqueursfond) */
-
-  for (x = 0; x < N; x++)
-  {
-    if (B[x] && (M[x] == 0) && (!masque || MA[x]))
-    {
-      nlabels += 1;
-      M[x] = nlabels;
-      FahPush(FAH, x, 0);
-      while (! FahVide(FAH))
-      {
-        w = FahPop(FAH);
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if ((y != -1) &&  B[y] && (M[y] == 0) && (!masque || MA[y]))
-          {
-            M[y] = nlabels;
-            FahPush(FAH, y, 0);
-          } /* if y ... */
-        } /* for k ... */
-      } /* while (! FahVide(FAH)) */
-    } /* if (M[x] == 0) */
-  } /* for (x = 0; x < N; x++) */
-
-  /* ================================================ */
-  /* INITIALISATION DE LA FAH                         */
-  /* ================================================ */
-
-  FahFlush(FAH);
-  FahPush(FAH, -1, 0);   /* force la creation du niveau 0 dans la Fah. */
-                         /* NECESSAIRE pour eviter la creation prematuree */
-                         /* de la file d'urgence */ 
-
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] && (!masque || MA[x]))            /* on va empiler les voisins des regions marquees */
-    {
-      for (k = 0; k < 8; k += incr_vois)
-      {
-        y = voisin(x, k, rs, N);
-        if ((y != -1) && !M[y] && !IsSet(y, EN_FAH))
-        {        
-          FahPush(FAH, y, F[y]);
-          Set(y, EN_FAH);
-        }
-      } /* for (k = 0; k < 8; k += 2) */
-    } /* if (M[x]) */
-  } /* for (x = 0; x < N; x++) */
-
-  x = FahPop(FAH);
-#ifdef PARANO
-  if (x != -1)
-  {   
-     fprintf(stderr,"%s : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n", F_NAME);
-     return(0);
-  }
-#endif
-
-  /* ================================================ */
-  /* INONDATION                                       */
-  /* ================================================ */
-
-#ifdef ANIMATE
-  animimage = copyimage(image);
-  A = UCHARDATA(animimage);
-#endif
-  nlabels += 1;          /* cree le label pour les points de la LPE */
-  while (! FahVide(FAH))
-  {
-    x = FahPop(FAH);
-    UnSet(x, EN_FAH);
-#ifdef ANIMATE
-    if (F[x] > curlev)
-    {
-      printf("Niveau %d\n", F[x]);
-      sprintf(imname, "anim%03d.pgm", nimage); nimage++;
-      for (y = 0; y < N; y++)
-        if ((M[y] == nlabels) || (M[y] == 0)) A[y] = 255; else A[y] = 0;
-      writeimage(animimage, imname);
-      curlev = F[x];
-    }
-#endif
-
-    ncc = 0;
-    for (k = 0; k < 8; k += incr_vois)
-    {
-      y = voisin(x, k, rs, N);
-      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-      {
-        etiqcc[ncc] = M[y];        
-        ncc += 1;
-      }
-    } /* for k */
-
-    /* Here is the labelling */
-    M[x] = etiqcc[0];
-    for (k = 0; k < 8; k += incr_vois)
-    {
-      y = voisin(x, k, rs, N);     
-      if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-      {          
-	FahPush(FAH, y, F[y]); 
-	Set(y, EN_FAH);
-      } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-    } /* for k */
-
-  } /* while (! FahVide(FAH)) */
-  /* FIN PROPAGATION */
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FahTermine(FAH);
-  return(1);
-} /*  /* llpemeyersansligne() */
-
-/* ==================================== */
-int32_t llpemeyer_regular_llpemeyer3d(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque,
-        int32_t connex)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "llpemeyer3d"
-{
-  register int32_t i;                       /* index muet */
-  register int32_t x;                       /* index muet de pixel */
-  register int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t w;                       /* index muet (generalement un voisin de x) */
-  register int32_t k;                       /* index muet */
-  int32_t j;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t d = depth(image);        /* nb plans */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *B = UCHARDATA(marqueurs);       /* l'image de marqueurs */
-  uint8_t *BF;                             /* l'image de marqueurs du fond */
-  uint8_t *MA;                             /* l'image de masque */
-  uint32_t *M;             /* l'image d'etiquettes */
-  int32_t nlabels;                 /* nombre de labels differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  int32_t etiqcc[6];
-  int32_t ncc;  
-
-  if ((rowsize(marqueurs) != rs) || (colsize(marqueurs) != cs))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-
-  if (marqueursfond && ((rowsize(marqueursfond) != rs) || (colsize(marqueursfond) != cs) || (depth(marqueursfond) != d)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (marqueursfond) BF = UCHARDATA(marqueursfond);
-  if (masque && ((rowsize(masque) != rs) || (colsize(masque) != cs) || (depth(masque) != d)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (masque) MA = UCHARDATA(masque);
-
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "%s() : CreeFah failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* CREATION DES LABELS INITIAUX                     */
-  /* ================================================ */
-
-  M = (uint32_t *)calloc(N, sizeof(int32_t));
-  if (M == NULL)
-  {   fprintf(stderr, "%s() : calloc failed\n", F_NAME);
-      return(0);
-  }
-  nlabels = 0;
-
-  if (marqueursfond)
-  {
-    nlabels += 1;                 /* tous les marqueurs du fond ont le meme label (1) */
-    for (x = 0; x < N; x++)
-    {
-      if (BF[x] && (M[x] == 0) && (!masque || MA[x]))
-      {
-        M[x] = nlabels;
-        FahPush(FAH, x, 0);
-        while (! FahVide(FAH))
-        {
-          w = FahPop(FAH);
-          switch (connex)
-          {
-	    case 6:
-              for (k = 0; k <= 10; k += 2) /* parcourt les 6 voisins */
-              {
-                y = voisin6(w, k, rs, n, N);
-                if ((y != -1) && BF[y] && (M[y] == 0) && (!masque || MA[y]))
-                { M[y] = nlabels; FahPush(FAH, y, 0); }
-              } /* for k ... */
-              break;
-	    case 18:
-              for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
-              {
-                y = voisin18(w, k, rs, n, N);
-                if ((y != -1) && BF[y] && (M[y] == 0) && (!masque || MA[y]))
-                { M[y] = nlabels; FahPush(FAH, y, 0); }
-              } /* for k ... */
-              break;
-	    case 26:
-              for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
-              {
-                y = voisin26(w, k, rs, n, N);
-                if ((y != -1) && BF[y] && (M[y] == 0) && (!masque || MA[y]))
-                { M[y] = nlabels; FahPush(FAH, y, 0); }
-              } /* for k ... */
-              break;
-	  } /* switch (connex) */
-        } /* while (! FahVide(FAH)) */
-      } /* if (M[x] == 0) */
-    } /* for (x = 0; x < N; x++) */
-  } /* if (marqueursfond) */
-
-  for (x = 0; x < N; x++)
-  {
-    if (B[x] && (M[x] == 0) && (!masque || MA[x]))
-    {
-      nlabels += 1;
-      M[x] = nlabels;
-      FahPush(FAH, x, 0);
-      while (! FahVide(FAH))
-      {
-        w = FahPop(FAH);
-        switch (connex)
-        {
-	  case 6:
-            for (k = 0; k <= 10; k += 2)
-            {
-              y = voisin6(w, k, rs, n, N);
-              if ((y!=-1) && (M[y]==0) && (B[y]==B[w]) && (!masque || MA[y]))
-              { M[y] = nlabels; FahPush(FAH, y, 0); } /* if y ... */
-            } /* for k ... */
-            break;
-	  case 18:
-            for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
-            {
-              y = voisin18(w, k, rs, n, N);
-              if ((y!=-1) && (M[y]==0) && (B[y]==B[w]) && (!masque || MA[y]))
-              { M[y] = nlabels; FahPush(FAH, y, 0); } /* if y ... */
-            } /* for k ... */
-            break;
-	  case 26:
-            for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
-            {
-              y = voisin26(w, k, rs, n, N);
-              if ((y!=-1) && (M[y]==0) && (B[y]==B[w]) && (!masque || MA[y]))
-              { M[y] = nlabels; FahPush(FAH, y, 0); } /* if y ... */
-            } /* for k ... */
-            break;
-	} /* switch (connex) */
-      } /* while (! FahVide(FAH)) */
-    } /* if (M[x] == 0) */
-  } /* for (x = 0; x < N; x++) */
-
-  /* ================================================ */
-  /* INITIALISATION DE LA FAH                         */
-  /* ================================================ */
-
-  FahFlush(FAH);
-  FahPush(FAH, -1, 0);   /* force la creation du niveau 0 dans la Fah. */
-                         /* NECESSAIRE pour eviter la creation prematuree */
-                         /* de la file d'urgence */ 
-
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] && (!masque || MA[x]))    /* on va empiler les voisins des regions marquees */
-    {
-      switch (connex)
-      {
-        case 6:
-          for (k = 0; k <= 10; k += 2)
-          {
-            y = voisin6(x, k, rs, n, N);
-            if ((y!=-1)&&!M[y]&&!IsSet(y,EN_FAH)){ FahPush(FAH, y, F[y]); Set(y, EN_FAH); }
-          } /* for (k = 0; k < 8; k += 2) */
-          break;
-	  case 18:
-            for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
-            {
-              y = voisin18(x, k, rs, n, N);
-              if ((y!=-1)&&!M[y]&&!IsSet(y,EN_FAH)){ FahPush(FAH, y, F[y]); Set(y, EN_FAH); }
-            } /* for (k = 0; k < 18; k += 1) */
-          break;
-	  case 26:
-            for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
-            {
-              y = voisin26(x, k, rs, n, N);
-              if ((y!=-1)&&!M[y]&&!IsSet(y,EN_FAH)){ FahPush(FAH, y, F[y]); Set(y, EN_FAH); }
-            } /* for (k = 0; k < 26; k += 1) */
-          break;
-      } /* switch (connex) */
-    } /* if (B[x]) */
-  } /* for (x = 0; x < N; x++) */
-
-  x = FahPop(FAH);
-#ifdef PARANO
-  if (x != -1)
-  {   
-     fprintf(stderr,"%s : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n", F_NAME);
-     return(0);
-  }
-#endif
-
-  /* ================================================ */
-  /* INONDATION                                       */
-  /* ================================================ */
-
-  nlabels += 1;          /* cree le label pour les points de la LPE */
-  while (! FahVide(FAH))
-  {
-    x = FahPop(FAH);
-    UnSet(x, EN_FAH);
-
-    ncc = 0;
-    switch (connex)
-    {
-      case 6:
-        for (k = 0; k <= 10; k += 2)
-        {
-          y = voisin6(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-          {
-            etiqcc[ncc] = M[y];        
-            ncc += 1;
-          }
-        } /* for k */
-        break;
-      case 18:
-        for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
-        {
-          y = voisin18(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-          {
-            etiqcc[ncc] = M[y];        
-            ncc += 1;
-          }
-        } /* for k */
-        break;
-      case 26:
-        for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
-        {
-          y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-          {
-            etiqcc[ncc] = M[y];        
-            ncc += 1;
-          }
-        } /* for k */
-        break;
-    } /* switch (connex) */
-
-    if (ncc == 1)
-    {
-      M[x] = etiqcc[0];
-      switch (connex)
-      {
-        case 6:
-          for (k = 0; k <= 10; k += 2)
-          {
-            y = voisin6(x, k, rs, n, N);     
-            if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-            {
-              FahPush(FAH, y, F[y]);
-              Set(y, EN_FAH);
-            } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-          } /* for k */
-          break;
-        case 18:
-          for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
-          {
-            y = voisin18(x, k, rs, n, N);
-            if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-            {
-              FahPush(FAH, y, F[y]);
-              Set(y, EN_FAH);
-            } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-          } /* for k */
-          break;
-        case 26:
-          for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
-          {
-            y = voisin26(x, k, rs, n, N);
-            if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-            {
-              FahPush(FAH, y, F[y]);
-              Set(y, EN_FAH);
-            } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-          } /* for k */
-          break;
-      } /* switch (connex) */
-    } 
-    else 
-    if (ncc > 1)
-    {
-      M[x] = nlabels;
-    }
-  } /* while (! FahVide(FAH)) */
-  /* FIN PROPAGATION */
-
-  for (x = 0; x < N; x++)
-  {
-    if ((M[x] == nlabels) || (M[x] == 0)) F[x] = 255; else F[x] = 0;
-  }
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FahTermine(FAH);
-  free(M);
-  return(1);
-} /* llpemeyer3d() */
-
-/* ==================================== */
-int32_t llpemeyer_regular_llpemeyer3dsansligne(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque,
-        int32_t connex,
-        struct xvimage *result	
-)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "llpemeyer3dsansligne"
-{
-  register int32_t i;                       /* index muet */
-  register int32_t x;                       /* index muet de pixel */
-  register int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t w;                       /* index muet (generalement un voisin de x) */
-  register int32_t k;                       /* index muet */
-  int32_t j;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t d = depth(image);        /* nb plans */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *B = UCHARDATA(marqueurs);       /* l'image de marqueurs */
-  uint8_t *BF;                             /* l'image de marqueurs du fond */
-  uint8_t *MA;                             /* l'image de masque */
-  uint32_t *M;             /* l'image d'etiquettes */
-  int32_t nlabels;                 /* nombre de labels differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  int32_t etiqcc[6];
-  int32_t ncc;  
-
-  if (depth(image) == 1) 
-  {
-    fprintf(stderr, "%s: cette version ne traite que les images volumiques\n", F_NAME);
-    exit(0);
-  }
-
-  if (datatype(result) != VFF_TYP_4_BYTE) 
-  {
-    fprintf(stderr, "%s: le resultat doit etre de type VFF_TYP_4_BYTE\n", F_NAME);
-    return 0;
-  }
-
-  if ((rowsize(marqueurs) != rs) || (colsize(marqueurs) != cs))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-
-  if (marqueursfond && ((rowsize(marqueursfond) != rs) || (colsize(marqueursfond) != cs) || (depth(marqueursfond) != d)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (marqueursfond) BF = UCHARDATA(marqueursfond);
-  if (masque && ((rowsize(masque) != rs) || (colsize(masque) != cs) || (depth(masque) != d)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (masque) MA = UCHARDATA(masque);
-
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "%s() : CreeFah failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* CREATION DES LABELS INITIAUX                     */
-  /* ================================================ */
-
-  M = ULONGDATA(result);
-  memset(M, 0, N*sizeof(int32_t));
-  nlabels = 0;
-
-  if (marqueursfond)
-  {
-    nlabels += 1;                 /* tous les marqueurs du fond ont le meme label (1) */
-    for (x = 0; x < N; x++)
-    {
-      if (BF[x] && (M[x] == 0) && (!masque || MA[x]))
-      {
-        M[x] = nlabels;
-        FahPush(FAH, x, 0);
-        while (! FahVide(FAH))
-        {
-          w = FahPop(FAH);
-          switch (connex)
-          {
-	    case 6:
-              for (k = 0; k <= 10; k += 2) /* parcourt les 6 voisins */
-              {
-                y = voisin6(w, k, rs, n, N);
-                if ((y != -1) && BF[y] && (M[y] == 0) && (!masque || MA[y]))
-                { M[y] = nlabels; FahPush(FAH, y, 0); }
-              } /* for k ... */
-              break;
-	    case 18:
-              for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
-              {
-                y = voisin18(w, k, rs, n, N);
-                if ((y != -1) && BF[y] && (M[y] == 0) && (!masque || MA[y]))
-                { M[y] = nlabels; FahPush(FAH, y, 0); }
-              } /* for k ... */
-              break;
-	    case 26:
-              for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
-              {
-                y = voisin26(w, k, rs, n, N);
-                if ((y != -1) && BF[y] && (M[y] == 0) && (!masque || MA[y]))
-                { M[y] = nlabels; FahPush(FAH, y, 0); }
-              } /* for k ... */
-              break;
-	  } /* switch (connex) */
-        } /* while (! FahVide(FAH)) */
-      } /* if (M[x] == 0) */
-    } /* for (x = 0; x < N; x++) */
-  } /* if (marqueursfond) */
-
-  for (x = 0; x < N; x++)
-  {
-    if (B[x] && (M[x] == 0) && (!masque || MA[x]))
-    {
-      nlabels += 1;
-      M[x] = nlabels;
-      FahPush(FAH, x, 0);
-      while (! FahVide(FAH))
-      {
-        w = FahPop(FAH);
-        switch (connex)
-        {
-	  case 6:
-            for (k = 0; k <= 10; k += 2)
-            {
-              y = voisin6(w, k, rs, n, N);
-              if ((y!=-1) && (M[y]==0) && (B[y]==B[w]) && (!masque || MA[y]))
-              { M[y] = nlabels; FahPush(FAH, y, 0); } /* if y ... */
-            } /* for k ... */
-            break;
-	  case 18:
-            for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
-            {
-              y = voisin18(w, k, rs, n, N);
-              if ((y!=-1) && (M[y]==0) && (B[y]==B[w]) && (!masque || MA[y]))
-              { M[y] = nlabels; FahPush(FAH, y, 0); } /* if y ... */
-            } /* for k ... */
-            break;
-	  case 26:
-            for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
-            {
-              y = voisin26(w, k, rs, n, N);
-              if ((y!=-1) && (M[y]==0) && (B[y]==B[w]) && (!masque || MA[y]))
-              { M[y] = nlabels; FahPush(FAH, y, 0); } /* if y ... */
-            } /* for k ... */
-            break;
-	} /* switch (connex) */
-      } /* while (! FahVide(FAH)) */
-    } /* if (M[x] == 0) */
-  } /* for (x = 0; x < N; x++) */
-
-  /* ================================================ */
-  /* INITIALISATION DE LA FAH                         */
-  /* ================================================ */
-
-  FahFlush(FAH);
-  FahPush(FAH, -1, 0);   /* force la creation du niveau 0 dans la Fah. */
-                         /* NECESSAIRE pour eviter la creation prematuree */
-                         /* de la file d'urgence */ 
-
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] && (!masque || MA[x]))    /* on va empiler les voisins des regions marquees */
-    {
-      switch (connex)
-      {
-        case 6:
-          for (k = 0; k <= 10; k += 2)
-          {
-            y = voisin6(x, k, rs, n, N);
-            if ((y!=-1)&&!M[y]&&!IsSet(y,EN_FAH)){ FahPush(FAH, y, F[y]); Set(y, EN_FAH); }
-          } /* for (k = 0; k < 8; k += 2) */
-          break;
-	  case 18:
-            for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
-            {
-              y = voisin18(x, k, rs, n, N);
-              if ((y!=-1)&&!M[y]&&!IsSet(y,EN_FAH)){ FahPush(FAH, y, F[y]); Set(y, EN_FAH); }
-            } /* for (k = 0; k < 18; k += 1) */
-          break;
-	  case 26:
-            for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
-            {
-              y = voisin26(x, k, rs, n, N);
-              if ((y!=-1)&&!M[y]&&!IsSet(y,EN_FAH)){ FahPush(FAH, y, F[y]); Set(y, EN_FAH); }
-            } /* for (k = 0; k < 26; k += 1) */
-          break;
-      } /* switch (connex) */
-    } /* if (B[x]) */
-  } /* for (x = 0; x < N; x++) */
-
-  x = FahPop(FAH);
-#ifdef PARANO
-  if (x != -1)
-  {   
-     fprintf(stderr,"%s : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n", F_NAME);
-     return(0);
-  }
-#endif
-
-  /* ================================================ */
-  /* INONDATION                                       */
-  /* ================================================ */
-
-  nlabels += 1;          /* cree le label pour les points de la LPE */
-  while (! FahVide(FAH))
-  {
-    x = FahPop(FAH);
-    UnSet(x, EN_FAH);
-
-    ncc = 0;
-    switch (connex)
-    {
-      case 6:
-        for (k = 0; k <= 10; k += 2)
-        {
-          y = voisin6(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-          {
-            etiqcc[ncc] = M[y];        
-            ncc += 1;
-          }
-        } /* for k */
-        break;
-      case 18:
-        for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
-        {
-          y = voisin18(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-          {
-            etiqcc[ncc] = M[y];        
-            ncc += 1;
-          }
-        } /* for k */
-        break;
-      case 26:
-        for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
-        {
-          y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-          {
-            etiqcc[ncc] = M[y];        
-            ncc += 1;
-          }
-        } /* for k */
-        break;
-    } /* switch (connex) */
-
-    /* Label */
-      M[x] = etiqcc[0];
-      switch (connex)
-      {
-        case 6:
-          for (k = 0; k <= 10; k += 2)
-          {
-            y = voisin6(x, k, rs, n, N);     
-            if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-            {
-              FahPush(FAH, y, F[y]);
-              Set(y, EN_FAH);
-            } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-          } /* for k */
-          break;
-        case 18:
-          for (k = 0; k < 18; k += 1) /* parcourt les 18 voisins */
-          {
-            y = voisin18(x, k, rs, n, N);
-            if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-            {
-              FahPush(FAH, y, F[y]);
-              Set(y, EN_FAH);
-            } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-          } /* for k */
-          break;
-        case 26:
-          for (k = 0; k < 26; k += 1) /* parcourt les 26 voisins */
-          {
-            y = voisin26(x, k, rs, n, N);
-            if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-            {
-              FahPush(FAH, y, F[y]);
-              Set(y, EN_FAH);
-            } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-          } /* for k */
-          break;
-      } /* switch (connex) */
-  } /* while (! FahVide(FAH)) */
-  /* FIN PROPAGATION */
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FahTermine(FAH);
-  return(1);
-} /* llpemeyer3dsansligne() */
-
-/* ==================================== */
-int32_t llpemeyer_regular_llpemeyer3d2(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *masque,
-        int32_t connex)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "llpemeyer3d2"
-{
-  fprintf(stderr, "%s: not yet implemented\n", F_NAME);
-  return 0;
-
-  return(1);
-} /* llpemeyer3d2() */
-
-
-
-/* ==================================== */
-int32_t llpemeyer_regular_llpemeyerbiconnecte(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque,
-        int32_t parite)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "llpemeyerbiconnecte"
-{
-  register int32_t i;                       /* index muet */
-  register int32_t x;                       /* index muet de pixel */
-  register int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t w;                       /* index muet (generalement un voisin de x) */
-  register int32_t k;                       /* index muet */
-  int32_t j;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *B = UCHARDATA(marqueurs);       /* l'image de marqueurs */
-  uint8_t *BF;                             /* l'image de marqueurs du fond */
-  uint8_t *MA;                             /* l'image de masque */
-  uint32_t *M;             /* l'image d'etiquettes */
-  int32_t nlabels;                 /* nombre de labels differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  int32_t etiqcc[4];
-  int32_t ncc;  
-  const int32_t incr_vois=1;
-#ifdef ANIMATE
-  int32_t curlev = -1, nimage = 0; 
-  char imname[128];
-  struct xvimage *animimage;
-  uint8_t *A;
-#endif
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "%s: cette version ne traite pas les images volumiques\n", F_NAME);
-    exit(0);
-  }
-
-  if ((rowsize(marqueurs) != rs) || (colsize(marqueurs) != cs))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-
-  if (marqueursfond && ((rowsize(marqueursfond) != rs) || (colsize(marqueursfond) != cs)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (masque && ((rowsize(masque) != rs) || (colsize(masque) != cs)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (masque) MA = UCHARDATA(masque);
-  if (marqueursfond) BF = UCHARDATA(marqueursfond);
-
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "%s : CreeFah failed\n", F_NAME);
-      return(0);
-  }
-
-
-  /* ================================================ */
-  /* CREATION DES LABELS INITIAUX                     */
-  /* ================================================ */
-
-  M = (uint32_t *)calloc(N, sizeof(int32_t));
-  if (M == NULL)
-  {   fprintf(stderr, "%s : calloc failed\n", F_NAME);
-      return(0);
-  }
-  nlabels = 0;
-
-  if (marqueursfond)
-  {
-    nlabels += 1;                 /* tous les marqueurs du fond ont le meme label (1) */
-    for (x = 0; x < N; x++)
-    {
-      if (BF[x] && (M[x] == 0) && (!masque || MA[x]))
-      {
-        M[x] = nlabels;
-        FahPush(FAH, x, 0);
-        while (! FahVide(FAH))
-        {
-          w = FahPop(FAH);
-          for (k = 0; k < 6; k += incr_vois)
-          {
-            y = voisin6b(w, k, rs, N, parite);
-            if ((y != -1) &&  BF[y] && (M[y] == 0) && (!masque || MA[y]))
-            {
-              M[y] = nlabels;
-              FahPush(FAH, y, 0);
-            } /* if y ... */
-          } /* for k ... */
-        } /* while (! FahVide(FAH)) */
-      } /* if (M[x] == 0) */
-    } /* for (x = 0; x < N; x++) */
-  } /* if (marqueursfond) */
-
-  for (x = 0; x < N; x++)
-  {
-    if (B[x] && (M[x] == 0) && (!masque || MA[x]))
-    {
-      nlabels += 1;
-      M[x] = nlabels;
-      FahPush(FAH, x, 0);
-      while (! FahVide(FAH))
-      {
-        w = FahPop(FAH);
-        for (k = 0; k < 6; k += incr_vois)
-        {
-          y = voisin6b(w, k, rs, N, parite);
-          if ((y != -1) &&  B[y] && (M[y] == 0) && (!masque || MA[y]))
-          {
-            M[y] = nlabels;
-            FahPush(FAH, y, 0);
-          } /* if y ... */
-        } /* for k ... */
-      } /* while (! FahVide(FAH)) */
-    } /* if (M[x] == 0) */
-  } /* for (x = 0; x < N; x++) */
-
-  /* ================================================ */
-  /* INITIALISATION DE LA FAH                         */
-  /* ================================================ */
-
-  FahFlush(FAH);
-  FahPush(FAH, -1, 0);   /* force la creation du niveau 0 dans la Fah. */
-                         /* NECESSAIRE pour eviter la creation prematuree */
-                         /* de la file d'urgence */ 
-
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] && (!masque || MA[x]))            /* on va empiler les voisins des regions marquees */
-    {
-      for (k = 0; k < 6; k += incr_vois)
-      {
-        y = voisin6b(x, k, rs, N, parite);
-        if ((y != -1) && !M[y] && !IsSet(y, EN_FAH))
-        {        
-          FahPush(FAH, y, F[y]);
-          Set(y, EN_FAH);
-        }
-      } /* for (k = 0; k < 8; k += 2) */
-    } /* if (M[x]) */
-  } /* for (x = 0; x < N; x++) */
-
-  x = FahPop(FAH);
-#ifdef PARANO
-  if (x != -1)
-  {   
-     fprintf(stderr,"%s : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n", F_NAME);
-     return(0);
-  }
-#endif
-
-  /* ================================================ */
-  /* INONDATION                                       */
-  /* ================================================ */
-
-#ifdef ANIMATE
-  animimage = copyimage(image);
-  A = UCHARDATA(animimage);
-#endif
-  nlabels += 1;          /* cree le label pour les points de la LPE */
-  while (! FahVide(FAH))
-  {
-    x = FahPop(FAH);
-    UnSet(x, EN_FAH);
-#ifdef ANIMATE
-    if (F[x] > curlev)
-    {
-      printf("Niveau %d\n", F[x]);
-      sprintf(imname, "anim%03d.pgm", nimage); nimage++;
-      for (y = 0; y < N; y++)
-        if ((M[y] == nlabels) || (M[y] == 0)) A[y] = 255; else A[y] = 0;
-      writeimage(animimage, imname);
-      curlev = F[x];
-    }
-#endif
-
-    ncc = 0;
-    for (k = 0; k < 6; k += incr_vois)
-    {
-      y = voisin6b(x, k, rs, N, parite);
-      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-      {
-        etiqcc[ncc] = M[y];        
-        ncc += 1;
-      }
-    } /* for k */
-
-    if (ncc == 1)
-    {
-      M[x] = etiqcc[0];
-      for (k = 0; k < 6; k += incr_vois)
-      {
-        y = voisin6b(x, k, rs, N, parite);     
-        if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-        {          
-          FahPush(FAH, y, F[y]); 
-          Set(y, EN_FAH);
-        } /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-      } /* for k */
-    } 
-    else 
-    if (ncc > 1)
-    {
-      M[x] = nlabels;
-    }
-
-  } /* while (! FahVide(FAH)) */
-  /* FIN PROPAGATION */
-
-  for (x = 0; x < N; x++)
-  {
-    if ((M[x] == nlabels) || (M[x] == 0)) F[x] = 255; else F[x] = 0;
-  }
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FahTermine(FAH);
-  free(M);
-  return(1);
-} /*  /* llpemeyer() */
-
-
-/* ==================================== */
-int32_t llpemeyer_regular_llpemeyerbiconnecte3d(
-        struct xvimage *image,
-        struct xvimage *marqueurs,
-        struct xvimage *marqueursfond,
-        struct xvimage *masque)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "llpemeyerbiconnecte3d"
-{
-  register int32_t i;                       /* index muet */
-  register int32_t x;                       /* index muet de pixel */
-  register int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t w;                       /* index muet (generalement un voisin de x) */
-  register int32_t k;                       /* index muet */
-  int32_t j;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t d = depth(image);        /* nb plans */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *B = UCHARDATA(marqueurs);       /* l'image de marqueurs */
-  uint8_t *BF;                             /* l'image de marqueurs du fond */
-  uint8_t *MA;                             /* l'image de masque */
-  uint32_t *M;             /* l'image d'etiquettes */
-  int32_t nlabels;                 /* nombre de labels differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  int32_t etiqcc[6];
-  int32_t ncc;  
-
-  if ((rowsize(marqueurs) != rs) || (colsize(marqueurs) != cs))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-
-  if (marqueursfond && ((rowsize(marqueursfond) != rs) || (colsize(marqueursfond) != cs) || (depth(marqueursfond) != d)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (marqueursfond) BF = UCHARDATA(marqueursfond);
-  if (masque && ((rowsize(masque) != rs) || (colsize(masque) != cs) || (depth(masque) != d)))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    return 0;
-  }
-  if (masque) MA = UCHARDATA(masque);
-
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "%s() : CreeFah failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* CREATION DES LABELS INITIAUX                     */
-  /* ================================================ */
-  printf("%s: creation des labels initiaux\n", F_NAME);
-  M = (uint32_t *)calloc(N, sizeof(int32_t));
-  if (M == NULL)
-  {   fprintf(stderr, "%s() : calloc failed\n", F_NAME);
-      return(0);
-  }
-  nlabels = 0;
-
-  if (marqueursfond)
-  {
-    nlabels += 1;                 /* tous les marqueurs du fond ont le meme label (1) */
-    for (x = 0; x < N; x++)
-    {
-      if (BF[x] && (M[x] == 0) && (!masque || MA[x]))
-      {
-        M[x] = nlabels;
-        FahPush(FAH, x, 0);
-        while (! FahVide(FAH))
-        {
-          w = FahPop(FAH);
-	  for (k = 0; k < 14; k ++ ) /* parcourt les 14 voisins */
-              {
-                y = voisin14b(w, k, rs, n, N);
-                if ((y != -1) && BF[y] && (M[y] == 0) && (!masque || MA[y]))
-                { M[y] = nlabels; FahPush(FAH, y, 0); }
-              } /* for k ... */
-        } /* while (! FahVide(FAH)) */
-      } /* if (M[x] == 0) */
-    } /* for (x = 0; x < N; x++) */
-  } /* if (marqueursfond) */
-
-  for (x = 0; x < N; x++)
-  {
-    if (B[x] && (M[x] == 0) && (!masque || MA[x]))
-    {
-      nlabels += 1;
-      M[x] = nlabels;
-      FahPush(FAH, x, 0);
-      while (! FahVide(FAH))
-      {
-        w = FahPop(FAH);
-	for (k = 0; k < 14; k ++)
-            {
-              y = voisin14b(w, k, rs, n, N);
-              if ((y!=-1) && (M[y]==0) && (B[y]==B[w]) && (!masque || MA[y]))
-              {M[y] = nlabels; FahPush(FAH, y, 0); } /* if y ... */
-            } /* for k ... */
-      } /* while (! FahVide(FAH)) */
-    } /* if (M[x] == 0) */
-  } /* for (x = 0; x < N; x++) */
-  
-  /* ================================================ */
-  /* INITIALISATION DE LA FAH                         */
-  /* ================================================ */
-
-  printf("%s: initialisation FAH\n", F_NAME);
-  FahFlush(FAH);
-  FahPush(FAH, -1, 0);   /* force la creation du niveau 0 dans la Fah. */
-                         /* NECESSAIRE pour eviter la creation prematuree */
-                         /* de la file d'urgence */ 
-
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] && (!masque || MA[x]))    /* on va empiler les voisins des regions marquees */
-    {
-      for (k = 0; k < 14; k ++)
-      {
-	y = voisin14b(x, k, rs, n, N);
-	if ((y!=-1)&&!M[y]&&!IsSet(y,EN_FAH)){FahPush(FAH, y, F[y]); Set(y, EN_FAH); }
-      } /* for (k = 0; k < 8; k += 2) */
-    } /* if (B[x]) */
-  } /* for (x = 0; x < N; x++) */  
-  x = FahPop(FAH);
-#ifdef PARANO
-  if (x != -1)
-  {   
-    fprintf(stderr,"%s : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n", F_NAME);
-    return(0);
-  }
-#endif
-  
-  /* ================================================ */
-  /* INONDATION                                       */
-  /* ================================================ */
-  printf("%s: Innondation \n", F_NAME);
-  nlabels += 1;          /* cree le label pour les points de la LPE */
-  while (! FahVide(FAH))
-  {
-    x = FahPop(FAH);
-    UnSet(x, EN_FAH);
-    
-    ncc = 0;
-    
-    for (k = 0; k < 14; k ++)
-    {
-      y = voisin14b(x, k, rs, n, N);
-      if(y >= N)
-      {
-	printf("%s: Attention on innonde en dehors de l'image %d %d rs %d, n %d ,N %d \n", F_NAME, x,k, rs, n ,N);
-	exit(-1);
-      }
-      if ((y != -1) && (M[y] != 0) && (M[y] != nlabels) && NotIn(M[y], etiqcc, ncc)) 
-      {
-	etiqcc[ncc] = M[y];        	
-	ncc += 1;
-      }
-    } /* for k */
-        
-    if (ncc == 1)
-    {
-      M[x] = etiqcc[0];
-      
-      for (k = 0; k < 14; k ++)
-      {
-	y = voisin14b(x, k, rs, n, N);     
-	if ((y != -1) && (M[y] == 0) && (! IsSet(y, EN_FAH)) && (!masque || MA[y]))
-	{
-	  FahPush(FAH, y, F[y]);
-	  Set(y, EN_FAH);
-	} /* if ((y != -1) && (! IsSet(y, EN_FAH))) */
-      } /* for k */
-      
-    } 
-    else 
-      if (ncc > 1)
-      {
-	M[x] = nlabels;
-      }
-  } /* while (! FahVide(FAH)) */
-  /* FIN PROPAGATION */
-  
-  for (x = 0; x < N; x++)
-  {
-    if ((M[x] == nlabels) || (M[x] == 0)) F[x] = 255; else F[x] = 0;
-  }
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FahTermine(FAH);
-  free(M);
-  return(1);
-} /* llpemeyerbiconnecte3d() */
-
diff -r 8b1af7363833 src/lib/llvkern.c
--- a/src/lib/llvkern.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,345 +0,0 @@
-/* $Id: llvkern.c,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-/* operateur de calcul du noyau de nivellement */
-/* methode: saturation avec politique 4-directionnelle 
-   utilise 4 fifo */
-/* Michel Couprie -  avril 1997 */
-/* juin 1999 : OBSOLETE - voir lhtkern.c */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcfifo.h>
-#include <mctopo.h>
-#include <mcindic.h>
-#include <llabelextrema.h>
-#include <llvkern.h>
-
-#define EN_FIFO       0
-#define PARANO
-/*
-#define DEBUG
-*/
-
-/* ==================================== */
-static 
-int32_t testabaisse4(uint8_t *SOURCE, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t t4mm, t4m, t8p, t8pp;
-  int32_t modifie = 0;
-
-#ifdef DEBUG
-printf("testabaisse : point %d (%d %d), val = %d\n", x, x%rs, x/rs, SOURCE[x]);
-#endif
-
-  nbtopo(SOURCE, x, rs, N, &t4mm, &t4m, &t8p, &t8pp);
-  while (t4mm == 1)
-  {
-    modifie = 1;
-    SOURCE[x] = alpha8m(SOURCE, x, rs, N);
-    nbtopo(SOURCE, x, rs, N, &t4mm, &t4m, &t8p, &t8pp);
-  }
-
-#ifdef DEBUG
-if (modifie) printf("========> ABAISSE : %d\n", SOURCE[x]);
-#endif
-
-  return modifie;
-} /* testabaisse4() */
-
-/* ==================================== */
-static 
-int32_t testabaisse8(uint8_t *SOURCE, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t t8mm, t8m, t4p, t4pp;
-  int32_t modifie = 0;
-
-#ifdef DEBUG
-printf("testabaisse : point %d (%d %d), val = %d\n", x, x%rs, x/rs, SOURCE[x]);
-#endif
-
-  nbtopo2(SOURCE, x, rs, N, &t8mm, &t8m, &t4p, &t4pp);
-  while (t8mm == 1)
-  {
-    modifie = 1;
-    SOURCE[x] = alpha8m(SOURCE, x, rs, N);
-    nbtopo2(SOURCE, x, rs, N, &t8mm, &t8m, &t4p, &t4pp);
-  }
-
-#ifdef DEBUG
-if (modifie) printf("========> ABAISSE : %d\n", SOURCE[x]);
-#endif
-
-  return modifie;
-} /* testabaisse8() */
-
-/* ==================================== */
-static
-void empilevoisins(int32_t x, int32_t rs, int32_t N, Fifo *FIFOna, Fifo *FIFOea, Fifo *FIFOsa, Fifo *FIFOoa)
-/* ==================================== */
-{
-  int32_t y;
-
-  y = voisin(x, NORD, rs, N);
-  if ((y!=-1) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOna, y); Set(y, EN_FIFO); }
-  y = voisin(x, NORD+1, rs, N);
-  if ((y!=-1) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOna, y); Set(y, EN_FIFO); }
-  y = voisin(x, EST, rs, N);
-  if ((y!=-1) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOea, y); Set(y, EN_FIFO); }
-  y = voisin(x, EST+1, rs, N);
-  if ((y!=-1) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOea, y); Set(y, EN_FIFO); }
-  y = voisin(x, SUD, rs, N);
-  if ((y!=-1) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOsa, y); Set(y, EN_FIFO); }
-  y = voisin(x, SUD+1, rs, N);
-  if ((y!=-1) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOsa, y); Set(y, EN_FIFO); }
-  y = voisin(x, OUEST, rs, N);
-  if ((y!=-1) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOoa, y); Set(y, EN_FIFO); }
-  y = voisin(x, OUEST+1, rs, N);
-  if ((y!=-1) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-    { FifoPush(FIFOoa, y); Set(y, EN_FIFO); }
-} /* empilevoisins() */
-
-/* ==================================== */
-int32_t llvkern_llvkern(struct xvimage *image, int32_t nitermax, int32_t connex)
-/* ==================================== */
-
-{ 
-  int32_t i;
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  int32_t z;                       /* index muet (generalement un voisin de y) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *lab;
-  uint32_t *M;            /* l'image d'etiquettes de composantes connexes */
-  int32_t nminima;                 /* nombre de minima differents */
-  int32_t niter;                   /* nombre d'iterations effectuees (4 directions) */
-  Fifo * FIFOn;
-  Fifo * FIFOs;
-  Fifo * FIFOe;
-  Fifo * FIFOo;
-  Fifo * FIFOna;
-  Fifo * FIFOsa;
-  Fifo * FIFOea;
-  Fifo * FIFOoa;
-  Fifo * FIFOtmp;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "llvkern: cette version ne traite pas les images volumiques\n");
-    return 0;
-  }
-
-  lab = allocimage(NULL, rs, cs, 1, VFF_TYP_4_BYTE);
-  if (lab == NULL)
-  {   
-    fprintf(stderr, "lhtkern: allocimage failed\n");
-    return 0;
-  }
-  M = ULONGDATA(lab);
-
-  if (!llabelextrema(image, connex, LABMIN, lab, &nminima))
-  {   
-    fprintf(stderr, "lhtkern: llabelextrema failed\n");
-    return 0;
-  }
-
-  IndicsInit(N);
-
-  FIFOn = CreeFifoVide(N/2);
-  FIFOs = CreeFifoVide(N/2);
-  FIFOe = CreeFifoVide(N/2);
-  FIFOo = CreeFifoVide(N/2);
-  if ((FIFOn == NULL) && (FIFOs == NULL) && (FIFOe == NULL) && (FIFOo == NULL))
-  {   fprintf(stderr, "llvkern() : CreeFifoVide failed\n");
-      return(0);
-  }
-
-  /* ================================================ */
-  /*                  DEBUT ALGO                      */
-  /* ================================================ */
-
-  /* ========================================================= */
-  /*   INITIALISATION DES FIFOs: empile les voisins des minima */
-  /* ========================================================= */
-
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] != 0)                  /* le pixel appartient a un minimum */
-    {
-        y = voisin(x, NORD, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOn, y); Set(y, EN_FIFO); }
-        y = voisin(x, NORD+1, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOn, y); Set(y, EN_FIFO); }
-        y = voisin(x, EST, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOe, y); Set(y, EN_FIFO); }
-        y = voisin(x, EST+1, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOe, y); Set(y, EN_FIFO); }
-        y = voisin(x, SUD, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOs, y); Set(y, EN_FIFO); }
-        y = voisin(x, SUD+1, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOs, y); Set(y, EN_FIFO); }
-        y = voisin(x, OUEST, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOo, y); Set(y, EN_FIFO); }
-        y = voisin(x, OUEST+1, rs, N);
-        if ((y!=-1) && (M[y]==0) && !IsSet(y,EN_FIFO) && nonbord(y,rs,N))
-          { FifoPush(FIFOo, y); Set(y, EN_FIFO); }
-    } /* if (M[x] != 0) */
-  } /* for x */
-
-  freeimage(lab);
-
-  FIFOna = CreeFifoVide(N/4);
-  FIFOsa = CreeFifoVide(N/4);
-  FIFOea = CreeFifoVide(N/4);
-  FIFOoa = CreeFifoVide(N/4);
-  if ((FIFOna == NULL) && (FIFOsa == NULL) && (FIFOea == NULL) && (FIFOoa == NULL))
-  {   fprintf(stderr, "llvkern() : CreeFifoVide failed\n");
-      return(0);
-  }
-
-  /* ================================================ */
-  /*                  DEBUT SATURATION                */
-  /* ================================================ */
-
-
-  niter = 0;
-
-if (connex == 4)
-{
-  while (! (FifoVide(FIFOn) && FifoVide(FIFOe) && FifoVide(FIFOs) && FifoVide(FIFOo))
-          && ((nitermax == 0) || (niter < nitermax))
-        )
-  {
-    niter++;
-
-    while (! FifoVide(FIFOn))
-    {
-      x = FifoPop(FIFOn);
-      UnSet(x, EN_FIFO);
-      if (testabaisse4(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-    } /* while (! FifoVide(FIFOn)) */
-
-    while (! FifoVide(FIFOs))
-    {
-      x = FifoPop(FIFOs);
-      UnSet(x, EN_FIFO);
-      if (testabaisse4(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-    } /* while (! FifoVide(FIFOs)) */
-
-    while (! FifoVide(FIFOe))
-    {
-      x = FifoPop(FIFOe);
-      UnSet(x, EN_FIFO);
-      if (testabaisse4(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-    } /* while (! FifoVide(FIFOe)) */
-
-    while (! FifoVide(FIFOo))
-    {
-      x = FifoPop(FIFOo);
-      UnSet(x, EN_FIFO);
-      if (testabaisse4(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-    } /* while (! FifoVide(FIFOo)) */
-
-    FIFOtmp = FIFOn; FIFOn = FIFOna; FIFOna = FIFOtmp;
-    FIFOtmp = FIFOe; FIFOe = FIFOea; FIFOea = FIFOtmp;
-    FIFOtmp = FIFOs; FIFOs = FIFOsa; FIFOsa = FIFOtmp;
-    FIFOtmp = FIFOo; FIFOo = FIFOoa; FIFOoa = FIFOtmp;
-
-  } /* while (! (FifoVide(FIFOn) && FifoVide(FIFOe) && FifoVide(FIFOs) && FifoVide(FIFOo))) */
-}
-
-else /* connex == 8 */
-
-{
-  while (! (FifoVide(FIFOn) && FifoVide(FIFOe) && FifoVide(FIFOs) && FifoVide(FIFOo))
-          && ((nitermax == 0) || (niter < nitermax))
-        )
-  {
-    niter++;
-
-    while (! FifoVide(FIFOn))
-    {
-      x = FifoPop(FIFOn);
-      UnSet(x, EN_FIFO);
-      if (testabaisse8(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-    } /* while (! FifoVide(FIFOn)) */
-
-    while (! FifoVide(FIFOs))
-    {
-      x = FifoPop(FIFOs);
-      UnSet(x, EN_FIFO);
-      if (testabaisse8(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-    } /* while (! FifoVide(FIFOs)) */
-
-    while (! FifoVide(FIFOe))
-    {
-      x = FifoPop(FIFOe);
-      UnSet(x, EN_FIFO);
-      if (testabaisse8(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-    } /* while (! FifoVide(FIFOe)) */
-
-    while (! FifoVide(FIFOo))
-    {
-      x = FifoPop(FIFOo);
-      UnSet(x, EN_FIFO);
-      if (testabaisse8(SOURCE, x, rs, N))         /* modifie l'image le cas echeant */
-        empilevoisins(x, rs, N, FIFOna, FIFOea, FIFOsa, FIFOoa);
-    } /* while (! FifoVide(FIFOo)) */
-
-    FIFOtmp = FIFOn; FIFOn = FIFOna; FIFOna = FIFOtmp;
-    FIFOtmp = FIFOe; FIFOe = FIFOea; FIFOea = FIFOtmp;
-    FIFOtmp = FIFOs; FIFOs = FIFOsa; FIFOsa = FIFOtmp;
-    FIFOtmp = FIFOo; FIFOo = FIFOoa; FIFOoa = FIFOtmp;
-
-  } /* while (! (FifoVide(FIFOn) && FifoVide(FIFOe) && FifoVide(FIFOs) && FifoVide(FIFOo))) */
-}
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FifoTermine(FIFOn);
-  FifoTermine(FIFOe);
-  FifoTermine(FIFOs);
-  FifoTermine(FIFOo);
-  FifoTermine(FIFOna);
-  FifoTermine(FIFOea);
-  FifoTermine(FIFOsa);
-  FifoTermine(FIFOoa);
-
-#ifdef PERF
-  save_time(N, read_chrono(&chrono1), "llvkern", image->name);    
-#endif
-  return(1);
-}
-/* -library_code_end */
diff -r 8b1af7363833 src/lib/lmedialaxisRita._notused_c
--- a/src/lib/lmedialaxisRita._notused_c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lmedialaxisRita._notused_c	Mon Jan 13 15:50:10 2014 +0100
@@ -1,15 +1,48 @@
-/* $Id: lmedialaxisRita.c,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
+/*
+Copyright ESIEE (2009) 
+
+m.couprie@esiee.fr
+
+This software is an image processing library whose purpose is to be
+used primarily for research and teaching.
+
+This software is governed by the CeCILL  license under French law and
+abiding by the rules of distribution of free software. You can  use, 
+modify and/ or redistribute the software under the terms of the CeCILL
+license as circulated by CEA, CNRS and INRIA at the following URL
+"http://www.cecill.info". 
+
+As a counterpart to the access to the source code and  rights to copy,
+modify and redistribute granted by the license, users are provided only
+with a limited warranty  and the software's author,  the holder of the
+economic rights,  and the successive licensors  have only  limited
+liability. 
+
+In this respect, the user's attention is drawn to the risks associated
+with loading,  using,  modifying and/or developing or reproducing the
+software by the user in light of its specific status of free software,
+that may mean  that it is complicated to manipulate,  and  that  also
+therefore means  that it is reserved for developers  and  experienced
+professionals having in-depth computer knowledge. Users are therefore
+encouraged to load and test the software's suitability as regards their
+requirements in conditions enabling the security of their systems and/or 
+data to be ensured and,  more generally, to use and operate it in the 
+same conditions as regards security. 
+
+The fact that you are presently reading this means that you have had
+knowledge of the CeCILL license and that you accept its terms.
+*/
 /* 
 Fonctions pour l'axe médian exact ou approché, et
 pour la fonction bissectrice.
 
 Michel Couprie - mai 2002
 Rita Zrour - juin 2004
-  axe médian euclidien exact (algo de Rémy-Thiel) et fonction bissectrice (lbisector)
-Michel Couprie - juillet 2004 - révision lbisector
-Laurent Najman - lbisector_talbot
-Michel Couprie - juillet 2004 - révision lbisector_talbot
-Michel Couprie - août 2005 - variante lbisector Coeurjolly
+  axe médian euclidien exact (algo de Rémy-Thiel) et fonction bissectrice (lmedialaxisRita_lbisector)
+Michel Couprie - juillet 2004 - révision lmedialaxisRita_lbisector
+Laurent Najman - lmedialaxisRita_lbisector_talbot
+Michel Couprie - juillet 2004 - révision lmedialaxisRita_lbisector_talbot
+Michel Couprie - août 2005 - variante lmedialaxisRita_lbisector Coeurjolly
 Andre Vital Saude - avril 2006 - ameliorations des look-up tables
 */
 
@@ -82,7 +115,7 @@
 static double pscal(vect2Dint u, vect2Dint v) { return (double)(u.x*v.x + u.y*v.y); }
 
 /* ==================================== */
-int32_t lmedax_talbot(struct xvimage *img,   /* donnee: image binaire */       
+int32_t lmedialaxisRita_lmedax_talbot(struct xvimage *img,   /* donnee: image binaire */       
                   struct xvimage *res    /* resultat: centres des boules max (approx) */
 )
 /* ==================================== */
@@ -94,7 +127,7 @@
   suivant l'algo de Danielsson 4SED
 */
 #undef F_NAME
-#define F_NAME "lmedax_talbot"
+#define F_NAME "lmedialaxisRita_lmedax_talbot"
 { 
   uint32_t n1,n2,n3;     /* normes des vecteurs (au carre) */
   int32_t rs = img->row_size;
@@ -127,12 +160,12 @@
   for (i = 0; i < N; i++) 
     F[i] = 255-F[i];
 
-  M = ULONGDATA(res);
+  M = SLONGDATA(res);
   for (i = 0; i < N; i++) 
     M[i] = norm(L[i]);
   writeimage(res, "_res");
 
-  M = ULONGDATA(res);
+  M = SLONGDATA(res);
   for (i = 0; i < N; i++) if (F[i])
   {
     printf("i=(%d,%d); L[i]=(%d,%d)\n", i%rs, i/rs, L[i].x, L[i].y);
@@ -172,10 +205,10 @@
   }
   free(L);
   return(1);
-} // lmedax_talbot()
+} // lmedialaxisRita_lmedax_talbot()
 
 /* ==================================== */
-int32_t lmedax_meyer(struct xvimage *img,   /* donnee: image binaire */       
+int32_t lmedialaxisRita_lmedax_meyer(struct xvimage *img,   /* donnee: image binaire */       
                  struct xvimage *res    /* resultat: centres des boules max (approx) */
 )
 /* ==================================== */
@@ -183,13 +216,13 @@
   Methode de Meyer (approximation)
 */
 #undef F_NAME
-#define F_NAME "lmedax_meyer"
+#define F_NAME "lmedialaxisRita_lmedax_meyer"
 { 
   int32_t rs = img->row_size;
   int32_t cs = img->col_size;
   int32_t N= rs * cs;            /* taille de l'image */
   uint8_t *F = UCHARDATA(img);          /* pointeur sur l'image */
-  uint32_t *M = ULONGDATA(res);          /* donnees de l'image resultat */
+  uint32_t *M = SLONGDATA(res);          /* donnees de l'image resultat */
   uint32_t *D;          /* distance */
   uint32_t *H;          /* tampon */
   struct xvimage *inv;
@@ -253,10 +286,10 @@
     if (F[x] && (M[x] < D[x])) M[x] = D[x]; else M[x] = 0;  
   free(D);
   return(1);
-} // lmedax_meyer()
+} // lmedialaxisRita_lmedax_meyer()
 
 /* ==================================== */
-int32_t lmedax_meyer3d(struct xvimage *img,   /* donnee: image binaire */       
+int32_t lmedialaxisRita_lmedax_meyer3d(struct xvimage *img,   /* donnee: image binaire */       
                    struct xvimage *res    /* resultat: centres des boules max (approx) */
 )
 /* ==================================== */
@@ -264,7 +297,7 @@
   Methode de Meyer (approximation)
 */
 #undef F_NAME
-#define F_NAME "lmedax_meyer3d"
+#define F_NAME "lmedialaxisRita_lmedax_meyer3d"
 { 
   int32_t rs = rowsize(img);
   int32_t cs = colsize(img);
@@ -272,7 +305,7 @@
   int32_t ps = rs * cs;
   int32_t N = ps * ds;                            /* taille de l'image */
   uint8_t *F = UCHARDATA(img);          /* pointeur sur l'image */
-  uint32_t *M = ULONGDATA(res);          /* donnees de l'image resultat */
+  uint32_t *M = SLONGDATA(res);          /* donnees de l'image resultat */
   uint32_t *D;          /* distance */
   uint32_t *H;          /* tampon */
   struct xvimage *inv;
@@ -331,13 +364,13 @@
     if (F[x] && (M[x] < D[x])) M[x] = D[x]; else M[x] = 0;  
   free(D);
   return(1);
-} // lmedax_meyer3d()
+} // lmedialaxisRita_lmedax_meyer3d()
 
 /* ==================================== */
-int32_t lmedax_mc(struct xvimage *f)
+int32_t lmedialaxisRita_lmedax_mc(struct xvimage *f)
 /* ==================================== */
 #undef F_NAME
-#define F_NAME "lmedax_mc"
+#define F_NAME "lmedialaxisRita_lmedax_mc"
 {
   int32_t i, k;
   int32_t rs = rowsize(f);        /* taille ligne f */
@@ -363,7 +396,7 @@
     fprintf(stderr, "%s: allocimage failed\n", F_NAME);
     return(0);
   }
-  D = ULONGDATA(dist);
+  D = SLONGDATA(dist);
 
   if (ds == 1)
   {
@@ -465,7 +498,7 @@
   freeimage(tmp2);
   freeimage(res);
   return 1;
-} // lmedax_mc()
+} // lmedialaxisRita_lmedax_mc()
 
 
 /* ==================================== */
@@ -493,6 +526,10 @@
 typedef uint32_t * Image;
 typedef int32_t * TabDTg;
 
+typedef struct  Weighting{
+    int32_t x, y, z, RR;
+}  Weighting;
+
 typedef Weighting *MaskG;	      	//used to store Mglut
 
 /*
@@ -509,8 +546,8 @@
 
 /* int32_t callcheckR(int32_t distance,MaskG M); */
 /* int32_t RadiusMax(uint32_t * gg, int32_t rs, int32_t cs, int32_t ds); */
-int32_t ApplySymmetries(int32_t x, int32_t y, int32_t x1, int32_t y1, int32_t rs, int32_t cs, Neigbors *Mg);
-int32_t ApplySymmetries3d(int32_t x, int32_t y, int32_t z, int32_t x1, int32_t y1, int32_t z1, int32_t rs, int32_t cs, int32_t ds, Neigbors *Mg);
+int32_t lmedialaxisRita_ApplySymmetries(int32_t x, int32_t y, int32_t x1, int32_t y1, int32_t rs, int32_t cs, Neigbors *Mg);
+int32_t lmedialaxisRita_ApplySymmetries3d(int32_t x, int32_t y, int32_t z, int32_t x1, int32_t y1, int32_t z1, int32_t rs, int32_t cs, int32_t ds, Neigbors *Mg);
 /* int32_t CallMedial(int32_t x, int32_t y, Image image, int32_t rs, int32_t cs, MaskG MgL, LookUpTable Lut, int32_t nbcollut, int32_t rrmax); */
 /* int32_t CallMedial3d(int32_t x, int32_t y, int32_t z, Image image, int32_t rs, int32_t cs, int32_t ds, MaskG MgL, LookUpTable Lut, int32_t nbcollut, int32_t rrmax); */
 
@@ -540,7 +577,7 @@
 /* } */
 
 //----------------------------------
-int32_t ApplySymmetries(int32_t x, int32_t y, int32_t x1, int32_t y1, int32_t rs, int32_t cs, Neigbors *Mg)
+int32_t lmedialaxisRita_ApplySymmetries(int32_t x, int32_t y, int32_t x1, int32_t y1, int32_t rs, int32_t cs, Neigbors *Mg)
 //----------------------------------
 // ATTENTION : roles de x et y inversés (cf. Rita)
 {
@@ -567,10 +604,10 @@
     }
   }
   return count;	// this is important to know how many vector are present in Mg
-} // ApplySymmetries()
+} // lmedialaxisRita_ApplySymmetries()
 
 //----------------------------------
-int32_t ApplySymmetries3d(int32_t x, int32_t y, int32_t z, int32_t x1, int32_t y1, int32_t z1, int32_t rs, int32_t cs, int32_t ds, Neigbors *Mg)
+int32_t lmedialaxisRita_ApplySymmetries3d(int32_t x, int32_t y, int32_t z, int32_t x1, int32_t y1, int32_t z1, int32_t rs, int32_t cs, int32_t ds, Neigbors *Mg)
 //----------------------------------
 // ATTENTION : roles de x, y, z inversés (cf. Rita)
 {
@@ -646,7 +683,7 @@
     }
   }
   return count;		// this is important to know how many vector are present in Mg
-} // ApplySymmetries3d()
+} // lmedialaxisRita_ApplySymmetries3d()
 
 /*This function takes a point in the initial image find all possible neighbors in Mglut;
 calls find neighbors to check for each vector in Mglut its neighbors; puts the point in the 
@@ -663,7 +700,7 @@
 
 /*   for(t = 0; t < e; t++) //t determine the position of the vector in Mglut */
 /*   {	 */
-/*     nb = ApplySymmetries(MgL[t].x, MgL[t].y, x, y, rs, cs, &MgN1); */
+/*     nb = lmedialaxisRita_ApplySymmetries(MgL[t].x, MgL[t].y, x, y, rs, cs, &MgN1); */
 /*     for(j = 0; j < nb; j++) */
 /*     { */
 /*       xx = x + MgN1.neig[j].x;  */
@@ -687,7 +724,7 @@
   //foreach vg in MgLut do
   for (i = 0; i < mlut.numd; i++) {
     vg = mlut.vec[i];
-    nb = ApplySymmetries(vg.x, vg.y, x, y, rs, cs, &MgN1);
+    nb = lmedialaxisRita_ApplySymmetries(vg.x, vg.y, x, y, rs, cs, &MgN1);
     for(j = 0; j < nb; j++)
     {
       xx = x + MgN1.neig[j].x; 
@@ -711,7 +748,7 @@
 
 /*   for(t = 0; t < e; t++) //t determine the position of the vector in Mglut */
 /*   {	 */
-/*     nb = ApplySymmetries3d(MgL[t].x, MgL[t].y, MgL[t].z, x, y, z, rs, cs, ds, &MgN1); */
+/*     nb = lmedialaxisRita_ApplySymmetries3d(MgL[t].x, MgL[t].y, MgL[t].z, x, y, z, rs, cs, ds, &MgN1); */
 /*     for(j = 0; j < nb; j++) */
 /*     { */
 /*       xx = x + MgN1.neig[j].x;  */
@@ -736,7 +773,7 @@
   //foreach vg in MgLut do
   for (i = 0; i < mlut.numd; i++) {
     vg = mlut.vec[i];
-    nb = ApplySymmetries3d(vg.x, vg.y, vg.z, x, y, z, rs, cs, ds, &MgN1);
+    nb = lmedialaxisRita_ApplySymmetries3d(vg.x, vg.y, vg.z, x, y, z, rs, cs, ds, &MgN1);
     for(j = 0; j < nb; j++)
     {
       xx = x + MgN1.neig[j].x; 
@@ -751,10 +788,10 @@
 } // IsMA3d()
 
 /* ==================================== */
-int32_t lmedax_Remy_Thiel(struct xvimage *ImageDist, struct xvimage *ImageMedial)
+int32_t lmedialaxisRita_lmedax_Remy_Thiel(struct xvimage *ImageDist, struct xvimage *ImageMedial)
 /* ==================================== */
 #undef F_NAME
-#define F_NAME "lmedax_Remy_Thiel"
+#define F_NAME "lmedialaxisRita_lmedax_Remy_Thiel"
 /*
 from the article: " Exact Medial Axis With Euclidean Distance"
   algorithm to compute the medial axis based on the look-up table
@@ -803,8 +840,8 @@
     return 0;
   }    
 
-  imagedist = ULONGDATA(ImageDist);
-  imagemedial = ULONGDATA(ImageMedial);
+  imagedist = SLONGDATA(ImageDist);
+  imagemedial = SLONGDATA(ImageMedial);
   memset(imagemedial, 0, N*sizeof(int32_t));
 
   rmax= findMaxLong(imagedist, N);
@@ -1020,11 +1057,11 @@
 /* #endif */
 
 /*   return 1; */
-} // lmedax_Remy_Thiel()
+} // lmedialaxisRita_lmedax_Remy_Thiel()
 
 
 /* ==================================== */
-struct xvimage *lmedialaxis(struct xvimage *f, int32_t mode)
+struct xvimage *lmedialaxisRita_lmedialaxis(struct xvimage *f, int32_t mode)
 /* ==================================== */
 /* f must be allocated */
 {
@@ -1048,23 +1085,23 @@
     fprintf(stderr, "%s: allocimage failed\n", F_NAME);
     return(NULL);
   }
-  D = ULONGDATA(medial);
+  D = SLONGDATA(medial);
 
     if ((mode == 0) && (ds == 1))
     {
-      if (! lmedax_meyer(f, medial))
-	//if (! lmedax_talbot(f, medial))
+      if (! lmedialaxisRita_lmedax_meyer(f, medial))
+	//if (! lmedialaxisRita_lmedax_talbot(f, medial))
       {
-        fprintf(stderr, "%s: lmedax_meyer failed\n", F_NAME);
+        fprintf(stderr, "%s: lmedialaxisRita_lmedax_meyer failed\n", F_NAME);
         return(NULL);
       }
     }
     else
     if ((mode == 0) && (ds > 1))
     {
-      if (! lmedax_meyer3d(f, medial))
+      if (! lmedialaxisRita_lmedax_meyer3d(f, medial))
       {
-        fprintf(stderr, "%s: lmedax_meyer3d failed\n", F_NAME);
+        fprintf(stderr, "%s: lmedialaxisRita_lmedax_meyer3d failed\n", F_NAME);
         return(NULL);
       }
     }
@@ -1108,9 +1145,9 @@
         fprintf(stderr, "%s: lsedt_meijster failed\n", F_NAME);
         return(NULL);
       }
-      if (! lmedax_Remy_Thiel(dist, medial))
+      if (! lmedialaxisRita_lmedax_Remy_Thiel(dist, medial))
       {
-        fprintf(stderr, "%s: lmedax_Remy_Thiel failed\n", F_NAME);
+        fprintf(stderr, "%s: lmedialaxisRita_lmedax_Remy_Thiel failed\n", F_NAME);
         return(NULL);
       }
       freeimage(dist);
@@ -1132,7 +1169,7 @@
         fprintf(stderr, "%s: function lt4pp failed\n", F_NAME);
         return(NULL);
       }
-      T1 = ULONGDATA(dist);
+      T1 = SLONGDATA(dist);
       for (i = 0; i < N; i++) 
         if ((T1[i] == 0) && (F[i] == 0)) ; // F[i] = D[i]; 
         else D[i] = 0; 
@@ -1155,7 +1192,7 @@
         fprintf(stderr, "%s: function lt8pp failed\n", F_NAME);
         return(NULL);
       }
-      T1 = ULONGDATA(dist);
+      T1 = SLONGDATA(dist);
       for (i = 0; i < N; i++) 
         if ((T1[i] == 0) && (F[i] == 0)) ; // F[i] = D[i]; 
         else D[i] = 0; 
@@ -1178,7 +1215,7 @@
         fprintf(stderr, "%s: function lt6pp failed\n", F_NAME);
         return(NULL);
       }
-      T1 = ULONGDATA(dist);
+      T1 = SLONGDATA(dist);
       for (i = 0; i < N; i++) 
         if ((T1[i] == 0) && (F[i] == 0)) ; // F[i] = D[i]; 
         else D[i] = 0; 
@@ -1196,12 +1233,12 @@
         return(NULL);
       }
       dist = copyimage(medial);
-      if (! lt26pp(dist))           // pour les maxima de la fonction distance
+      if (! lmctopo3d_t26pp(dist))           // pour les maxima de la fonction distance
       {
-        fprintf(stderr, "%s: function lt26pp failed\n", F_NAME);
+        fprintf(stderr, "%s: function lmctopo3d_t26pp failed\n", F_NAME);
         return(NULL);
       }
-      T1 = ULONGDATA(dist);
+      T1 = SLONGDATA(dist);
       for (i = 0; i < N; i++) 
         if ((T1[i] == 0) && (F[i] == 0)) ; // F[i] = D[i]; 
         else D[i] = 0; 
@@ -1246,10 +1283,10 @@
     }
 #endif
   return medial;
-} // lmedialaxis()
+} // lmedialaxisRita_lmedialaxis()
 
 /* ==================================== */
-int32_t lmedialaxisbin(struct xvimage *f, int32_t mode)
+int32_t lmedialaxisRita_lmedialaxisbin(struct xvimage *f, int32_t mode)
 /* ==================================== */
 {
 #undef F_NAME
@@ -1260,16 +1297,16 @@
   struct xvimage *dist;
   uint32_t *D;
 
-  dist = lmedialaxis(f, mode);
+  dist = lmedialaxisRita_lmedialaxis(f, mode);
   if (dist == NULL)
   {   
     fprintf(stderr, "%s: lmedialaxis failed\n", F_NAME);
     return(0);
   }
-  D = ULONGDATA(dist);
+  D = SLONGDATA(dist);
   for (i = 0; i < N; i++) if (D[i]) F[i] = NDG_MAX; else F[i] = NDG_MIN;
   return 1;
-} // lmedialaxisbin()
+} // lmedialaxisRita_lmedialaxisbin()
 
 /* ==================================== */
 /* ==================================== */
@@ -1358,7 +1395,7 @@
 } // CheckAngle3d()
 
 //----------------------------------
-int32_t ApplySymmetriesB(int32_t x, int32_t y, int32_t x1, int32_t y1, int32_t rs, int32_t cs, Neigbors *Mg)
+int32_t lmedialaxisRita_ApplySymmetriesB(int32_t x, int32_t y, int32_t x1, int32_t y1, int32_t rs, int32_t cs, Neigbors *Mg)
 //----------------------------------
 {
   int32_t vectx[8], vecty[8], i;
@@ -1384,10 +1421,10 @@
     }
   }
   return count;	// this is important to know how many vector are present in Mg
-} // ApplySymmetriesB()
+} // lmedialaxisRita_ApplySymmetriesB()
 
 //----------------------------------
-int32_t ApplySymmetriesB3d(int32_t x, int32_t y, int32_t z, int32_t x1, int32_t y1, int32_t z1, int32_t rs, int32_t cs, int32_t ds, Neigbors *Mg)
+int32_t lmedialaxisRita_ApplySymmetriesB3d(int32_t x, int32_t y, int32_t z, int32_t x1, int32_t y1, int32_t z1, int32_t rs, int32_t cs, int32_t ds, Neigbors *Mg)
 //----------------------------------
 {
   int32_t vectx[48], vecty[48], vectz[48], i;
@@ -1462,10 +1499,10 @@
     }
   }
   return count;		// this is important to know how many vector are present in Mg
-} // ApplySymmetriesB3d()
+} // lmedialaxisRita_ApplySymmetriesB3d()
 
 /* ==================================== */
-double ComputeAngle(int32_t x, int32_t y, Image image,
+double lmedialaxisRita_ComputeAngle(int32_t x, int32_t y, Image image,
 		    int32_t rs, int32_t cs, 
 		    int32_t *TabIndDec, int32_t nval, Coordinates *ListDecs,
 		    ZeroNeighbors ZeroNei)
@@ -1477,7 +1514,7 @@
 //          logiquement locale, passé en paramètre pour éviter allocations/libérations
 {
 #undef F_NAME
-#define F_NAME "ComputeAngle"
+#define F_NAME "lmedialaxisRita_ComputeAngle"
   int32_t nb, i, j, xx, yy, rr, counter, k, c, ti, d, nbdec;
   double maxangle;
   Neigbors MgN1;
@@ -1513,7 +1550,7 @@
       for(d = 0; d < nbdec; d++)
       {
 	xnew = ListDecs[ti+d].x; ynew = ListDecs[ti+d].y;
-	nb = ApplySymmetriesB(xnew, ynew, X[k], Y[k], rs, cs, &MgN1);	
+	nb = lmedialaxisRita_ApplySymmetriesB(xnew, ynew, X[k], Y[k], rs, cs, &MgN1);	
 	for (j = 0; j < nb; j++)
         {
 	  xx = X[k] + MgN1.neig[j].x; yy = Y[k] + MgN1.neig[j].y; 
@@ -1560,10 +1597,10 @@
   maxangle = CheckAngle(x, y, ZeroNei, counter);
 
   return maxangle;
-} // ComputeAngle()
+} // lmedialaxisRita_ComputeAngle()
  
 /* ==================================== */
-double ComputeAngle_8(int32_t x, int32_t y, Image image,
+double lmedialaxisRita_ComputeAngle_8(int32_t x, int32_t y, Image image,
 		    int32_t rs, int32_t cs, 
 		    int32_t *TabIndDec, int32_t nval, Coordinates *ListDecs,
 		    ZeroNeighbors ZeroNei)
@@ -1576,7 +1613,7 @@
 //          logiquement locale, passé en paramètre pour éviter allocations/libérations
 {
 #undef F_NAME
-#define F_NAME "ComputeAngle"
+#define F_NAME "lmedialaxisRita_ComputeAngle"
   int32_t nb, i, j, xx, yy, rr, counter, k, c, ti, d, nbdec;
   double maxangle;
   Neigbors MgN1;
@@ -1607,7 +1644,7 @@
       for(d = 0; d < nbdec; d++)
       {
 	xnew = ListDecs[ti+d].x; ynew = ListDecs[ti+d].y;
-	nb = ApplySymmetriesB(xnew, ynew, X[k], Y[k], rs, cs, &MgN1);	
+	nb = lmedialaxisRita_ApplySymmetriesB(xnew, ynew, X[k], Y[k], rs, cs, &MgN1);	
 	for (j = 0; j < nb; j++)
         {
 	  xx = X[k] + MgN1.neig[j].x; yy = Y[k] + MgN1.neig[j].y;
@@ -1637,10 +1674,10 @@
   maxangle = CheckAngle(x, y, ZeroNei, counter);
 
   return maxangle;
-} // ComputeAngle_8()
+} // lmedialaxisRita_ComputeAngle_8()
 
 /* ==================================== */
-double ComputeAngle3d (int32_t x, int32_t y, int32_t z, Image image,
+double lmedialaxisRita_ComputeAngle3d (int32_t x, int32_t y, int32_t z, Image image,
 		       int32_t rs, int32_t cs, int32_t ds, 
 		       int32_t *TabIndDec, int32_t nval, Coordinates *ListDecs,
 		       ZeroNeighbors ZeroNei)
@@ -1652,7 +1689,7 @@
 //          logiquement locale, passé en paramètre pour éviter allocations/libérations
 {
 #undef F_NAME
-#define F_NAME "ComputeAngle3d"
+#define F_NAME "lmedialaxisRita_ComputeAngle3d"
   int32_t nb, i, j, xx, yy, zz, rr, counter, k, c, ti, d, nbdec, ps = rs*cs;
   double maxangle;
   Neigbors MgN1;
@@ -1691,7 +1728,7 @@
 	xnew = ListDecs[ti+d].x; // direction of search to reach the first zero (CTg table)
 	ynew = ListDecs[ti+d].y;
 	znew = ListDecs[ti+d].z;
-	nb = ApplySymmetriesB3d(xnew, ynew, znew, X[k], Y[k], Z[k], rs, cs, ds, &MgN1);	
+	nb = lmedialaxisRita_ApplySymmetriesB3d(xnew, ynew, znew, X[k], Y[k], Z[k], rs, cs, ds, &MgN1);	
 	for (j = 0; j < nb; j++)
         {
 	  xx = X[k] + MgN1.neig[j].x; 
@@ -1741,10 +1778,10 @@
   maxangle = CheckAngle3d(x, y, z, ZeroNei, counter);
 
   return maxangle;
-} // ComputeAngle3d()
+} // lmedialaxisRita_ComputeAngle3d()
 
 /* ==================================== */
-int32_t lbisector(struct xvimage *id, struct xvimage *im, struct xvimage *ia)
+int32_t lmedialaxisRita_lbisector(struct xvimage *id, struct xvimage *im, struct xvimage *ia)
 /* ==================================== */
 /*
    Calcule la fonction bissectrice pour les points non nuls de l'image 'im'. 
@@ -1753,7 +1790,7 @@
 */
 {
 #undef F_NAME
-#define F_NAME "lbisector"
+#define F_NAME "lmedialaxisRita_lbisector"
   int32_t i, j, k, nval, npoints, npointsmax;
   int32_t rs = rowsize(id);
   int32_t cs = colsize(id);
@@ -1765,7 +1802,7 @@
   int32_t *TabIndDec;
   Coordinates *ListDecs;
   FILE *fd=NULL;
-  uint32_t *imagedist = ULONGDATA(id);
+  uint32_t *imagedist = SLONGDATA(id);
   uint8_t *imagemask = UCHARDATA(im);
   float *imageangle = FLOATDATA(ia);
   char tablefilename[512];
@@ -1869,7 +1906,7 @@
       {
 	if (imagemask[j*rs + i] != 0)
         {
-	  angle = ComputeAngle(i, j, imagedist, rs, cs, TabIndDec, nval, ListDecs, ZeroNeigg);
+	  angle = lmedialaxisRita_ComputeAngle(i, j, imagedist, rs, cs, TabIndDec, nval, ListDecs, ZeroNeigg);
 	  imageangle[j*rs + i] = (float)acos(angle);				
 	}
 	else
@@ -1936,7 +1973,7 @@
         {
 	  if (imagemask[k*ps + j*rs + i] != 0)
           {
-	    angle = ComputeAngle3d(i, j, k, imagedist, rs, cs, ds, TabIndDec, nval, ListDecs, ZeroNeigg);
+	    angle = lmedialaxisRita_ComputeAngle3d(i, j, k, imagedist, rs, cs, ds, TabIndDec, nval, ListDecs, ZeroNeigg);
 	    imageangle[k*ps + j*rs + i] = (float)acos(angle);				
 	  }
 	  else
@@ -1978,10 +2015,10 @@
   free(TabIndDec);
   free(ListDecs);
   return 1;
-} // lbisector()
+} // lmedialaxisRita_lbisector()
  
 /* ==================================== */
-double ComputeAngle_Rita(
+double lmedialaxisRita_ComputeAngle_Rita(
 			int32_t x, int32_t y, Image image,
 			int32_t rs, int32_t cs, int32_t *distarray,
 			int32_t *xarray, int32_t *yarray, int32_t number, 
@@ -2021,7 +2058,7 @@
 	xnew = xarray[i]; // direction of search to reach the first zero (CTg table)
 	ynew = yarray[i];
 			
-	nb=ApplySymmetriesB(xnew, ynew, X[k], Y[k], rs, cs, &MgN1);	
+	nb=lmedialaxisRita_ApplySymmetriesB(xnew, ynew, X[k], Y[k], rs, cs, &MgN1);	
 	for (j = 0; j < nb; j++)
 	{
 	  xx = X[k] + MgN1.neig[j].x;
@@ -2046,10 +2083,10 @@
 
   maxangle=CheckAngle(x,y,ZeroNei,counter);
   return maxangle;
-} // ComputeAngle_Rita()
+} // lmedialaxisRita_ComputeAngle_Rita()
 
 /* ==================================== */
-int32_t lbisector_Rita(struct xvimage *id, struct xvimage *im, struct xvimage *ia)
+int32_t lmedialaxisRita_lbisector_Rita(struct xvimage *id, struct xvimage *im, struct xvimage *ia)
 /* ==================================== */
 /*
    Calcule la fonction bissectrice pour les points non nuls de l'image 'im'. 
@@ -2058,7 +2095,7 @@
 */
 {
 #undef F_NAME
-#define F_NAME "lbisector_Rita"
+#define F_NAME "lmedialaxisRita_lbisector_Rita"
   int32_t i, j, numb;
   int32_t rs, cs, N;
   double angle;	
@@ -2082,7 +2119,7 @@
     fprintf(stderr, "%s: distance image must be int32_t\n", F_NAME);
     return 0;
   }    
-  imagedist = ULONGDATA(id);
+  imagedist = SLONGDATA(id);
   rs = rowsize(id);
   cs = colsize(id);
   N = rs * cs;
@@ -2133,7 +2170,7 @@
     {
       if (imagemask[i*rs + j] != 0)
       {
-	angle = ComputeAngle_Rita(i,j,imagedist,rs,cs,distCTg,XcoodCTg,YcoodCTg,numb,ZeroNeigg);
+	angle = lmedialaxisRita_ComputeAngle_Rita(i,j,imagedist,rs,cs,distCTg,XcoodCTg,YcoodCTg,numb,ZeroNeigg);
 	imageangle[i*rs + j] = (float)acos(angle);				
       }
       else
@@ -2145,14 +2182,14 @@
   free(YcoodCTg);
   free(XcoodCTg);
   return 1;
-} // lbisector_Rita()
+} // lmedialaxisRita_lbisector_Rita()
 
 /* =============================================================== */
-int32_t lbisector_talbot(struct xvimage * image, struct xvimage *angles) 
+int32_t lmedialaxisRita_lbisector_talbot(struct xvimage * image, struct xvimage *angles) 
 /* =============================================================== */
 {
 #undef F_NAME
-#define F_NAME "lbisector_talbot"
+#define F_NAME "lmedialaxisRita_lbisector_talbot"
   int32_t N, i, j, y, rs, cs;
   uint8_t *F;
   float *A;
@@ -2292,7 +2329,7 @@
   } // for j
   free(L);
   return 1;
-} // lbisector_talbot()
+} // lmedialaxisRita_lbisector_talbot()
 
 /* ==================================== */
 int32_t lmaxball(struct xvimage *ImageDist, struct xvimage *Result)
@@ -2339,7 +2376,7 @@
 
 
 /* ==================================== */
-int32_t Downstream(int32_t x, int32_t y, Image image,
+int32_t lmedialaxisRita_Downstream(int32_t x, int32_t y, Image image,
 		int32_t rs, int32_t cs, 
 		int32_t *TabIndDec, int32_t nval, Coordinates *ListDecs,
 		ZeroNeighbors ZeroNei)
@@ -2352,7 +2389,7 @@
 // Retourne le nombre de points de l'aval
 {
 #undef F_NAME
-#define F_NAME "Downstream"
+#define F_NAME "lmedialaxisRita_Downstream"
   int32_t nb, i, j, xx, yy, rr, counter, k, c, ti, d, nbdec;
   Neigbors MgN1;
   int32_t xnew, ynew;
@@ -2366,7 +2403,7 @@
   for(d = 0; d < nbdec; d++)
   {
     xnew = ListDecs[ti+d].x; ynew = ListDecs[ti+d].y;
-    nb = ApplySymmetriesB(xnew, ynew, x, y, rs, cs, &MgN1);	
+    nb = lmedialaxisRita_ApplySymmetriesB(xnew, ynew, x, y, rs, cs, &MgN1);	
     for (j = 0; j < nb; j++)
     {
       xx = x + MgN1.neig[j].x; yy = y + MgN1.neig[j].y; 
@@ -2381,10 +2418,10 @@
     } // for (j = 0; j < nb; j++)
   } // for(d = 0; d < nbdec; d++)
   return counter;
-} // Downstream()
+} // lmedialaxisRita_Downstream()
 
 /* ==================================== */
-int32_t Downstream3d(int32_t x, int32_t y, int32_t z, Image image,
+int32_t lmedialaxisRita_Downstream3d(int32_t x, int32_t y, int32_t z, Image image,
 		int32_t rs, int32_t cs, int32_t ds, 
 		int32_t *TabIndDec, int32_t nval, Coordinates *ListDecs,
 		ZeroNeighbors ZeroNei)
@@ -2397,7 +2434,7 @@
 // Retourne le nombre de points de l'aval
 {
 #undef F_NAME
-#define F_NAME "Downstream3d"
+#define F_NAME "lmedialaxisRita_Downstream3d"
   int32_t nb, i, j, xx, yy, zz, rr, counter, c, ti, d, nbdec;
   int32_t ps = rs*cs;
   Neigbors MgN1;
@@ -2414,7 +2451,7 @@
     xnew = ListDecs[ti+d].x; 
     ynew = ListDecs[ti+d].y; 
     znew = ListDecs[ti+d].z;
-    nb = ApplySymmetriesB3d(xnew, ynew, znew, x, y, z, rs, cs, ds, &MgN1);	
+    nb = lmedialaxisRita_ApplySymmetriesB3d(xnew, ynew, znew, x, y, z, rs, cs, ds, &MgN1);	
     for (j = 0; j < nb; j++)
     {
       xx = x + MgN1.neig[j].x; 
@@ -2434,17 +2471,17 @@
     } // for (j = 0; j < nb; j++)
   } // for(d = 0; d < nbdec; d++)
   return counter;
-} // Downstream3d()
+} // lmedialaxisRita_Downstream3d()
 
 /* ==================================== */
-int32_t lprintdownstream(struct xvimage *id)
+int32_t lmedialaxisRita_lprintdownstream(struct xvimage *id)
 /* ==================================== */
 /*
   Imprime le downstream de chaque point objet (pour tests)
 */
 {
 #undef F_NAME
-#define F_NAME "lprintdownstream"
+#define F_NAME "lmedialaxisRita_lprintdownstream"
   int32_t i, j, k, nval, npoints, npointsmax;
   int32_t rs = rowsize(id);
   int32_t cs = colsize(id);
@@ -2455,7 +2492,7 @@
   int32_t *TabIndDec;
   Coordinates *ListDecs;
   FILE *fd=NULL;
-  uint32_t *imagedist = ULONGDATA(id);
+  uint32_t *imagedist = SLONGDATA(id);
   char tablefilename[512];
   int32_t distmax; 
   int32_t card_downstream, n;
@@ -2525,7 +2562,7 @@
     for (j = 0; j < cs; j++)
       for (i = 0; i < rs; i++)
       {
-	card_downstream = Downstream(i, j, imagedist, rs, cs, TabIndDec, nval, ListDecs, ZeroNeigg);
+	card_downstream = lmedialaxisRita_Downstream(i, j, imagedist, rs, cs, TabIndDec, nval, ListDecs, ZeroNeigg);
 	if ((imagedist[j*rs + i]) && card_downstream)
 	{
 	  printf("[%d,%d,%d] : ", i, j, 0);//BUG
@@ -2590,7 +2627,7 @@
       for (j = 0; j < cs; j++)
 	for (i = 0; i < rs; i++)
         {
-	  card_downstream = Downstream3d(i, j, k, imagedist, rs, cs, ds, TabIndDec, nval, ListDecs, ZeroNeigg);
+	  card_downstream = lmedialaxisRita_Downstream3d(i, j, k, imagedist, rs, cs, ds, TabIndDec, nval, ListDecs, ZeroNeigg);
 	  if ((imagedist[k*ps + j*rs + i]) && card_downstream)
 	  {
 	    printf("[%d,%d,%d] : ", i, j, k);
@@ -2605,5 +2642,5 @@
   free(TabIndDec);
   free(ListDecs);
   return 1;
-} // lprintdownstream()
+} // lmedialaxisRita_lprintdownstream()
 
diff -r 8b1af7363833 src/lib/lmeshwarp._notused_c
--- a/src/lib/lmeshwarp._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,625 +0,0 @@
-/* $Id: lmeshwarp.c,v 1.1.1.1 2008-11-25 08:01:42 mcouprie Exp $ */
-/* mesh warper */
-/* Michel Couprie - decembre 1998 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#ifdef HP
-#define _INCLUDE_XOPEN_SOURCE
-#endif
-#include <math.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcutil.h>
-#include <mcxbib.h>
-#include <mcgeo.h>
-#include <lbresen.h>
-#include <lvoronoi.h>
-#include <lmeshwarp.h>
-
-#define MAXSIZEMESH 5000
-
-/* ==================================== */
-int32_t warptriangle(
-  triangle * ts,
-  triangle * td,
-  uint8_t *F,
-  uint8_t *H,
-  int32_t rspix)
-/* ==================================== */
-{
-  int32_t x, y;
-  mat33 m;                              /* matrice de travail */
-  mat33 a;                              /* transformation affine dest -> source */
-  vec3 b;
-  vec3 sol;
-  double X, Y;
-
-  if (inittriangle(ts) == 0)
-  {
-    printf("mauvais triangle source\n");
-    return(0);
-  }
-
-  if (inittriangle(td) == 0)
-  {
-    printf("mauvais triangle destination\n");
-    return(0);
-  }
-
-  /* ------------------------------------------------------------------ */
-  /* identification des parametres de la transformation affine lineaire */
-  /* ------------------------------------------------------------------ */
-
-  m[0][0] = td->xa;     m[0][1] = td->ya;     m[0][2] = 1.0;
-  m[1][0] = td->xb;     m[1][1] = td->yb;     m[1][2] = 1.0;
-  m[2][0] = td->xc;     m[2][1] = td->yc;     m[2][2] = 1.0;
-
-  b[0] = ts->xa;
-  b[1] = ts->xb;
-  b[2] = ts->xc;
-  
-  if (solsyst3(m, b, sol) == 0)
-  {
-    printf("determinant nul\n");
-    return 0;
-  }
-
-  a[0][0] = sol[0];     a[0][1] = sol[1];     a[0][2] = sol[2];
-
-  b[0] = ts->ya;
-  b[1] = ts->yb;
-  b[2] = ts->yc;
-  
-  if (solsyst3(m, b, sol) == 0)
-  {
-    printf("determinant nul\n");
-    return 0;
-  }
-
-  a[1][0] = sol[0];     a[1][1] = sol[1];     a[1][2] = sol[2];
-  a[2][0] = 0.0;        a[2][1] = 0.0;        a[2][2] = 1.0;
-
-  /* ------------------------------------------------------------- */
-  /* calcul des intensites des points dans le triangle destination */
-  /* ------------------------------------------------------------- */
-  
-  for (x = (int32_t)floor(td->xmin); x <= (int32_t)ceil(td->xmax); x++)
-    for (y = (int32_t)floor(td->ymin); y <= (int32_t)ceil(td->ymax); y++)
-      if ((danstriangle(td, (double)x, (double)y)) && (F[y * rspix + x] == 0))
-      {
-        b[0] = (double)x;
-        b[1] = (double)y;
-        b[2] = 1.0;
-        multmat3vec3(a, b, sol);
-        X = sol[0];
-        Y = sol[1];
-
-        F[y * rspix + x] = H[((int32_t)Y) * rspix + (int32_t)X];
-      }
-  return 1;
-}
-
-
-/* ==================================== */
-int32_t lwarp(
-  struct xvimage * in,
-  point *S, 
-  point *SD, 
-  int32_t n, 
-  int32_t **v, 
-  int32_t *nv, 
-  int32_t *ec
-)
-/* ==================================== */
-{
-  int32_t x, a, b, c;
-  uint8_t *F;
-  uint8_t *H;                     /* image de travail */
-  int32_t rspix, cspix, N;
-  triangle ts;
-  triangle td;
-
-  rspix = in->row_size;
-  cspix = in->col_size;
-  N = rspix * cspix;
-  F = UCHARDATA(in);
-
-  H = (uint8_t *)calloc(1,N * sizeof(char));
-  if (H == NULL)
-  {   fprintf(stderr,"lwarp() : malloc failed for H\n");
-      return(0);
-  }
-
-  memcpy((void *)H, (void *)F, N*sizeof(char));
-  memset(F, 0, N*sizeof(char));
-  for (a = 0; a < n; a++)       /* attention : on fait 2 fois le travail ! */
-  {
-    ts.xa = (int32_t)S[a].x; ts.ya = (int32_t)S[a].y;
-    td.xa = (int32_t)SD[a].x; td.ya = (int32_t)SD[a].y;
-    b = 0;
-    for (c = 1; c < nv[a]; c++)
-    {
-      ts.xb = (int32_t)S[v[a][b]].x; ts.yb = (int32_t)S[v[a][b]].y;
-      ts.xc = (int32_t)S[v[a][c]].x; ts.yc = (int32_t)S[v[a][c]].y;
-      td.xb = (int32_t)SD[v[a][b]].x; td.yb = (int32_t)SD[v[a][b]].y;
-      td.xc = (int32_t)SD[v[a][c]].x; td.yc = (int32_t)SD[v[a][c]].y;
-      (void)warptriangle(&ts, &td, F, H, rspix);
-      b = c;
-    }
-    if (!ec[a])
-    {
-      c = 0;
-      ts.xb = (int32_t)S[v[a][b]].x; ts.yb = (int32_t)S[v[a][b]].y;
-      ts.xc = (int32_t)S[v[a][c]].x; ts.yc = (int32_t)S[v[a][c]].y;   
-      td.xb = (int32_t)SD[v[a][b]].x; td.yb = (int32_t)SD[v[a][b]].y;
-      td.xc = (int32_t)SD[v[a][c]].x; td.yc = (int32_t)SD[v[a][c]].y;  
-      (void)warptriangle(&ts, &td, F, H, rspix);
-    }
-  }
-  free(H);
-  return 1;
-} /* lwarp() */
-
-/* ==================================== */
-void desmesh(
-  point *S, 
-  int32_t n, 
-  int32_t **v, 
-  int32_t *nv, 
-  int32_t *ec)
-/* ==================================== */
-{
-  int32_t i, j;
-
-  for (i = 0; i < n; i++)
-    for (j = 0; j < nv[i]; j++)
-      Line((int32_t)S[i].x, (int32_t)S[i].y, (int32_t)S[v[i][j]].x, (int32_t)S[v[i][j]].y);
-} /* desmesh() */
-
-/* ==================================== */
-void deshot(
-  int32_t hotxpix,
-  int32_t hotypix)
-/* ==================================== */
-{
-    /* redessine le point chaud */
-    Color(MC_RED);
-    Line(hotxpix-1, hotypix, hotxpix+1, hotypix);
-    Line(hotxpix, hotypix-1, hotxpix, hotypix+1);
-}
-
-/* ==================================== */
-void effhot(
-  int32_t hotxpix,
-  int32_t hotypix)
-/* ==================================== */
-{
-    /* efface le point chaud */
-    ColToWhite();
-    Line(hotxpix-1, hotypix, hotxpix+1, hotypix);
-    Line(hotxpix, hotypix-1, hotxpix, hotypix+1);
-}
-
-/* ==================================== */
-int32_t LePlusProche(point *S, int32_t n, double x, double y)
-/* ==================================== */
-{
-  int32_t j, k;
-  double d, dk;
-  point p;
-
-  p.x = x; p.y = y;
-  j = 0; 
-  d = carredistance(p, S[j]);
-  for (k = 0; k < n; k++)
-  {
-    dk = carredistance(p, S[k]);
-    if (dk < d) { d = dk; j = k; }
-  } /* for k */
-  return j;
-} /* LePlusProche() */
-
-/* ==================================== */
-int32_t lmeshwarp(
-        struct xvimage *image,
-        int32_t mrs)
-/* ==================================== */
-{
-  register int32_t i, j, k, z;     /* index muet */
-  int32_t xx, yy;                  /* index muet */
-  int32_t eventtype;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille plan */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *SAVE;         /* l'image de sauvegarde */
-#define NBBUTTONS   3
-#define BOXWIDTH  100
-#define BOXHEIGHT  20
-#define NBLIGBUTT   4
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT;
-  int32_t Width = rs;
-  int32_t ImageHeight = cs;
-  int32_t ImageWidth = rs;
-  double a = 0.03;
-  double d, x, y;
-  int32_t showgrid = 1;
-#define MODE_EXPAND  0
-#define MODE_RETRACT 1
-#define MODE_PICK    2
-#define MODE_DEPOSE  3
-#define MODE_NEWP    4
-#define MODE_DELP    5
-  int32_t mode = MODE_NEWP;
-  int32_t hotx, hoty;
-  int32_t hotxpix, hotypix;
-  int32_t **voisins = NULL, *nbvois = NULL, *envconv = NULL;
-  point *S;
-  point *SD;
-  int32_t nbmeshpoints = 0;
-  int32_t oldnbmeshpoints;
-  int32_t picked;
-  int32_t affimage = 1;
-  int32_t delaunay = 1;
-  double s;
-  int32_t mcs;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lmeshwarp: cette version ne traite pas les images volumiques\n");
-    return 0;
-  }
-  
-  S = (point *)calloc(1,MAXSIZEMESH * sizeof(point));
-  SD = (point *)calloc(1,MAXSIZEMESH * sizeof(point));
-  if ((S == NULL) || (SD == NULL))
-  {   fprintf(stderr, "lmeshwarp() : malloc failed for S\n");
-      return(0);
-  }
-
-  s = (double)rs / (double)(mrs - 1);
-  mcs = (int32_t)((double)cs / (s * sin(M_PI / 3)));
-
-  nbmeshpoints = 0;
-  /* calcule la grille initiale */
-  for (j = 0; j < mcs; j++)
-  {
-    if ((j % 2) == 0)
-      for (i = 0; i < mrs; i++)
-      {
-        S[nbmeshpoints].x = (double)((rs-1) * i) / (mrs-1);
-        S[nbmeshpoints].y = (double)((cs-1) * j) / (mcs-1);
-        nbmeshpoints++;
-      }
-    else
-    {
-      S[nbmeshpoints].x = 0.0;
-      S[nbmeshpoints].y = (double)((cs-1) * j) / (mcs-1);
-      nbmeshpoints++;
-      for (i = 0; i < mrs - 1; i++)
-      {
-        S[nbmeshpoints].x = (double)((rs-1) * i) / (mrs-1) + s / 2;
-        S[nbmeshpoints].y = (double)((cs-1) * j) / (mcs-1);
-        nbmeshpoints++;
-      }
-      S[nbmeshpoints].x = (double)(rs - 1);
-      S[nbmeshpoints].y = (double)((cs-1) * j) / (mcs-1);      
-      nbmeshpoints++;
-    }
-  }
-
-  for (i = 0; i < nbmeshpoints; i++) SD[i] = S[i];
-  oldnbmeshpoints = nbmeshpoints;
-
-  SAVE = (uint8_t *)calloc(1,N * sizeof(char));
-  if (SAVE == NULL)
-  {   fprintf(stderr, "lmeshwarp() : malloc failed for SAVE\n");
-      return(0);
-  }
-
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], " WARP   ");
-  strcpy(ButtonStrings[0][1], " HIDE   ");
-  strcpy(ButtonStrings[0][2], " UNDO   ");
-
-  strcpy(ButtonStrings[1][0], " EXPAND ");
-  strcpy(ButtonStrings[1][1], " RETRACT");
-  strcpy(ButtonStrings[1][2], " PICK   ");
-
-  strcpy(ButtonStrings[2][0], " NEW P  ");
-  strcpy(ButtonStrings[2][1], " DEL P  ");
-  strcpy(ButtonStrings[2][2], " MK MESH");
-
-  strcpy(ButtonStrings[3][0], " RS MESH");
-  strcpy(ButtonStrings[3][1], " REDRAW ");
-  strcpy(ButtonStrings[3][2], " QUIT   ");
-
-ReDraw:
-
-  /* send output to the screen */
-  if (affimage)
-  {
-#ifdef DEBUG
-fprintf(stderr,"debut affimage\n");
-#endif
-    for (z = 0; z < N; z++)
-    {
-      Color(SOURCE[z]/4);
-      Point(z%rs, z/rs);
-    }
-    affimage = 0;
-#ifdef DEBUG
-fprintf(stderr,"fin affimage\n");
-#endif
-  }
-
-  if (delaunay)
-  {
-    if (voisins)
-      for (i = 0; i < oldnbmeshpoints; i++) 
-        free(voisins[i]);
-    if (voisins) free(voisins);
-    if (nbvois) free(nbvois);
-    if (envconv) free(envconv);
-    voisins = NULL; nbvois = envconv = NULL;
-#ifdef DEBUG
-fprintf(stderr,"debut delaunay\n");
-#endif
-    ldelaunay(S, nbmeshpoints, &voisins, &nbvois, &envconv);
-    oldnbmeshpoints = nbmeshpoints; 
-    delaunay = 0;
-#ifdef DEBUG
-fprintf(stderr,"fin delaunay\n");
-#endif
-  }
-
-  if (showgrid)   
-  {
-#ifdef DEBUG
-fprintf(stderr,"debut showgrid\n");
-#endif
-    Color(MC_RED);   desmesh(S, nbmeshpoints, voisins, nbvois, envconv);
-    Color(MC_GREEN); desmesh(SD, nbmeshpoints, voisins, nbvois, envconv);
-#ifdef DEBUG
-fprintf(stderr,"fin showgrid\n");
-#endif
-  }
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k*BoxWidth, ImageHeight + i*BoxHeight, k*BoxWidth, ImageHeight + (i+1)*BoxHeight);
-      if ((i == 1) && (k == 0) && (mode == MODE_EXPAND)) Color(MC_RED); else
-      if ((i == 1) && (k == 1) && (mode == MODE_RETRACT)) Color(MC_RED); else
-      if ((i == 1) && (k == 2) && (mode == MODE_PICK)) Color(MC_RED); else
-      if ((i == 1) && (k == 2) && (mode == MODE_DEPOSE)) Color(MC_RED); else
-      if ((i == 2) && (k == 0) && (mode == MODE_NEWP)) Color(MC_RED); else
-      if ((i == 2) && (k == 1) && (mode == MODE_DELP)) Color(MC_RED);
-      String(k*BoxWidth + 3, ImageHeight + (i+1)*BoxHeight - 4, ButtonStrings[i][k]);
-      ColToBlack();
-    }
-  }
-
-  FlushGraphics();  
-
-  eventtype = WaitEvent(&xx, &yy);
-  switch(eventtype)
-  {
-    case KeyPress: 
-      switch(xx)
-      {
-        case key_q: goto Terminate;
-        case space: goto ReDraw;
-        
-#ifdef OLD
-        case num1: mode = 1; break;
-        case num2: mode = 2; break;
-        case num0: mode = 0; break;
-        case key_x: rotallx(cube, cubec); copiecube(cube, cubec); affcube(cube);
-                    inversecube(cubec, cube); break;
-        case key_y: rotally(cube, cubec); copiecube(cube, cubec); affcube(cube);
-                    inversecube(cubec, cube); break;
-        case key_z: rotallz(cube, cubec); copiecube(cube, cubec); affcube(cube);
-                    inversecube(cubec, cube); break;
-        case key_l: scanf("%x", &i); initcubes(cube, cubec, i); affcube(cube); break;
-        case key_p: printf("%% %x\n", i); latexcube(cube, 0, 40, 20, 6, 6, 4); break;
-        case key_u: symyz(cube, cubec); copiecube(cube, cubec); affcube(cube); break;
-        case key_v: symx(cube, cubec); copiecube(cube, cubec); affcube(cube); break;
-        case key_i: symy(cube, cubec); copiecube(cube, cubec); affcube(cube); break;
-        case key_r: symz(cube, cubec); copiecube(cube, cubec); affcube(cube); break;
-        case key_s: sym(cube, cubec); copiecube(cube, cubec); affcube(cube); break;
-        case key_a:
-        case key_w: break;
-        default: printf("bad key : %d\n", xx); break;
-#endif
-      }
-      goto ReDisplay;
-
-    case ButtonPress:
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight))
-  {
-    if ((mode == MODE_EXPAND) || (mode == MODE_RETRACT))
-    {
-     /* modifie la grille */
-     for (i = 0; i < nbmeshpoints; i++)
-     {
-         x = SD[i].x;
-         y = SD[i].y;
-         d = sqrt((x-(double)xx) * (x-(double)xx) + (y-(double)yy) * (y-(double)yy));
-         if (mode == MODE_EXPAND)
-         {
-           x += (x - (double)xx) / (a*d*d);
-           y += (y - (double)yy) / (a*d*d);
-           if (x < 0.0) x = 0.0;
-           if (y < 0.0) y = 0.0;
-	 }
-         else
-	 {
-           x -= (x - (double)xx) / (a*d*d);
-           y -= (y - (double)yy) / (a*d*d);
-	 }
-         if (x > (double)(rs-1)) x = (double)(rs-1);
-         if (y > (double)(cs-1)) y = (double)(cs-1);
-         SD[i].x = x;
-	 SD[i].y = y;
-       }
-       goto ReDraw;
-    }
-    if (mode == MODE_PICK)
-    {
-      picked = LePlusProche(SD, nbmeshpoints, (double)xx, (double)yy);
-      hotxpix = (int32_t)SD[picked].x;
-      hotypix = (int32_t)SD[picked].y;
-      deshot(hotxpix, hotypix);
-      strcpy(ButtonStrings[1][2], " DEPOSE ");
-      mode = MODE_DEPOSE;
-      goto ReDisplay;
-    }
-    if (mode == MODE_DEPOSE)
-    {
-      SD[picked].x = (double)xx;
-      SD[picked].y = (double)yy;
-      strcpy(ButtonStrings[1][2], " PICK   ");
-      mode = MODE_PICK;
-      if (showgrid)   
-      {
-        Color(MC_RED);   desmesh(S, nbmeshpoints, voisins, nbvois, envconv);
-        Color(MC_GREEN); desmesh(SD, nbmeshpoints, voisins, nbvois, envconv);
-      }
-      goto ReDisplay;
-    }
-    if (mode == MODE_NEWP)
-    {
-      if (nbmeshpoints >= MAXSIZEMESH)
-        fprintf(stderr, "lmeshwarp() : trop de points\n");
-      else  
-      {
-        SD[nbmeshpoints].x = S[nbmeshpoints].x = (double)xx;
-        SD[nbmeshpoints].y = S[nbmeshpoints].y = (double)yy;
-        nbmeshpoints++;
-        deshot(xx, yy);
-        delaunay = 1;
-        goto ReDisplay;
-      }
-    } /* if (mode == MODE_NEWP) */
-    if (mode == MODE_DELP)
-    {
-      picked = LePlusProche(S, nbmeshpoints, (double)xx, (double)yy);
-      hotxpix = (int32_t)S[picked].x;
-      hotypix = (int32_t)S[picked].y;
-      effhot(hotxpix, hotypix);
-      for (i = picked; i < nbmeshpoints-1; i++) SD[i] = S[i] = S[i+1];
-      nbmeshpoints-- ; 
-      delaunay = 1;
-      goto ReDisplay;
-    }
-  }
-  else /* click hors de l'image */
-  {
-    xx /= BoxWidth;
-    yy -= ImageHeight;
-    yy /= BoxHeight;
-
-    switch(yy)
-    {
-      case 0: switch(xx)
-              {
-                case 0: /* WARP */
-                  lwarp(image, S, SD, nbmeshpoints, voisins, nbvois, envconv);
-                  for (i = 0; i < nbmeshpoints; i++) S[i] = SD[i];
-                  delaunay = 1;
-                  affimage = 1;
-                  strcpy(ButtonStrings[0][1], " SHOW   ");
-                  showgrid = 0;
-                  goto ReDraw;
-                case 1: /* SHOW / HIDE */
-                  if (showgrid) 
-                  {
-                    strcpy(ButtonStrings[0][1], " SHOW   ");
-                    showgrid = 0;
-                    affimage = 1;
-                  }
-                  else
-                  { 
-                    strcpy(ButtonStrings[0][1], " HIDE   ");
-                    showgrid = 1;
-		  }
-                  goto ReDraw;
-                case 2: /* UNDO */
-                  goto ReDraw;
-	      } /* switch(xx) */
-      case 1: switch(xx)
-              {
-                case 0: mode = MODE_EXPAND; goto ReDisplay;
-                case 1: mode = MODE_RETRACT; goto ReDisplay;
-                case 2: mode = MODE_PICK; goto ReDisplay;
-	      } /* switch(xx) */
-      case 2: switch(xx)
-              {
-                case 0: mode = MODE_NEWP; goto ReDisplay;
-                case 1: mode = MODE_DELP; goto ReDisplay;
-                case 2: affimage = 1; goto ReDraw;
-	      } /* switch(xx) */
-      case 3: switch(xx)
-              {
-                case 0: 
-                  /* raz la grille */
-                  nbmeshpoints = 0;
-                  goto ReDraw;
-                case 1: 
-                  affimage = 1; goto ReDraw;
-                case 2: goto Terminate;
-	      } /* switch(xx) */
-    } /* switch(yy) */
-  } /* else */
-      break;
-
-    case ButtonRelease: 
-      break;
-
-    case EnterNotify: 
-      break;
-
-  } /* switch (eventtype) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      free(ButtonStrings[i][k]);
-  if (voisins)
-  {
-    for (i = 0; i < nbmeshpoints; i++) 
-      free(voisins[i]);
-    free(voisins);
-  }
-  if (nbvois) free(nbvois);
-  if (envconv) free(envconv);
-  free(S);
-  free(SD);
-  free(SAVE);
-  return(1);
-}
-
diff -r 8b1af7363833 src/lib/lmeshwarp.c.new
--- a/src/lib/lmeshwarp.c.new	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,556 +0,0 @@
-/* mesh warper */
-/* Michel Couprie - decembre 1998 */
-
-#include <stdio.h>
-#include <math.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcutil.h>
-#include <mcxbib.h>
-#include <mcgeo.h>
-#include <lbresen.h>
-#include <lvoronoi.h>
-#include <lmeshwarp.h>
-
-#define arrondi(z) ((z-(double)((int)z))<0.5?((int)z):((int)z+1))
-#define signe(z) ((z>0.0)?1.0:-1.0)
-
-#define MAXSIZEMESH 5000
-
-/* ==================================== */
-int warptriangle(
-  triangle * ts,
-  triangle * td,
-  unsigned char *F,
-  unsigned char *H,
-  int rspix)
-/* ==================================== */
-{
-  int x, y;
-  mat33 m;                              /* matrice de travail */
-  mat33 a;                              /* transformation affine dest -> source */
-  vec3 b;
-  vec3 sol;
-  double X, Y;
-
-  if (inittriangle(ts) == 0)
-  {
-    printf("mauvais triangle source\n");
-    return(0);
-  }
-
-  if (inittriangle(td) == 0)
-  {
-    printf("mauvais triangle destination\n");
-    return(0);
-  }
-
-  /* ------------------------------------------------------------------ */
-  /* identification des parametres de la transformation affine lineaire */
-  /* ------------------------------------------------------------------ */
-
-  m[0][0] = td->xa;     m[0][1] = td->ya;     m[0][2] = 1.0;
-  m[1][0] = td->xb;     m[1][1] = td->yb;     m[1][2] = 1.0;
-  m[2][0] = td->xc;     m[2][1] = td->yc;     m[2][2] = 1.0;
-
-  b[0] = ts->xa;
-  b[1] = ts->xb;
-  b[2] = ts->xc;
-  
-  if (solsyst3(m, b, sol) == 0)
-  {
-    printf("determinant nul\n");
-    return 0;
-  }
-
-  a[0][0] = sol[0];     a[0][1] = sol[1];     a[0][2] = sol[2];
-
-  b[0] = ts->ya;
-  b[1] = ts->yb;
-  b[2] = ts->yc;
-  
-  if (solsyst3(m, b, sol) == 0)
-  {
-    printf("determinant nul\n");
-    return 0;
-  }
-
-  a[1][0] = sol[0];     a[1][1] = sol[1];     a[1][2] = sol[2];
-  a[2][0] = 0.0;        a[2][1] = 0.0;        a[2][2] = 1.0;
-
-  /* ------------------------------------------------------------- */
-  /* calcul des intensites des points dans le triangle destination */
-  /* ------------------------------------------------------------- */
-  
-  for (x = (int)floor(td->xmin); x <= (int)ceil(td->xmax); x++)
-    for (y = (int)floor(td->ymin); y <= (int)ceil(td->ymax); y++)
-      if ((danstriangle(td, (double)x, (double)y)) && (F[y * rspix + x] == 0))
-      {
-        b[0] = (double)x;
-        b[1] = (double)y;
-        b[2] = 1.0;
-        multmat3vec3(a, b, sol);
-        X = sol[0];
-        Y = sol[1];
-
-        F[y * rspix + x] = H[((int)Y) * rspix + (int)X];
-      }
-  return 1;
-}
-
-
-/* ==================================== */
-int lwarp(
-  struct xvimage * in,
-  point *S, 
-  point *SD, 
-  int n, 
-  int **v, 
-  int *nv, 
-  int *ec
-)
-/* ==================================== */
-{
-  int x, a, b, c;
-  unsigned char *F;
-  unsigned char *H;                     /* image de travail */
-  int rspix, cspix, N;
-  triangle ts;
-  triangle td;
-
-  rspix = in->row_size;
-  cspix = in->col_size;
-  N = rspix * cspix;
-  F = UCHARDATA(in);
-
-  H = (unsigned char *)malloc(N*sizeof(char));
-  if (H == NULL)
-  {   fprintf(stderr,"lwarp() : malloc failed for H\n");
-      return(0);
-  }
-  for (x = 0; x < N; x++) H[x] = F[x];
-  for (x = 0; x < N; x++) F[x] = 0;
-
-  for (a = 0; a < n; a++)       /* attention : on fait 2 fois le travail ! */
-  {
-    ts.xa = (int)S[a].x; ts.ya = (int)S[a].y;
-    td.xa = (int)SD[a].x; td.ya = (int)SD[a].y;
-    b = 0;
-    for (c = 1; c < nv[a]; c++)
-    {
-      ts.xb = (int)S[v[a][b]].x; ts.yb = (int)S[v[a][b]].y;
-      ts.xc = (int)S[v[a][c]].x; ts.yc = (int)S[v[a][c]].y;
-      td.xb = (int)SD[v[a][b]].x; td.yb = (int)SD[v[a][b]].y;
-      td.xc = (int)SD[v[a][c]].x; td.yc = (int)SD[v[a][c]].y;
-      (void)warptriangle(&ts, &td, F, H, rspix);
-      b = c;
-    }
-    if (!ec[a])
-    {
-      c = 0;
-      ts.xb = (int)S[v[a][b]].x; ts.yb = (int)S[v[a][b]].y;
-      ts.xc = (int)S[v[a][c]].x; ts.yc = (int)S[v[a][c]].y;   
-      td.xb = (int)SD[v[a][b]].x; td.yb = (int)SD[v[a][b]].y;
-      td.xc = (int)SD[v[a][c]].x; td.yc = (int)SD[v[a][c]].y;  
-      (void)warptriangle(&ts, &td, F, H, rspix);
-    }
-  }
-
-  free(H);
-  return 1;
-} /* lwarp() */
-
-/* ==================================== */
-void desmesh(
-  point *S, 
-  int n, 
-  int **v, 
-  int *nv, 
-  int *ec)
-/* ==================================== */
-{
-  int i, j;
-
-  for (i = 0; i < n; i++)
-    for (j = 0; j < nv[i]; j++)
-      Line((int)S[i].x, (int)S[i].y, (int)S[v[i][j]].x, (int)S[v[i][j]].y);
-} /* desmesh() */
-
-/* ==================================== */
-void deshot(
-  int hotxpix,
-  int hotypix)
-/* ==================================== */
-{
-    /* redessine le point chaud */
-    Color(MC_RED);
-    Line(hotxpix-1, hotypix, hotxpix+1, hotypix);
-    Line(hotxpix, hotypix-1, hotxpix, hotypix+1);
-}
-
-/* ==================================== */
-void effhot(
-  int hotxpix,
-  int hotypix)
-/* ==================================== */
-{
-    /* efface le point chaud */
-    ColToWhite();
-    Line(hotxpix-1, hotypix, hotxpix+1, hotypix);
-    Line(hotxpix, hotypix-1, hotxpix, hotypix+1);
-}
-
-/* ==================================== */
-int LePlusProche(point *S, int n, double x, double y)
-/* ==================================== */
-{
-  int j, k;
-  double d, dk;
-  point p;
-
-  p.x = x; p.y = y;
-  j = 0; 
-  d = carredistance(p, S[j]);
-  for (k = 0; k < n; k++)
-  {
-    dk = carredistance(p, S[k]);
-    if (dk < d) { d = dk; j = k; }
-  } /* for k */
-  return j;
-} /* LePlusProche() */
-
-/* ==================================== */
-int lmeshwarp(
-        struct xvimage *image,
-        int mrs, 
-        int mcs)        /* mrs, mcs : taille de la grille */
-/* ==================================== */
-{
-  register int i, j, k, z;     /* index muet */
-  int xx, yy;                  /* index muet */
-  int eventtype;
-  int rs = rowsize(image);     /* taille ligne */
-  int cs = colsize(image);     /* taille colonne */
-  int N = rs * cs;             /* taille plan */
-  unsigned char *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  unsigned char *SAVE;         /* l'image de sauvegarde */
-#define NBBUTTONS   3
-#define BOXWIDTH  100
-#define BOXHEIGHT  20
-#define NBLIGBUTT   4
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int BoxWidth = BOXWIDTH;
-  int BoxHeight = BOXHEIGHT;
-  int Height = cs + BoxHeight * NBLIGBUTT;
-  int Width = rs;
-  int ImageHeight = cs;
-  int ImageWidth = rs;
-  double a = 0.1;
-  double d, x, y;
-  int showgrid = 1;
-#define MODE_EXPAND  0
-#define MODE_RETRACT 1
-#define MODE_PICK    2
-#define MODE_DEPOSE  3
-#define MODE_NEWP    4
-#define MODE_DELP    5
-  int mode = MODE_NEWP;
-  int hotx, hoty;
-  int hotxpix, hotypix;
-  int **voisins = NULL, *nbvois = NULL, *envconv = NULL;
-  point *S;
-  point *SD;
-  int nbmeshpoints = 0;
-  int picked;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lmeshwarp: cette version ne traite pas les images volumiques\n");
-    return 0;
-  }
-  
-  S = (point *)malloc(MAXSIZEMESH * sizeof(point));
-  SD = (point *)malloc(MAXSIZEMESH * sizeof(point));
-  if ((S == NULL) || (SD == NULL))
-  {   fprintf(stderr, "lmeshwarp() : malloc failed for S\n");
-      return(0);
-  }
-
-  nbmeshpoints = 0;
-  /* calcule la grille initiale */
-  for (j = 0; j < mcs; j++)
-    for (i = 0; i < mrs; i++)
-    {
-      S[nbmeshpoints].x = (double)((rs-1) * i) / (mrs-1);
-      S[nbmeshpoints].y = (double)((cs-1) * j) / (mcs-1);
-      nbmeshpoints++;
-    }
-
-  for (i = 0; i < nbmeshpoints; i++) SD[i] = S[i];
-
-  SAVE = (unsigned char *)malloc(N * sizeof(char));
-  if (SAVE == NULL)
-  {   fprintf(stderr, "lmeshwarp() : malloc failed for SAVE\n");
-      return(0);
-  }
-
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)malloc(16);
-
-  strcpy(ButtonStrings[0][0], " WARP   ");
-  strcpy(ButtonStrings[0][1], " HIDE   ");
-  strcpy(ButtonStrings[0][2], " UNDO   ");
-
-  strcpy(ButtonStrings[1][0], " EXPAND ");
-  strcpy(ButtonStrings[1][1], " RETRACT");
-  strcpy(ButtonStrings[1][2], " PICK   ");
-
-  strcpy(ButtonStrings[2][0], " NEW P  ");
-  strcpy(ButtonStrings[2][1], " DEL P  ");
-  strcpy(ButtonStrings[2][2], " MK MESH");
-
-  strcpy(ButtonStrings[3][0], " RS MESH");
-  strcpy(ButtonStrings[3][1], " REDRAW ");
-  strcpy(ButtonStrings[3][2], " QUIT   ");
-
-ReDraw:
-
-  /* send output to the screen */
-  for (z = 0; z < N; z++)
-  {
-    Color(SOURCE[z]/4);
-    Point(z%rs, z/rs);
-  }
-
-  ldelaunay(S, nbmeshpoints, &voisins, &nbvois, &envconv);
-
-  if (showgrid)   
-  {
-    Color(MC_RED);   desmesh(S, nbmeshpoints, voisins, nbvois, envconv);
-    Color(MC_GREEN); desmesh(SD, nbmeshpoints, voisins, nbvois, envconv);
-  }
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k*BoxWidth, ImageHeight + i*BoxHeight, k*BoxWidth, ImageHeight + (i+1)*BoxHeight);
-      if ((i == 1) && (k == 0) && (mode == MODE_EXPAND)) Color(MC_RED); else
-      if ((i == 1) && (k == 1) && (mode == MODE_RETRACT)) Color(MC_RED); else
-      if ((i == 1) && (k == 2) && (mode == MODE_PICK)) Color(MC_RED); else
-      if ((i == 1) && (k == 2) && (mode == MODE_DEPOSE)) Color(MC_RED); else
-      if ((i == 2) && (k == 0) && (mode == MODE_NEWP)) Color(MC_RED); else
-      if ((i == 2) && (k == 1) && (mode == MODE_DELP)) Color(MC_RED);
-      String(k*BoxWidth + 3, ImageHeight + (i+1)*BoxHeight - 4, ButtonStrings[i][k]);
-      ColToBlack();
-    }
-  }
-
-  FlushGraphics();  
-
-  eventtype = WaitEvent(&xx, &yy);
-  switch(eventtype)
-  {
-    case KeyPress: 
-      switch(xx)
-      {
-        case key_q: goto Terminate;
-        case space: goto ReDraw;
-        case key_e: 
-        
-/*
-        case num1: mode = 1; break;
-        case num2: mode = 2; break;
-        case num0: mode = 0; break;
-        case key_x: rotallx(cube, cubec); copiecube(cube, cubec); affcube(cube);
-                    inversecube(cubec, cube); break;
-        case key_y: rotally(cube, cubec); copiecube(cube, cubec); affcube(cube);
-                    inversecube(cubec, cube); break;
-        case key_z: rotallz(cube, cubec); copiecube(cube, cubec); affcube(cube);
-                    inversecube(cubec, cube); break;
-        case key_l: scanf("%x", &i); initcubes(cube, cubec, i); affcube(cube); break;
-        case key_p: printf("%% %x\n", i); latexcube(cube, 0, 40, 20, 6, 6, 4); break;
-        case key_u: symyz(cube, cubec); copiecube(cube, cubec); affcube(cube); break;
-        case key_v: symx(cube, cubec); copiecube(cube, cubec); affcube(cube); break;
-        case key_i: symy(cube, cubec); copiecube(cube, cubec); affcube(cube); break;
-        case key_r: symz(cube, cubec); copiecube(cube, cubec); affcube(cube); break;
-        case key_s: sym(cube, cubec); copiecube(cube, cubec); affcube(cube); break;
-        case key_a:
-        case key_w: break;
-        default: printf("bad key : %d\n", xx); break;
-*/
-      }
-      goto ReDisplay;
-
-    case ButtonPress:
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight))
-  {
-    if ((mode == MODE_EXPAND) || (mode == MODE_RETRACT))
-    {
-    }
-    if (mode == MODE_PICK)
-    {
-      picked = LePlusProche(SD, nbmeshpoints, (double)xx, (double)yy);
-      hotxpix = (int)SD[picked].x;
-      hotypix = (int)SD[picked].y;
-      deshot(hotxpix, hotypix);
-      strcpy(ButtonStrings[1][2], " DEPOSE ");
-      mode = MODE_DEPOSE;
-      goto ReDisplay;
-    }
-    if (mode == MODE_DEPOSE)
-    {
-      SD[picked].x = (double)xx;
-      SD[picked].y = (double)yy;
-      strcpy(ButtonStrings[1][2], " PICK   ");
-      mode = MODE_PICK;
-      if (showgrid)   
-      {
-        Color(MC_RED);   desmesh(S, nbmeshpoints, voisins, nbvois, envconv);
-        Color(MC_GREEN); desmesh(SD, nbmeshpoints, voisins, nbvois, envconv);
-      }
-      goto ReDisplay;
-    }
-    if (mode == MODE_NEWP)
-    {
-      if (nbmeshpoints >= MAXSIZEMESH)
-        fprintf(stderr, "lmeshwarp() : trop de points\n");
-      else  
-      {
-        if (voisins)
-          for (i = 0; i < nbmeshpoints; i++) 
-            free(voisins[i]);
-        if (voisins) free(voisins);
-        if (nbvois) free(nbvois);
-        if (envconv) free(envconv);
-        voisins = NULL; nbvois = envconv = NULL;
-
-        S[nbmeshpoints].x = (double)xx;
-        S[nbmeshpoints].y = (double)yy;
-        nbmeshpoints++;
-        deshot(xx, yy);
-        goto ReDisplay;
-      }
-    } /* if (mode == MODE_NEWP) */
-    if (mode == MODE_DELP)
-    {
-      if (voisins)
-        for (i = 0; i < nbmeshpoints; i++) 
-          free(voisins[i]);
-      if (voisins) free(voisins);
-      if (nbvois) free(nbvois);
-      if (envconv) free(envconv);
-      voisins = NULL; nbvois = envconv = NULL;
-
-      picked = LePlusProche(S, nbmeshpoints, (double)xx, (double)yy);
-      hotxpix = (int)S[picked].x;
-      hotypix = (int)S[picked].y;
-      effhot(hotxpix, hotypix);
-      for (i = picked; i < nbmeshpoints-1; i++) S[i] = S[i+1];
-      nbmeshpoints-- ; 
-      goto ReDisplay;
-    }
-  }
-  else /* click hors de l'image */
-  {
-    xx /= BoxWidth;
-    yy -= ImageHeight;
-    yy /= BoxHeight;
-
-    switch(yy)
-    {
-      case 0: switch(xx)
-              {
-                case 0: /* WARP */
-                  lwarp(image, S, SD, nbmeshpoints, voisins, nbvois, envconv);
-                  goto ReDraw;
-                case 1: /* SHOW / HIDE */
-                  if (showgrid) 
-                  {
-                    strcpy(ButtonStrings[0][1], " SHOW   ");
-                    showgrid = 0; 
-                  }
-                  else
-                  { 
-                    strcpy(ButtonStrings[0][1], " HIDE   ");
-                    showgrid = 1;
-		  }
-                  goto ReDraw;
-                case 2: /* UNDO */
-                  goto ReDraw;
-	      } /* switch(xx) */
-      case 1: switch(xx)
-              {
-                case 0: mode = MODE_EXPAND; goto ReDisplay;
-                case 1: mode = MODE_RETRACT; goto ReDisplay;
-                case 2: mode = MODE_PICK; goto ReDisplay;
-	      } /* switch(xx) */
-      case 2: switch(xx)
-              {
-                case 0: mode = MODE_NEWP; goto ReDisplay;
-                case 1: mode = MODE_DELP; goto ReDisplay;
-                case 2: ldelaunay(S, nbmeshpoints, &voisins, &nbvois, &envconv);
-                        for (i = 0; i < nbmeshpoints; i++) SD[i] = S[i];
-                        goto ReDraw;
-	      } /* switch(xx) */
-      case 3: switch(xx)
-              {
-                case 0: 
-                  /* raz la grille */
-                  nbmeshpoints = 0;
-                  if (voisins)
-                    for (i = 0; i < nbmeshpoints; i++) 
-                      free(voisins[i]);
-                  if (voisins) free(voisins);
-                  if (nbvois) free(nbvois);
-                  if (envconv) free(envconv);
-                  voisins = NULL; nbvois = envconv = NULL;
-                  goto ReDraw;
-                case 1: 
-                  goto ReDraw;
-                case 2: goto Terminate;
-	      } /* switch(xx) */
-    } /* switch(yy) */
-  } /* else */
-      break;
-
-    case ButtonRelease: 
-      break;
-
-    case EnterNotify: 
-      break;
-
-  } /* switch (eventtype) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      free(ButtonStrings[i][k]);
-  if (voisins)
-  {
-    for (i = 0; i < nbmeshpoints; i++) 
-      free(voisins[i]);
-    free(voisins);
-  }
-  if (nbvois) free(nbvois);
-  if (envconv) free(envconv);
-  free(S);
-  free(SD);
-  free(SAVE);
-  return(1);
-}
-
diff -r 8b1af7363833 src/lib/lppm2GA.c
--- a/src/lib/lppm2GA.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lppm2GA.c	Mon Jan 13 15:50:10 2014 +0100
@@ -41,7 +41,7 @@
 #include <mccodimage.h>
 #include <jccodimage.h>
 #include <mcutil.h>
-#include <lderiche.h>
+#include <jclderiche.h>
 #include <lppm2GA.h>
 
 #define SCALE 10
@@ -198,9 +198,9 @@
   b1 = b3 = 2 * e_a;
   b2 = b4 = - e_2a;
 
-  lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im1,
+  derichegen(Imd, rs, cs, buf1, buf2, Im1,
 	     a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4);
-  lderiche_derichegen(Imd, rs, cs, buf1, buf2, Im2,
+  derichegen(Imd, rs, cs, buf1, buf2, Im2,
 	     a5, a6, a7, a8, a1, a2, a3, a4, b1, b2, b3, b4);
   
   for(j = 0; j < cs; j++)
diff -r 8b1af7363833 src/lib/lprofil.c
--- a/src/lib/lprofil.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,228 +0,0 @@
-/* $Id: lprofil.c,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-/* operateur interactif de visualisation de profils 1D */
-/* Michel Couprie - mai 1998 */
-
-#define ZOOM4
-/*
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcutil.h>
-#include <mcxbib.h>
-#include <lbresen.h>
-#include <lprofil.h>
-
-#include <unistd.h>
-
-/* ==================================== */
-void afficheprofil(int32_t *profil, int32_t n, int32_t t)
-/* ==================================== */
-{
-  struct xvimage *im;
-  uint8_t *F;
-  int32_t i, j;
-  char filename[32];
-  
-  im = allocimage(NULL, n, NDG_MAX, 1, VFF_TYP_1_BYTE);
-  if (im == NULL)
-  {   
-    fprintf(stderr, "afficheprofil: allocimage failed\n");
-    exit(0);
-  }
-  F = UCHARDATA(im);
-
-  for (i = 0; i < n; i++)
-  {
-    for (j = 0; j < profil[i]; j++)
-      F[(NDG_MAX - j) * n + i] = NDG_MAX;
-    for (j = profil[i]; j <= NDG_MAX; j++)
-      F[(NDG_MAX - j) * n + i] = NDG_MIN;
-  }
-  sprintf(filename, "_%d.profil", t);
-  writeimage(im, filename);
-  freeimage(im);
-  if (fork() == 0) /* fils - processus xv */
-  {
-    execlp("xv", "xv", filename, NULL);
-    perror("xv");
-  }
-
-} /* afficheprofil() */
-
-/* ==================================== */
-int32_t lprofil(struct xvimage *image)
-/* ==================================== */
-{
-  register int32_t x, y, z;        /* index muet de pixel */
-  int32_t debut, fin, xx, yy, i, k, t;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille plan */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  int32_t *lp;                     /* pour la liste de points du profil */
-  uint8_t *ep;           /* etiquettes des points du profil */
-  int32_t np;                      /* le nb de points effectif */
-#define NBBUTTONS   2
-#define BOXWIDTH  100
-#define BOXHEIGHT  20
-#define NBLIGBUTT   1
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT;
-  int32_t Width = rs;
-  int32_t ImageHeight = cs;
-  int32_t ImageWidth = rs;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lprofil: cette version ne traite pas les images volumiques\n");
-    return 0;
-  }
-
-  lp = (int32_t *)calloc(1,2 * N * sizeof(int32_t));
-  if (lp == NULL)
-  {
-    fprintf(stderr, "lprofil: malloc failed\n");
-    return 0;
-  }
-
-  ep = (uint8_t *)calloc(1,2 * N * sizeof(uint8_t));
-  if (ep == NULL)
-  {
-    fprintf(stderr, "lprofil: malloc failed\n");
-    return 0;
-  }
-
-#ifdef ZOOM4
-  Height += cs;
-  Width += rs;
-  ImageHeight += cs;
-  ImageWidth += rs;
-#endif
-
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], " REDRAW ");
-  strcpy(ButtonStrings[0][1], " QUIT   ");
-
-  debut = fin = -1;
-  t = 0;
-
-ReDraw:
-
-  /* send output to the screen */
-  for (z = 0; z < N; z++)
-  {
-    Color(SOURCE[z]/4);
-#ifdef ZOOM4
-    Point(2*(z%rs), 2*(z/rs));
-    Point(2*(z%rs)+1, 2*(z/rs));
-    Point(2*(z%rs), 2*(z/rs)+1);
-    Point(2*(z%rs)+1, 2*(z/rs)+1);
-#else
-    Point(z%rs, z/rs);
-#endif
-  }
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k*BoxWidth, ImageHeight + i*BoxHeight, k*BoxWidth, ImageHeight + (i+1)*BoxHeight);
-      String(k*BoxWidth + 3, ImageHeight + (i+1)*BoxHeight - 4, ButtonStrings[i][k]);
-    }
-  }
-
-  Color(MC_RED);
-
-ReDisplay:
-
-  FlushGraphics();  
-
-  WaitMouseEvent(&xx, &yy);
-
-  if ((xx >= 0) && (yy >= 0) && (xx < ImageWidth) && (yy < ImageHeight))
-  {
-#ifdef ZOOM4
-    xx /= 2;
-    yy /= 2;
-#endif
-    z = yy * rs + xx;
-    if (debut == -1) 
-    {
-      debut = z; 
-    }
-    else
-    { 
-      fin = z;
-      x = debut % rs;
-      y = debut / rs;
-      xx = fin % rs;
-      yy = fin / rs;
-
-      lbresenlist(rs, x, y, xx, yy, lp, &np);
-
-      /* dessine le profil et remplace les coord. des points par les ndg */
-      for (i = 0; i < np; i++)
-      {
-        z = lp[i];
-#ifdef ZOOM4
-        Point(2*(z%rs), 2*(z/rs));
-        Point(2*(z%rs)+1, 2*(z/rs));
-        Point(2*(z%rs), 2*(z/rs)+1);
-        Point(2*(z%rs)+1, 2*(z/rs)+1);
-#else
-        Point(z%rs, z/rs);
-#endif          
-        lp[i] = SOURCE[z];
-      } /* for (i = 0; i < np; i++) */
-
-      t++;
-      afficheprofil(lp, np, t);
-      debut = -1;
-    }
-  }
-  else /* click hors de l'image */
-  {
-    xx /= BoxWidth;
-    yy -= ImageHeight;
-    yy /= BoxHeight;
-
-    switch(yy)
-    {
-      case 0: switch(xx)
-              {
-                case 0: goto ReDraw;
-                case 1: goto Terminate;
-	      } /* switch(xx) */
-    } /* switch(yy) */
-  }
-goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-  free(lp);
-  free(ep);
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      free(ButtonStrings[i][k]);
-
-  return(1);
-}
-
diff -r 8b1af7363833 src/lib/lrecons._notused_c
--- a/src/lib/lrecons._notused_c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lrecons._notused_c	Mon Jan 13 15:50:10 2014 +0100
@@ -1,4 +1,37 @@
-/* $Id: lrecons.c,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
+/*
+Copyright ESIEE (2009) 
+
+m.couprie@esiee.fr
+
+This software is an image processing library whose purpose is to be
+used primarily for research and teaching.
+
+This software is governed by the CeCILL  license under French law and
+abiding by the rules of distribution of free software. You can  use, 
+modify and/ or redistribute the software under the terms of the CeCILL
+license as circulated by CEA, CNRS and INRIA at the following URL
+"http://www.cecill.info". 
+
+As a counterpart to the access to the source code and  rights to copy,
+modify and redistribute granted by the license, users are provided only
+with a limited warranty  and the software's author,  the holder of the
+economic rights,  and the successive licensors  have only  limited
+liability. 
+
+In this respect, the user's attention is drawn to the risks associated
+with loading,  using,  modifying and/or developing or reproducing the
+software by the user in light of its specific status of free software,
+that may mean  that it is complicated to manipulate,  and  that  also
+therefore means  that it is reserved for developers  and  experienced
+professionals having in-depth computer knowledge. Users are therefore
+encouraged to load and test the software's suitability as regards their
+requirements in conditions enabling the security of their systems and/or 
+data to be ensured and,  more generally, to use and operate it in the 
+same conditions as regards security. 
+
+The fact that you are presently reading this means that you have had
+knowledge of the CeCILL license and that you accept its terms.
+*/
 /* operateur de reconstruction binaire */
 /* 
    entrees : img, une image en niveaux de gris
@@ -100,7 +133,7 @@
     fprintf(stderr, "lrecons: allocimage failed\n");
     return 0;
   }
-  LABELS = ULONGDATA(labels);
+  LABELS = SLONGDATA(labels);
   memset(LABELS, 0, N * sizeof(int32_t));
 
   resfus = allocimage(NULL, rs, cs, d, VFF_TYP_4_BYTE);
@@ -109,7 +142,7 @@
     fprintf(stderr, "lrecons: allocimage failed\n");
     return 0;
   }
-  RESFUS = ULONGDATA(resfus);
+  RESFUS = SLONGDATA(resfus);
 
   for (x = 0; x < N; x++) if (S[x]) S[x] = VAL_SEG;
 
diff -r 8b1af7363833 src/lib/lreconsdilat.c
--- a/src/lib/lreconsdilat.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,152 +0,0 @@
-/* $Id: lreconsdilat.c,v 1.1.1.1 2008-11-25 08:01:42 mcouprie Exp $ */
-/* operateur de reconstruction par dilatation de g sous f */
-/* methode : propagation des changements par fifo */
-/* d'apres la these de Michel Grimaud (pp 22) */
-/* Michel Couprie - juillet 1996 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcfifo.h>
-#include <mcindic.h>
-#include <mcutil.h>
-#include <lreconsdilat.h>
-
-/* ==================================== */
-int32_t lreconsdilat_lreconsdilat(
-        struct xvimage *g,
-        struct xvimage *f,
-        uint8_t *mask) 
-/* reconstruction de g sous f */
-/* g : image marqueur */
-/* f : image masque */
-/* mask : masque du 8-voisinage representant l'element structurant */
-/* resultat dans g */
-/* ==================================== */
-{
-  int32_t nbchang, iter;
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(g);         /* taille ligne */
-  int32_t cs = colsize(g);         /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *G = UCHARDATA(g);      /* l'image marqueur */
-  uint8_t *F = UCHARDATA(f);      /* l'image masque */
-  uint8_t *H;                     /* image de travail */
-  uint8_t *temp;
-  uint8_t sup;
-  Fifo * FIFO[2];
-
-  if ((rowsize(f) != rs) || (colsize(f) != cs))
-  {
-    fprintf(stderr, "lreconsdilat: tailles incompatibles\n");
-    return 0;
-  }
-
-  if (depth(f) != 1) 
-  {
-    fprintf(stderr, "lreconsdilat: cette version ne traite pas les images volumiques\n");
-    return 0;
-  }
-
-  FIFO[0] = CreeFifoVide(N);
-  FIFO[1] = CreeFifoVide(N);
-  if ((FIFO[0] == NULL) || (FIFO[1] == NULL))
-  {   fprintf(stderr,"lreconseros() : CreeFifoVide failed\n");
-      return(0);
-  }
-
-  IndicsInit(N);
-
-  for (x = 0; x < N; x++)      /* mise en fifo initiale de tous les points */    
-  {
-    FifoPush(FIFO[1], x);
-    Set(x, 1);
-  }
-
-  H = (uint8_t *)calloc(1,N*sizeof(char));
-  if (H == NULL)
-  {   fprintf(stderr,"lreconsdilat() : malloc failed for H\n");
-      return(0);
-  }
-
-  iter = 0;
-  do
-  {
-    iter += 1;
-    nbchang = 0;
-    while (! FifoVide(FIFO[iter % 2]))
-    {
-      x = FifoPop(FIFO[iter % 2]);
-      UnSet(x, iter % 2);
-      sup = G[x];
-      for (k = 0; k < 8; k += 1)
-      {
-        if (mask[k])                      /* element structurant */
-	{
-          y = voisin(x, k, rs, N);
-          if ((y != -1) && (G[y] > sup)) sup = G[y];
-        }
-      } /* for k */
-
-      sup = mcmin(sup, F[x]);
-      if (G[x] != sup) /* changement: on enregistre x ainsi que ses voisins */
-      {
-        nbchang += 1;
-        if (! IsSet(x, (iter + 1) % 2))
-        {
-          FifoPush(FIFO[(iter + 1) % 2], x);
-          Set(x, (iter + 1) % 2);
-	}
-        for (k = 0; k < 8; k += 1)
-        {
-          y = voisin(x, k, rs, N);
-          if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
-          {
-            FifoPush(FIFO[(iter + 1) % 2], y);
-            Set(y, (iter + 1) % 2);
-          }
-        } /* for k */
-      }
-      H[x] = sup;
-
-    } /* while ! FifoVide */
-    
-    /* echange les roles de G et H */
-    temp = G;
-    G = H;
-    H = temp;
-
-#ifdef VERBOSE
-    printf("iteration %d, nbchang %d\n", iter, nbchang);
-#endif
-  } while (nbchang != 0);
-
-  /* remet le resultat dans g si necessaire */
-  if (G != UCHARDATA(g))
-  {
-    for (x = 0; x < N; x++)
-      (UCHARDATA(g))[x] = G[x];
-    free(G);
-  }
-  else
-    free(H);
-
-  FifoTermine(FIFO[0]);
-  FifoTermine(FIFO[1]);
-  return 1;
-}
-
-
-
-
-
-
-
-
-
-
-
diff -r 8b1af7363833 src/lib/lreconsdilat3d.c
--- a/src/lib/lreconsdilat3d.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,149 +0,0 @@
-/* $Id: lreconsdilat3d.c,v 1.1.1.1 2008-11-25 08:01:42 mcouprie Exp $ */
-/* obsolete - voir lgeodesic.c */
-/* operateur de reconstruction 3d par dilatation de g sous f */
-/* methode : propagation des changements par fifo */
-/* d'apres la these de Michel Grimaud (pp 22) */
-/* Michel Couprie - novembre 1999 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcfifo.h>
-#include <mcindic.h>
-#include <mcutil.h>
-#include <lreconsdilat3d.h>
-
-/* ==================================== */
-int32_t lreconsdilat3d_lreconsdilat3d(
-        struct xvimage *g,
-        struct xvimage *f,
-        uint8_t *mask) 
-/* reconstruction de g sous f */
-/* g : image marqueur */
-/* f : image masque */
-/* mask : masque du 26-voisinage representant l'element structurant */
-/* resultat dans g */
-/* ==================================== */
-{
-  int32_t nbchang, iter;
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(g);         /* taille ligne */
-  int32_t cs = colsize(g);         /* taille colonne */
-  int32_t d = depth(g);            /* nombre plans */           
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
-  uint8_t *G = UCHARDATA(g);      /* l'image marqueur */
-  uint8_t *F = UCHARDATA(f);      /* l'image masque */
-  uint8_t *H;                     /* image de travail */
-  uint8_t *temp;
-  uint8_t sup;
-  Fifo * FIFO[2];
-
-  if ((rowsize(f) != rs) || (colsize(f) != cs) || (depth(f) != d))
-  {
-    fprintf(stderr, "lreconsdilat3d: tailles incompatibles\n");
-    return 0;
-  }
-
-  FIFO[0] = CreeFifoVide(N);
-  FIFO[1] = CreeFifoVide(N);
-  if ((FIFO[0] == NULL) || (FIFO[1] == NULL))
-  {   fprintf(stderr,"lreconsdilat3d() : CreeFifoVide failed\n");
-      return(0);
-  }
-
-  IndicsInit(N);
-
-  for (x = 0; x < N; x++)      /* mise en fifo initiale de tous les points */    
-  {
-    FifoPush(FIFO[1], x);
-    Set(x, 1);
-  }
-
-  H = (uint8_t *)calloc(1,N*sizeof(char));
-  if (H == NULL)
-  {   fprintf(stderr,"lreconsdilat3d() : malloc failed for H\n");
-      return(0);
-  }
-
-  iter = 0;
-  do
-  {
-    iter += 1;
-    nbchang = 0;
-    while (! FifoVide(FIFO[iter % 2]))
-    {
-      x = FifoPop(FIFO[iter % 2]);
-      UnSet(x, iter % 2);
-      sup = G[x];
-      for (k = 0; k < 26; k += 1)
-      {
-        if (mask[k])                      /* element structurant */
-	{
-          y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (G[y] > sup)) sup = G[y];
-        }
-      } /* for k */
-
-      sup = mcmin(sup, F[x]);
-      if (G[x] != sup) /* changement: on enregistre x ainsi que ses voisins */
-      {
-        nbchang += 1;
-        if (! IsSet(x, (iter + 1) % 2))
-        {
-          FifoPush(FIFO[(iter + 1) % 2], x);
-          Set(x, (iter + 1) % 2);
-	}
-        for (k = 0; k < 26; k += 1)
-        {
-          y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
-          {
-            FifoPush(FIFO[(iter + 1) % 2], y);
-            Set(y, (iter + 1) % 2);
-          }
-        } /* for k */
-      }
-      H[x] = sup;
-
-    } /* while ! FifoVide */
-    
-    /* echange les roles de G et H */
-    temp = G;
-    G = H;
-    H = temp;
-
-#ifdef VERBOSE
-    printf("iteration %d, nbchang %d\n", iter, nbchang);
-#endif
-  } while (nbchang != 0);
-
-  /* remet le resultat dans g si necessaire */
-  if (G != UCHARDATA(g))
-  {
-    for (x = 0; x < N; x++)
-      (UCHARDATA(g))[x] = G[x];
-    free(G);
-  }
-  else
-    free(H);
-
-  FifoTermine(FIFO[0]);
-  FifoTermine(FIFO[1]);
-  return 1;
-}
-
-
-
-
-
-
-
-
-
-
-
diff -r 8b1af7363833 src/lib/lreconseros.c
--- a/src/lib/lreconseros.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,141 +0,0 @@
-/* $Id: lreconseros.c,v 1.1.1.1 2008-11-25 08:01:41 mcouprie Exp $ */
-/* operateur de reconstruction par erosion de g au dessus de f */
-/* methode : propagation des changements par fifo */
-/* d'apres la these de Michel Grimaud (pp 22) */
-/* Michel Couprie - juillet 1996 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcfifo.h>
-#include <mcindic.h>
-#include <mcutil.h>
-#include <lreconseros.h>
-
-/* ==================================== */
-int32_t lreconseros_lreconseros(
-        struct xvimage *g,
-        struct xvimage *f,
-        uint8_t *mask) 
-/* reconstruction par erosion de g au dessus de f */
-/* g : image marqueur */
-/* f : image masque */
-/* mask : masque du 8-voisinage representant l'element structurant */
-/* resultat dans g */
-/* ==================================== */
-{
-  int32_t nbchang, iter;
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(g);         /* taille ligne */
-  int32_t cs = colsize(g);         /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *G = UCHARDATA(g);      /* l'image marqueur (au dessus de f) */
-  uint8_t *F = UCHARDATA(f);      /* l'image masque */
-  uint8_t *H;                     /* image de travail */
-  uint8_t *temp;
-  uint8_t inf;
-  Fifo * FIFO[2];
-
-  if ((rowsize(f) != rs) || (colsize(f) != cs))
-  {
-    fprintf(stderr, "lreconseros: tailles incompatibles\n");
-    return 0;
-  }
-
-  if (depth(f) != 1) 
-  {
-    fprintf(stderr, "lreconsdilat: cette version ne traite pas les images volumiques\n");
-    return 0;
-  }
-
-  H = (uint8_t *)calloc(1,N*sizeof(char));
-  if (H == NULL)
-  {   fprintf(stderr,"lreconseros() : malloc failed for H\n");
-      return(0);
-  }
-
-  FIFO[0] = CreeFifoVide(N);
-  FIFO[1] = CreeFifoVide(N);
-  if ((FIFO[0] == NULL) || (FIFO[1] == NULL))
-  {   fprintf(stderr,"lreconseros() : CreeFifoVide failed\n");
-      return(0);
-  }
-
-  IndicsInit(N);
-
-  for (x = 0; x < N; x++)      /* mise en fifo initiale de tous les points */    
-  {
-    FifoPush(FIFO[1], x);
-    Set(x, 1);
-  }
-
-  iter = 0;
-  do
-  {
-    iter += 1;
-    nbchang = 0;
-    while (! FifoVide(FIFO[iter % 2]))
-    {
-      x = FifoPop(FIFO[iter % 2]);
-      UnSet(x, iter % 2);
-      inf = G[x];
-      for (k = 0; k < 8; k += 1)
-      {
-        if (mask[k])                      /* element structurant */
-	{
-          y = voisin(x, k, rs, N);
-          if ((y != -1) && (G[y] < inf)) inf = G[y];
-	}
-      } /* for k */
-
-      inf = mcmax(inf, F[x]);
-      if (G[x] != inf)           /* le point a change : on l'enregistre ainsi que ses voisins */
-      {
-        nbchang += 1;
-        if (! IsSet(x, (iter + 1) % 2))
-        {
-          FifoPush(FIFO[(iter + 1) % 2], x);
-          Set(x, (iter + 1) % 2);
-	}
-        for (k = 0; k < 8; k += 1)
-        {
-          y = voisin(x, k, rs, N);
-          if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
-          {
-            FifoPush(FIFO[(iter + 1) % 2], y);
-            Set(y, (iter + 1) % 2);
-          }
-        } /* for k */
-      }
-      H[x] = inf;
-
-    } /* while ! FifoVide */
-    
-    /* echange les roles de G et H */
-    temp = G;
-    G = H;
-    H = temp;
-
-#ifdef VERBOSE
-    printf("iteration %d, nbchang %d\n", iter, nbchang);
-#endif
-  } while (nbchang != 0);
-
-  /* remet le resultat dans g si necessaire */
-  if (G != UCHARDATA(g))
-  {
-    for (x = 0; x < N; x++)
-      (UCHARDATA(g))[x] = G[x];
-    free(G);
-  }
-  else
-    free(H);
-
-  FifoTermine(FIFO[0]);
-  FifoTermine(FIFO[1]);
-  return 1;
-}
diff -r 8b1af7363833 src/lib/lreconseros3d.c
--- a/src/lib/lreconseros3d.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,138 +0,0 @@
-/* $Id: lreconseros3d.c,v 1.1.1.1 2008-11-25 08:01:41 mcouprie Exp $ */
-/* obsolete - voir lgeodesic.c */
-/* operateur de reconstruction 3D par erosion de g au dessus de f */
-/* methode : propagation des changements par fifo */
-/* d'apres la these de Michel Grimaud (pp 22) */
-/* Michel Couprie - novembre 1999 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcfifo.h>
-#include <mcindic.h>
-#include <mcutil.h>
-#include <lreconseros3d.h>
-
-/* ==================================== */
-int32_t lreconseros3d_lreconseros3d(
-        struct xvimage *g,
-        struct xvimage *f,
-        uint8_t *mask) 
-/* reconstruction par erosion de g au dessus de f */
-/* g : image marqueur */
-/* f : image masque */
-/* mask : masque du 26-voisinage representant l'element structurant */
-/* resultat dans g */
-/* ==================================== */
-{
-  int32_t nbchang, iter;
-  int32_t x;                       /* index muet de pixel */
-  int32_t y;                       /* index muet (generalement un voisin de x) */
-  int32_t k;                       /* index muet */
-  int32_t rs = rowsize(g);         /* taille ligne */
-  int32_t cs = colsize(g);         /* taille colonne */
-  int32_t d = depth(g);            /* nombre plans */           
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
-  uint8_t *G = UCHARDATA(g);      /* l'image marqueur (au dessus de f) */
-  uint8_t *F = UCHARDATA(f);      /* l'image masque */
-  uint8_t *H;                     /* image de travail */
-  uint8_t *temp;
-  uint8_t inf;
-  Fifo * FIFO[2];
-
-  if ((rowsize(f) != rs) || (colsize(f) != cs) || (depth(f) != d))
-  {
-    fprintf(stderr, "lreconseros3d: tailles incompatibles\n");
-    return 0;
-  }
-
-  H = (uint8_t *)calloc(1,N*sizeof(char));
-  if (H == NULL)
-  {   fprintf(stderr,"lreconseros3d() : malloc failed for H\n");
-      return(0);
-  }
-
-  FIFO[0] = CreeFifoVide(N);
-  FIFO[1] = CreeFifoVide(N);
-  if ((FIFO[0] == NULL) || (FIFO[1] == NULL))
-  {   fprintf(stderr,"lreconseros3d() : CreeFifoVide failed\n");
-      return(0);
-  }
-
-  IndicsInit(N);
-
-  for (x = 0; x < N; x++)      /* mise en fifo initiale de tous les points */    
-  {
-    FifoPush(FIFO[1], x);
-    Set(x, 1);
-  }
-
-  iter = 0;
-  do
-  {
-    iter += 1;
-    nbchang = 0;
-    while (! FifoVide(FIFO[iter % 2]))
-    {
-      x = FifoPop(FIFO[iter % 2]);
-      UnSet(x, iter % 2);
-      inf = G[x];
-      for (k = 0; k < 26; k += 1)
-      {
-        if (mask[k])                      /* element structurant */
-	{
-          y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (G[y] < inf)) inf = G[y];
-	}
-      } /* for k */
-
-      inf = mcmax(inf, F[x]);
-      if (G[x] != inf)           /* le point a change : on l'enregistre ainsi que ses voisins */
-      {
-        nbchang += 1;
-        if (! IsSet(x, (iter + 1) % 2))
-        {
-          FifoPush(FIFO[(iter + 1) % 2], x);
-          Set(x, (iter + 1) % 2);
-	}
-        for (k = 0; k < 26; k += 1)
-        {
-          y = voisin26(x, k, rs, n, N);
-          if ((y != -1) && (! IsSet(y, (iter + 1) % 2)))
-          {
-            FifoPush(FIFO[(iter + 1) % 2], y);
-            Set(y, (iter + 1) % 2);
-          }
-        } /* for k */
-      }
-      H[x] = inf;
-
-    } /* while ! FifoVide */
-    
-    /* echange les roles de G et H */
-    temp = G;
-    G = H;
-    H = temp;
-
-#ifdef VERBOSE
-    printf("iteration %d, nbchang %d\n", iter, nbchang);
-#endif
-  } while (nbchang != 0);
-
-  /* remet le resultat dans g si necessaire */
-  if (G != UCHARDATA(g))
-  {
-    for (x = 0; x < N; x++)
-      (UCHARDATA(g))[x] = G[x];
-    free(G);
-  }
-  else
-    free(H);
-
-  FifoTermine(FIFO[0]);
-  FifoTermine(FIFO[1]);
-  return 1;
-}
diff -r 8b1af7363833 src/lib/lresize.c
--- a/src/lib/lresize.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,48 +0,0 @@
-/* $Id: lresize.c,v 1.1.1.1 2008-11-25 08:01:40 mcouprie Exp $ */
-/* zoom par un facteur rationnel < 1 */
-/* Michel Couprie - decembre 1996 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-
-#include "mccodimage.h"
-#include "mcimage.h"
-#include "mcutil.h"
-#include "lzoom.h"
-
-/* ==================================== */
-int32_t lresize_lzoom(
-  struct xvimage * in,
-  struct xvimage ** out,
-  double z)
-/* ==================================== */
-{
-  int32_t x, y, x1, y1, xn, yn, xx, yy;
-  uint8_t *ptin;
-  uint8_t *ptout;
-  int32_t rs, cs;
-  int32_t rs2, cs2;
-  double k, tmp, d, dx1, dxn, dy1, dyn, sigmad;
-
-  if (depth(in) != 1) 
-  {
-    fprintf(stderr, "lzoom: cette version ne traite pas les images volumiques\n");
-    exit(0);
-  }
-
-  rs = in->row_size;
-  cs = in->col_size;
-  ptin = UCHARDATA(in);
-
-  if ((z >= 1.0) || (z <= 0.0))
-  {   fprintf(stderr,"lzoom() : bad zoom factor : %g - must be < 1\n", z);
-      return 0;
-  }
-
-  rs2 = (int32_t)(rs * z);
-  cs2 = (int32_t)(cs * z);
-  k = 1.0 / z;
-  return 1;
-}
diff -r 8b1af7363833 src/lib/lsalembier._obsolete_c
--- a/src/lib/lsalembier._obsolete_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,4301 +0,0 @@
-/* $Id: lsalembier.c,v 1.1.1.1 2008-11-25 08:01:42 mcouprie Exp $ */
-
-OBSOLETE - voir ldynamique, lattribXXXX
-
-/* 
-   Operateurs utilisant l'arbre des composantes.
-   =============================================
-   (algorithme de P. Salembier)
-
-   Operateurs : 
-      lsegreconsheight (avec reconstruction basee sur la signature de l'attribut contrast)
-      lsegmentheight (sans reconstruction)
-      lsegmentarea
-      lsegmentvol
-
-      lareaopening
-      lareaclosing
-
-      lheightmaxima
-      lvolmaxima
-
-      lheightselnb   (selection d'un nombre donne de composantes)
-      lareaselnb   (selection d'un nombre donne de composantes)
-      lvolselnb   (selection d'un nombre donne de composantes)
-
-   Michel Couprie - octobre 1999
-
-   Decembre 2000 : l*selnb, lvolmaxima, lsegmentvol, legmentheight, lsegmentarea  
-                   versions 3d (sauf lsegreconsheight)
-
-   Juin 2001 : lheightselnb : ajout des options "min" et "max" 
-               (recherche la valeur min ou max telle que le critere est satisfait)
-
-   Decembre 2001 : ldynamique (d'apres Grimaud et L. Najman)
-   Fevrier 2002 : lwshedtopo (d'apres MC, GB)
-   Fevrier-juin 2002 : lwshedval (d'apres LN, MC, GB)
-   Mai 2002 : nouvelles versions de l*selnb
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <math.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mclifo.h>
-#include <mcfahsalembier.h>
-#include <mcutil.h>
-#include <mcindic.h>
-#include <lsalembier.h>
-
-#define PARANO
-/*
-#define VERBOSE
-#define DEBUG
-#define DEBUGRECONS
-#define DEBUGFLOOD
-*/
-
-/*         CES FLAGS SONT POSITIONNES PAR LE MAKEFILE: 
-#define ATTR_SURF
-#define ATTR_HEIGHT
-#define ATTR_PERIM
-#define ATTR_HBORD
-#define ATTR_CONTRAST
-#define ATTR_VOL
-#define ATTR_DYN
-#define RECONS
-*/
-
-#define CONDITION_VIOLATION 0x01
-
-#define FILTERED_OUT 0x01
-#define LEAFMIN      0x02
-#define LEAFMAX      0x04
-#define LEAF         (LEAFMIN|LEAFMAX)
-#define LCA1         0x08
-#define LCA2         0x10
-#define LCA          (LCA1|LCA2)
-
-#define NOT_ANALYZED 2000000000
-#define IN_THE_QUEUE 2000000001
-
-/*
-   principe de l'encodage des composantes: 
-   le niveau est code dans les bits 24 a 31
-   il reste donc 24 bits pour coder le numero de la composante, 
-         24
-   soit 2   = 16 megacomposantes par niveau.
-*/
-
-#define ENCODE(y,h) (y|(h<<24))
-#define DECODENUM(y) (y&0x00ffffff)
-#define DECODENIV(y) (y>>24)
-
-/* 
-   macros pour l'acces aux donnees de la structure CompactTree
-*/
-
-#define NBCOMP(h) ((h==0)?(cpct->hc[0]):(cpct->hc[h]-cpct->hc[h-1]))
-#define INDEXCOMP(h,j) ((h==0)?(j):(cpct->hc[h-1]+j))
-#define NBFILS(c) ((c==0)?(cpct->dfils[0]):(cpct->dfils[c]-cpct->dfils[c-1]))
-#define INDEXFILS(c,j) ((c==0)?(j):(cpct->dfils[c-1]+j))
-
-/* ============================================================================== */
-/* 
-  Structure de donnees pour la construction de l'arbre des composantes.
-
-  Les sommets de cet arbre sont les composantes des coupes >=, 
-  a l'exception de celles qui sont egales a une composante d'un niveau inferieur.
-  Il y a donc moins de N sommets (N = nombre de pixels) et de N-1 arcs.
-
-  Une composante (sommet) est representee par deux donnees : 
-  son niveau (sur 8 bits) et son numero dans le niveau (sur 24 bits), 
-  le tout encode dans un entier 32 bits.
-
-  L'arbre est represente par
-  une liste d'arcs (tableaux tete et queue), fleches de la racine vers les feuilles.
-*/
-/* ============================================================================== */
-typedef struct {
-  uint32_t nbmaxarcs;          /* nombre maximum d'arcs */
-  uint32_t nbarcs;             /* nombre effectif d'arcs */
-  uint32_t racine;             /* racine de l'arbre */
-  uint32_t *tete;              /* sommets initiaux des arcs de l'arbre */
-  uint32_t *queue;             /* sommets terminaux des arcs de l'arbre */  
-#ifdef ATTR_SURF
-  int32_t surf_racine;                 /* attribut surface pour la racine */
-  int32_t *surf;                       /* attributs des sommets terminaux des arcs */
-#endif
-#ifdef ATTR_PERIM
-  int32_t *perim;
-#endif 
-#ifdef ATTR_HBORD
-  int32_t *hbord;
-#endif
-#ifdef ATTR_VOL
-  int32_t *vol;
-#endif
-} CompTree;
-/* ============================================================================== */
-
-/* ============================================================================== */
-/* 
-  Structure de donnees compacte pour l'arbre des composantes.
-
-  L'arbre est represente par cinq tableaux:
-  - le tableau 'hc' qui au niveau de gris h, associe le nombre de composantes de 
-    niveau <= h (histogramme cumule). On a donc:
-      nombre de composantes de niveau 0 = hc[0]
-      nombre de composantes de niveau h > 0 = hc[h] - hc[h-1]
-      index derniere composante de niveau h s'il en existe = hc[h] - 1
-  - le tableau 'comp' qui, a l'index i d'une composante, associe le code de la 
-    composante (represente dans 32 bits comme dans la structure CompTree)
-  - le tableau 'pere' qui, a l'index i d'une composante, associe l'index du pere de i
-    (sauf pour la racine qui a pour index 0 et a laquelle est associee 0)
-  - le tableau 'dfils' qui, a l'index i d'une composante, associe l'index(+1) 
-    du dernier fils de i (sauf pour les feuilles)
-  - le tableau 'fils' qui contient les listes de fils
-*/
-/* ============================================================================== */
-#define CPCT_ROOT 0
-typedef struct {
-  uint32_t nbcomp;  /* nombre de composantes */
-  uint32_t *comp;   /* tableau des composantes */
-  uint32_t *pere;   /* tableau representant la relation 'pere' */  
-  uint32_t *dfils;  /* tableau donnant l'index+1 du dernier fils dans le tableau 'fils' */
-  uint32_t *fils;   /* tableau representant, avec le precedent, la relation 'fils' */  
-  uint32_t *hc;     /* histogramme cumule des composantes */
-#ifdef ATTR_SURF
-  int32_t *surf;
-#endif
-#ifdef ATTR_HEIGHT
-  int32_t *height;
-#endif
-#ifdef ATTR_PERIM
-  int32_t *perim; 
-#endif
-#ifdef ATTR_HBORD
-  int32_t *hbord;
-#endif
-#ifdef ATTR_CONTRAST
-  double *contrast;           /* attribut flottant */
-#endif
-#ifdef ATTR_VOL
-  int32_t *vol;
-#endif
-#ifdef ATTR_DYN
-  int32_t *dyn;
-#endif
-  char *flags;          /* 8 booleens pour des usages divers */
-} CompactTree;
-/* ============================================================================== */
-
-
-/* ======================================================================== */
-/* ======================================================================== */
-/* FONCTIONS POUR LE TRI */
-/* ======================================================================== */
-/* ======================================================================== */
-
-// cle DOUBLE
-
-/* =============================================================== */
-static int32_t d_Partitionner(int32_t *A, double *T, int32_t p, int32_t r)
-/* =============================================================== */
-/*
-  partitionne les elements de A entre l'indice p (compris) et l'indice r (compris)
-  en deux groupes : les elements q tq T[A[q]] <= T[A[p]] et les autres.
-*/
-{
-  int32_t t;
-  double x = T[A[p]];
-  int32_t i = p - 1;
-  int32_t j = r + 1;
-  while (1)
-  {
-    do j--; while (T[A[j]] > x);
-    do i++; while (T[A[i]] < x);
-    if (i < j) { t = A[i]; A[i] = A[j]; A[j] = t; }
-    else return j;
-  } /* while (1) */   
-} /* d_Partitionner() */
-
-/* =============================================================== */
-static int32_t d_PartitionStochastique(int32_t *A, double *T, int32_t p, int32_t r)
-/* =============================================================== */
-/*
-  partitionne les elements de A entre l'indice p (compris) et l'indice r (compris)
-  en deux groupes : les elements k tels que T[A[k]] <= T[A[q]] et les autres, 
-  avec q tire au hasard dans [p,r].
-*/
-{
-  int32_t t, q;
-
-  q = p + (rand() % (r - p + 1));
-  t = A[p];         /* echange A[p] et A[q] */
-  A[p] = A[q]; 
-  A[q] = t;
-  return d_Partitionner(A, T, p, r);
-} /* d_PartitionStochastique() */
-
-/* =============================================================== */
-static void d_TriRapideStochastique (int32_t * A, double *T, int32_t p, int32_t r)
-/* =============================================================== */
-/* 
-  trie les valeurs du tableau A de l'indice p (compris) a l'indice r (compris) 
-  par ordre croissant 
-*/
-{
-  int32_t q; 
-  if (p < r)
-  {
-    q = d_PartitionStochastique(A, T, p, r);
-    d_TriRapideStochastique (A, T, p, q) ;
-    d_TriRapideStochastique (A, T, q+1, r) ;
-  }
-} /* d_TriRapideStochastique() */
-
-// cle INT
-
-/* =============================================================== */
-static int32_t i_Partitionner(int32_t *A, int32_t *T, int32_t p, int32_t r)
-/* =============================================================== */
-/*
-  partitionne les elements de A entre l'indice p (compris) et l'indice r (compris)
-  en deux groupes : les elements q tq T[A[q]] <= T[A[p]] et les autres.
-*/
-{
-  int32_t t;
-  int32_t x = T[A[p]];
-  int32_t i = p - 1;
-  int32_t j = r + 1;
-  while (1)
-  {
-    do j--; while (T[A[j]] > x);
-    do i++; while (T[A[i]] < x);
-    if (i < j) { t = A[i]; A[i] = A[j]; A[j] = t; }
-    else return j;
-  } /* while (1) */   
-} /* i_Partitionner() */
-
-/* =============================================================== */
-static int32_t i_PartitionStochastique(int32_t *A, int32_t *T, int32_t p, int32_t r)
-/* =============================================================== */
-/*
-  partitionne les elements de A entre l'indice p (compris) et l'indice r (compris)
-  en deux groupes : les elements k tels que T[A[k]] <= T[A[q]] et les autres, 
-  avec q tire au hasard dans [p,r].
-*/
-{
-  int32_t t, q;
-
-  q = p + (rand() % (r - p + 1));
-  t = A[p];         /* echange A[p] et A[q] */
-  A[p] = A[q]; 
-  A[q] = t;
-  return i_Partitionner(A, T, p, r);
-} /* i_PartitionStochastique() */
-
-/* =============================================================== */
-static void i_TriRapideStochastique (int32_t * A, int32_t *T, int32_t p, int32_t r)
-/* =============================================================== */
-/* 
-  trie les valeurs du tableau A de l'indice p (compris) a l'indice r (compris) 
-  par ordre croissant 
-*/
-{
-  int32_t q; 
-  if (p < r)
-  {
-    q = i_PartitionStochastique(A, T, p, r);
-    i_TriRapideStochastique (A, T, p, q) ;
-    i_TriRapideStochastique (A, T, q+1, r) ;
-  }
-} /* i_TriRapideStochastique() */
-
-/* ======================================================================== */
-/* ======================================================================== */
-/* CONSTRUCTION ET GESTION DE L'ARBRE DES COMPOSANTES */
-/* ======================================================================== */
-/* ======================================================================== */
-
-/* ==================================== */
-CompTree * InitCompTree(int32_t nbmaxarcs)
-/* ==================================== */
-{
-  CompTree *ct;
-  ct = (CompTree *)calloc(1,sizeof(CompTree));
-  if (ct == NULL) return NULL;
-  ct->tete = (uint32_t *)calloc(1,nbmaxarcs * sizeof(int32_t));
-  if (ct->tete == NULL) return NULL;
-  ct->queue = (uint32_t *)calloc(1,nbmaxarcs * sizeof(int32_t));
-  if (ct->queue == NULL) return NULL;
-#ifdef ATTR_SURF
-  ct->surf = (int32_t *)calloc(1,nbmaxarcs * sizeof(int32_t));
-  if (ct->surf == NULL) return NULL;
-#endif
-#ifdef ATTR_PERIM
-  ct->perim = (int32_t *)calloc(1,nbmaxarcs * sizeof(int32_t));
-  if (ct->perim == NULL) return NULL;
-#endif
-#ifdef ATTR_HBORD
-  ct->hbord = (int32_t *)calloc(1,nbmaxarcs * sizeof(int32_t));
-  if (ct->hbord == NULL) return NULL;
-#endif
-#ifdef ATTR_VOL
-  ct->vol = (int32_t *)calloc(1,nbmaxarcs * sizeof(int32_t));
-  if (ct->vol == NULL) return NULL;
-#endif
-  ct->nbmaxarcs = nbmaxarcs;
-  ct->nbarcs = 0;
-  ct->racine = CPCT_ROOT;
-  return ct;
-} /* InitCompTree() */
-
-/* ==================================== */
-void TermineCompTree(CompTree *ct)
-/* ==================================== */
-{
-  free(ct->tete);
-  free(ct->queue);
-#ifdef ATTR_SURF
-  free(ct->surf);
-#endif
-#ifdef ATTR_PERIM
-  free(ct->perim);
-#endif
-#ifdef ATTR_HBORD
-  free(ct->hbord);
-#endif
-#ifdef ATTR_VOL
-  free(ct->vol);
-#endif
-  free(ct);
-} /* TermineCompTree() */
-
-/* ==================================== */
-CompactTree * CompTree2CompactTree(CompTree *ct, uint32_t *number_nodes)
-/* ==================================== */
-/* ATTENTION EFFET DE BORD : DETRUIT LA RELATION number_nodes */
-{
-  CompactTree *cpct;
-  uint32_t i, n, h, t, th, tn, q, qh, qn;
-  uint32_t nbcomp = ct->nbarcs + 1;
-  uint32_t *nfils;
-
-  cpct = (CompactTree *)calloc(1,sizeof(CompactTree));
-  if (cpct == NULL) return NULL;
-  cpct->nbcomp = nbcomp;
-  cpct->comp = (uint32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (cpct->comp == NULL) return NULL;
-  cpct->pere = (uint32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (cpct->pere == NULL) return NULL;
-  cpct->dfils = (uint32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (cpct->dfils == NULL) return NULL;
-  cpct->fils = (uint32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (cpct->fils == NULL) return NULL;
-  cpct->hc = (uint32_t *)calloc(1,256 * sizeof(int32_t));
-  if (cpct->hc == NULL) return NULL;
-#ifdef ATTR_SURF
-  cpct->surf = (int32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (cpct->surf == NULL) return NULL;
-#endif
-#ifdef ATTR_HEIGHT
-  cpct->height = (int32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (cpct->height == NULL) return NULL;
-#endif
-#ifdef ATTR_PERIM
-  cpct->perim = (int32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (cpct->perim == NULL) return NULL;
-#endif
-#ifdef ATTR_HBORD
-  cpct->hbord = (int32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (cpct->hbord == NULL) return NULL;
-#endif
-#ifdef ATTR_CONTRAST
-  cpct->contrast = (double *)calloc(1,nbcomp * sizeof(double));
-  if (cpct->contrast == NULL) return NULL;
-#endif
-#ifdef ATTR_VOL
-  cpct->vol = (int32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (cpct->vol == NULL) return NULL;
-#endif
-#ifdef ATTR_DYN
-  cpct->dyn = (int32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (cpct->dyn == NULL) return NULL;
-#endif
-  cpct->flags = (char *)calloc(nbcomp, sizeof(char));
-  if (cpct->flags == NULL) return NULL;
-
-  /* calcule l'histogramme cumule hc */
-  n = cpct->hc[0] = number_nodes[0]; 
-  for (i = 1; i < 256; i++) { n += number_nodes[i]; cpct->hc[i] = n; }
-
-  /* construit le tableau des composantes comp */
-  n = 0; h = 0; while (!number_nodes[h]) h++; /* ATTENTION CODE FRAGILE */
-  for (i = 0; i < nbcomp; i++)                /* SUPPOSE CORRECTES LES DONNEES D'ENTREE */
-  {                                           /* PAS DE VERIFICATION */
-    cpct->comp[i] = ENCODE(n,h); 
-    number_nodes[h]--; n++;
-    if (!number_nodes[h]) { n = 0; while (!number_nodes[h]) h++; }
-  } /* for i */
-  
-  /* construit la relation pere */
-  for (i = 0; i < nbcomp-1; i++)
-  {
-    t = ct->tete[i]; q = ct->queue[i];
-    th = DECODENIV(t); tn = DECODENUM(t);
-    qh = DECODENIV(q); qn = DECODENUM(q);
-    cpct->pere[INDEXCOMP(qh,qn)] = INDEXCOMP(th,tn);
-  }
-  q = ct->racine; qh = DECODENIV(q); qn = DECODENUM(q);
-  cpct->pere[INDEXCOMP(qh,qn)] = INDEXCOMP(qh,qn);
-
-  /* construit la relation dfils et fils */
-  nfils = (uint32_t *)calloc(nbcomp, sizeof(int32_t));
-  if (nfils == NULL) return NULL;
-  for (i = 1; i < nbcomp; i++) nfils[cpct->pere[i]] += 1;
-    /* exception : la racine (0) est fille d'elle-meme, cette relation n'est pas comptee */ 
-  cpct->dfils[CPCT_ROOT] = nfils[CPCT_ROOT];
-  for (i = 1; i < nbcomp; i++) cpct->dfils[i] = cpct->dfils[i - 1] + nfils[i];
-  for (i = 1; i < nbcomp; i++)
-  {
-    t = cpct->pere[i]; /* i est fils de t */
-    nfils[t] -= 1;
-    cpct->fils[INDEXFILS(t,nfils[t])] = i;
-  }
-  free(nfils);
-
-  /* transfere les attributs (cas particulier pour la racine) */
-  for (i = 0; i < nbcomp-1; i++)
-  {
-    q = ct->queue[i]; qh = DECODENIV(q); qn = DECODENUM(q);
-#ifdef ATTR_SURF
-    cpct->surf[INDEXCOMP(qh,qn)] = ct->surf[i];
-#endif
-#ifdef ATTR_PERIM
-    cpct->perim[INDEXCOMP(qh,qn)] = ct->perim[i];
-#endif
-#ifdef ATTR_HBORD
-    cpct->hbord[INDEXCOMP(qh,qn)] = ct->hbord[i];
-#endif
-#ifdef ATTR_VOL
-    cpct->vol[INDEXCOMP(qh,qn)] = ct->vol[i];
-#endif
-  }
-#ifdef ATTR_SURF
-  cpct->surf[CPCT_ROOT] = ct->surf_racine;
-#endif
-#ifdef ATTR_PERIM
-  cpct->perim[CPCT_ROOT] = 0;
-#endif
-#ifdef ATTR_HBORD
-  cpct->hbord[CPCT_ROOT] = 0;
-#endif
-#ifdef ATTR_VOL
-  cpct->vol[CPCT_ROOT] = 0;
-#endif  
-  return cpct;
-} /* CompTree2CompactTree() */
-
-/* ==================================== */
-void ReInitFlags(CompactTree * cpct)
-/* ==================================== */
-{
-  uint32_t nbcomp = cpct->nbcomp;
-  memset(cpct->flags,0,nbcomp);
-} /* ReInitFlags() */
-
-#ifdef ATTR_SURF
-/* ==================================== */
-int32_t surfrec(CompactTree * cpct, uint32_t som, int32_t *na1)
-/* ==================================== */
-/*
-   Calcule la surface de chacune des composantes, a partir de 
-   l'information stockee dans cpct->surf[i], qui correspond a la 
-   difference de surface entre la composante i et ses filles.
-   Le resultat est provisoirement stocke dans le tableau na1 (indexe par
-   le numero de composante i), pour etre ensuite recopie dans cpct->surf[i].
-*/ 
-{
-  int32_t i, n, j;
-  n = NBFILS(som);
-  if (n == 0) return na1[som] = cpct->surf[som];
-  na1[som] = cpct->surf[som];
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    na1[som] += surfrec(cpct, j, na1);
-  }
-  return na1[som];
-} /* surfrec() */
-#endif
-
-#ifdef ATTR_VOL
-/* ==================================== */
-int32_t volrec(CompactTree * cpct, uint32_t som, int32_t *na1)
-/* ==================================== */
-/*
-   Attention: pour utiliser cette fonction, il faut avoir 
-   prealablement calcule la surface des composantes (cf. surfrec())
-   et avoir stocke cette information dans cpct->surf[].
-
-   Calcule le volume de chacune des composantes, a partir de 
-   l'information stockee dans cpct->surf[i], qui correspond a la 
-   surface de la composante.
-   Le resultat est provisoirement stocke dans le tableau na1 (indexe par
-   le numero de composante i), pour etre ensuite recopie dans cpct->vol[i].
-*/ 
-{
-  int32_t i, n, j;
-  n = NBFILS(som);
-  if (n == 0) return na1[som] = cpct->surf[som];
-  na1[som] = cpct->surf[som];
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    na1[som] += volrec(cpct, j, na1);
-  }
-  return na1[som];
-} /* volrec() */
-#endif
-
-#ifdef ATTR_HEIGHT
-/* ==================================== */
-int32_t heightrec(CompactTree * cpct, uint32_t som, int32_t *na1)
-/* ==================================== */
-/* retourne le niveau max des descendants de som (ou le niveau de som pour une feuille) */ 
-{
-  int32_t i, n, j, h;
-  n = NBFILS(som);
-  if (n == 0) return na1[som] = DECODENIV(cpct->comp[som]);
-  na1[som] = 0;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    h = heightrec(cpct, j, na1);
-    na1[som] = max(na1[som], h);
-  }
-  return na1[som];
-} /* heightrec() */
-#endif
-
-#ifdef ATTR_PERIM
-/* ==================================== */
-int32_t perimrec(CompactTree * cpct, uint32_t som, int32_t *nperim)
-/* ==================================== */
-{
-  int32_t i, n, j;
-  n = NBFILS(som);
-  if (n == 0) return nperim[som] = cpct->perim[som];
-  nperim[som] = cpct->perim[som];
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    nperim[som] += perimrec(cpct, j, nperim);
-  }
-  return nperim[som];
-} /* perimrec() */
-#endif
-
-#ifdef ATTR_HBORD
-/* ==================================== */
-int32_t hbordrec(CompactTree * cpct, uint32_t som, int32_t *nhbord)
-/* ==================================== */
-{
-  int32_t i, n, j;
-  n = NBFILS(som);
-  if (n == 0) return nhbord[som] = cpct->hbord[som];
-  nhbord[som] = cpct->hbord[som];
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    nhbord[som] += hbordrec(cpct, j, nhbord);
-  }
-  return nhbord[som];
-} /* hbordrec() */
-#endif
-
-/* ==================================== */
-void CalculeAttributs(CompactTree * cpct)
-/* ==================================== */
-{
-  int32_t *na1, *na2, i;
-  uint32_t nbcomp = cpct->nbcomp;
-
-  na1 = (int32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  na2 = (int32_t *)calloc(1,nbcomp * sizeof(int32_t));
-#ifdef ATTR_SURF
-  (void)surfrec(cpct, 0, na1);
-  for (i = 0; i < nbcomp; i++) cpct->surf[i] = na1[i];
-#endif
-#ifdef ATTR_VOL
-  if (cpct->surf == NULL)
-  {
-    fprintf(stderr, "CalculeAttributs: VOL ne peut etre calcule dans SURF\n");
-    exit(0);
-  }
-  (void)volrec(cpct, 0, na1);
-  for (i = 0; i < nbcomp; i++) cpct->vol[i] = na1[i];
-#endif
-#ifdef ATTR_HEIGHT
-
-  (void)heightrec(cpct, 0, na1);
-  /* pour la mesure de la hauteur, il faut rajouter la difference de niveau avec le pere */
-  for (i = 1; i < nbcomp; i++) cpct->height[i] = na1[i] 
-	     /* - DECODENIV(cpct->comp[i]) + DECODENIV(cpct->comp[i]) */ /* inutile */
-                                               - DECODENIV(cpct->comp[cpct->pere[i]]) - 1;
-
-  cpct->height[0] = NDG_MAX - NDG_MIN;
-#endif
-#ifdef ATTR_PERIM
-  (void)perimrec(cpct, 0, na1);
-  for (i = 0; i < nbcomp; i++) cpct->perim[i] = na1[i]; 
-#endif
-#ifdef ATTR_HBORD
-  (void)hbordrec(cpct, 0, na2);
-  for (i = 0; i < nbcomp; i++) cpct->hbord[i] = na2[i];  
-#endif
-#ifdef ATTR_CONTRAST
-  for (i = 0; i < nbcomp; i++) cpct->contrast[i] = ((double)(na2[i]))/na1[i];  
-#endif
-  free(na1);
-  free(na2);
-} /* CalculeAttributs() */
-
-#ifdef ATTR_HEIGHT
-/* ==================================== */
-int32_t FiltreHeightRec(CompactTree * cpct, int32_t som, int32_t h)
-/* ==================================== */
-/*
-  Filtre les sommets de l'arbre selon un critere de hauteur : 
-
-     height(som) >= h
-
-  Un sommet 'som' ne satisfaisant pas le critere est marque FILTERED_OUT.
-  La fonction traite recursivement les fils, et retourne le nombre NNM de sommets non marques dans
-    la descendance (inclus le sommet lui-meme).
-  Un sommet non filtre et dont le NNM de la descendance vaut 0 est marque LEAFMIN. 
-*/
-{
-  int32_t i, n, j, NNM = 0;
-  n = NBFILS(som);
-  if (cpct->height[som] < h) cpct->flags[som] |= FILTERED_OUT;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    NNM += FiltreHeightRec(cpct, j, h);
-  }
-  if (cpct->height[som] >= h)           /* sommet non filtre */
-  {
-    if (NNM == 0) cpct->flags[som] |= LEAFMIN;
-    NNM++;
-  }
-  return NNM;
-} /* FiltreHeightRec() */
-#endif
-
-#ifdef ATTR_SURF
-/* ==================================== */
-int32_t FiltreSurfRec(CompactTree * cpct, int32_t som, int32_t h)
-/* ==================================== */
-/*
-  Filtre les sommets de l'arbre selon un critere de surface : 
-
-     surf(som) >= h
-
-  Un sommet 'som' ne satisfaisant pas le critere est marque FILTERED_OUT.
-  La fonction traite recursivement les fils, et retourne le nombre NNM de sommets non marques dans
-    la descendance (inclus le sommet lui-meme).
-  Un sommet non filtre et dont le NNM de la descendance vaut 0 est marque LEAFMIN. 
-*/
-{
-  int32_t i, n, j, NNM = 0;
-  n = NBFILS(som);
-  if (cpct->surf[som] < h) cpct->flags[som] |= FILTERED_OUT;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    NNM += FiltreSurfRec(cpct, j, h);
-  }
-  if (cpct->surf[som] >= h)           /* sommet non filtre */
-  {
-    if (NNM == 0) cpct->flags[som] |= LEAFMIN;
-    NNM++;
-  }
-  return NNM;
-} /* FiltreSurfRec() */
-#endif
-
-#ifdef ATTR_VOL
-/* ==================================== */
-int32_t FiltreVolRec(CompactTree * cpct, int32_t som, int32_t h)
-/* ==================================== */
-/*
-  Filtre les sommets de l'arbre selon un critere de volume : 
-
-     vol(som) >= h
-
-  Un sommet 'som' ne satisfaisant pas le critere est marque FILTERED_OUT.
-  La fonction traite recursivement les fils, et retourne le nombre NNM de sommets non marques dans
-    la descendance (inclus le sommet lui-meme).
-  Un sommet non filtre et dont le NNM de la descendance vaut 0 est marque LEAFMIN. 
-*/
-{
-  int32_t i, n, j, NNM = 0;
-  n = NBFILS(som);
-  if (cpct->vol[som] < h) cpct->flags[som] |= FILTERED_OUT;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    NNM += FiltreVolRec(cpct, j, h);
-  }
-  if (cpct->vol[som] >= h)           /* sommet non filtre */
-  {
-    if (NNM == 0) cpct->flags[som] |= LEAFMIN;
-    NNM++;
-  }
-  return NNM;
-} /* FiltreVolRec() */
-#endif
-
-/* ==================================== */
-int32_t MaximiseSegmentation(CompactTree * cpct, int32_t som)
-/* ==================================== */
-/*
-  
-*/
-{
-  int32_t i, n, j, f, nf, NF = 0;
-  if (cpct->flags[som] & FILTERED_OUT) return 0;
-  n = NBFILS(som);
-  if (n == 0) return 1;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    if (nf = MaximiseSegmentation(cpct, j)) { f = j; NF += nf; }
-  }
-  if (NF == 0) return 1;
-  if (NF == 1)
-  {
-    cpct->flags[f] |= FILTERED_OUT;
-    cpct->flags[som] |= LEAFMAX;
-    return 1;
-  }
-  return 1 + NF;
-} /*  MaximiseSegmentation() */
-
-#ifdef ATTR_CONTRAST
-/* ==================================== */
-void Reconstruction(CompactTree * cpct, int32_t som)
-/* ==================================== */
-/*
-  Recherche a partir de la racine, les sommets marques LEAF.
-  A partir de chacun de ces sommets :
-    - remonte en suivant les etiquettes LEAFMAX jusqu'a trouver un sommet marque LEAFMIN,
-    - stocke dans 'branche' le chemin (liste de sommets), dans 'contrast' l'attribut contrast associe a chaque sommet,
-      et dans 'index' les index des sommets (initialises a 0,1,2,3,...)
-    - trie le tableau index sur la cle contraste,
-    - selectionne un sommet M maximum (si plusieurs, ...),
-    - a partir de M, on "redescend" en demarquant les sommets
-*/
-{
-  int32_t i, n, m, j, k, M;
-  double contrast[256];
-  int32_t branche[256];
-  int32_t index[256];
-
-  if (!(cpct->flags[som] & LEAF)) /* remonte l'arbre pour trouver une LEAF */ 
-  {
-    n = NBFILS(som);
-    for (i = 0; i < n; i++) 
-    {
-      j = INDEXFILS(som, i);
-      j = cpct->fils[j];
-      Reconstruction(cpct, j);
-    }
-  }
-  else /* on a trouve une LEAF */
-  {
-    m = 0;  /* m indexe le tableau contrast */
-    k = som;
-    while (!(cpct->flags[k] & LEAFMIN))
-    {
-      contrast[m] = cpct->contrast[k];
-      branche[m] = k;
-      m++;
-      n = NBFILS(k); /* on va chercher le fils qui est marque LEAF */
-      for (i = 0; i < n; i++) 
-      {
-        j = INDEXFILS(k, i);
-        j = cpct->fils[j];
-        if (cpct->flags[j] & LEAF) break;
-      }
-      k = j;
-#ifdef PARANO
-      if (i >= n) fprintf(stderr, "Reconstruction : ERREUR INATTENDUE\n");
-#endif
-    }
-    contrast[m] = cpct->contrast[k];
-    branche[m] = k;
-    m++;    
-
-#ifdef DEBUGRECONS
-    printf("Reconstruction Sommet %d\n", som);
-    for (i = 0; i < m; i++) printf("%d %d %g\n", i, branche[i], contrast[i]);
-#endif
-
-    /* trie le tableau index sur la cle contraste */
-    for (i = 0; i < m; i++) index[i] = i;
-    d_TriRapideStochastique (index, contrast, 0, m-1);
-
-#ifdef DEBUGRECONS
-    printf("Apres tri : \n");
-    for (i = 0; i < m; i++) printf("%d %d %g\n", index[i], branche[index[i]], contrast[index[i]]);
-#endif
-
-    /* selectionne un sommet M maximum (SI PLUSIEURS, ... CHOIX ARBITRAIRE), */
-    M = branche[index[m-1]];
-
-    /* a partir de M, on "redescend" en demarquant les sommets */
-    cpct->flags[M] &= ~FILTERED_OUT;
-    cpct->flags[M] |= LEAFMAX;
-    k = cpct->pere[M];
-    while (cpct->flags[k] & LEAFMAX)
-    {
-      cpct->flags[k] &= ~LEAFMAX;
-      cpct->flags[k] &= ~FILTERED_OUT;
-      k = cpct->pere[k];
-    }
-  } /* else (on a trouve une LEAF) */
-} /*  Reconstruction() */
-#endif
-
-/* ==================================== */
-int32_t NbLeafs(CompactTree * cpct, int32_t som)
-/* ==================================== */
-/*
-  Recherche a partir du sommet som, les sommets marques LEAF.
-  Retourne le nombre de ces sommets.
-*/
-{
-  int32_t i, j, k, n;
-
-  if (!(cpct->flags[som] & LEAF)) /* remonte l'arbre pour trouver une LEAF */ 
-  {
-    n = NBFILS(som);
-    k = 0; 
-    for (i = 0; i < n; i++) 
-    {
-      j = INDEXFILS(som, i);
-      j = cpct->fils[j];
-      k += NbLeafs(cpct, j);
-    }
-    return k;
-  }
-  else /* (on a trouve une LEAF) */
-    return 1;
-} /* NbLeafs() */
-
-/* ==================================== */
-void RecupereImageFiltree(CompactTree * cpct,           
-       uint32_t *STATUS,
-       int32_t rs, int32_t N, 
-       uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t i, h;
-  uint32_t c, comp;
-  for (i = 0; i < N; i++) 
-  {
-    h = ORI[i];
-    c = STATUS[i];
-    comp = INDEXCOMP(h,c);
-    while (cpct->flags[comp] == FILTERED_OUT) comp = cpct->pere[comp];
-    ORI[i] = DECODENIV(cpct->comp[comp]);
-  }  
-} /* RecupereImageFiltree() */
-
-/* ==================================== */
-void RecupereSegmentation(CompactTree * cpct,           
-       uint32_t *STATUS,
-       int32_t rs, int32_t N, 
-       uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t i, h;
-  uint32_t c, comp;
-  for (i = 0; i < N; i++) 
-  {
-    h = ORI[i];
-    c = STATUS[i];
-    comp = INDEXCOMP(h,c);
-    while (cpct->flags[comp] & FILTERED_OUT) 
-    {
-#ifdef PARANO
-      if (comp == cpct->pere[comp])       
-        fprintf(stderr, "RecupereSegmentation: la racine a ete eliminee\n");
-#endif
-      comp = cpct->pere[comp];
-    }
-    if (cpct->flags[comp] & LEAF) ORI[i] = NDG_MAX; else ORI[i] = NDG_MIN;
-  }  
-} /* RecupereSegmentation() */
-
-/* ==================================== */
-void TermineCompactTree(CompactTree *cpct)
-/* ==================================== */
-{
-  free(cpct->comp);
-  free(cpct->pere);
-  free(cpct->dfils);
-  free(cpct->fils);
-  free(cpct->hc);
-#ifdef ATTR_SURF
-  free(cpct->surf);
-#endif
-#ifdef ATTR_HEIGHT
-  free(cpct->height);
-#endif
-#ifdef ATTR_PERIM
-  free(cpct->perim);
-#endif
-#ifdef ATTR_HBORD
-  free(cpct->hbord);
-#endif
-#ifdef ATTR_CONTRAST
-  free(cpct->contrast);
-#endif
-#ifdef ATTR_VOL
-  free(cpct->vol);
-#endif
-#ifdef ATTR_DYN
-  free(cpct->dyn);
-#endif
-
-  free(cpct->flags);
-  free(cpct);
-} /* TermineCompactTree() */
-
-/* ==================================== */
-void AfficheCompTree(CompTree *ct)
-/* ==================================== */
-{
-  int32_t i;
-  printf("===========================\n");
-  printf("nombre max arcs = %d\n", ct->nbmaxarcs);
-  printf("nombre arcs = %d\n", ct->nbarcs);
-  printf("racine = C%d,%d\n", DECODENIV(ct->racine), DECODENUM(ct->racine));
-  printf("===========================\n");
-  for (i = 0; i < ct->nbarcs; i++)
-    printf("C%d,%d --> C%d,%d\n", 
-           DECODENIV(ct->tete[i]), DECODENUM(ct->tete[i]), 
-           DECODENIV(ct->queue[i]), DECODENUM(ct->queue[i]));
-  printf("===========================\n");
-} /* AfficheCompTree() */
-
-/* ==================================== */
-void AfficheCompactTree(CompactTree *cpct)
-/* ==================================== */
-{
-  uint32_t i, j, n, f;
-  printf("===========================\n");
-  printf("nombre composantes = %d\n", cpct->nbcomp);
-  printf("===========================\n");
-  for (i = 0; i < cpct->nbcomp; i++)
-  {
-    printf("comp[%d] = C%d,%d ", i, DECODENIV(cpct->comp[i]), DECODENUM(cpct->comp[i]));
-#ifdef ATTR_SURF
-    printf("surf = %d  ", cpct->surf[i]);
-#endif
-#ifdef ATTR_HEIGHT
-    printf("height = %d  ", cpct->height[i]);
-#endif
-#ifdef ATTR_VOL
-    printf("vol = %d  ", cpct->vol[i]);
-#endif
-#ifdef ATTR_PERIM
-    printf("perim = %d  ", cpct->perim[i]);
-#endif
-#ifdef ATTR_HBORD
-    printf("hbord = %d  ", cpct->hbord[i]);
-#endif
-#ifdef ATTR_CONTRAST
-    printf("contrast = %g ",cpct->contrast[i]);
-#endif
-#ifdef ATTR_DYN
-    printf("dynamique = %d ",cpct->dyn[i]);
-#endif
-    printf("fils = [ ");
-    n = NBFILS(i);
-    for (j = 0; j < n; j++)
-    {
-      f = INDEXFILS(i,j);
-      f = cpct->fils[f];
-      printf("C%d,%d ", DECODENIV(cpct->comp[f]), DECODENUM(cpct->comp[f]), f);
-    }
-    printf("] ");
-    if (cpct->flags[i] & FILTERED_OUT) printf(" - OUT");
-    if (cpct->flags[i] & LEAFMIN) printf(" - LEAFMIN");
-    if (cpct->flags[i] & LEAFMAX) printf(" - LEAFMAX");
-    printf("\n");
-  }
-  printf("===========================\n");
-  for (i = 0; i < cpct->nbcomp; i++)
-    printf("pere[%d] = %d\n", i, cpct->pere[i]);
-  printf("===========================\n");
-} /* AfficheCompactTree() */
-
-/* ==================================== */
-void AfficheImaComp(CompactTree * cpct,           
-       uint32_t *STATUS,
-       int32_t rs, int32_t N, 
-       uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t i, h;
-  uint32_t c, comp;
-  for (i = 0; i < N; i++) 
-  {
-    h = ORI[i];
-    c = STATUS[i];
-    printf("C%d,%d\t", h, c);
-    if ((i % rs) == (rs - 1)) printf("\n");
-  }  
-} /* AfficheImaComp() */
-
-/* ==================================== */
-void WriteCompactTree(CompactTree *cpct, char * filename)
-/* ==================================== */
-{
-  uint32_t i, j, n, f;
-  FILE * fd = NULL;
-  char buf[256];
-
-  fd = fopen(filename,"w");
-  if (!fd)
-  {
-    fprintf(stderr, "WriteCompactTree: cannot open file: %s\n", filename);
-    exit(0);
-  }
-
-  fprintf(fd, "%d %d\n", cpct->nbcomp, cpct->nbcomp-1);
-  fprintf(fd, "noms sommets\n");
-  for (i = 0; i < cpct->nbcomp; i++)
-  {
-    sprintf(buf, "C%d,%d", DECODENIV(cpct->comp[i]), DECODENUM(cpct->comp[i]));
-    fprintf(fd, "%d %s\n", i, buf);
-  }
-  fprintf(fd, "arcs\n");
-  for (i = 1; i < cpct->nbcomp; i++)
-    fprintf(fd, "%d %d\n", cpct->pere[i], i);
-  fclose(fd);
-} /* WriteCompactTree() */
-
-/* ==================================== */
-int32_t LeafCount(CompactTree *cpct)
-/* ==================================== */
-{
-  uint32_t i, f = 0;
-  for (i = 0; i < cpct->nbcomp; i++)
-    if ((NBFILS(i)) == 0) f++;
-  return f;
-} /* LeafCount() */
-
-/* ==================================== */
-int32_t LeafMark(CompactTree *cpct)
-/* ==================================== */
-{
-  uint32_t i, f = 0;
-  for (i = 0; i < cpct->nbcomp; i++)
-    if ((NBFILS(i)) == 0) { f++; cpct->flags[i] |= LEAF; }
-  return f;
-} /* LeafMark() */
-
-/* ==================================== */
-int32_t NbFilsNonFiltres(CompactTree * cpct, int32_t som)
-/* ==================================== */
-/*
-  retourne le nombre de fils de 'som' non marques FILTERED_OUT.
-*/
-{
-  int32_t i, n, j, NNM = 0;
-  n = NBFILS(som);
-  if (n == 0) 
-    return 0;
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(som, i);
-    j = cpct->fils[j];
-    if (!(cpct->flags[j] & FILTERED_OUT)) NNM++;
-    else if (NbFilsNonFiltres(cpct, j)>=1) NNM++;
-  }
-  return NNM;
-} /* NbFilsNonFiltres() */
-
-/* ==================================== */
-void AjouteArc(CompTree *ct, uint32_t i, uint32_t j 
-#ifdef ATTR_SURF
-               , int32_t surf
-#endif
-#ifdef ATTR_PERIM
-               , int32_t perim
-#endif
-#ifdef ATTR_HBORD
-               , int32_t hbord
-#endif
-              )
-/* ==================================== */
-{
-  if (ct->nbarcs >= ct->nbmaxarcs)
-  {
-    fprintf(stderr, "AjouteArc : structure CompTree saturee (%d arcs)\n", ct->nbarcs);
-    exit(0);
-  }
-  ct->tete[ct->nbarcs] = i;
-  ct->queue[ct->nbarcs] = j;
-#ifdef ATTR_SURF
-  ct->surf[ct->nbarcs] = surf;
-#endif
-#ifdef ATTR_PERIM
-  ct->perim[ct->nbarcs] = perim;
-#endif
-#ifdef ATTR_HBORD
-  ct->hbord[ct->nbarcs] = hbord;
-#endif
-  ct->nbarcs += 1;
-} /* AjouteArc() */
-
-/* ==================================== */
-int32_t contrib_perim(int32_t p, uint8_t *ORI, uint32_t *STATUS, int32_t rs, int32_t N, int32_t incr_vois)
-/* ==================================== */
-{ /* calcule la contribution du point p au perimetre de la composante */
-  int32_t q, k, nv = 0;
-
-  for (k = 0; k < 8; k += incr_vois) /* compte le nombre nv de voisins deja traites */
-  {
-    q = voisin(p, k, rs, N);
-    if ((q != -1) && (ORI[q] >= ORI[p]) && (STATUS[q] < NOT_ANALYZED)) nv++;
-  } /* for (k = 0; k < 8; k += incr_vois) */
-
-  return 4 - 2 * nv;
-}
-
-/* ==================================== */
-int32_t contrib_hbord(int32_t p, uint8_t *ORI, uint32_t *STATUS, int32_t rs, int32_t N, int32_t incr_vois)
-/* ==================================== */
-{ /* calcule la contribution du point p au hbord de la composante */
-  int32_t q, k, h = 0;
-
-  for (k = 0; k < 8; k += incr_vois)
-  {
-    q = voisin(p, k, rs, N);
-    if (q != -1) h += (ORI[p] - ORI[q]);
-  } /* for (k = 0; k < 8; k += incr_vois) */
-
-  return h;
-}
-
-/* ==================================== */
-int32_t flood(int32_t h,                        /* niveau a inonder */
-          Fah *FAH, 
-          uint32_t *STATUS,         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-	                                /* en sortie, contient le numero de la comp. de niveau h */
-                                        /* qui contient le pixel */
-          uint32_t *number_nodes,   /* nombre de composantes par niveau */
-          uint8_t *node_at_level, /* tableau de booleens */
-          CompTree * tree,              /* l'arbre en construction */
-          int32_t incr_vois,                /* = 1 pour la 8-connexite, 
-                                           = 2 pour la 4-connexite */ 
-          int32_t rs, int32_t N, 
-          uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t p, q, k, m, i, j;
-#ifdef ATTR_SURF
-  int32_t surf = 0;
-#endif
-#ifdef ATTR_PERIM
-  int32_t perim = 0;
-#endif
-#ifdef ATTR_HBORD
-  int32_t hbord = 0;
-#endif
-
-#ifdef DEBUGFLOOD
-  printf("debut flood niveau %d\n", h);
-#endif
-
-  node_at_level[h] = 1; /* CORRECTION BUG: LIGNE AJOUTEE LE 02/08/00 */
-  while (!FahVideNiveau(FAH, h))               /* first step : propagation */
-  {                                            /* ======================== */
-    p = FahPopNiveau(FAH, h);
-    STATUS[p] = number_nodes[h];
-#ifdef DEBUGFLOOD
-    printf("STATUS[p] %d\n", STATUS[p]);
-#endif
-    for (k = 0; k < 8; k += incr_vois)
-    {
-      q = voisin(p, k, rs, N);
-      if ((q != -1) && (STATUS[q] == NOT_ANALYZED))
-      {
-        FahPush(FAH, q, ORI[q]);
-        STATUS[q] = IN_THE_QUEUE;
-        node_at_level[ORI[q]] = 1;
-        if (ORI[q] > ORI[p])
-	{
-          m = ORI[q];
-          do 
-          {
-#ifdef PARANO
-            if ((m < 0) || (m > 255))
-            {
-              fprintf(stderr, "flood: mauvais niveau : %d ; ORI[q] = %d\n", m, ORI[q]);
-              exit(0);
-            }
-#endif
-            m = flood(m, FAH, STATUS, number_nodes, node_at_level, tree, incr_vois, rs, N, ORI); 
-          } while ((m != h) && (m >= 0));
-	} /* if (ORI[q] > ORI[p]) */
-      } /* if ((q != -1) && (STATUS[q] == NOT_ANALYZED)) */
-    } /* for (k = 0; k < 8; k += incr_vois) */
-#ifdef ATTR_SURF
-    surf += 1;
-#endif
-#ifdef ATTR_PERIM
-    perim += contrib_perim(p, ORI, STATUS, rs, N, incr_vois);
-#endif
-#ifdef ATTR_HBORD
-    hbord += contrib_hbord(p, ORI, STATUS, rs, N, incr_vois);
-#endif
-  } /* while (!FahVideNiveau(FAH, h)) */
-#ifdef DEBUGFLOOD
-  printf("retour flood niveau %d\n", h);
-#endif
-  number_nodes[h] += 1;
-
-  m = h - 1;                                    /* second step : define the father */
-  while ((m >= 0) && (!node_at_level[m])) m--;  /* =============================== */
-  i = number_nodes[h] - 1;
-  if (m >= 0)
-  {
-    j = number_nodes[m];
-#ifdef DEBUGFLOOD
-    printf("AjouteArc (%d %d) (%d %d)\n", m, j, h, i);
-#endif
-    AjouteArc(tree, ENCODE(j,m), ENCODE(i,h)    /* definit Cm,j comme le pere de Ch,i */
-#ifdef ATTR_SURF
-              , surf
-#endif
-#ifdef ATTR_PERIM
-              , perim
-#endif
-#ifdef ATTR_HBORD
-              , hbord
-#endif
-             ); 
-  } /* if (m >= 0) */
-  else
-  {
-#ifdef DEBUGFLOOD
-    printf("DefinitRacine (%d %d)\n", h, i);
-#endif
-    tree->racine = ENCODE(i,h);                /* Ch,i est racine */
-#ifdef ATTR_SURF
-    tree->surf_racine = surf;
-#endif
-
-  }
-  node_at_level[h] = 0;
-#ifdef DEBUGFLOOD
-  printf("fin flood niveau %d, retourne %d\n", h, m);
-#endif
-  return m;
-} /* flood() */
-
-/* ==================================== */
-int32_t flood3d(
-          int32_t h,                        /* niveau a inonder */
-          Fah *FAH, 
-          uint32_t *STATUS,         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-	                                /* en sortie, contient le numero de la comp. de niveau h */
-                                        /* qui contient le pixel */
-          uint32_t *number_nodes,   /* nombre de composantes par niveau */
-          uint8_t *node_at_level, /* tableau de booleens */
-          CompTree * tree,              /* l'arbre en construction */
-          int32_t connex,
-          int32_t rs, int32_t ps, int32_t N, 
-          uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t p, q, k, m, i, j;
-#ifdef ATTR_SURF
-  int32_t surf = 0;
-#endif
-#ifdef ATTR_PERIM
-  int32_t perim = 0;
-#endif
-#ifdef ATTR_HBORD
-  int32_t hbord = 0;
-#endif
-
-#ifdef DEBUGFLOOD
-  printf("debut flood3d niveau %d\n", h);
-#endif
-
-  node_at_level[h] = 1; /* CORRECTION BUG: LIGNE AJOUTEE LE 02/08/00 */
-  while (!FahVideNiveau(FAH, h))               /* first step : propagation */
-  {                                            /* ======================== */
-    p = FahPopNiveau(FAH, h);
-    STATUS[p] = number_nodes[h];
-#ifdef DEBUGFLOOD
-    printf("STATUS[p] %d\n", STATUS[p]);
-#endif
-
-    switch (connex)
-    {
-      case 6:
-        for (k = 0; k <= 10; k += 2)   /* parcourt les 6 voisins */
-        {
-          q = voisin6(p, k, rs, ps, N);
-          if ((q != -1) && (STATUS[q] == NOT_ANALYZED))
-          {
-            FahPush(FAH, q, ORI[q]);
-            STATUS[q] = IN_THE_QUEUE;
-            node_at_level[ORI[q]] = 1;
-            if (ORI[q] > ORI[p])
-	    {
-              m = ORI[q];
-              do 
-              {
-#ifdef PARANO
-                if ((m < 0) || (m > 255))
-                {
-                  fprintf(stderr, "flood3d: mauvais niveau : %d ; ORI[q] = %d\n", m, ORI[q]);
-                  exit(0);
-                }
-#endif
-                m = flood3d(m, FAH, STATUS, number_nodes, node_at_level, tree, connex, rs, ps, N, ORI); 
-              } while ((m != h) && (m >= 0));
-	    } /* if (ORI[q] > ORI[p]) */
-          } /* if ((q != -1) && (STATUS[q] == NOT_ANALYZED)) */
-        } /* for (...) */
-        break;
-      case 18:
-        for (k = 0; k < 18; k++)   /* parcourt les 18 voisins */
-        {
-          q = voisin18(p, k, rs, ps, N);
-          if ((q != -1) && (STATUS[q] == NOT_ANALYZED))
-          {
-            FahPush(FAH, q, ORI[q]);
-            STATUS[q] = IN_THE_QUEUE;
-            node_at_level[ORI[q]] = 1;
-            if (ORI[q] > ORI[p])
-	    {
-              m = ORI[q];
-              do 
-              {
-#ifdef PARANO
-                if ((m < 0) || (m > 255))
-                {
-                  fprintf(stderr, "flood3d: mauvais niveau : %d ; ORI[q] = %d\n", m, ORI[q]);
-                  exit(0);
-                }
-#endif
-                m = flood3d(m, FAH, STATUS, number_nodes, node_at_level, tree, connex, rs, ps, N, ORI); 
-              } while ((m != h) && (m >= 0));
-	    } /* if (ORI[q] > ORI[p]) */
-          } /* if ((q != -1) && (STATUS[q] == NOT_ANALYZED)) */
-        } /* for (...) */
-        break;
-      case 26:
-        for (k = 0; k < 26; k++)   /* parcourt les 26 voisins */
-        {
-          q = voisin26(p, k, rs, ps, N);
-          if ((q != -1) && (STATUS[q] == NOT_ANALYZED))
-          {
-            FahPush(FAH, q, ORI[q]);
-            STATUS[q] = IN_THE_QUEUE;
-            node_at_level[ORI[q]] = 1;
-            if (ORI[q] > ORI[p])
-	    {
-              m = ORI[q];
-              do 
-              {
-#ifdef PARANO
-                if ((m < 0) || (m > 255))
-                {
-                  fprintf(stderr, "flood3d: mauvais niveau : %d ; ORI[q] = %d\n", m, ORI[q]);
-                  exit(0);
-                }
-#endif
-                m = flood3d(m, FAH, STATUS, number_nodes, node_at_level, tree, connex, rs, ps, N, ORI); 
-              } while ((m != h) && (m >= 0));
-	    } /* if (ORI[q] > ORI[p]) */
-          } /* if ((q != -1) && (STATUS[q] == NOT_ANALYZED)) */
-        } /* for (...) */
-        break;
-      default:
-        fprintf(stderr, "flood3d: mauvaise connexite: %d\n", connex);
-        exit(0);
-    } /* switch (connex) */
-
-#ifdef ATTR_SURF
-    surf += 1;
-#endif
-  } /* while (!FahVideNiveau(FAH, h)) */
-#ifdef DEBUGFLOOD
-  printf("retour flood3d niveau %d\n", h);
-#endif
-  number_nodes[h] += 1;
-
-  m = h - 1;                                    /* second step : define the father */
-  while ((m >= 0) && (!node_at_level[m])) m--;  /* =============================== */
-  i = number_nodes[h] - 1;
-  if (m >= 0)
-  {
-    j = number_nodes[m];
-#ifdef DEBUGFLOOD
-    printf("AjouteArc (%d %d) (%d %d)\n", m, j, h, i);
-#endif
-    AjouteArc(tree, ENCODE(j,m), ENCODE(i,h)    /* definit Cm,j comme le pere de Ch,i */
-#ifdef ATTR_SURF
-              , surf
-#endif
-#ifdef ATTR_PERIM
-              , perim
-#endif
-#ifdef ATTR_HBORD
-              , hbord
-#endif
-             ); 
-  } /* if (m >= 0) */
-  else
-  {
-#ifdef DEBUGFLOOD
-    printf("DefinitRacine (%d %d)\n", h, i);
-#endif
-    tree->racine = ENCODE(i,h);                /* Ch,i est racine */
-#ifdef ATTR_SURF
-    tree->surf_racine = surf;
-#endif
-  }
-  node_at_level[h] = 0;
-#ifdef DEBUGFLOOD
-  printf("fin flood3d niveau %d, retourne %d\n", h, m);
-#endif
-  return m;
-} /* flood3d() */
-
-/* ==================================== */
-int32_t LowestCommonAncestor(
-  CompactTree * cpct,
-  int32_t argc,
-  int32_t *argv,
-  uint8_t d)
-/* Retourne le plus proche commun ancetre des cellules de la liste (argc, argv)
-   dont le niveau est > d, ou -1 s'il n'existe pas. 
-   Utilise le champ "flags". 
-   
-*/
-/* ==================================== */
-{
-  int32_t x, i, lca, NoComAnc;
-  if (argc <= 0) return -1;
-  if (argc == 1) return argv[0];
-
-  x = argv[0];      /* index de la premiere cellule */
-  do
-  {
-    cpct->flags[x] |= LCA1;     /* marque LCA1 tous les ancetres de x plus hauts que d */
-    x = cpct->pere[x];
-  } while ((x != CPCT_ROOT) && (DECODENIV(cpct->comp[x]) > d));
-  
-  for (i = 1; i < argc; i++)   /* boucle pour les autres cellules */
-  {
-    x = argv[i];
-    NoComAnc = 1;              /* pas d'ancetre commun trouve */
-    do
-    {                          /* remonte les ancetres de x sans depasser d */
-      if (cpct->flags[x] & LCA1)  /* on a un ancetre commun */
-      {
-        NoComAnc = 0; 
-      	cpct->flags[x] |= LCA2;   /* on le marque LCA2 */
-      	break;                 /* on arrete la remontee (sort du do while) */
-      }
-      else
-        x = cpct->pere[x];     /* on continue la remontee */
-    } while ((x != CPCT_ROOT) && (DECODENIV(cpct->comp[x]) > d));
-    if (NoComAnc) break;       /* pas d'AC: on sort aussi du for */
-  } /* for (i = 1; i < argc; i++) */
-
-  x = argv[0];        /* index de la premiere cellule */
-  do
-  {                   /* derniere remontee: demarque et repere le lca */
-    if (cpct->flags[x] & LCA2) lca = x;
-    cpct->flags[x] &= ~LCA;
-    x = cpct->pere[x];
-  }  while ((x != CPCT_ROOT) && (DECODENIV(cpct->comp[x]) > d));
-  
-  for (i = 1; i < argc; i++)   /* boucle pour les autres cellules */
-  {
-    x = argv[i];
-    do
-    { cpct->flags[x] &= ~LCA;
-      x = cpct->pere[x];     /* on continue la remontee */
-    } while ((x != CPCT_ROOT) && (DECODENIV(cpct->comp[x]) > d));
-  } /* for (i = 1; i < argc; i++) */
-
-#ifdef DEBUGLCA
-printf("LowComAnc(");
-for (i = 0; i < argc; i++) printf(" %d ", argv[i]);
-printf(") -> ");
-if (NoComAnc) printf("NIL\n"); else printf("%d\n", lca);
-#endif
-
-  if (NoComAnc)                /* pas d'ancetre commun */
-    return -1;
-  else
-    return lca;
-} /* LowestCommonAncestor() */
-
-/* ==================================== */
-int32_t Ancestor(CompactTree * cpct, int32_t c1, int32_t c2)
-/* Teste si la composante c1 est ancetre de la composante c2
-*/
-/* ==================================== */
-{
-  do
-  {
-    if (c1 == c2) return 1;
-    c2 = cpct->pere[c2];
-  } while (c2 != CPCT_ROOT);
-  return 0;
-} /* Ancestor() */
-
-/* ======================================================================== */
-/* ======================================================================== */
-/* OPERATEURS BASES SUR L'ARBRE DES COMPOSANTES */
-/* ======================================================================== */
-/* ======================================================================== */
-
-#ifdef ATTR_HEIGHT
-/* ==================================== */
-int32_t lsegmentheight(struct xvimage *image, int32_t connex, int32_t param, int32_t maximise)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lsegmentheight"
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * CTREE;          /* resultat : l'arbre des composantes compacte' */
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-
-
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  CTREE = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-
-  CalculeAttributs(CTREE);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeAttributs terminee\n");
-#endif
-
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-#endif
-
-  (void)FiltreHeightRec(CTREE, 0, param);
-
-#ifdef VERBOSE
-  fprintf(stderr, "FiltreHeightRec terminee\n");
-#endif
-
-  if ( maximise )
-    (void)MaximiseSegmentation(CTREE, 0);
-
-#ifdef VERBOSE
-  fprintf(stderr, "MaximiseSegmentation terminee\n");
-#endif
-
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-  WriteCompactTree(CTREE, "ctree.graph");
-#endif
-
-  RecupereSegmentation(CTREE, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereSegmentation terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(CTREE);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  return(1);
-} /* lsegmentheight() */
-
-#ifdef RECONS
-/* ==================================== */
-int32_t lsegreconsheight(struct xvimage *image, int32_t connex, int32_t param)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lsegreconsheight"
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t N = rs * cs;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * CTREE;          /* resultat : l'arbre des composantes compacte' */
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "%s: cette version ne traite pas les images volumiques\n", F_NAME);
-    exit(0);
-  }
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-    default: 
-      fprintf(stderr, "%s: mauvaise connexite: %d\n", F_NAME, connex);
-      return 0;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-
-  (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  CTREE = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-#endif
-
-  CalculeAttributs(CTREE);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeAttributs terminee\n");
-#endif
-
-  (void)FiltreHeightRec(CTREE, 0, param);
-
-#ifdef VERBOSE
-  fprintf(stderr, "FiltreHeightRec terminee\n");
-#endif
-
-  (void)MaximiseSegmentation(CTREE, 0);
-
-#ifdef VERBOSE
-  fprintf(stderr, "MaximiseSegmentation terminee\n");
-#endif
-
-  Reconstruction(CTREE, 0);
-
-#ifdef VERBOSE
-  fprintf(stderr, "Reconstruction terminee\n");
-#endif
-
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-  WriteCompactTree(CTREE, "ctree.graph");
-#endif
-
-  RecupereSegmentation(CTREE, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereSegmentation terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(CTREE);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  return(1);
-} /* lsegreconsheight() */
-#endif
-#endif
-
-#ifdef ATTR_SURF
-/* ==================================== */
-int32_t lsegmentarea(struct xvimage *image, int32_t connex, int32_t param, int32_t maximise)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lsegmentarea"
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * CTREE;          /* resultat : l'arbre des composantes compacte' */
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-
-
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  CTREE = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-
-  CalculeAttributs(CTREE);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeAttributs terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-#endif
-
-  (void)FiltreSurfRec(CTREE, 0, param);
-
-#ifdef VERBOSE
-  fprintf(stderr, "FiltreSurfRec terminee\n");
-#endif
-
-  if ( maximise )
-    (void)MaximiseSegmentation(CTREE, 0);
-
-#ifdef VERBOSE
-  fprintf(stderr, "MaximiseSegmentation terminee\n");
-#endif
-
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-  WriteCompactTree(CTREE, "ctree.graph");
-#endif
-
-  RecupereSegmentation(CTREE, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereSegmentation terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(CTREE);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  return(1);
-} /* lsegmentarea() */
-#endif
-
-#ifdef ATTR_VOL
-/* ==================================== */
-int32_t lsegmentvol(struct xvimage *image, int32_t connex, int32_t param, int32_t maximise)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lsegmentvol"
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * CTREE;          /* resultat : l'arbre des composantes compacte' */
-  int32_t nbcomp;
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  CTREE = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-
-  CalculeAttributs(CTREE);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeAttributs terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-#endif
-
-  (void)FiltreVolRec(CTREE, 0, param);
-
-#ifdef VERBOSE
-  fprintf(stderr, "FiltreVolRec terminee\n");
-#endif
-
-  if ( maximise )
-    (void)MaximiseSegmentation(CTREE, 0);
-
-  nbcomp = NbLeafs(CTREE, 0);
-
-#ifdef VERBOSE
-  fprintf(stderr, "nombre de composantes pertinentes : %d\n", nbcomp);
-#endif
-
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-  WriteCompactTree(CTREE, "ctree.graph");
-#endif
-
-  RecupereSegmentation(CTREE, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereSegmentation terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(CTREE);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  return(1);
-} /* lsegmentvol() */
-#endif
-
-#ifdef ATTR_HEIGHT
-/* ==================================== */
-void ProcessLeafMins(CompactTree * cpct, int32_t som)
-/* ==================================== */
-/*
-  Recherche a partir du sommet som, les sommets marques LEAFMIN.
-  Demarque en remontant jusqu'au premier noeud.
-  Version pour un filtre morphologique (avec RecupereImageFiltreeH).
-*/
-{
-  int32_t i, j, n, h;
-
-  if (!(cpct->flags[som] & LEAFMIN))
-  {
-    n = NBFILS(som);           /* remonte l'arbre pour trouver une LEAFMIN */ 
-    for (i = 0; i < n; i++) 
-    {
-      j = INDEXFILS(som, i);
-      j = cpct->fils[j];
-      ProcessLeafMins(cpct, j);
-    }
-  }
-  else /* (on a trouve une LEAFMIN) */
-  {
-    cpct->flags[som] &= ~LEAFMIN; /* demarque som */
-    while (NBFILS(som) == 1)      /* remonte jusqu'au premier noeud ou feuille */
-    {
-      som = INDEXFILS(som, 0);
-      som = cpct->fils[som];
-      cpct->flags[som] &= ~FILTERED_OUT;
-    }
-    cpct->flags[som] |= LEAFMIN;  /* marque */
-  }
-} /* ProcessLeafMins() */
-
-/* ==================================== */
-void ProcessLeafMinsOp(CompactTree * cpct, int32_t som)
-/* ==================================== */
-/*
-  Recherche a partir du sommet som, les sommets marques LEAFMIN.
-  Demarque en remontant jusqu'a la feuille la plus haute.
-  Version pour une ouverture (avec RecupereImageFiltree).
-*/
-{
-  int32_t i, j, n, m, jm, h;
-
-  if (!(cpct->flags[som] & LEAFMIN))
-  {
-    n = NBFILS(som);           /* remonte l'arbre pour trouver une LEAFMIN */ 
-    for (i = 0; i < n; i++) 
-    {
-      j = INDEXFILS(som, i);
-      j = cpct->fils[j];
-      ProcessLeafMinsOp(cpct, j);
-    }
-  }
-  else /* (on a trouve une LEAFMIN) */
-  {
-    cpct->flags[som] &= ~LEAFMIN; /* demarque som */
-    while (NBFILS(som) > 0)       /* remonte jusqu'a une (vraie) feuille */
-    {
-      /* recherche l'indice im du fils de hauteur maxi */
-      n = NBFILS(som);
-      m = -1;
-      for (i = 0; i < n; i++) 
-      {
-        j = INDEXFILS(som, i);
-        j = cpct->fils[j];
-        h = DECODENIV(cpct->comp[j]) + cpct->height[j];
-        if (h > m) { m = h; jm = j; } 
-      }
-      /* remonte en demarquant */
-      som = jm;
-      cpct->flags[som] &= ~FILTERED_OUT;
-    }
-    cpct->flags[som] |= LEAFMIN;  /* marque LEAFMIN le sommet atteint */
-  }
-} /* ProcessLeafMinsOp() */
-
-/* ==================================== */
-void RecupereImageFiltreeH(CompactTree * cpct,           
-       uint32_t *STATUS,
-       int32_t rs, int32_t N, 
-       uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t i, h;
-  uint32_t c, comp;
-  for (i = 0; i < N; i++) 
-  {
-    h = ORI[i];
-    c = STATUS[i];
-    comp = INDEXCOMP(h,c);
-    while (cpct->flags[comp] == FILTERED_OUT) comp = cpct->pere[comp];
-    if (cpct->flags[comp] & LEAFMIN)
-      ORI[i] = DECODENIV(cpct->comp[comp]) + cpct->height[comp];
-    else
-      ORI[i] = DECODENIV(cpct->comp[comp]);
-  }  
-} /* RecupereImageFiltreeH() */
-
-/* ==================================== */
-int32_t lheightmaxima_variante(struct xvimage *image, int32_t connex, int32_t param)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lheightmaxima_variante"
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * CTREE;          /* resultat : l'arbre des composantes compacte' */
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  CTREE = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-#endif
-
-  CalculeAttributs(CTREE);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeAttributs terminee\n");
-#endif
-
-  (void)FiltreHeightRec(CTREE, 0, param);
-
-#ifdef VERBOSE
-  fprintf(stderr, "FiltreHeightRec terminee\n");
-#endif
-
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-  WriteCompactTree(CTREE, "ctree.graph");
-#endif
-
-  ProcessLeafMinsOp(CTREE, 0);
-
-#ifdef VERBOSE
-  fprintf(stderr, "ProcessLeafMinsOp terminee\n");
-#endif
-
-  RecupereImageFiltree(CTREE, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereImageFiltree terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(CTREE);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  return(1);
-} /* lheightopening() */
-
-/* ==================================== */
-int32_t lheightmaxima(struct xvimage *image, int32_t connex, int32_t param)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lheightmaxima"
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * CTREE;          /* resultat : l'arbre des composantes compacte' */
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  CTREE = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-#endif
-
-  CalculeAttributs(CTREE);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeAttributs terminee\n");
-#endif
-
-  (void)FiltreHeightRec(CTREE, 0, param);
-
-#ifdef VERBOSE
-  fprintf(stderr, "FiltreHeightRec terminee\n");
-#endif
-
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-  WriteCompactTree(CTREE, "ctree.graph");
-#endif
-
-  RecupereImageFiltree(CTREE, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereImageFiltree terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(CTREE);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  return(1);
-} /* lheightmaxima() */
-#endif
-
-#ifdef ATTR_SURF
-/* ==================================== */
-int32_t lareaopening(struct xvimage *image, int32_t connex, int32_t param)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lareaopening"
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * CTREE;          /* resultat : l'arbre des composantes compacte' */
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-  
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F); 
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  CTREE = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-#endif
-
-  CalculeAttributs(CTREE);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeAttributs terminee\n");
-#endif
-
-  (void)FiltreSurfRec(CTREE, 0, param);
-
-#ifdef VERBOSE
-  fprintf(stderr, "FiltreSurfRec terminee\n");
-#endif
-
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-  WriteCompactTree(CTREE, "ctree.graph");
-#endif
-
-  RecupereImageFiltree(CTREE, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereImageFiltree terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(CTREE);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  return(1);
-} /* lareaopening() */
-
-/* ==================================== */
-int32_t lareaclosing(struct xvimage *image, int32_t connex, int32_t param)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lareaclosing"
-{
-  register int32_t i;
-  int32_t ret;
-  int32_t N = rowsize(image) * colsize(image) * depth(image);
-  uint8_t *F = UCHARDATA(image);
-  for (i = 0; i < N; i++) F[i] = 255 - F[i];
-  ret = lareaopening(image, connex, param);
-  for (i = 0; i < N; i++) F[i] = 255 - F[i];
-  return(ret);
-} /* lareaclosing() */
-#endif
-
-#ifdef ATTR_VOL
-/* ==================================== */
-int32_t lvolmaxima(struct xvimage *image, int32_t connex, int32_t param)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lvolmaxima"
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * CTREE;          /* resultat : l'arbre des composantes compacte' */
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-  
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F); 
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  CTREE = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-#endif
-
-  CalculeAttributs(CTREE);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeAttributs terminee\n");
-#endif
-
-  (void)FiltreVolRec(CTREE, 0, param);
-
-#ifdef VERBOSE
-  fprintf(stderr, "FiltreVolRec terminee\n");
-#endif
-
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-  WriteCompactTree(CTREE, "ctree.graph");
-#endif
-
-  RecupereImageFiltree(CTREE, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereImageFiltree terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(CTREE);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  return(1);
-} /* lvolmaxima() */
-#endif
-
-#ifdef ATTR_HEIGHT
-/* ==================================== */
-int32_t lheightselnb(struct xvimage *image, int32_t connex, int32_t param, int32_t mode)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lheightselnb"
-/* 
-  param: nombre de composantes a trouver
-  mode: parametre obsolete
-*/
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * cpct;          /* resultat : l'arbre des composantes compacte' */
-  int32_t nbcomp, nbfeuilles;
-  int32_t *A;                       /* tableau pour le tri des composantes par hauteurs croissantes */
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  cpct = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-
-  CalculeAttributs(cpct);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeAttributs terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(cpct);
-#endif
-
-  nbfeuilles = LeafMark(cpct);
-  nbcomp = cpct->nbcomp;
-  A = (int32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (A == NULL)
-  {   fprintf(stderr, "%s() : malloc failed\n", F_NAME);
-      return(0);
-  }
-  for (i = 0; i < nbcomp; i++) A[i] = i;
-  i_TriRapideStochastique (A, cpct->height, 0, nbcomp-1);
-  i = 0;
-  while ((nbfeuilles > param) && (i < nbcomp))
-  {
-    //printf("i = %d, A[i] = %d, cpct->height[A[i]] = %d, nbf = %d\n", 
-    //       i, A[i], cpct->height[A[i]], nbfeuilles);
-    if (NbFilsNonFiltres(cpct, A[i]) == 0)
-    {
-      cpct->flags[A[i]] |= FILTERED_OUT;
-      cpct->flags[A[i]] &= ~LEAF;
-      k = cpct->pere[A[i]];
-      if (NbFilsNonFiltres(cpct, k) != 0) 
-        nbfeuilles--;
-      else
-        cpct->flags[k] |= LEAF;
-    }
-#ifdef PARANO
-    else
-      printf("Erreur imprevue : Composante non feuille : %d\n", A[i]);
-#endif
-    i++;
-  } // while ((nbfeuilles > param) && (i < nbcomp))
-
-#ifdef DEBUG
-  AfficheCompactTree(cpct);
-  WriteCompactTree(cpct, "ctree.graph");
-#endif
-
-  //  RecupereImageFiltree(CTREE, STATUS, rs, N, F);
-  RecupereSegmentation(cpct, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereSegmentation terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(cpct);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  free(A);
-  return(1);
-} /* lheightselnb() */
-#endif
-
-#ifdef ATTR_SURF
-/* ==================================== */
-int32_t lareaselnb(struct xvimage *image, int32_t connex, int32_t param)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lareaselnb"
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * cpct;          /* resultat : l'arbre des composantes compacte' */
-  int32_t nbcomp, nbfeuilles;
-  int32_t *A;                       /* tableau pour le tri des composantes par hauteurs croissantes */
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  cpct = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(cpct);
-#endif
-
-  CalculeAttributs(cpct);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeAttributs terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(cpct);
-#endif
-
-  nbfeuilles = LeafMark(cpct);
-  nbcomp = cpct->nbcomp;
-  A = (int32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (A == NULL)
-  {   fprintf(stderr, "%s() : malloc failed\n", F_NAME);
-      return(0);
-  }
-  for (i = 0; i < nbcomp; i++) A[i] = i;
-  i_TriRapideStochastique (A, cpct->surf, 0, nbcomp-1);
-  i = 0;
-  while ((nbfeuilles > param) && (i < nbcomp))
-  {
-    //printf("i = %d, A[i] = %d, cpct->surf[A[i]] = %d, nbf = %d\n", 
-    //       i, A[i], cpct->surf[A[i]], nbfeuilles);
-    if (NbFilsNonFiltres(cpct, A[i]) == 0)
-    {
-      cpct->flags[A[i]] |= FILTERED_OUT;
-      cpct->flags[A[i]] &= ~LEAF;
-      k = cpct->pere[A[i]];
-      if (NbFilsNonFiltres(cpct, k) != 0) 
-        nbfeuilles--;
-      else
-        cpct->flags[k] |= LEAF;
-    }
-#ifdef PARANO
-    else
-      printf("Erreur imprevue : Composante non feuille : %d\n", A[i]);
-#endif
-    i++;
-  } // while ((nbfeuilles > param) && (i < nbcomp))
-
-#ifdef DEBUG
-  AfficheCompactTree(cpct);
-  WriteCompactTree(cpct, "ctree.graph");
-#endif
-
-  RecupereSegmentation(cpct, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereSegmentation terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(cpct);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  free(A);
-  return(1);
-} /* lareaselnb() */
-#endif
-
-#ifdef ATTR_VOL
-/* ==================================== */
-int32_t lvolselnb(struct xvimage *image, int32_t connex, int32_t param)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lvolselnb"
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * cpct;          /* resultat : l'arbre des composantes compacte' */
-  int32_t nbcomp, nbfeuilles;
-  int32_t *A;                       /* tableau pour le tri des composantes par hauteurs croissantes */
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  cpct = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(cpct);
-#endif
-
-  CalculeAttributs(cpct);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeAttributs terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompactTree(cpct);
-#endif
-
-  nbfeuilles = LeafMark(cpct);
-  nbcomp = cpct->nbcomp;
-  A = (int32_t *)calloc(1,nbcomp * sizeof(int32_t));
-  if (A == NULL)
-  {   fprintf(stderr, "%s() : malloc failed\n", F_NAME);
-      return(0);
-  }
-  for (i = 0; i < nbcomp; i++) A[i] = i;
-  i_TriRapideStochastique (A, cpct->vol, 0, nbcomp-1);
-  i = 0;
-  while ((nbfeuilles > param) && (i < nbcomp))
-  {
-    //printf("i = %d, A[i] = %d, cpct->vol[A[i]] = %d, nbf = %d\n", 
-    //       i, A[i], cpct->vol[A[i]], nbfeuilles);
-    if (NbFilsNonFiltres(cpct, A[i]) == 0)
-    {
-      cpct->flags[A[i]] |= FILTERED_OUT;
-      cpct->flags[A[i]] &= ~LEAF;
-      k = cpct->pere[A[i]];
-      if (NbFilsNonFiltres(cpct, k) != 0) 
-        nbfeuilles--;
-      else
-        cpct->flags[k] |= LEAF;
-    }
-#ifdef PARANO
-    else
-      printf("Erreur imprevue : Composante non feuille : %d\n", A[i]);
-#endif
-    i++;
-  } // while ((nbfeuilles > param) && (i < nbcomp))
-
-#ifdef DEBUG
-  AfficheCompactTree(cpct);
-  WriteCompactTree(cpct, "ctree.graph");
-#endif
-
-  RecupereSegmentation(cpct, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereSegmentation terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(cpct);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  free(A);
-  return(1);
-} /* lvolselnb() */
-#endif
-
-
-#ifdef ATTR_DYN
-/* ==================================== */
-void CalculeDynamiqueMaxima(CompactTree * cpct)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "CalculeDynamiqueMaxima"
-/* 
-Definition Grimaud : obligation d'atteindre un maximum de niveau strictement superieur
-*/
-{
-  uint32_t nbcomp = cpct->nbcomp;
-  int32_t i, h, ncompnivh, f, p, s;
-  uint8_t *tmp;
-
-  tmp = (uint8_t *)calloc(nbcomp, sizeof(char));
-  if (tmp == NULL) 
-  {   fprintf(stderr, "%s() : calloc failed for tmp\n", F_NAME);
-      exit(0);
-  }
-
-  /* met le champ dyn a 0 */
-  for (i = 0; i < nbcomp; i++)  cpct->dyn[i] = 0;
-
-  /* balaye les feuilles par ordre decroissant */
-  for (h = 255; h > 0; h--)
-  {
-    ncompnivh = cpct->hc[h] - cpct->hc[h-1]; /* nb composantes dans le niveau h */
-    if (ncompnivh > 0)
-    {
-      for (i = cpct->hc[h] - 1; i > cpct->hc[h] - 1 - ncompnivh; i--)
-      {
-        if (NBFILS(i) == 0) /* feuille */
-        {
-          f = i;
-          p = cpct->pere[f];
-          /* 
-            on remonte la branche a partir de la feuille i
-            en marquant les noeuds (grace a tmp) par le niveau de i,
-            jusqu'a trouver un noeud p marque (tmp) par une valeur plus forte
-            ou la racine
-            alors : dyn[i] = niv[i] - niv[p]
-	  */
-          while ((p != f) && (tmp[p] <= h))
-	  {
-            tmp[p] = h;
-            f = p;
-            p = cpct->pere[f];
-	  } /* while ((p != f) && (tmp[p] <= h)) */
-          cpct->dyn[i] = h - DECODENIV(cpct->comp[p]);
-	} /* if (NBFILS(i) == 0) */
-      } /* for i */
-    } /* if (ncompnivh > 0) */
-  } /* for h */
-
-#ifdef VERBOSE
-  printf("FIN DU CALCUL DE LA DYNAMIQUE DES MAXIMA\n");
-#endif
-
-  free(tmp);
-} /* CalculeDynamiqueMaxima() */
-
-/* ==================================== */
-void CalculeDynamiqueContours(CompactTree * cpct)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "CalculeDynamiqueContours"
-/* 
-Variante definition Grimaud : obligation d'atteindre un maximum de niveau superieur ou egal
-*/
-{
-  uint32_t nbcomp = cpct->nbcomp;
-  int32_t i, h, ncompnivh, f, p, s, v;
-  uint8_t *tmp;
-
-  tmp = (uint8_t *)calloc(nbcomp, sizeof(char));
-  if (tmp == NULL) 
-  {   fprintf(stderr, "%s() : calloc failed for tmp\n", F_NAME);
-      exit(0);
-  }
-
-  /* met le champ dyn a 0 */
-  for (i = 0; i < nbcomp; i++)  cpct->dyn[i] = 0;
-
-  /* balaye les feuilles par ordre decroissant */
-  for (h = 255; h > 0; h--)
-  {
-    ncompnivh = cpct->hc[h] - cpct->hc[h-1]; /* nb composantes dans le niveau h */
-    if (ncompnivh > 0)
-    {
-      for (i = cpct->hc[h] - 1; i > cpct->hc[h] - 1 - ncompnivh; i--)
-      {
-        if (NBFILS(i) == 0) /* feuille */
-        {
-          f = i;
-          p = cpct->pere[f];
-          /* 
-            on remonte la branche a partir de la feuille i
-            en marquant les noeuds (grace a tmp) par le niveau de i,
-            jusqu'a trouver un noeud p marque (tmp) par une valeur plus forte ou egale
-            ou la racine
-            alors : dyn[i] = niv[i] - niv[p]
-            et (si non racine) : dyn[p] = max(dyn[p],dyn[i])
-               (si racine) : -1 la premiere fois, idem ensuite
-	  */
-          while ((p != f) && (tmp[p] < h))
-	  {
-            tmp[p] = h;
-            f = p;
-            p = cpct->pere[f];
-	  } /* while ((p != f) && (tmp[p] < h)) */
-          cpct->dyn[i] = h - DECODENIV(cpct->comp[p]);
-          if (p != f) cpct->dyn[p] = max(cpct->dyn[p],cpct->dyn[i]);
-          else
-	  {
-            if (cpct->dyn[p] == 0) cpct->dyn[p] = -1;
-            else cpct->dyn[p] = max(cpct->dyn[p],cpct->dyn[i]);
-	  }
-	} /* if (NBFILS(i) == 0) */
-      } /* for i */
-    } /* if (ncompnivh > 0) */
-  } /* for h */
-
-  // detection des noeuds i violant la condition : 
-  //   val(i) >= val(p) pour tout p descendant de i
-
-  // balaye les noeuds non feuilles par ordre de niveau decroissant.
-  // a partir d'un noeud i (de valuation v)
-  // on remonte vers la racine: 
-  //   soit p le noeud courant
-  //   si val(p) < v alors marque p (flag CONDITION_VIOLATION)
-  //   sinon v = val(p) pour continuer la verification sur les ancetres de i
-  for (h = 255; h > 0; h--)
-  {
-    ncompnivh = cpct->hc[h] - cpct->hc[h-1]; /* nb composantes dans le niveau h */
-    if (ncompnivh > 0)
-    {
-      for (i = cpct->hc[h] - 1; i > cpct->hc[h] - 1 - ncompnivh; i--)
-      {
-        if (NBFILS(i) > 0) /* non feuille */
-        {
-          v = cpct->dyn[i];
-          f = i;
-          p = cpct->pere[f];
-          while (p != f)
-	  {
-            if (cpct->dyn[p] < v) cpct->flags[p] |= CONDITION_VIOLATION;
-            else v = cpct->dyn[p];
-            f = p;
-            p = cpct->pere[f];
-	  } /* while (p != f) */
-	} /* if (NBFILS(i) > 0) */
-      } /* for i */
-    } /* if (ncompnivh > 0) */
-  } /* for h */
-
-#ifdef VERBOSE
-  printf("FIN DU CALCUL DE LA DYNAMIQUE DES CONTOURS\n");
-#endif
-
-  free(tmp);
-} /* CalculeDynamiqueContours() */
-
-/* ==================================== */
-void RecupereDynamique(CompactTree * cpct,           
-       uint32_t *STATUS,
-       int32_t rs, int32_t N, 
-       uint8_t *ORI            /* informations sur l'image originale */
-)
-/* ==================================== */
-{
-  int32_t i, h;
-  uint32_t c, comp;
-  for (i = 0; i < N; i++) 
-  {
-    h = ORI[i];
-    c = STATUS[i];
-    comp = INDEXCOMP(h,c);
-    ORI[i] = cpct->dyn[comp];
-  }  
-} /* RecupereDynamique() */
-
-/* ==================================== */
-int32_t ldynamique(struct xvimage *image, int32_t connex)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "ldynamique"
-{
-  register int32_t i, k, l;         /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * CTREE;          /* resultat : l'arbre des composantes compacte' */
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 1; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  CTREE = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-
-  CalculeDynamiqueMaxima(CTREE);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CalculeDynamique terminee\n");
-#endif
-
-#ifdef DEBUG
-  AfficheCompactTree(CTREE);
-  AfficheImaComp(CTREE, STATUS, rs, N, F);
-#endif
-
-  RecupereDynamique(CTREE, STATUS, rs, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "RecupereDynamique terminee\n");
-#endif
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(CTREE);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  return(1);
-} /* ldynamique() */
-
-/* ==================================== */
-void SimplifyComp(CompactTree *cpct, int32_t *ncomp, int32_t *tabcomp) 
-/* ==================================== */
-// supprime dans tabcomp les composantes qui sont ancetres d'une autre
-{
-  int32_t k, j, i; 
-  for (i = 0; i < *ncomp; i++)
-  if (tabcomp[i] != -1)
-  {
-    for (j = i + 1; j < *ncomp; j++)
-    if (tabcomp[j] != -1)
-    {
-      if (Ancestor(cpct, tabcomp[j], tabcomp[i])) 
-      {
-        tabcomp[j] = -1;
-      }
-      else if (Ancestor(cpct, tabcomp[i], tabcomp[j])) 
-      {
-        tabcomp[i] = -1;
-        break;
-      }
-    } // for j
-  } // for i
-  k = j = 0;
-  for (i = 0; i < *ncomp; i++)
-  {
-    tabcomp[j] = tabcomp[i];
-    if (tabcomp[i] != -1)
-      j++;
-    else
-      k++; // nb elements supprimes
-  }
-  *ncomp -= k;
-} /* SimplifyComp() */
-
-/* ================================================ */
-void BuildTree(uint8_t *F, int32_t rs, int32_t ps, int32_t N, int32_t connex, int32_t incr_vois,
-	       Fah * FAH, uint32_t *STATUS, 
-               uint32_t *number_nodes, uint8_t *node_at_level,
-               CompTree * TREE, CompactTree ** cpct
-              )
-/* ================================================ */
-{
-  int32_t i, j, k;
-
-  // INITIALISATIONS
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 0; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-  // APPEL FONCTION RECURSIVE flood
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F);
-  *cpct = CompTree2CompactTree(TREE, number_nodes);
-} // BuildTree()
-
-/* ==================================== */
-int32_t TrouveComposantes(int32_t x, uint8_t *F, int32_t rs, int32_t N, int32_t incr_vois, 
-                  uint32_t *STATUS, CompactTree * cpct, int32_t *tabcomp)
-/* ==================================== */
-{
-    int32_t k, y, ncomp = 0;
-    for (k = 0; k < 8; k += incr_vois) // parcourt les c-voisins y de x d'un niveau > F[x]
-    {
-      y = voisin(x, k, rs, N);
-      if ((y != -1) && (F[y] > F[x]))
-      {
-        tabcomp[ncomp] = INDEXCOMP(F[y],STATUS[y]);
-        ncomp++;
-      }
-    } /* for (k = 0; k < 8; k += incr_vois) */
-#ifdef DEBUG
-    printf("    Comp. du voisinage: %d [%d %d %d %d]\n", ncomp, tabcomp[0], tabcomp[1], tabcomp[2], tabcomp[3]);
-#endif
-    SimplifyComp(cpct, &ncomp, tabcomp); // supprime dans tabcomp les composantes qui sont ancetres d'une autre
-
-#ifdef DEBUG
-    printf("    Comp. du voisinage (simpl.): %d [%d %d %d %d]\n", ncomp, tabcomp[0], tabcomp[1], tabcomp[2], tabcomp[3]);
-#endif
-    return ncomp;
-} // TrouveComposantes() 
-
-#define EN_FAH     0 
-#define WATERSHED  1
-#define MASSIF     2
-#define WATERSHED2 3
-#define MODIFIE    4
-
-/* ==================================== */
-int32_t Watershed_old(
-  uint8_t *F, 
-  int32_t rs, 
-  int32_t N, 
-  int32_t incr_vois, 
-  Fah * FAH, 
-  uint32_t *STATUS, 
-  CompactTree * cpct)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "Watershed_old"
-{
-  int32_t i, j, k, x, y;
-  int32_t c;                        /* une composante */
-  int32_t tabcomp[8];               /* liste de composantes */
-  int32_t ncomp;                    /* nombre de composantes dans tabcomp */
-  int32_t nbelev;                   /* nombre d'elevations effectuees */
-
-  // INITIALISATIONS
-  FahFlush(FAH); // Re-initialise la FAH
-
-  // etiquetage des c-maxima (doit pouvoir se faire au vol lors de la construction de l'arbre)
-  for (i = 0; i < N; i++)
-  {
-    c = INDEXCOMP(F[i],STATUS[i]);
-    if (NBFILS(c) == 0) Set(i,MASSIF);
-  } // for (i = 0; i < N; i++)
-
-  // empile les c-voisins des c-maxima
-  for (i = 0; i < N; i++)
-  {
-    if (IsSet(i,MASSIF))
-    {
-      for (k = 0; k < 8; k += incr_vois)
-      {
-        j = voisin(i, k, rs, N);
-        if ((j != -1) && (!IsSet(j,MASSIF)) && (!IsSet(j,EN_FAH)))
-	{
-          Set(j,EN_FAH);
-          FahPush(FAH, j, NDG_MAX - F[j]);
-	}
-      } /* for (k = 0; k < 8; k += incr_vois) */
-    } // if (IsSet(i,MASSIF))
-  } // for (i = 0; i < N; i++)
-
-  // BOUCLE PRINCIPALE
-  nbelev = 0;
-  while (!FahVide(FAH))
-  {
-    x = FahPop(FAH);
-    UnSet(x,EN_FAH);
-#ifdef DEBUG
-    printf("Pop Point %d,%d Niveau %d\n", x % rs, x / rs, F[x]);
-#endif
-
-    ncomp = TrouveComposantes(x, F, rs, N, incr_vois, STATUS, cpct, tabcomp);
-
-    if (ncomp == 1)
-      c = tabcomp[0];
-    else 
-      c = LowestCommonAncestor(cpct, ncomp, tabcomp, F[x]);
-
-#ifdef DEBUG
-    printf("    LCA: %d\n", c);
-#endif
-
-    if ((c == -1) && (ncomp >= 2))
-    {
-      Set(x,WATERSHED);
-#ifdef DEBUG
-      printf("    Pas d'elevation ; LPE\n");
-#endif
-    }
-
-    if (c != -1)
-    {
-      nbelev++;
-      F[x] = DECODENIV(cpct->comp[c]);      // eleve le niveau du point x
-      STATUS[x] = DECODENUM(cpct->comp[c]); // maj pointeur image -> composantes 
-      Set(x,MODIFIE);
-      if (NBFILS(c) == 0) // feuille
-      {
-        Set(x,MASSIF);
-#ifdef DEBUG
-        printf("    Eleve au niveau: %d ; MASSIF\n", F[x]);
-#endif
-      } // if feuille
-      else
-      if (NBFILS(c) > 1) // noeud
-      {
-        Set(x,WATERSHED);
-#ifdef DEBUG
-        printf("    Eleve au niveau: %d ; LPE\n", F[x]);
-#endif
-      }
-#ifdef PARANO
-      else
-        printf("Watershed() : ERREUR COMPOSANTE BRANCHE!!!\n");
-#endif
-
-      // empile les c-voisins de x non marques MASSIF ni EN_FAH
-      for (k = 0; k < 8; k += incr_vois)
-      {
-        y = voisin(x, k, rs, N);
-        if ((y != -1) && (!IsSet(y,MASSIF)) && (!IsSet(y,EN_FAH)))
-        {
-          Set(y,EN_FAH);
-          FahPush(FAH, y, NDG_MAX - F[y]);
-#ifdef DEBUG
-          printf("        Push Point %d,%d Niveau %d\n", y % rs, y / rs, F[y]);
-#endif
-        }
-      } // for (k = 0; k < 8; k += incr_vois)
-    } // if (c != -1)
-  } // while (!FahVide(FAH))
-
-#ifdef VERBOSE
-    printf("Nombre d'elevations %d\n", nbelev);
-#endif
-} // Watershed_old()
-
-/* ==================================== */
-int32_t trouvefeuillerec(CompactTree * cpct, int32_t p, int32_t v)
-/* ==================================== */
-/*
-  retourne l'index d'une feuille descendant de p tq dyn(f) = v, ou -1 en cas d'echec
-*/ 
-{
-  int32_t i, n, j, f;
-  n = NBFILS(p);
-  if (n == 0) 
-  {
-    if (cpct->dyn[p] == v) return p;
-    return -1;
-  }
-  for (i = 0; i < n; i++) 
-  {
-    j = INDEXFILS(p, i);
-    j = cpct->fils[j];
-    f = trouvefeuillerec(cpct, j, v);
-    if (f != -1) return f;
-  }
-  return -1;
-} /* trouvefeuillerec() */
-
-/* ==================================== */
-void ElimineDupliques(int32_t *ncomp, int32_t *tabcomp) 
-/* ==================================== */
-{
-  int32_t k, j, i; 
-  for (i = 0; i < *ncomp; i++)
-    if (tabcomp[i] != -1)
-      for (j = i + 1; j < *ncomp; j++)
-        if (tabcomp[j] == tabcomp[i])
-          tabcomp[j] = -1;
-  k = j = 0;
-  for (i = 0; i < *ncomp; i++)
-  {
-    tabcomp[j] = tabcomp[i];
-    if (tabcomp[i] != -1)
-      j++;
-    else
-      k++; // nb elements supprimes
-  }
-  *ncomp -= k;
-} /* ElimineDupliques() */
-
-/* ==================================== */
-static int32_t InList(int32_t e, int32_t *list, int32_t n)                       
-/* ==================================== */
-{
-/* renvoie 1 si e est dans list, 0 sinon */
-/* e : l'element a rechercher */
-/* list : la liste (tableau d'entiers) */
-/* n : le nombre d'elements dans la liste */
-  while (n > 0)
-    if (list[--n] == e) return 1;
-  return 0;
-} /* InList() */
-
-/* ==================================== */
-int32_t lwshedval(struct xvimage *image, int32_t connex)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lwshedval"
-/*! \fn int32_t lwshedval(struct xvimage *image, int32_t connex)
-    \param image (entrée/sortie) : une image 2D ndg
-    \param connex (entrée) : 4 ou 8 
-    \return code erreur : 0 si échec, 1 sinon
-    \brief ligne de partage des eaux valuée (algo MC, GB, LN)
-*/
-/*
-ndg := noyau de l'image originale
-calculer arbre et dynamiques des feuilles
-repeter
-  f = feuille de dynamique minimale
-  df = dyn(f)
-  hcf = |ndg(f) - dyn(f)| 
-  ptcol = (select x in border(f), ndg(x) == hcf)
-  vf = (select f' feuille, ptcol in border(f'))
-  ptsarc = {x in border(f) inter border(vf)}
-  pour tout x dans ptsarc faire V(x) := dyn(f)
-  supprimer f
-  raccourcir branches
-jusqu'a size(tree) ==  1
-*/
-{
-  register int32_t i, j, k, l;      /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *V;             /* l'image resultat (valuations) */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * cpct;           /* resultat : l'arbre des composantes compacte' */
-  Lifo * LIFO;                  /* liste d'attente pour les points a problemes */
-                                /* OPTIM remarque : on peut gagner de la place en 
-                                   utilisant un niveau "bidon" dans la FAH pour stocker ces points 
-                                   vu qu'ils ne peuvent se trouver dans les 2 a la fois
-                                */
-  int32_t vmin;
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-  LIFO = CreeLifoVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  V = (uint8_t *)calloc(N, sizeof(char));
-  if (V == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for V\n", F_NAME);
-      return(0);
-  }
-
-  IndicsInit(N);
-
-  /* ======================================================================= */
-  /* 1ERE ETAPE : CALCUL DE L'ARBRE DES COMPOSANTES ET DE LA DYNAMIQUE */
-  /* ======================================================================= */
-
-  BuildTree(F, rs, ps, N, connex, incr_vois,
-	    FAH, STATUS, number_nodes, node_at_level, TREE, &cpct);
-
-  CalculeDynamiqueMaxima(cpct);
-
-#ifdef DEBUG
-  AfficheCompactTree(cpct);
-#endif
-
-  /* ======================================================================= */
-  /* 2EME ETAPE : CALCUL DE LA LIGNE DE PARTAGE DES EAUX */
-  /* ======================================================================= */
-
-  Watershed(F, rs, N, incr_vois, FAH, STATUS, cpct);
-
-{ int32_t nbcomp = cpct->nbcomp;
-  int32_t h, c, comp;  
-  int32_t f, df, hcf;
-  int32_t vf, nvf, svf, ptcol, voisinf, voisinvf;
-
-  i = 0;
-  while (nbcomp > 1)
-  {
-    // trouve la feuille f de dyn. minimale
-    f = -1;
-    df = NDG_MAX+1;
-    for (k = 0; k < cpct->nbcomp; k++) 
-      if (!(cpct->flags[k] & FILTERED_OUT) && 
-           (NbFilsNonFiltres(cpct,k) == 0) && (cpct->dyn[k] < df))
-      {
-        f = k;
-        df = cpct->dyn[f];
-      }
-
-    //  hcf = |ndg(f) - dyn(f)| 
-    hcf = DECODENIV(cpct->comp[f]) - df;
-
-#ifdef DEBUGWV
-printf("f = %d ; dyn = %d ; ndg = %d ; hcf = %d\n", f, cpct->dyn[f], hcf+df, hcf);
-#endif
-
-    //  ptcol = (select x in border(f), ndg(x) == hcf)
-    // attention il faut remonter les "branches mortes" 
-    for (x = 0; x < N; x++)
-    {
-      h = F[x];
-      c = STATUS[x];
-      comp = INDEXCOMP(h,c);
-      while ((comp != cpct->pere[comp]) && (cpct->flags[cpct->pere[comp]] & FILTERED_OUT)) 
-        comp = cpct->pere[comp]; // remonte branche morte
-      if ((comp != f) && (h == hcf))
-      {
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(x, k, rs, N);
-          if (y != -1)
-	  {
-            h = F[y];
-            c = STATUS[y];
-            comp = INDEXCOMP(h,c);
-            while ((comp != cpct->pere[comp]) && (cpct->flags[cpct->pere[comp]] & FILTERED_OUT)) 
-              comp = cpct->pere[comp]; // remonte branche morte
-            if (comp == f)
-            {
-              ptcol = x;
-              goto ptcolfound;
-	    }
-	  } // if (y != -1)
-        } // for (k = 0; k < 8; k += incr_vois)
-      } // if (comp == f) 
-    } // for (x = 0; x < N; x++)
-ptcolfound:
-#ifdef DEBUGWV
-printf("ptcol = %d,%d\n", ptcol%rs, ptcol/rs);
-#endif
-
-    //  vf = (select f' feuille, ptcol in border(f'))
-    x = ptcol;
-    for (k = 0; k < 8; k += incr_vois)
-    {
-      y = voisin(x, k, rs, N);
-      if (y != -1)
-      {
-        h = F[y];
-        c = STATUS[y];
-        comp = INDEXCOMP(h,c);
-        // while ((comp != cpct->pere[comp]) && (cpct->flags[cpct->pere[comp]] & FILTERED_OUT)) 
-        //  comp = cpct->pere[comp]; // remonte branche morte
-        if ((comp != f) && !(cpct->flags[comp] & FILTERED_OUT) && (NbFilsNonFiltres(cpct,comp) == 0))
-        {
-          vf = comp;
-          nvf = h;
-          svf = c;
-          break;
-        }
-      } // if (y != -1)
-    } // for (k = 0; k < 8; k += incr_vois)
-#ifdef DEBUGWV
-printf("vf = %d, nvf = %d\n", vf, nvf);
-#endif
-
-    //  ptsarc = {x in border(f) inter border(vf)}
-    //  pour tout x dans ptsarc faire V(x) := dyn(f)
-    for (x = 0; x < N; x++)
-    {
-      voisinf = voisinvf  = 0;
-      for (k = 0; k < 8; k += incr_vois)
-      {
-        y = voisin(x, k, rs, N);
-        if (y != -1)
-        {
-          h = F[y];
-          c = STATUS[y];
-          comp = INDEXCOMP(h,c);
-	  //          while ((comp != cpct->pere[comp]) && (cpct->flags[cpct->pere[comp]] & FILTERED_OUT)) 
-          //  comp = cpct->pere[comp]; // remonte branche morte
-          if (comp == f) { voisinf = 1; printf("x = %d,%d ; y = %d,%d ; voisin de f =  %d\n", x % rs, x / rs, y % rs, y / rs, f); }
-          if (comp == vf) { voisinvf = 1; printf("x = %d,%d ; y = %d,%d ; voisin de vf =  %d\n", x % rs, x / rs, y % rs, y / rs, vf); }
-	} // if (y != -1)
-      } // for (k = 0; k < 8; k += incr_vois)
-      if (voisinf && voisinvf) 
-      {
-        V[x] = df;
-#ifdef DEBUGWV
-printf("x = %d,%d ; V[x] = %d\n", x % rs, x / rs, V[x]);
-#endif
-      }
-    } // for (x = 0; x < N; x++)
-
-    //  supprimer f
-    cpct->flags[f] |= FILTERED_OUT;
-    nbcomp--;
-#ifdef DEBUGWV
-printf("supprime %d ; nbcomp = %d\n", f, nbcomp);
-#endif
-    // fusionne f et vf
-    for (x = 0; x < N; x++)
-    {
-      h = F[x];
-      c = STATUS[x];
-      comp = INDEXCOMP(h,c);
-      if (comp == f)
-      {
-        F[x] = nvf;
-        STATUS[x] = svf;
-#ifdef DEBUGWV
-printf("x = %d,%d ; nouveau F[x] = %d\n", x % rs, x / rs, F[x]);
-#endif
-      }
-    }
-
-    //  raccourcir branches
-    //  i.e. supprimer peres des noeuds dont le pere n'a qu'un fils
-    for (comp = 0; comp < cpct->nbcomp; comp++)
-      if (!(cpct->flags[comp] & FILTERED_OUT) && (NbFilsNonFiltres(cpct,cpct->pere[comp]) == 1))
-        {
-          if (!(cpct->flags[cpct->pere[comp]] & FILTERED_OUT))
-          {          
-            cpct->flags[cpct->pere[comp]] |= FILTERED_OUT;
-            nbcomp--;
-#ifdef DEBUGWV
-printf("supprime %d ; nbcomp = %d\n", cpct->pere[comp], nbcomp);
-#endif
-	  }
-	}
-
-AfficheCompactTree(cpct);
-
-  } // while (nbcomp > 1)
-}
-
-  memcpy(F, V, N); // recopie de V dans F
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FahTermine(FAH);
-  LifoTermine(LIFO);
-  TermineCompTree(TREE);
-  TermineCompactTree(cpct);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  free(V);
-  return(1);
-} /* lwshedval() */
-
-/* ==================================== */
-int32_t lwshedtopo(struct xvimage *image, int32_t connex)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lwshedtopo"
-/*! \fn int32_t lwshedtopo(struct xvimage *image, int32_t connex)
-    \param image (entrée/sortie) : une image 2D ndg
-    \param connex (entrée) : 4 ou 8 
-    \return code erreur : 0 si échec, 1 sinon
-    \brief ligne de partage des eaux "topologique" (algo MC, GB)
-*/
-{
-  register int32_t i, j, k, l;      /* index muet */
-  register int32_t w, x, y, z;      /* index muet de pixel */
-  int32_t rs = rowsize(image);      /* taille ligne */
-  int32_t cs = colsize(image);      /* taille colonne */
-  int32_t ds = depth(image);        /* nb plans */
-  int32_t ps = rs * cs;             /* taille plan */
-  int32_t N = ps * ds;              /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  Fah * FAH;                    /* la file d'attente hierarchique */
-  int32_t incr_vois;                /* 1 pour la 8-connexite,  2 pour la 4-connexite */
-  uint32_t *STATUS;         /* etat d'un pixel - doit etre initialise a NOT_ANALYZED */
-                                /* en sortie, contient le numero de la composante de niveau h */
-                                /* qui contient le pixel (avec h = valeur du pixel) */
-  uint32_t *number_nodes;   /* nombre de composantes par niveau */
-  uint8_t *node_at_level; /* tableau de booleens */
-  CompTree * TREE;              /* resultat : l'arbre des composantes */
-  CompactTree * cpct;          /* resultat : l'arbre des composantes compacte' */
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-  } /* switch (connex) */
-
-  FAH = CreeFahVide(N);
-
-  STATUS = (uint32_t *)calloc(1,N * sizeof(int32_t));
-  if (STATUS == NULL)
-  {   fprintf(stderr, "%s() : malloc failed for STATUS\n", F_NAME);
-      return(0);
-  }
-
-  number_nodes = (uint32_t *)calloc(256, sizeof(int32_t));
-  if (number_nodes == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for number_nodes\n", F_NAME);
-      return(0);
-  }
-
-  node_at_level = (uint8_t *)calloc(256, sizeof(char));
-  if (node_at_level == NULL)
-  {   fprintf(stderr, "%s() : calloc failed for node_at_level\n", F_NAME);
-      return(0);
-  }
-  
-  TREE = InitCompTree(N);
-  if (TREE == NULL)
-  {   fprintf(stderr, "%s() : InitCompTree failed\n", F_NAME);
-      return(0);
-  }
-
-  /* ======================================================================= */
-  /* 1ERE ETAPE : CALCUL DE L'ARBRE DES COMPOSANTES */
-  /* ======================================================================= */
-
-  /* ================================================ */
-  /* INITIALISATIONS                                  */
-  /* ================================================ */
-
-  for (i = 0; i < N; i++) STATUS[i] = NOT_ANALYZED;
-  k = 0;             /* recherche un pixel k de niveau de gris minimal dans l'image */
-  for (i = 0; i < N; i++) if (F[i] < F[k]) k = i;
-  FahPush(FAH, k, F[k]);
-
-#ifdef VERBOSE
-  fprintf(stderr, "init terminee\n");
-#endif
-
-  /* ================================================ */
-  /* APPEL FONCTION RECURSIVE flood                   */
-  /* ================================================ */
-
-  if ((connex == 4) || (connex == 8))
-    (void)flood(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, incr_vois, rs, N, F); 
-  else
-    (void)flood3d(F[k], FAH, STATUS, number_nodes, node_at_level, TREE, connex, rs, ps, N, F);
-
-#ifdef VERBOSE
-  fprintf(stderr, "flood terminee\n");
-#endif
-#ifdef DEBUG
-  AfficheCompTree(TREE);
-#endif
-
-  cpct = CompTree2CompactTree(TREE, number_nodes);
-
-#ifdef VERBOSE
-  fprintf(stderr, "CompTree2CompactTree terminee\n");
-#endif
-
-#ifdef DEBUG
-  AfficheCompactTree(cpct);
-  AfficheImaComp(cpct, STATUS, rs, N, F);
-#endif
-
-  /* ======================================================================= */
-  /* 2EME ETAPE : CALCUL DE LA LIGNE DE PARTAGE DES EAUX */
-  /* ======================================================================= */
-
-  IndicsInit(N);
-  Watershed(F, rs, N, incr_vois, FAH, STATUS, cpct);
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FahTermine(FAH);
-  TermineCompTree(TREE);
-  TermineCompactTree(cpct);
-  free(STATUS);
-  free(number_nodes);
-  free(node_at_level);
-  return(1);
-} /* lwshedtopo() */
-
-#endif
-
-
-
diff -r 8b1af7363833 src/lib/lsegbi._notused_c
--- a/src/lib/lsegbi._notused_c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,685 +0,0 @@
-/* $Id: lsegbi.c,v 1.1.1.1 2008-11-25 08:01:41 mcouprie Exp $ */
-/* operateur de segmentation par inondation "double" a partir des min et des max */
-/* utilise une File d'Attente Hierarchique */
-/* Michel Couprie - fevrier 1997 */
-/* version 1.0 du 18/02/97 */
-/* version 2.0 du 13/05/99 : version homotopique */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcfahpure.h>
-#include <mclifo.h>
-#include <mcindic.h>
-#include <mctopo.h>
-#include <mcutil.h>
-#include <llabelextrema.h>
-#include <lsegbi.h>
-
-#define PARANO                 /* even paranoid people have ennemies */
-#define VERBOSE
-
-/*
-#define TRACEPOP
-#define TRACEPUSH
-#define TRACEFUS
-#define TRACEDEM
-*/
-
-//#define GRADMAX 255
-#define GRADMAX 128
-
-/*
-   Methode 1: segmentation HOMOTOPIQUE
-
-   etiquette les minima avec 1, les maxima avec 0.
-
-   pour chaque point y dans voisinage d'un point x dans un extremum, on empile dans la Fah
-   au niveau | SOURCE[x] - SOURCE[y] |, le point y ainsi qu'un code sur 3 bits indiquant
-   la direction de x.
-
-   pour un minimum, on utilise le 4-voisinage, et pour un maximum le 8-voisinage.
-
-   on retire iterativement un point y de la Fah, tant que Fah non vide.
-   si y n'est toujours pas extremum, et si le gradient n'a pas augmente, et
-     (si son voisin x code est maximum et y constructible jusqu'au niveau de x OU
-      si son voisin x code est minimum et y destructible jusqu'au niveau de x)
-   alors on fusionne y avec l'extremum voisin x
-         on empile les 'gradients' entre y et ses voisins non-extrema
-
-   CORRECTION DU GRADIENT
-
-   le gradient inf ou sup peut etre multiplie par un coefficient C: 0<C<=1
-   pour favoriser soit l'objet, soit le fond
-
-====================================================================================
-
-   Methode 2: segmentation NON HOMOTOPIQUE
-
-   etiquette les minima avec 1, les maxima avec 0.
-
-   pour chaque point y dans voisinage d'un point x dans un extremum, on empile dans la Fah
-   au niveau | SOURCE[x] - SOURCE[y] |, le point y ainsi qu'un code sur 3 bits indiquant
-   la direction de x.
-
-   pour un minimum, on utilise le 4-voisinage, et pour un maximum le 8-voisinage.
-
-   on retire iterativement un point y de la Fah, tant que Fah non vide. 
-   si y n'est toujours pas extremum, et si son voisin x code est toujours extremum,
-                                     et si le gradient n'a pas augmente,
-                                     et si y n'est ni convergent ni divergent,
-                                     et si y peut subir la transformation suivante sans
-                                       changer la topologie : 
-
-     on fusionne y avec l'extremum voisin x
- 
-     si deux minima d'altitudes differentes deviennent 4-voisins (resp. deux maxima 8-voisins) 
-     il faut demarquer le plus haut en tant que minimum (resp. le plus bas en tant que maximum) 
-
-     si y est reste extremum, on empile les 'gradients' entre y et ses voisins non-extrema
-
-     si y a ete demarque, on empile les 'gradients' entre y et ses voisin extrema
-
-   CORRECTION DU GRADIENT
-
-   le gradient inf ou sup peut etre multiplie par un coefficient C: 0<C<=1
-   pour favoriser soit l'objet, soit le fond
-
-*/
-
-/*
-#define Cmin 1.0
-#define Cmax 1.0
-*/
-
-#define CORRIGEMIN(g) ((uint8_t)(Cmin*g))
-#define CORRIGEMAX(g) ((uint8_t)(Cmax*g))
-
-#define MAXIMUM 0
-#define MINIMUM 1
-
-/* ==================================== */
-static void Demarque(
-  Lifo * LIFO,
-  uint8_t *I,
-  int32_t rs,
-  int32_t N,
-  int32_t incrvois,
-  int32_t x)
-/* ==================================== */
-{
-  int32_t y, k;
-  uint8_t niv = I[x];
-
-
-#ifdef TRACEDEM
-printf("DEMARQUE extremum incluant le point %d (%d,%d) ; incrvois = %d\n", 
-                  x, x%rs, x/rs, incrvois);
-#endif
-
-  LifoPush(LIFO, x);
-  while (! LifoVide(LIFO))
-  {
-    x = LifoPop(LIFO);
-    UnSetAll(x);
-    for (k = 0; k < 8; k += incrvois)
-    {
-      y = voisin(x, k, rs, N);
-      if ((y != -1) && (I[y] == niv) && (IsSetAny(y)))
-        LifoPush(LIFO, y);
-    } /* for k ... */
-  } /* while (! LifoVide(LIFO)) */
-} /* Demarque() */
-
-
-/*
-   y est un non-extremum, voisin de x extremum.
-   principe de l'encodage du gradient : 
-   le numero de voisin de y par rapport a x est stocke sur 3 bits, avec le codage suivant: 
-		3	2	1			
-		4	x	0
-		5	6	7
-   soit k.
-   un point y est stocke avec la direction dans laquelle on trouve
-   l'extremum x, avec le codage reciproque : 
-                7       6       5
-                0       y       4
-                1       2       3
-   soit (k+4) % 8.
-   
-   ce code est place dans les bits 29 a 31 de l'int32_t contenant y
-                                                      29
-   il reste donc 29 bits pour coder les pixels, soit 2   = 1/2 gigapixels.
-
-*/
-
-#define ENCODE(y,k) (y|(((k+4)%8)<<29))
-#define ENCODEINV(y,k) (y|(k<<29))
-#define DECODEPIX(y) (y&0x1fffffff)
-#define DECODEDIR(y) (y>>29)
-
-/* ==================================== */
-int32_t lsegbinonhomotopique(
-        struct xvimage *image,
-        int32_t connexmin,
-        double Cmin,
-        double Cmax)
-/* ==================================== */
-{
-  register uint32_t x, y, z, k;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *lab;
-  uint32_t *M;            /* pour stocker temporairement les extrema  */
-  int32_t nextrema;                /* nombre d'extrema differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  Lifo * LIFO;
-  uint32_t direction;
-  uint8_t niveau;
-  int32_t tracedate = 0;
-  int32_t grad;
-  int32_t connexmax, incrvoismin, incrvoismax;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lsegbi: cette version ne traite pas les images volumiques\n");
-    exit(0);
-  }
-
-  switch (connexmin)
-  {
-    case 4: incrvoismin = 2; incrvoismax = 1; connexmax = 8; break;
-    case 8: incrvoismin = 1; incrvoismax = 2; connexmax = 4; break;
-    default: 
-      fprintf(stderr, "lsegbi: mauvaise connexite: %d\n", connexmin);
-      return 0;
-  } /* switch (connexmin) */
-
-  IndicsInit(N);
-
-  /* ===================================================== */
-  /* etiquetage des min et des max en deux passes */
-  /* pas optimal en temps de calul mais alloue la memoire pendant peu de temps */
-  /* ===================================================== */
-
-  lab = allocimage(NULL, rs, cs, 1, VFF_TYP_4_BYTE);
-  if (lab == NULL)
-  {   
-    fprintf(stderr, "lsegbi: allocimage failed\n");
-    exit(0);
-  }
-  M = ULONGDATA(lab);
-  if (! llabelextrema(image, connexmax, LABMAX, lab, &nextrema))
-  {
-    fprintf(stderr, "lsegbi: llabelextrema failed\n");
-    exit(0);
-  }
-  for (x = 0; x < N; x++) if (M[x]) Set(x, MAXIMUM);
-  if (! llabelextrema(image, connexmin, LABMIN, lab, &nextrema))
-  {
-    fprintf(stderr, "lsegbi: llabelextrema failed\n");
-    exit(0);
-  }
-  for (x = 0; x < N; x++) if (M[x]) Set(x, MINIMUM);
-  freeimage(lab);
-
-  FAH = CreeFahVide(4 * N);
-  if (FAH == NULL)
-  {   fprintf(stderr, "lsegbi() : CreeFah failed\n");
-      return(0);
-  }
-
-  LIFO = CreeLifoVide(N);
-  if (LIFO == NULL)
-  {   fprintf(stderr, "lsegbi() : CreeLifoVide failed\n");
-      return(0);
-  }
-
-  /* ===================================================== */
-  /*                INITIALISATION DE LA FAH               */
-  /* ===================================================== */
-  
-  for (x = 0; x < N; x++)
-  {
-    if (IsSet(x, MINIMUM))           
-    {                                /* place les voisins non extrema de x dans la Fah */
-      for (k = 0; k < 8; k += incrvoismin)
-      {
-        y = voisin(x, k, rs, N);
-        if ((y != -1) && (!IsSetAny(y)))
-	{
-          FahPush(FAH, ENCODE(y,k), CORRIGEMIN((F[y]-F[x])));
-#ifdef TRACEPUSH
-printf("%d: empile(1) point %d (%d,%d) au niveau %d ; voisin MIN = %d (%d,%d)\n", 
-       tracedate++, y, y%rs, y/rs, CORRIGEMIN((F[y]-F[x])), x, x%rs, x/rs);
-#endif
-	}
-      } /* for k = 0 ... */
-    } /* if (IsSet(x, MINIMUM)) */
-    else
-    if (IsSet(x, MAXIMUM))
-    {                                /* place les voisins non extrema de x dans la Fah */
-      for (k = 0; k < 8; k += incrvoismax)
-      {
-        y = voisin(x, k, rs, N);
-        if ((y != -1) && (!IsSetAny(y)))
-	{
-          FahPush(FAH, ENCODE(y,k), CORRIGEMAX((F[x]-F[y])));
-#ifdef TRACEPUSH
-printf("%d: empile(2) point %d (%d,%d) au niveau %d ; voisin MAX = %d (%d,%d)\n", 
-       tracedate++, y, y%rs, y/rs, CORRIGEMAX((F[x]-F[y])), x, x%rs, x/rs);
-#endif
-	}
-      } /* for k = 0 ... */
-    } /* if (IsSet(x, MAXIMUM)) */
-  } /* for x */
-
-  x = FahPop(FAH);
-
-  /* ===================================================== */
-  /* INONDATION */
-  /* ===================================================== */
-
-  while (! FahVide(FAH)) 
-  {
-    niveau = FahNiveau(FAH);
-    y = FahPop(FAH);
-    direction = DECODEDIR(y);
-    y = DECODEPIX(y);
-    x = voisin(y, direction, rs, N);
-
-#ifdef TRACEPOP
-printf("%d: POP point %d (%d,%d) ; niveau %d ; dir. %d ; extr. %d (%d,%d)\n", 
-       tracedate++, y, y%rs, y/rs, niveau, direction, x, x%rs, x/rs);
-#endif
-    
-    if ((!IsSetAny(y)) && (IsSetAny(x)))  /* y non extremum et x extremum */
-    {
-      if (IsSet(x, MAXIMUM)) grad = CORRIGEMAX((F[x]-F[y]));
-      else                   grad = CORRIGEMIN((F[y]-F[x]));
-
-      if (grad <= niveau)                  /* le gradient n'a pas augmente */
-      {                                    /* "fusionne" le point y a l'extremum x */
-#ifdef TRACEFUS
-if (IsSet(x, MINIMUM))
-  printf("%d: FUSIONNE point %d (%d,%d) au mINimum %d (%d,%d)\n", 
-         tracedate++, y, y%rs, y/rs, x, x%rs, x/rs);
-else
-  printf("%d: FUSIONNE point %d (%d,%d) au mAXimum %d (%d,%d)\n", 
-         tracedate++, y, y%rs, y/rs, x, x%rs, x/rs);
-#endif
-        Indics[y] = Indics[x];
-        F[y] = F[x];
-
-        /* teste l'extinction d'extrema */
-
-        if (IsSet(y, MINIMUM))
-        for (k = 0; k < 8; k += incrvoismin)
-        {
-          z = voisin(y, k, rs, N);
-          if (z != -1)
-          {
-            if ((IsSet(z, MINIMUM)) && (F[z] > F[y]))  /* rencontre de 2 minima */
-            Demarque(LIFO, F, rs, N, incrvoismin, z);
-            else
-            if (F[y] > F[z])         /* le "minimum" de y rencontre un point inferieur */ 
-              Demarque(LIFO, F, rs, N, incrvoismin, y);
-          } /* if (z != -1) */
-        } /* for k = 0 ... */
-        else
-        if (IsSet(y, MAXIMUM))
-        for (k = 0; k < 8; k += incrvoismax)
-        {
-          z = voisin(y, k, rs, N);
-          if (z != -1)
-          {
-            if ((IsSet(z, MAXIMUM)) && (F[z] < F[y]))   /* rencontre de 2 maxima */
-              Demarque(LIFO, F, rs, N, incrvoismax, z);
-            else
-            if (F[y] < F[z])         /* le "maximum" de y rencontre un point superieur */ 
-              Demarque(LIFO, F, rs, N, incrvoismax, y);
-          } /* if (z != -1) */
-        } /* for k = 0 ... */
-  
-        /* recherche ou actualisation de candidats dans le voisinage */
-
-        if (IsSet(y, MINIMUM))
-        {
-          for (k = 0; k < 8; k += incrvoismin)
-          {
-            z = voisin(y, k, rs, N);
-            if ((z != -1) && (!IsSetAny(z)))
-            {
-              FahPush(FAH, ENCODE(z,k), CORRIGEMIN((F[z]-F[y])));
-#ifdef TRACEPUSH
-printf("%d: empile(3) point %d (%d,%d) au niveau %d ; voisin MIN = %d (%d,%d)\n", 
-       tracedate++, z, z%rs, z/rs, CORRIGEMIN((F[z]-F[y])), y, y%rs, y/rs);
-#endif
-            }
-          } /* for k = 0 ... */
-        } /* if (IsSet(y, MINIMUM)) */
-        else
-        if (IsSet(y, MAXIMUM))
-        {
-          for (k = 0; k < 8; k += incrvoismax)
-          {
-            z = voisin(y, k, rs, N);
-            if ((z != -1) && (!IsSetAny(z)))
-            {
-              FahPush(FAH, ENCODE(z,k), CORRIGEMAX((F[y]-F[z])));
-#ifdef TRACEPUSH
-printf("%d: empile(4) point %d (%d,%d) au niveau %d ; voisin MAX = %d (%d,%d)\n", 
-       tracedate++, z, z%rs, z/rs, CORRIGEMAX((F[y]-F[z])), y, y%rs, y/rs);
-#endif
-	    }
-          } /* for k = 0 ... */
-        } /* if (IsSet(y, MAXIMUM)) */
-        else                             /* y a ete "demarque" */
-        {                                /* on doit chercher un extremum dans le voisinage */
-          for (k = 0; k < 8; k += incrvoismax)
-          {
-            z = voisin(y, k, rs, N);
-            if ((z != -1) && (IsSet(z, MAXIMUM)))
-            {
-              FahPush(FAH, ENCODEINV(y,k), CORRIGEMAX((F[z]-F[y])));
-#ifdef TRACEPUSH
-printf("%d: empile(5) point %d (%d,%d) au niveau %d ; voisin MAX = %d (%d,%d)\n", 
-       tracedate++, y, y%rs, y/rs, CORRIGEMAX((F[z]-F[y])), z, z%rs, z/rs);
-#endif
-	    }
-	  } /* for k = 0 ... */
-          for (k = 0; k < 8; k += incrvoismin)
-          {
-            z = voisin(y, k, rs, N);
-            if ((z != -1) && (IsSet(z, MINIMUM)))
-            {
-              FahPush(FAH, ENCODEINV(y,k), CORRIGEMIN((F[y]-F[z])));
-#ifdef TRACEPUSH
-printf("%d: empile(6) point %d (%d,%d) au niveau %d ; voisin MIN = %d (%d,%d)\n", 
-       tracedate++, y, y%rs, y/rs, CORRIGEMIN((F[y]-F[z])), z, z%rs, z/rs);
-#endif
-	    }          
-          } /* for k = 0 ... */
-        } /* y a ete "demarque" */
-      } /* if (grad <= niveau) */
-    } /* if ((!IsSetAny(x)) ... */
-  } /* while (! FahVide(FAH)) */
-  /* FIN INONDATION */
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  IndicsTermine();
-  FahTermine(FAH);
-  LifoTermine(LIFO);
-  return(1);
-} /* segbinonhomotopique() */
-
-/* ==================================== */
-int32_t lsegbihomotopique(
-        struct xvimage *image,
-        int32_t connexmin,
-        double Cmin,
-        double Cmax)
-/* ==================================== */
-{
-  register uint32_t x, y, z, k;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *labmin;
-  struct xvimage *labmax;
-  int32_t *Min, *Max;
-  int32_t nmin, nmax;              /* nombre d'extrema differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  uint32_t direction;
-  uint8_t niveau;
-  int32_t tracedate = 0;
-  int32_t grad;
-  int32_t connexmax, incrvoismin, incrvoismax;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lsegbi: cette version ne traite pas les images volumiques\n");
-    exit(0);
-  }
-
-  switch (connexmin)
-  {
-    case 4: incrvoismin = 2; incrvoismax = 1; connexmax = 8; break;
-    case 8: incrvoismin = 1; incrvoismax = 2; connexmax = 4; break;
-    default: 
-      fprintf(stderr, "lsegbi: mauvaise connexite: %d\n", connexmin);
-      return 0;
-  } /* switch (connexmin) */
-
-  /* ===================================================== */
-  /* etiquetage des min et des max en deux passes */
-  /* pas optimal */
-  /* ===================================================== */
-
-  labmin = allocimage(NULL, rs, cs, 1, VFF_TYP_4_BYTE);
-  labmax = allocimage(NULL, rs, cs, 1, VFF_TYP_4_BYTE);
-  if ((labmin == NULL) || (labmax == NULL))
-  {   
-    fprintf(stderr, "lsegbi: allocimage failed\n");
-    exit(0);
-  }
-  Min = ULONGDATA(labmin);
-  Max = ULONGDATA(labmax);
-
-  if (! llabelextrema(image, connexmax, LABMAX, labmax, &nmax))
-  {
-    fprintf(stderr, "lsegbi: llabelextrema failed\n");
-    exit(0);
-  }
-
-  if (! llabelextrema(image, connexmin, LABMIN, labmin, &nmin))
-  {
-    fprintf(stderr, "lsegbi: llabelextrema failed\n");
-    exit(0);
-  }
-
-  for (x = 0; x < N; x++) /* on range dans labmin les etquettes des minima */
-    if (Min[x] != 0)      /* (en negatif) et celles des maxima (en positif) */
-      Min[x] = -Min[x];
-    else if (Max[x] != 0) 
-      Min[x] = Max[x];
-
-  freeimage(labmax);
-
-  /* ===================================================== */
-  /*                INITIALISATION DE LA FAH               */
-  /* ===================================================== */
-
-  FAH = CreeFahVide(4 * N);
-  if (FAH == NULL)
-  {   fprintf(stderr, "lsegbi() : CreeFah failed\n");
-      return(0);
-  }
-  
-  for (x = 0; x < N; x++)
-  {
-    if (Min[x] < 0) /* MINIMUM */
-    {                                /* place les voisins non extrema de x dans la Fah */
-      for (k = 0; k < 8; k += incrvoismin)
-      {
-        y = voisin(x, k, rs, N);
-        if ((y != -1) && (Min[y] == 0) && (CORRIGEMIN((F[y]-F[x])) <= GRADMAX))
-	{
-          FahPush(FAH, ENCODE(y,k), CORRIGEMIN((F[y]-F[x])));
-#ifdef TRACEPUSH
-printf("%d: empile(1) point (%d,%d|%d) prio %d ; voisin MIN = (%d,%d|%d)\n", 
-       tracedate++, y%rs, y/rs, F[y], CORRIGEMIN((F[y]-F[x])), x%rs, x/rs, F[x]);
-#endif
-	}
-      } /* for k = 0 ... */
-    } /* if x MINIMUM */
-    else
-    if (Min[x] > 0) /* MAXIMUM */
-    {                                /* place les voisins non extrema de x dans la Fah */
-      for (k = 0; k < 8; k += incrvoismax)
-      {
-        y = voisin(x, k, rs, N);
-        if ((y != -1) && (Min[y] == 0) && (CORRIGEMAX((F[x]-F[y])) <= GRADMAX))
-	{
-          FahPush(FAH, ENCODE(y,k), CORRIGEMAX((F[x]-F[y])));
-#ifdef TRACEPUSH
-printf("%d: empile(2) point (%d,%d|%d) prio %d ; voisin MAX = (%d,%d|%d)\n", 
-       tracedate++, y%rs, y/rs, F[y], CORRIGEMAX((F[x]-F[y])), x%rs, x/rs, F[x]);
-#endif
-	}
-      } /* for k = 0 ... */
-    } /* if x MAXIMUM */
-  } /* for x */
-
-  x = FahPop(FAH);
-
-  /* ===================================================== */
-  /* INONDATION */
-  /* ===================================================== */
-
-fprintf(stderr, "debut inondation\n");
-
-  while (! FahVide(FAH)) 
-  {
-    niveau = FahNiveau(FAH);
-    y = FahPop(FAH);
-    direction = DECODEDIR(y);
-    y = DECODEPIX(y);
-    x = voisin(y, direction, rs, N);
-
-#ifdef TRACEPOP
-printf("%d: POP point (%d,%d|%d) ; prio %d ; dir. %d ; extr. (%d,%d|%d)\n", 
-       tracedate++, y%rs, y/rs, F[y], niveau, direction, x%rs, x/rs, F[x]);
-#endif
-    
-    /*
-     si y n'est toujours pas extremum, et si le gradient n'a pas augmente, et
-       (si son voisin x code est maximum et y constructible jusqu'au niveau de x 
-        OU
-        si son voisin x code est minimum et y destructible jusqu'au niveau de x
-       )
-     alors on fusionne y avec l'extremum voisin x
-           on empile les 'gradients' entre y et ses voisins non-extrema
-    */
-    if (Min[y] == 0)
-    {
-      if (Min[x] > 0) /* x MAXIMUM */
-      { 
-        grad = CORRIGEMAX((F[x]-F[y]));
-        if (grad <= niveau)                  /* le gradient n'a pas augmente */
-        {
-          uint8_t oldvy = F[y];
-          int32_t pp;
-          if (connexmin == 4)
-	  {
-            pp = beta4m(F, y, rs, N); /* A AMELIORER: si le test pp echoue, ne pas faire la suite */
-#define LAMBDA 255
-#ifdef LAMBDA    
-            while (lambdaconstr4(F, y, LAMBDA, rs, N)) F[y] = alpha8p(F, y, rs, N); /* 8p: sic */
-#else                                                  
-            while (pconstr4(F, y, rs, N)) F[y] = alpha8p(F, y, rs, N); /* 8p: sic */
-#endif
-	  }
-          else /* if (connexmin == 8) */
-	  {
-            pp = beta8m(F, y, rs, N);
-#ifdef LAMBDA    
-            printf("lambdaconstr8: not yet implemented\n"); exit(0);
-#else                                                  
-            while (pconstr8(F, y, rs, N)) F[y] = alpha8p(F, y, rs, N);
-#endif
-	  }
-          if ((F[y] != F[x]) || ((pp != -1) && PlusProche(oldvy,pp,F[x])))
-            F[y] = oldvy;              /* on remet y a sa valeur originale */
-          else
-	  {
-#ifdef TRACEFUS
-            printf("%d: FUSIONNE point (%d,%d|%d) au mAXimum (%d,%d|%d)\n", 
-            tracedate++, y%rs, y/rs, F[y], x%rs, x/rs, F[x]);
-#endif
-            Min[y] = Min[x];
-            for (k = 0; k < 8; k += incrvoismax)
-            {
-              z = voisin(y, k, rs, N);
-              if ((z != -1) && (Min[z] == 0) && (CORRIGEMAX((F[y]-F[z])) <= GRADMAX))
-              {
-                FahPush(FAH, ENCODE(z,k), CORRIGEMAX((F[y]-F[z])));
-#ifdef TRACEPUSH
-printf("%d: empile(4) point (%d,%d|%d) au niveau %d ; voisin MAX = (%d,%d|%d)\n", 
-        tracedate++, z%rs, z/rs, F[z], CORRIGEMAX((F[y]-F[z])), y%rs, y/rs, F[y]);
-#endif
-	      }
-            } /* for k = 0 ... */
-	  }
-	} /* if (grad <= niveau) */
-      } /* if x MAXIMUM */
-      else
-      { /* if x  MINIMUM */
-        grad = CORRIGEMIN((F[y]-F[x]));
-        if (grad <= niveau)                  /* le gradient n'a pas augmente */
-        {
-          uint8_t oldvy = F[y];
-          int32_t pp;
-          if (connexmin == 4)
-	  {
-            pp = beta8p(F, y, rs, N);
-#ifdef LAMBDA    
-            while (lambdadestr4(F, y, LAMBDA, rs, N)) F[y] = alpha8m(F, y, rs, N); /* 8p: sic */
-#else                                                  
-            while (pdestr4(F, y, rs, N)) F[y] = alpha8m(F, y, rs, N); /* 8m: sic */
-#endif
-	  }
-          else /* if (connexmin == 8) */
-	  {
-            pp = beta4p(F, y, rs, N);
-#ifdef LAMBDA    
-            printf("lambdadestr8: not yet implemented\n"); exit(0);
-#else                                                  
-            while (pdestr8(F, y, rs, N)) F[y] = alpha8m(F, y, rs, N);
-#endif
-	  }
-          if ((F[y] != F[x]) || ((pp != -1) && PlusProche(oldvy,pp,F[x])))
-            F[y] = oldvy;        /* on remet y a sa valeur originale */
-          else
-	  {
-#ifdef TRACEFUS
-            printf("%d: FUSIONNE point (%d,%d|%d) au mINimum (%d,%d|%d)\n", 
-            tracedate++, y%rs, y/rs, F[y], x%rs, x/rs, F[x]);
-#endif
-            Min[y] = Min[x];
-            for (k = 0; k < 8; k += incrvoismin)
-            {
-              z = voisin(y, k, rs, N);
-              if ((z != -1) && (Min[z] == 0) && (CORRIGEMAX((F[z]-F[y])) <= GRADMAX))
-              {
-                FahPush(FAH, ENCODE(z,k), CORRIGEMIN((F[z]-F[y])));
-#ifdef TRACEPUSH
-printf("%d: empile(3) point (%d,%d|%d) au niveau %d ; voisin MIN = (%d,%d|%d)\n", 
-       tracedate++, z%rs, z/rs, F[z], CORRIGEMIN((F[z]-F[y])), y%rs, y/rs, F[y]);
-#endif
-              }
-            } /* for k = 0 ... */
-	  }
-        } /* if (grad <= niveau) */
-      } /* if x MINIMUM */
-    } /* if y non extremum ... */
-  } /* while (! FahVide(FAH)) */
-  /* FIN INONDATION */
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  FahTermine(FAH);
-  freeimage(labmin);
-  return(1);
-} /* segbihomotopique() */
diff -r 8b1af7363833 src/lib/lsegellipse._notused_c
--- a/src/lib/lsegellipse._notused_c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lsegellipse._notused_c	Mon Jan 13 15:50:10 2014 +0100
@@ -128,7 +128,7 @@
     fprintf(stderr, "lsegellipse: allocimage failed\n");
     return 0;
   }
-  LABEL = ULONGDATA(labels);
+  LABEL = SLONGDATA(labels);
 
   if (!llabelextrema(img, connex, minimum, labels, &n))
   {
diff -r 8b1af7363833 src/lib/lsegment.c
--- a/src/lib/lsegment.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1789 +0,0 @@
-/* $Id: lsegment.c,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-/* operateur interactif (ou non) de segmentation */
-/* utilise une File d'Attente Hierarchique */
-/* utilise un arbre des composantes (anciennement nomme captation basin tree, CBT) */
-/* Michel Couprie - novembre 1996 */
-/* version 5 du 16/01/99 */
-/*
-  20/1/97 : correction de la mesure de la profondeur 
-  5/08/97 : affichage en niveaux de gris
-  25/O8/97 : connexites 4 ou 8
-  01/09/97 : zoom (x 4)
-  1/2/98 : - retire   UnSetAll(x);   apres        ncc = 0; x = FahPop(FAH);
-           - remplace
-               n = FirstSon(CBT, y + 1) - FirstSon(CBT, y);
-             par
-               if (y < nbcell - 1)
-                 n = FirstSon(CBT, y + 1) - FirstSon(CBT, y);
-               else
-                 n = nbcell - 2 - FirstSon(CBT, y);
-           - nouvelle construction de l'arbre : travaille au niveau des plateaux et
-             non plus des pixels
-  14/3/98 : ajoute le perimetre et l'indice de circularite
-            la circularite est definie dans le continu par le rapport :
-                                          2
-                     4 . PI . Surf / Perim        et vaut 1 pour un disque. 
-
-            en discret, une etude empirique donne les facteurs K1 ou K2 a la place de 4.PI,
-            avec K1 = 256/21 pour Perim <= 16, et K2 = 13924/757 sinon.
-  18/3/98 : etude de la signature des attributs 
-  20/3/98 : ajout de l'attribut "distance a la racine" (RDIST)
-  28/3/98 : ajout de l'attribut "nombre de trous" (TROU)
-  29/3/98 : corrige le bug de SURF
-  29/3/98 : ajout de l'attribut "densite de trous" (DTROU = TROU*10000/SURF)
-  08/4/98 : ajout de l'attribut excentricite
-  29/5/98 : integration des versions non-interactive et interactive
-  14/12/98 : affichage du nombre de composantes pertinentes (en mode verbose)
-  16/01/99 : separation VERSION_EXPERIMENTALE (#define) de la version "stable"
-  20/4/00 : corrige bug 
-*/
-
-#define PARANO                 /* even paranoid people have ennemies */
-/*
-#define VERBOSE
-*/
-#define VOL2
-
-/*
-#define ZOOM4
-#define DEBUGSURF
-#define TRACECBT
-#define MOMENTS        A REVOIR
-*/
-
-/*
-   Methode : 
-
-===============================================
- CONSTRUCTION DU CBT
-===============================================
-  entree : une image F
-  sortie : le CBT, l'application M: Dom(F) -> CBT
-
-  M <- etiquettes des minima de F
-  nminima <- nombre de minima de F
-  init(CBT, nminima)
-  pour tout point x de Dom(F)
-    si x appartient a un minimum
-      SetData(CBT, M[x], F[x] + 1);
-      pour tout y dans gamma4(x)
-        si y n'appartient pas a un minimum et pas deja dans FAH
-          FahPush(FAH, y, F[y]);
-        finsi
-      finpour
-    finsi
-  finpour
-
-  tant que FAH non vide
-    x = FahPop(FAH);
-    etiqcc = liste des M[y], y dans le voisinage du plateau de x
-    diffanc = liste des ancetres differents des etiquettes de etiqcc dans le CBT
-    si |diffanc| == 1
-      M[x] = first(diffanc)
-    sinon
-      new = CreateCell(CBT)
-      M[x] = new
-      SetData(CBT, new, F[x] + 1)
-      pour tout a dans diffanc 
-        SetFather(CBT, a, new)
-      finpour
-    fin si
-    pour tout y dans gamma4(x) pas deja dans FAH
-      si M[y] == 0
-        FahPush(FAH, y, F[y]);
-      finsi
-    finpour
-  fintantque
-
-  regularise(CBT) 
-
-===============================================
- SEGMENTATION
-===============================================
-
-  en parallele avec la construction du CBT, on a recueilli une "mesure" (MU)
-  des bassins versants.
-
-  ici cette mesure est la surface de la plus grande coupe d'un BV avant sa fusion
-  avec un autre.
-
-  l'algorithme de segmentation est alors:
-
-  1ERE ETAPE : SELECTIONNE LE NB MAX DE CC PERTINENTES
-
-  init:  ranger au niveau 0 de la FAH les feuilles du CBT
-
-  tant que FAH non vide faire
-    k = FAHNIVEAU()
-    x = FAHPOP()
-    si MU[c] >= seuil alors
-      marque les ancetres de x "INVALIDE"
-      marque x "PERTINENT"
-    sinon
-      si pere(x) existe et non INVALIDE alors FAHPUSH(pere(x), k+1) finsi
-    finsi
-  fintantque
-
-  2EME ETAPE (FACULTATIVE) : MAXIMISE AU SENS DE L'INCLUSION 
-
-  Re-init:  ranger a leur niveau data dans la FAH les cellules PERTINENTes
-
-  I = arbre inverse
-
-  tant que FAH non vide faire
-    x = FAHPOP()
-    y = pere(x)
-    si y existe alors 
-      k = FirstSon(y)
-      n = FirstSon(y + 1) - FirstSon(y)
-      nbfilspert = 0
-      pour i de 0 a n-1 faire
-        si Label(I[k+i]) == PERTINENT
-          nbfilspert++ finsi finpour
-      si nbfilspert == 1 alors
-        Label(x) = NONMARQUE
-        Label(y) = PERTINENT
-        FahPush(y, Data(y))
-      finsi
-    finsi
-  fintantque
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <math.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mclifo.h>
-#include <mcfah.h>
-#include <mcindic.h>
-#include <mccbt.h>
-#include <mctopo.h>
-#include <mcxbib.h>
-#include <lsegment.h>
-
-#define EN_FAH     0
-#define MINIMUM    1
-#define MARQUE1    2
-#define MARQUE2    3
-#define MARQUETROU 4
-
-#define NONMARQUE  0
-#define INVALIDE   1
-#define PERTINENT  2
-
-#define K1 (256.0/21.0)
-#define K2 (13924.0/757.0)
-
-#include <unistd.h>
-/* ==================================== */
-static void visualise(int32_t tabres[], char * c, int32_t x, int32_t y)
-/* ==================================== */
-{
-  int32_t i, lastv;
-  FILE *fd = NULL;
-  char filename[32];
-/*
-  for (i = 0; i < 256; i++)
-    if (tabres[i] != -1)
-      printf("%d:%d ", i, tabres[i]);
-  printf("\n");
-*/
-  sprintf(filename, "_%s_%d_%d.sign", c, x, y);
-  fd = fopen(filename, "w");
-  if (!fd)
-  {
-    fprintf(stderr, "lsegment: unable to open file: %s\n", filename);
-    exit (0);
-  }
-  fprintf(fd, "\"%s\n", c);
-  fprintf(fd, "%d %d\n", 0, 0);
-  lastv = 0;
-  for (i = 0; i < 256; i++)
-    if (tabres[i] != -1)
-    {
-      fprintf(fd, "%d %d\n", i, lastv);
-      fprintf(fd, "move %d %d\n", i, tabres[i]);
-      lastv = tabres[i];
-    }
-  fprintf(fd, "%d %d\n", 255, lastv);
-
-  if (fork() == 0) /* fils - processus xgraph */
-  {
-    execlp("xgraph", "xgraph", "=400x180+0+0", "-lw", "4", filename, NULL);
-    perror("xgraph");
-  }
-
-  fclose(fd);
-} /* visualise() */
-
-#ifdef MOMENTS
-/* ==================================== */
-int32_t excentricity(double mx1, double my1, double mx2, double my2, 
-                 double mxy2, int32_t n)
-/* ==================================== */
-{
-  double Mx2, My2, Mxy2, delta;
-  double lambda1, lambda2;
-
-  /* moments d'ordre 2 */
-  Mx2 = mx2 - mx1 * mx1 / n;  
-  My2 = my2 - my1 * my1 / n;  
-  Mxy2 = mxy2 - mx1 * my1 / n;
-
-  /* calcul des valeurs propres de la matrice des covariances */
-  delta = (Mx2 - My2) * (Mx2 - My2) + 4 * Mxy2 * Mxy2;
-  lambda1 = (Mx2 + My2 + sqrt(delta)) / 2.0;
-  lambda2 = (Mx2 + My2 - sqrt(delta)) / 2.0;
-#ifdef DEBUGEXCEN
-  printf("Mx2 = %g ; My2 = %g ; Mxy2 = %g ; delta = %g\n", Mx2, My2, Mxy2, delta);
-  printf("lambda1 = %g ; lambda2 = %g\n", lambda1, lambda2);
-#endif
-  if (lambda2 < 0.0)
-  {
-    fprintf(stderr, "excentricity : valeur propre negative : %g\n", lambda2);
-    return 0;
-  }
-  return 255 - (int32_t)(lambda2 * 255 / lambda1);
-} /* excentricity() */
-#endif
-
-/* ==================================== */
-static
-int32_t circ(int32_t area, int32_t perim)
-/* ==================================== */
-{
-  int32_t val_attrib;
-  if (perim <= 30)
-    val_attrib = (int32_t)(100 * K1 * (double)area / (double)(perim * perim));
-  else
-    val_attrib = (int32_t)(100 * K2 * (double)area / (double)(perim * perim));
-  if (val_attrib > 100) return 100;
-  return val_attrib;
-} /* circ() */
-
-/* ==================================== */
-static
-int32_t dtrou(int32_t area, int32_t trou)
-/* ==================================== */
-{
-  return (10000 * trou) / area;
-} /* dtrou() */
-
-/* ==================================== */
-static
-void signature(int32_t mesure, int32_t X, int32_t Y, int32_t * M, cbtcell * CBT, int32_t rs, 
-               int32_t *SURF, int32_t *PROF, int32_t *VOL, int32_t *PER, 
-               uint8_t *RDIST, int32_t *TROU, uint8_t *EXCEN)
-/* ==================================== */
-{
-  int32_t tabres[256];
-  int32_t i;
-
-  for (i = 0; i < 256; i++) tabres[i] = -1;
-
-  if (mesure & PROFONDEUR)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)] = PROF[i]; i = Father(CBT, i); }
-    visualise(tabres, "prof", X, Y);
-  }
-  if (mesure & SURFACE)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)] = SURF[i]; i = Father(CBT, i); }
-    visualise(tabres, "surf", X, Y);
-  }
-  if (mesure & VOLUME)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)] = VOL[i]; i = Father(CBT, i); }
-    visualise(tabres, "vol", X, Y);
-  }
-#ifdef VERSION_EXPERIMENTALE
-  if (mesure & PERIMETRE)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)] = PER[i]; i = Father(CBT, i); }
-    visualise(tabres, "perim", X, Y);
-  }
-  if (mesure & CIRCULARITE)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)]=circ(SURF[i],PER[i]); i=Father(CBT,i); }
-    visualise(tabres, "circ", X, Y);
-  }
-  if (mesure & ROOTDIST)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)]= RDIST[i]; i=Father(CBT,i); }
-    visualise(tabres, "rdist", X, Y);
-  }
-  if (mesure & NBTROUS)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)]= TROU[i]; i=Father(CBT,i); }
-    visualise(tabres, "trou", X, Y);
-  }
-  if (mesure & DENSTROUS)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)]= dtrou(SURF[i],TROU[i]); i=Father(CBT,i); }
-    visualise(tabres, "dtrou", X, Y);
-  }
-#ifdef MOMENTS
-  if (mesure & EXCENTRICITE)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)]= EXCEN[i]; i=Father(CBT,i); }
-    visualise(tabres, "excen", X, Y);
-  }
-#endif
-#endif
-} /* signature() */
-
-
-/* ==================================== */
-static
-void printcomp(int32_t X, int32_t Y, int32_t * M, cbtcell * CBT, int32_t rs,
-               int32_t *SURF, int32_t *PROF, int32_t *VOL, int32_t *PER, 
-               uint8_t *RDIST, int32_t *TROU, uint8_t *EXCEN)
-/* ==================================== */
-{
-  int32_t x = M[Y*rs + X];
-  printf("niveau %d (%d, point %d,%d) \n", 
-          Data(CBT, x), x, X, Y);
-
-  while ((x != NIL) && (Label(CBT,x) == NONMARQUE)) 
-    x = Father(CBT,x);
-  if (Label(CBT,x) == PERTINENT)
-    printf("composante PERTINENTE de niveau %d (%d, point %d,%d) \n", 
-            Data(CBT, x), x, X, Y);
-  else
-    printf("composante NON PERTINENTE de niveau %d (%d, point %d,%d) \n", 
-            Data(CBT, x), x, X, Y);
-#ifdef VERSION_EXPERIMENTALE
-#ifdef MOMENTS
-  printf("PROF\tSURF\tVOL(K)\tPER\tCIRC\tRDIST\tTROU\tDTROU\tEXCEN\n");
-  printf("%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", 
-          PROF[x], SURF[x], VOL[x]/1000, PER[x], circ(SURF[x],PER[x]), 
-          RDIST[x], TROU[x], dtrou(SURF[x],TROU[x]), EXCEN[x]);
-#else
-  printf("PROF\tSURF\tVOL(K)\tPER\tCIRC\tRDIST\tTROU\tDTROU\n");
-  printf("%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", 
-          PROF[x], SURF[x], VOL[x]/1000, PER[x], circ(SURF[x],PER[x]), 
-          RDIST[x], TROU[x], dtrou(SURF[x],TROU[x]));
-#endif
-#else
-  printf("PROF\tSURF\tVOL(K)\n");
-  printf("%d\t%d\t%d\n", 
-          PROF[x], SURF[x], VOL[x]/1000);
-#endif
-} /* printcomp() */
-
-#ifdef VERSION_EXPERIMENTALE
-/* ==================================== */
-int32_t contribperim(int32_t w, uint8_t *F, uint8_t h, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t t4mm, t4m, t8p, t8pp;
-  if ((w%rs==rs-1) || (w<rs) || (w%rs==0) || (w>=N-rs)) return 1; /* point de bord */
-  nbtopoh(F, w, h, rs, N, &t4mm, &t4m, &t8p, &t8pp);
-  return t8pp;  /* les points de T8pp=n sont comptes n fois dans le perimetre */
-} /* contribperim() */
-#endif
-
-/* ==================================== */
-int32_t lsegment(struct xvimage *image, 
-             int32_t connex, 
-             int32_t mesure,  /* masque binaire des mesures utilisees (0: interactif) */
-             int32_t seuilsurf,
-             int32_t seuilprof,
-             int32_t seuilvol,
-#ifdef VERSION_EXPERIMENTALE
-             int32_t seuilperim,
-             int32_t seuilcirc,
-             int32_t seuilrdist,
-             int32_t seuiltrou,
-             int32_t seuildtrou,
-             int32_t seuilexcen,
-#endif
-             int32_t maximise)
-/* ==================================== */
-{
-  register int32_t i, k, l;        /* index muet */
-  register int32_t w, x, y, z;     /* index muet de pixel */
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *TEMP;         /* pour la recuperation de la segmentation */
-  int32_t *M;                     /* l'image d'etiquettes de composantes connexes */
-  int32_t label;
-  int32_t *T;                      /* table de correspondance pour regularisation */
-  int32_t *I;                      /* pour l'inversion du CBT */
-  int32_t nminima;                 /* nombre de minima differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  Lifo * LIFO;                 /* pour parcourir un plateau */
-  cbtcell * CBT;               /* arbre des bassins versants (Catchment Basin Tree) */
-  int32_t nbcell;
-  int32_t nbmaxcell;
-  int32_t *etiqcc;
-  int32_t nccmax;
-  int32_t ncc;
-  int32_t new;
-  int32_t prof;
-  int32_t *SURF;                   /* pour le stockage de la surface */
-  int32_t *PROF;                   /* pour le stockage de la profondeur */
-  int32_t *DERPROF;                /* pour le stockage de la derniere profondeur */
-  int32_t *VOL;                    /* pour le stockage du volume */
-#ifdef VERSION_EXPERIMENTALE
-  uint8_t *CONTRIPER;    /* pour le calcul du perimetre */
-  int32_t *PER;                    /* pour le stockage du perimetre */
-  int32_t *TROU;                   /* pour le stockage du nombre de trous */
-  uint8_t *RDIST;        /* pour le stockage de la dist. a la racine */
-#ifdef MOMENTS
-  uint8_t *EXCEN;        /* pour le stockage de l'excentricite */
-  double *mx1;                 /* moments */
-  double *my1;                 /*    -    */
-  double *mx2;                 /*    -    */
-  double *my2;                 /*    -    */
-  double *mxy2;                /*    -    */
-#endif
-#endif
-  int32_t increment = 1;
-  int32_t incr_vois;
-  int32_t h;
-  int32_t tailleplateau;
-#define NBBUTTONS 7
-#define BOXWIDTH 70
-#define BOXHEIGHT 20
-#ifdef VERSION_EXPERIMENTALE
-#ifdef MOMENTS
-#define NBLIGBUTT 7
-#else
-#define NBLIGBUTT 6
-#endif
-#else
-#define NBLIGBUTT 3
-#endif
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int32_t xx, yy;
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT;
-  int32_t Width = rs;
-  int32_t ImageHeight = cs;
-  int32_t ImageWidth = rs;
-  int32_t interactif;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lsegment: cette version ne traite pas les images volumiques\n");
-    exit(0);
-  }
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-    default: 
-      fprintf(stderr, "lsegment: mauvaise connexite: %d\n", connex);
-      return 0;
-  } /* switch (connex) */
-
-interactif = 0;
-if (mesure == 0)      /* version interactive */
-{
-  interactif = 1;
-  mesure = PROFONDEUR; 
-  seuilsurf = 1;
-  seuilprof = 0;
-  seuilvol = 0;
-#ifdef VERSION_EXPERIMENTALE
-  seuilperim = 0;
-  seuilcirc = 0;
-  seuilrdist = 0;
-  seuiltrou = 0;
-  seuildtrou = 0;
-  seuilexcen = 0;
-#endif
-  maximise = 0;
-
-#ifdef ZOOM4
-  Height += cs;
-  Width += rs;
-  ImageHeight += cs;
-  ImageWidth += rs;
-#endif
-  if (BoxWidth * NBBUTTONS > Width) Width = BoxWidth * NBBUTTONS;
-  
-#ifdef COLOR
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-#else
-  InitGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-#endif
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], " SURF");
-  sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "  1  ");
-  strcpy(ButtonStrings[0][5], " 10  ");
-  strcpy(ButtonStrings[0][6], " MIN ");
-
-  strcpy(ButtonStrings[1][0], " PROF");
-  sprintf(ButtonStrings[1][1], "%d", seuilprof);
-  strcpy(ButtonStrings[1][2], "  +  ");
-  strcpy(ButtonStrings[1][3], "  -  ");
-  strcpy(ButtonStrings[1][4], " 100 ");
-  strcpy(ButtonStrings[1][5], " 1000");
-  strcpy(ButtonStrings[1][6], "     ");
-
-#ifdef VOL2
-  strcpy(ButtonStrings[2][0], " VOL ");
-  sprintf(ButtonStrings[2][1], "%d", seuilvol);
-#endif
-#ifdef VERSION_EXPERIMENTALE
-#ifdef PER2
-  strcpy(ButtonStrings[2][0], " PER ");
-  sprintf(ButtonStrings[2][1], "%d", seuilperim);
-#endif
-#ifdef TROU2
-  strcpy(ButtonStrings[2][0], " TROU");
-  sprintf(ButtonStrings[2][1], "%d", seuiltrou);
-#endif
-#endif
-  strcpy(ButtonStrings[2][2], "  +  ");
-  strcpy(ButtonStrings[2][3], "  -  ");
-  strcpy(ButtonStrings[2][4], "10000");
-  strcpy(ButtonStrings[2][5], " OK  ");
-  strcpy(ButtonStrings[2][6], " QUIT");
-
-#ifdef VERSION_EXPERIMENTALE
-  strcpy(ButtonStrings[3][0], "RDIST");
-  sprintf(ButtonStrings[3][1], "%d", seuilrdist);
-  strcpy(ButtonStrings[3][2], "  +  ");
-  strcpy(ButtonStrings[3][3], "  -  ");
-  strcpy(ButtonStrings[3][4], "     ");
-  strcpy(ButtonStrings[3][5], "     ");
-  strcpy(ButtonStrings[3][6], "     ");
-
-  strcpy(ButtonStrings[4][0], " CIRC");
-  sprintf(ButtonStrings[4][1], "%d", seuilcirc);
-  strcpy(ButtonStrings[4][2], "  +  ");
-  strcpy(ButtonStrings[4][3], "  -  ");
-  strcpy(ButtonStrings[4][4], "     ");
-  strcpy(ButtonStrings[4][5], "     ");
-  strcpy(ButtonStrings[4][6], "     ");
-
-  strcpy(ButtonStrings[5][0], "DTROU");
-  sprintf(ButtonStrings[5][1], "%d", seuildtrou);
-  strcpy(ButtonStrings[5][2], "  +  ");
-  strcpy(ButtonStrings[5][3], "  -  ");
-  strcpy(ButtonStrings[5][4], "     ");
-  strcpy(ButtonStrings[5][5], "     ");
-  strcpy(ButtonStrings[5][6], "     ");
-#ifdef MOMENTS
-  strcpy(ButtonStrings[6][0], "EXCEN");
-  sprintf(ButtonStrings[6][1], "%d", seuilexcen);
-  strcpy(ButtonStrings[6][2], "  +  ");
-  strcpy(ButtonStrings[6][3], "  -  ");
-  strcpy(ButtonStrings[6][4], "     ");
-  strcpy(ButtonStrings[6][5], "     ");
-  strcpy(ButtonStrings[6][6], "     ");
-#endif
-#endif
-} /* if (mesure == 0) */
-
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "lsegment() : CreeFah failed\n");
-      return(0);
-  }
-
-  LIFO = CreeLifoVide(N);
-  if (LIFO == NULL)
-  {   fprintf(stderr, "lsegment() : CreeLifoVide failed\n");
-      return(0);
-  }
-
-#ifdef VERSION_EXPERIMENTALE
-  CONTRIPER = (uint8_t *)calloc(N, sizeof(char));
-  if (CONTRIPER == NULL)
-  {   fprintf(stderr, "lsegment() : calloc failed for CONTRIPER\n");
-      return(0);
-  }
-#endif
-
-  /* =================================================== */
-  /* CALCUL DES ETIQUETTES DES MINIMA  */
-  /* =================================================== */
-
-  M = (int32_t *)calloc(1,N * sizeof(int32_t));
-  if (M == NULL)
-  {   fprintf(stderr, "lsegment() : malloc failed for M\n");
-      return(0);
-  }
-
-  /* le LABEL M initialement est mis a -1 */
-  for (x = 0; x < N; x++) M[x] = -1;
-
-  nminima = 0;
-
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] == -1)          /* on trouve un point x non etiquete */
-    {
-      nminima += 1;              /* on cree un numero d'etiquette */
-      M[x] = nminima;
-      LifoPush(LIFO, x);         /* on va parcourir le plateau auquel appartient x */
-      while (! LifoVide(LIFO))
-      {
-        w = LifoPop(LIFO);
-        label = M[w];
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if (y != -1)
-          {
-            if ((label > 0) && (F[y] < F[w]))
-            { /* w non dans un minimum */
-              label = 0;
-              nminima -= 1;
-              M[w] = label;
-              LifoPush(LIFO, w);
-            } 
-            else
-            if (F[y] == F[w])
-            {
-              if (((label > 0) && (M[y] == -1)) ||
-                  ((label == 0) && (M[y] != 0)))
-              {
-                M[y] = label;
-                LifoPush(LIFO, y);
-              } /* if .. */
-            } /* if F ... */
-          } /* if (y != -1) */
-        } /* for k ... */
-      } /* while (! LifoVide(LIFO)) */
-    } /* if (M[x] == -1) */
-  } /* for (x = 0; x < N; x++) */
-
-  if (nminima < 2)
-  {   fprintf(stderr, "lsegment() : only 1 minimum - image probably empty\n");
-      return(0);
-  }
-  nminima += 1; /* pour le niveau 0 */
-
-  /* ================================================ */
-  /*                CONSTRUCTION DU CBT               */
-  /* ================================================ */
-
-  /* initialisation */
-  /* ============== */
-
-  nbmaxcell = nminima * 2;
-  CBT = (cbtcell *)calloc(1,nbmaxcell * sizeof(cbtcell));
-  if (CBT == NULL)
-  {   fprintf(stderr, "lsegment() : malloc failed for CBT\n");
-      return(0);
-  }
-
-  SURF    = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  PROF    = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  DERPROF = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  VOL     = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  if ((SURF==NULL) || (PROF==NULL) || (DERPROF==NULL) || (VOL==NULL))
-  {   fprintf(stderr, "lsegment() : calloc failed\n");
-      return(0);
-  }
-#ifdef VERSION_EXPERIMENTALE
-  PER     = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  TROU    = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  RDIST   = (uint8_t *)calloc(1,nbmaxcell * sizeof(char));
-  if ((PER==NULL) || (TROU==NULL) || (RDIST==NULL))
-  {   fprintf(stderr, "lsegment() : calloc failed\n");
-      return(0);
-  }
-#ifdef MOMENTS
-  EXCEN   = (uint8_t *)calloc(1,nbmaxcell * sizeof(char));
-  if (EXCEN==NULL)
-  {   fprintf(stderr, "lsegment() : calloc failed\n");
-      return(0);
-  }
-  mx1  = (double *)calloc(nbmaxcell, sizeof(double));   /* init a 0 */
-  my1  = (double *)calloc(nbmaxcell, sizeof(double));   /* init a 0 */
-  mx2  = (double *)calloc(nbmaxcell, sizeof(double));   /* init a 0 */
-  my2  = (double *)calloc(nbmaxcell, sizeof(double));   /* init a 0 */
-  mxy2 = (double *)calloc(nbmaxcell, sizeof(double));   /* init a 0 */
-  if ((mx1==NULL) || (my1==NULL) || (mx2==NULL) || (my2==NULL) || (mxy2==NULL))
-  {   fprintf(stderr, "lsegment() : calloc failed\n");
-      return(0);
-  }
-#endif
-#endif
-  /* initialise les attributs des minima */
-  for (x = 0; x < N; x++) 
-    if (M[x]) 
-    {
-      SURF[M[x]] += 1;
-      DERPROF[M[x]] = F[x] + 1;
-#ifdef MOMENTS
-      mx1[M[x]] += x%rs; 
-      my1[M[x]] += x/rs; 
-      mx2[M[x]] += (x%rs) * (x%rs); 
-      my2[M[x]] += (x/rs) * (x/rs);
-      mxy2[M[x]] += (x%rs) * (x/rs);
-#endif
-    }
-
-#ifdef VERSION_EXPERIMENTALE
-  for (x = 0; x < N; x++) /* pour le perimetre et les trous */
-  {
-    if (M[x] > 0)
-    {
-      CONTRIPER[x] = contribperim(x, F, F[x], rs, N);
-      if (!IsSet(x, MARQUETROU))
-      {
-        int32_t nbtrous = 0;
-        Set(x, MARQUETROU);
-        LifoPush(LIFO, x); /* on va parcourir le plateau auquel appartient x */
-        while (! LifoVide(LIFO))
-        {
-          w = LifoPop(LIFO);
-          for (k = 0; k < 8; k += incr_vois)
-          {
-            y = voisin(w, k, rs, N);
-            if ((y != -1) && (M[y] == M[x]) && (!IsSet(y, MARQUETROU)))
-            {
-              int32_t masque = 0, imasque = 1;
-              /* fabrique le masque des voisins de y MARQUES */
-              for (l = 0; l < 8; l += 1)
-              {
-                z = voisin(y, l, rs, N);
-                if ((z != -1) && (M[z] == M[y]) && IsSet(z, MARQUETROU))
-                  masque |= imasque; 
-                imasque = imasque << 1;
-              } /* for l ... */
-              if (connex == 4) 
-                { nbtrous += (t4(masque) - 1); if (t8b(masque) == 0) nbtrous--; }
-              else
-                { nbtrous += (t8(masque) - 1); if (t4b(masque) == 0) nbtrous--; }
-              Set(y, MARQUETROU);
-              LifoPush(LIFO, y);
-            } /* if (!IsSet(x, MARQUETROU)) */
-          } /* for k ... */
-        } /* while (! LifoVide(LIFO)) */
-        TROU[M[x]] = nbtrous;
-      } /* if (!IsSet(x, MARQUETROU) */
-    } /* if (M[x] > 0) */
-  } /* for (x = 0; x < N; x++) */
-  for (x = 0; x < N; x++) if (M[x]) PER[M[x]] += CONTRIPER[x];
-#endif
-
-  nccmax = 2*N / 3;  /* majore la longueur de la frontiere exterieure d'un plateau */
-  etiqcc = (int32_t *)calloc(1,nccmax * sizeof(int32_t));
-  if (etiqcc == NULL)
-  {   fprintf(stderr, "lsegment() : malloc failed for etiqcc\n");
-      return(0);
-  }
-
-  nbcell = nminima;  
-  InitCbt(CBT, nbcell+1); /* +1 : pour le decalage entre no minima et no neuds - 20/4/00 */
-
-  /* init. inondation */
-  /* ================ */
-  
-  FahPush(FAH, -1, 0);               /* force la creation du niveau 0 dans la Fah. */
-                                     /* NECESSAIRE pour eviter la creation prematuree */
-                                     /* de la file d'urgence */ 
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] != 0)                   /* le pixel appartient a un minimum */
-    {
-      Set(x, MINIMUM);
-      SetData(CBT, M[x], F[x]);     /* conceptuellement : F[x] + 1 */
-      for (k = 0; k < 8; k += incr_vois)
-      {                              /* si un voisin n'est pas deja dans la FAH */
-        y = voisin(x, k, rs, N);     /* et n'est pas dans un minimum, on le met en FAH */
-        if ((y != -1) && (! IsSet(y, EN_FAH)) && (M[y] == 0))
-	{
-          FahPush(FAH, y, F[y]);
-          Set(y, EN_FAH);
-        } /* if y */
-      } /* for k */
-    } /* if (M[x] != 0) */
-  } /* for x */
-
-  x = FahPop(FAH);
-#ifdef PARANO
-  if (x != -1)
-  {   
-     printf("segment() : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n");
-     return(0);
-  }
-#endif
-
-  /* ================================================================= */
-  /* INONDATION */
-  /* ================================================================= */
-
-  while (! FahVide(FAH))
-  {
-    x = FahPop(FAH);
-
-    if (M[x] == 0)
-    {
-      ncc = 0;
-      h = F[x];
-      tailleplateau = 0;
-      /* 1er parcours du plateau de x : enregistre les etiquettes voisines */
-      /* les points du plateau sont marques (MARQUE1) */
-      /* les points voisins du plateau sont marques (MARQUE2) */
-
-      Set(x, MARQUE1);
-      LifoPush(LIFO, x);
-      while (! LifoVide(LIFO))
-      {
-        w = LifoPop(LIFO);     /* w est un point du h-plateau */
-        tailleplateau++;
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if (y != -1)
-          {
-            if  ((M[y] != 0) && (!IsSet(y, MARQUE2)))
-            {
-              if (ncc >= nccmax)
-              {   
-                printf("segment() : ncc = %d ; nccmax = %d\n", ncc, nccmax);
-                return(0);
-              }
-              etiqcc[ncc] = M[y];
-              ncc += 1;
-              Set(y, MARQUE2);
-            }
-            if ((F[y] == h) && (!IsSet(y, MARQUE1)))
-            {
-              Set(y, MARQUE1);
-              LifoPush(LIFO, y);
-            }
-          } /* if (y != -1) */
-        } /* for (k = 0; k < 8; k += incr_vois) */
-      } /* while (! LifoVide(LIFO)) */
-      ncc = DiffAnc(CBT, ncc, etiqcc);
-
-#ifdef PARANO
-      if (ncc == 0)
-      {
-        printf("segment() : construction cbt : PAS DE cc DANS LE VOISINAGE !!!\n"); 
-        return(0);  
-      } else
-#endif
-      if (ncc == 1)
-      {
-        /* 2nd parcours du plateau de x : positionne les etiquettes M */
-        /* les points du plateau sont demarques (MARQUE1) */
-        /* les points voisins du plateau sont demarques (MARQUE2) */
-        /* les voisins du plateau sont eventuellement mis en FAH */
-
-        UnSet(x, MARQUE1);
-        LifoPush(LIFO, x);
-        while (! LifoVide(LIFO))
-        {
-          int32_t masque = 0, imasque = 1;
-
-          w = LifoPop(LIFO);     /* w est un point du h-plateau */
-          M[w] = etiqcc[0];
-          for (k = 0; k < 8; k += incr_vois)
-          {
-            y = voisin(w, k, rs, N);
-            if (y != -1)
-            {
-              UnSet(y, MARQUE2);
-              if ((! IsSet(y, EN_FAH)) && (M[y] == 0) && (!IsSet(y, MARQUE1)))
-              {
-                FahPush(FAH, y, F[y]);
-                Set(y, EN_FAH);
-              }
-              if ((F[y] == h) && (IsSet(y, MARQUE1)))
-              {
-                UnSet(y, MARQUE1);
-                LifoPush(LIFO, y);
-              }
-            } /* if (y != -1) */
-          } /* for (k = 0; k < 8; k += incr_vois) */
-
-#ifdef VERSION_EXPERIMENTALE
-          /* mise a jour du perimetre pour w */
-          for (k = 0; k < 8; k += 1)
-          {
-            y = voisin(w, k, rs, N);
-            if (y != -1)
-            {
-              if (F[y] < h)
-              {
-#ifdef DEBUGPERI
-printf("ncc=%d h=%d p=%d,%d M=%d vois=%d,%d -%d", ncc, h, w%rs, w/rs, M[w], y%rs, y/rs, CONTRIPER[y]);
-#endif
-                PER[M[w]] -= CONTRIPER[y];   /* mise a jour du perimetre */
-                CONTRIPER[y] = contribperim(y, F, h, rs, N);
-#ifdef DEBUGPERI
-printf(" +%d\n", CONTRIPER[y]);
-#endif
-                PER[M[w]] += CONTRIPER[y];
-              }
-            } /* if (y != -1) */
-          } /* for (k = 0; k < 8; k += 1) */
-
-          CONTRIPER[w] = contribperim(w, F, h, rs, N);
-#ifdef DEBUGPERI
-printf("p=%d,%d +%d\n", w%rs, w/rs, CONTRIPER[w]);
-#endif
-          PER[M[w]] += CONTRIPER[w]; 
-
-          /* mise a jour du nombre de trous pour w */
-          /* fabrique le masque des voisins de w appartenant a la composante */
-          for (k = 0; k < 8; k += 1)
-          {
-            y = voisin(w, k, rs, N);
-            if ((y != -1) && IsAnc(CBT, M[w], M[y]))
-              masque |= imasque; 
-            imasque = imasque << 1;
-          } /* for k ... */
-          if (connex == 4) 
-            { TROU[M[w]] += (t4(masque) - 1); if (t8b(masque) == 0) TROU[M[w]]--; }
-          else
-            { TROU[M[w]] += (t8(masque) - 1); if (t4b(masque) == 0) TROU[M[w]]--; }
-#ifdef DEBUGTROU
-printf("ncc=%d: M=%d, p=%d,%d h=%d masque=%x t4=%d t8b=%d, nbtrous=%d\n", ncc, M[w], w%rs, w/rs, F[w], masque, t4(masque), t8b(masque), TROU[M[w]]);
-#endif
-
-#ifdef MOMENTS
-          /* mise a jour des moments pour w */
-          mx1[M[w]] += w%rs; 
-          my1[M[w]] += w/rs; 
-          mx2[M[w]] += (w%rs) * (w%rs); 
-          my2[M[w]] += (w/rs) * (w/rs);
-          mxy2[M[w]] += (w%rs) * (w/rs);
-#endif
-#endif
-        } /* while (! LifoVide(LIFO)) */
-
-        /* mise a jour de la surface, profondeur, volume pour le plateau */
-        SURF[M[w]] += tailleplateau;
-#ifdef DEBUGSURF
-printf("pl. h=%d; ncc = %d; M=%d; taille =%d\n", h, ncc, M[w], tailleplateau);
-#endif
-        if (F[w] + 1 > DERPROF[M[w]])
-        {
-          VOL[M[w]] += SURF[M[w]] * (F[w] + 1 - DERPROF[M[w]]);
-          DERPROF[M[w]] = F[w] + 1;
-        }
-#ifdef MOMENTS
-        EXCEN[M[w]] = excentricity(mx1[M[w]], my1[M[w]], mx2[M[w]], 
-                                   my2[M[w]], mxy2[M[w]], SURF[M[w]]);
-#endif
-      } /* if (ncc == 1) */
-      else
-      {
-        int32_t p = 0;                   /* pour la mise a jour du perimetre */
-        new = CreateCell(CBT, &nbcell, nbmaxcell);
-        SetData(CBT, new, F[x]);     /* conceptuellement : F[x] + 1 */
-        for (i = 0; i < ncc; i++) SetFather(CBT, etiqcc[i], new);
-
-        /* 2nd parcours du plateau de x : positionne les etiquettes M */
-        /* les points du plateau sont demarques (MARQUE1) */
-        /* les points voisins du plateau sont demarques (MARQUE2) */
-        /* les voisins du plateau sont eventuellement mis en FAH */
-
-        UnSet(x, MARQUE1);
-        LifoPush(LIFO, x);
-        while (! LifoVide(LIFO))
-        {
-          int32_t masque = 0, imasque = 1;
-
-          w = LifoPop(LIFO);     /* w est un point du h-plateau */
-          UnSet(w, MARQUE1);
-          M[w] = new;
-          for (k = 0; k < 8; k += incr_vois)
-          {
-            y = voisin(w, k, rs, N);
-            if (y != -1)
-            {
-              UnSet(y, MARQUE2);
-              if ((! IsSet(y, EN_FAH)) && (M[y] == 0) && (!IsSet(y, MARQUE1)))
-              {
-                FahPush(FAH, y, F[y]);
-                Set(y, EN_FAH);
-              }
-              if ((F[y] == h) && (IsSet(y, MARQUE1)))
-              {
-                UnSet(y, MARQUE1);
-                LifoPush(LIFO, y);
-              }
-            } /* if (y != -1) */
-          } /* for (k = 0; k < 8; k += incr_vois) */
-
-#ifdef VERSION_EXPERIMENTALE
-          /* mise a jour du perimetre pour w */
-          for (k = 0; k < 8; k += 1)
-          {
-            y = voisin(w, k, rs, N);
-            if (y != -1)
-            {
-              if (F[y] < h)
-              {
-#ifdef DEBUGPERI
-printf("ncc=%d h=%d p=%d,%d M=%d vois=%d,%d -%d", ncc, h, w%rs, w/rs, M[w], y%rs, y/rs, CONTRIPER[y]);
-#endif
-                p -= CONTRIPER[y];   /* mise a jour du perimetre */
-                CONTRIPER[y] = contribperim(y, F, h, rs, N);
-#ifdef DEBUGPERI
-printf(" +%d\n", CONTRIPER[y]);
-#endif
-                p += CONTRIPER[y];
-              }
-            } /* if (y != -1) */
-          } /* for (k = 0; k < 8; k += 1) */
-          CONTRIPER[w] = contribperim(w, F, h, rs, N);
-#ifdef DEBUGPERI
-printf("p=%d,%d +%d\n", w%rs, w/rs, CONTRIPER[w]);
-#endif
-          p += CONTRIPER[w]; 
-
-          /* mise a jour du nombre de trous pour w */
-          /* fabrique le masque des voisins de w appartenant a la composante */
-          for (k = 0; k < 8; k += 1)
-          {
-            y = voisin(w, k, rs, N);
-            if ((y != -1) && IsAnc(CBT, new, M[y]))
-              masque |= imasque; 
-            imasque = imasque << 1;
-          } /* for k ... */
-          if (connex == 4) 
-            { TROU[new] += (t4(masque) - 1); if (t8b(masque) == 0) TROU[new]--; }
-          else
-            { TROU[new] += (t8(masque) - 1); if (t4b(masque) == 0) TROU[new]--; }
-#ifdef DEBUGTROU
-printf("ncc=%d: M=%d, p=%d,%d h=%d masque=%x t4=%d t8b=%d, nbtrous=%d\n", ncc, new, w%rs, w/rs, F[w], masque, t4(masque), t8b(masque), TROU[new]);
-#endif
-#ifdef MOMENTS
-          /* mise a jour des moments pour w */
-          mx1[new] += w%rs; 
-          my1[new] += w/rs; 
-          mx2[new] += (w%rs) * (w%rs); 
-          my2[new] += (w/rs) * (w/rs);
-          mxy2[new] += (w%rs) * (w/rs);
-#endif
-#endif
-        } /* while (! LifoVide(LIFO)) */
-
-#ifdef VERSION_EXPERIMENTALE
-        PER[M[x]] = p;
-#ifdef DEBUGPERI
-printf("ncc=%d M=%d PER=%d\n", ncc, M[w], p);
-#endif
-#endif
-        SURF[M[x]] = tailleplateau;
-#ifdef DEBUGSURF
-printf("pl. h=%d; ncc = %d; M=%d; taille =%d\n", h, ncc, M[x], tailleplateau);
-#endif
-        prof = 0;
-        for (i = 0; i < ncc; i++)
-        {
-          SURF[M[x]] += SURF[etiqcc[i]];
-#ifdef MOMENTS
-          mx1[M[x]] += mx1[etiqcc[i]];
-          my1[M[x]] += my1[etiqcc[i]];
-          mx2[M[x]] += mx2[etiqcc[i]];
-          my2[M[x]] += my2[etiqcc[i]];
-          mxy2[M[x]] += mxy2[etiqcc[i]];
-#endif
-#ifdef DEBUGSURF
-printf("   ajoute %d venant de %d\n", SURF[etiqcc[i]], etiqcc[i]);
-#endif
-          k = PROF[etiqcc[i]]+F[x]-Data(CBT,etiqcc[i]); /* conceptuellement : F[x] + 1 */
-          if (k > prof) prof = k;
-          if (F[x] + 1 > DERPROF[etiqcc[i]])
-          {
-            VOL[etiqcc[i]] += SURF[etiqcc[i]] * (F[x] + 1 - DERPROF[etiqcc[i]]);
-            DERPROF[etiqcc[i]] = F[x] + 1;
-          }
-          VOL[M[x]] += VOL[etiqcc[i]];
-#ifdef VERSION_EXPERIMENTALE
-          TROU[M[x]] += TROU[etiqcc[i]];
-#ifdef DEBUGTROU
-printf("ncc=%d M=%d TROU += %d (venant de %d)\n", ncc, M[x], TROU[etiqcc[i]], etiqcc[i]);
-#endif
-          PER[M[x]] += PER[etiqcc[i]];
-#ifdef DEBUGPERI
-printf("ncc=%d M=%d PER += %d (venant de %d)\n", ncc, M[x], PER[etiqcc[i]], etiqcc[i]);
-#endif
-#endif
-        } /* for i */
-        PROF[M[x]] = prof;
-        DERPROF[M[x]] = F[x] + 1;
-#ifdef VERSION_EXPERIMENTALE
-        TROU[M[x]] -= (ncc - 1);
-#ifdef DEBUGTROU
-printf("ncc=%d M=%d TROU[M[x]] = %d\n", ncc, M[x], TROU[M[x]]);
-#endif
-#ifdef MOMENTS
-        EXCEN[M[x]] = excentricity(mx1[M[x]], my1[M[x]], mx2[M[x]], 
-                                   my2[M[x]], mxy2[M[x]], SURF[M[x]]);
-#endif
-#endif
-      } /* else if (ncc == 1) */
-    } /* if (!IsSet(x, TRAITE)) */
-  } /* while (! FahVide(FAH)) */
-  /* FIN INONDATION */
-
-  free(etiqcc);
-#ifdef VERSION_EXPERIMENTALE
-  free(CONTRIPER);
-#ifdef MOMENTS
-  free(mx1);
-  free(my1);
-  free(mx2);
-  free(my2);
-  free(mxy2);
-#endif
-#endif
-  FahFlush(FAH);
-
-#ifdef DEBUG
-  printf("FIN DE LA CONSTRUCTION DU CBT\n");
-#endif
-
-  T = Regularise(CBT, nminima, nbcell);
-
-  for (x = 0; x < N; x++)
-    if ((M[x] >= nminima) && (T[M[x] - nminima]))
-    {
-      M[x] = T[M[x] - nminima]; /* nouvelle etiquette pour le point x */
-    }
-
-#ifdef DEBUG
-  printf("FIN DE LA REGULARISATION DU CBT\n");
-#endif
-
-  free(T);
-
-#ifdef PARANO
-  for (i = 0; i < nbcell; i++)
-    if (Label(CBT,i)) printf("ERROR : label = %d\n", Label(CBT, i));
-#endif
-
-#ifdef TRACECBT
-    PrintCbt(CBT, nbcell);
-    for (i = 0; i < N; i++)
-    {
-      if (i % rs == 0) printf("\n");
-      printf("%3d ", M[i]);
-    }
-    printf("\n");
-    printf("SURF = ");
-    for (i = 1; i < nbcell; i++)
-      printf("%3d ", SURF[i]);
-    printf("\n");
-#endif
-
-  /* ================================================ */
-  /* INVERSION DE L'ARBRE                             */
-  /* ================================================ */
-
-  I = InverseCBT(CBT, nminima, nbcell);
-
-  /* ================================================ */
-  /* CALCUL DE RDIST                                  */
-  /* ================================================ */
-#ifdef VERSION_EXPERIMENTALE
-  /* calcule l'attribut "distance a la racine RDIST" */
-  /* methode : propogation descendante, en largeur, a partir de la racine. */
-
-  FahFlush(FAH);
-  FahPush(FAH, nbcell - 1, 0);   /* empile la racine */
-  RDIST[nbcell - 1] = 0;
-  while (! FahVide(FAH))
-  {
-    int32_t n;
-    x = FahPop(FAH);
-    k = FirstSon(CBT, x);
-    if (k != NIL)
-    {
-      if (x < nbcell - 1)              /* x non racine */
-        n = FirstSon(CBT, x + 1) - FirstSon(CBT, x);
-      else
-        n = nbcell - 2 - FirstSon(CBT, x);
-      for (i = 0; i < n; i++)
-      {
-        FahPush(FAH, I[k + i], 0);
-        RDIST[ I[k + i] ] = RDIST[x] + 1;
-      } 
-    } /* if (k != NIL) */
-  } /* while (! FahVide(FAH)) */
-#endif
-  /* ================================================ */
-  /* SEGMENTATION                               */
-  /* ================================================ */
-
-  /* pour la mesure de la profondeur, il faut rajouter la difference de niveau avec le pere */
-  /* on remplace donc les PROF dans l'arbre */
-  for (x = 1; x < nbcell; x++) UnSetAll(x);
-  FahFlush(FAH);
-  for (i = 1; i < nminima+1; i++) FahPush(FAH, i, 0);
-  while (! FahVide(FAH))
-  {
-    k = FahNiveau(FAH);
-    x = FahPop(FAH);
-    y = Father(CBT,x);
-    if (y != NIL)
-    { 
-      PROF[x] += ((Data(CBT,y) - 1) - Data(CBT,x));
-      if (!IsSet(y, EN_FAH))
-      { 
-        Set(y, EN_FAH);
-        FahPush(FAH, y, k + 1); 
-      }
-    }
-    else PROF[x] = NDG_MAX - NDG_MIN; /* prof. maximum pour la racine */
-  } /* while (! FahVide(FAH)) */
-
-ReSegment:
-  /* init:  ranger au niveau 0 de la FAH les feuilles du CBT */
-  FahFlush(FAH);
-  for (i = 0; i < nbcell; i++) Label(CBT,i) = NONMARQUE;
-  for (i = 1; i < nminima+1; i++) FahPush(FAH, i, 0);
-
-  while (! FahVide(FAH))
-  {
-    k = FahNiveau(FAH);
-    x = FahPop(FAH);
-    y = Father(CBT,x);
-
-    if (Label(CBT,x) == NONMARQUE)
-    {
-      if (   ((SURF[x] >= seuilsurf) || (!(mesure & SURFACE)))
-          && ((PROF[x] >= seuilprof) || (!(mesure & PROFONDEUR)))
-          && ((VOL[x] >= seuilvol) || (!(mesure & VOLUME)))
-#ifdef VERSION_EXPERIMENTALE
-          && ((PER[x] >= seuilperim) || (!(mesure & PERIMETRE)))
-          && ((TROU[x] >= seuiltrou) || (!(mesure & NBTROUS)))
-          && ((RDIST[x] <= seuilrdist) || (!(mesure & ROOTDIST)))
-#ifdef MOMENTS
-          && ((EXCEN[x] >= seuilexcen) || (!(mesure & EXCENTRICITE)))
-#endif
-          && ((dtrou(SURF[x], TROU[x]) <= seuildtrou) || (!(mesure & DENSTROUS)))
-          && ((circ(SURF[x], PER[x]) >= seuilcirc) || (!(mesure & CIRCULARITE)))
-#endif
-         )
-      {
-        Label(CBT,x) = PERTINENT;
-        while ((y != NIL) && (Label(CBT,y) != INVALIDE))
-        {
-          Label(CBT,y) = INVALIDE;
-          y = Father(CBT,y);
-        } /* while ((y != NIL) && (Label(CBT,y) != INVALIDE)) */
-      } /* if (MU[x] >= seuil) */
-      else
-        if ((y != NIL) && (Label(CBT,y) != INVALIDE))
-          FahPush(FAH, y, k + 1);
-    } /* if (Label(CBT,x) != INVALIDE) */
-  } /* while (! FahVide(FAH)) */
-
-  if (maximise)
-  {
-    /*  2EME ETAPE : MAXIMISE AU SENS DE L'INCLUSION */
-
-    FahFlush(FAH);
-    for (x = 1; x < nbcell - 1; x++)   /* pas la racine */
-      if (Label(CBT, x) == PERTINENT)
-        FahPush(FAH, x, Data(CBT, x)); /* empile les composantes pertinentes */
-
-    while (! FahVide(FAH))
-    {
-      int32_t n, nbfilspert;
-  
-      x = FahPop(FAH);
-      y = Father(CBT, x);
-      k = FirstSon(CBT, y);
-      if (y < nbcell - 1)              /* pas la racine */
-        n = FirstSon(CBT, y + 1) - FirstSon(CBT, y);
-      else
-        n = nbcell - 2 - FirstSon(CBT, y);
-      nbfilspert = 0;
-      for (i = 0; i < n; i++)
-        if ((Label(CBT, I[k+i]) == PERTINENT) || (Label(CBT, I[k+i]) == INVALIDE))
-          nbfilspert++;
-      if (nbfilspert == 1)  /* si y, le pere de x, n'a pas d'autre fils pertinent */
-      {                     /* alors demarque x et marque y pertinent */
-        Label(CBT, x) = NONMARQUE;
-        Label(CBT, y) = PERTINENT;
-        FahPush(FAH, y, Data(CBT, y));
-      } /* if (nbfilspert == 1) */
-    } /* while (! FahVide(FAH)) */
-  } /* if (maximise) */
-
-#ifdef VERBOSE
-  i = 0;
-  for (x = 1; x < nbcell - 1; x++)   /* pas la racine */
-    if (Label(CBT, x) == PERTINENT) i++;
-  printf("Nombre de composantes pertinentes : %d\n", i);  
-#endif
-
-/* RECUPERATION DE LA SEGMENTATION */
-
-  TEMP = (uint8_t *)calloc(1,N * sizeof(char));
-  if (TEMP == NULL)
-  {   fprintf(stderr, "lsegment() : malloc failed for TEMP\n");
-      return(0);
-  }
-
-  for (i = 0; i < N; i++)
-  {
-    x = M[i];
-    while ((x != NIL) && (Label(CBT,x) == NONMARQUE)) 
-      x = Father(CBT,x);
-    if (Label(CBT,x) == PERTINENT)
-      TEMP[i] = 255;
-    else
-      TEMP[i] = 0;
-  } /* for x */  
-
-if (interactif)
-{
-
-/* ===========================================================
-    affichage : 
-   ===========================================================
-
-    <------- rs ------>     
-    ------------------- .
-    |                 | .
-    |                 | .
-    |                 | .
-    |      image      | cs
-    |                 | .
-    |                 | .
-    |                 | .
-    --------------------------------------------------
-    | SURF | 111  |  +   |  -   |  1   |  10  | MAX  |        BoxHeight
-    --------------------------------------------------
-    | PROF | 111  |  +   |  -   | 100  | 1000 |  ET  |        BoxHeight
-    --------------------------------------------------
-    | VOL  | 111  |  +   |  -   | 10000|  OK  | QUIT |        BoxHeight
-    --------------------------------------------------
-    | RDIST| 111  |  +   |  -   |      |      |      |        BoxHeight
-    --------------------------------------------------
-    | CIRC | 111  |  +   |  -   |      |      |      |        BoxHeight
-    --------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-  /* send output to the screen */
-#ifdef COLOR
-  for (x = 0; x < N; x++)
-  {
-    if (TEMP[x])    
-      Color(MC_RED);
-    else
-      Color(F[x]/4);
-#ifdef ZOOM4
-    Point(2*(x%rs), 2*(x/rs));
-    Point(2*(x%rs)+1, 2*(x/rs));
-    Point(2*(x%rs), 2*(x/rs)+1);
-    Point(2*(x%rs)+1, 2*(x/rs)+1);
-#else
-    Point(x%rs, x/rs);
-#endif
-  }
-#else
-  ColToWhite();
-  FRectangle(0, 0, ImageWidth, ImageHeight);
-  ColToBlack();
-  for (x = 0; x < N; x++)
-    if (TEMP[x])
-    {
-#ifdef ZOOM4
-      Point(2*(x%rs), 2*(x/rs));
-      Point(2*(x%rs)+1, 2*(x/rs));
-      Point(2*(x%rs), 2*(x/rs)+1);
-      Point(2*(x%rs)+1, 2*(x/rs)+1);
-#else
-      Point(x%rs, x/rs);
-#endif
-    }
-#endif
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, ImageHeight + i * BoxHeight, k * BoxWidth, ImageHeight + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, ImageHeight + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  switch (increment)
-  {
-    case 1: FRectangle(4 * BoxWidth, ImageHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, ImageHeight + BoxHeight - 2, ButtonStrings[0][4]);
-            ColToBlack();
-            break;
-   case 10: FRectangle(5 * BoxWidth, ImageHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, ImageHeight + BoxHeight - 2, ButtonStrings[0][5]);
-            ColToBlack();
-            break;
-  case 100: FRectangle(4 * BoxWidth, ImageHeight + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, ImageHeight + 2*BoxHeight - 2, ButtonStrings[1][4]);
-            ColToBlack();
-            break;
- case 1000: FRectangle(5 * BoxWidth, ImageHeight + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, ImageHeight + 2*BoxHeight - 2, ButtonStrings[1][5]);
-            ColToBlack();
-            break;
-case 10000: FRectangle(4 * BoxWidth, ImageHeight + 2*BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, ImageHeight + 3*BoxHeight - 2, ButtonStrings[2][4]);
-            ColToBlack();
-            break;
-  } /* switch (increment) */
-
-  if (mesure & SURFACE)
-  {
-    FRectangle(0, ImageHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + BoxHeight - 2, ButtonStrings[0][0]);
-    ColToBlack();
-  }
-  if (mesure & PROFONDEUR)
-  {
-    FRectangle(0, ImageHeight + BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 2*BoxHeight - 2, ButtonStrings[1][0]);
-    ColToBlack();
-  }
-#ifdef VOL2
-  if (mesure & VOLUME)
-#endif
-#ifdef PER2
-  if (mesure & PERIMETRE)
-#endif
-#ifdef TROU2
-  if (mesure & NBTROUS)
-#endif
-  {
-    FRectangle(0, ImageHeight + 2*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 3*BoxHeight - 2, ButtonStrings[2][0]);
-    ColToBlack();
-  }
-#ifdef VERSION_EXPERIMENTALE
-  if (mesure & ROOTDIST)
-  {
-    FRectangle(0, ImageHeight + 3*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 4*BoxHeight - 2, ButtonStrings[3][0]);
-    ColToBlack();
-  }
-  if (mesure & CIRCULARITE)
-  {
-    FRectangle(0, ImageHeight + 4*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 5*BoxHeight - 2, ButtonStrings[4][0]);
-    ColToBlack();
-  }
-  if (mesure & DENSTROUS)
-  {
-    FRectangle(0, ImageHeight + 5*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 6*BoxHeight - 2, ButtonStrings[5][0]);
-    ColToBlack();
-  }
-#ifdef MOMENTS
-  if (mesure & EXCENTRICITE)
-  {
-    FRectangle(0, ImageHeight + 6*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 7*BoxHeight - 2, ButtonStrings[6][0]);
-    ColToBlack();
-  }
-#endif
-#endif
-  FlushGraphics();  
-
-  WaitMouseEvent(&xx, &yy);
-
-  if ((xx < ImageWidth) && (yy < ImageHeight))
-  {
-#ifdef VERSION_EXPERIMENTALE
-#ifdef MOMENTS
-    signature(mesure, xx, yy, M, CBT, rs, SURF, PROF, VOL, PER, RDIST, TROU, EXCEN);
-    printcomp(xx, yy, M, CBT, rs, SURF, PROF, VOL, PER, RDIST, TROU, EXCEN);
-#else
-    signature(mesure, xx, yy, M, CBT, rs, SURF, PROF, VOL, PER, RDIST, TROU, NULL);
-    printcomp(xx, yy, M, CBT, rs, SURF, PROF, VOL, PER, RDIST, TROU, NULL);
-#endif
-#else
-    signature(mesure, xx, yy, M, CBT, rs, SURF, PROF, VOL, NULL, NULL, NULL, NULL);
-    printcomp(xx, yy, M, CBT, rs, SURF, PROF, VOL, NULL, NULL, NULL, NULL);
-#endif
-  }
-  xx /= BoxWidth;
-  yy -= ImageHeight;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: if ((mesure & SURFACE) && (mesure != SURFACE)) 
-                        mesure &= ~SURFACE;
-                      else if (!(mesure & SURFACE))
-                        mesure |= SURFACE;
-                      break;
-              case 1: break;
-              case 2: seuilsurf = seuilsurf + increment;
-                      sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-                      break;
-              case 3: seuilsurf = seuilsurf - increment;
-                      if (seuilsurf < 1) seuilsurf = 1;
-                      sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-                      break;
-              case 4: increment = 1;
-                      break;
-              case 5: increment = 10;
-                      break;
-              case 6: maximise = !maximise;
-                      if (maximise)
-                        sprintf(ButtonStrings[0][6], " MAX");
-                      else
-                        sprintf(ButtonStrings[0][6], " MIN");
-                      break;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: if ((mesure & PROFONDEUR) && (mesure != PROFONDEUR)) 
-                        mesure &= ~PROFONDEUR;
-                      else if (!(mesure & PROFONDEUR))
-                        mesure |= PROFONDEUR;
-                      break;
-              case 1: break;
-              case 2: seuilprof = seuilprof + increment;
-                      sprintf(ButtonStrings[1][1], "%d", seuilprof);
-                      break;
-              case 3: seuilprof = seuilprof - increment;
-                      if (seuilprof < 0) seuilprof = 0;
-                      sprintf(ButtonStrings[1][1], "%d", seuilprof);
-                      break;
-              case 4: increment = 100;
-                      break;
-              case 5: increment = 1000;
-                      break;
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    case 2: switch(xx)
-            {
-#ifdef VOL2
-              case 0: if ((mesure & VOLUME) && (mesure != VOLUME)) 
-                        mesure &= ~VOLUME;
-                      else if (!(mesure & VOLUME))
-                        mesure |= VOLUME;
-                      break;
-              case 1: break;
-              case 2: seuilvol = seuilvol + increment;
-                      sprintf(ButtonStrings[2][1], "%d", seuilvol);
-                      break;
-              case 3: seuilvol = seuilvol - increment;
-                      if (seuilvol < 0) seuilvol = 0;
-                      sprintf(ButtonStrings[2][1], "%d", seuilvol);
-                      break;
-#endif
-#ifdef PER2
-              case 0: if ((mesure & PERIMETRE) && (mesure != PERIMETRE)) 
-                        mesure &= ~PERIMETRE;
-                      else if (!(mesure & PERIMETRE))
-                        mesure |= PERIMETRE;
-                      break;
-              case 1: break;
-              case 2: seuilperim = seuilperim + increment;
-                      sprintf(ButtonStrings[2][1], "%d", seuilperim);
-                      break;
-              case 3: seuilperim = seuilperim - increment;
-                      if (seuilperim < 0) seuilperim = 0;
-                      sprintf(ButtonStrings[2][1], "%d", seuilperim);
-                      break;
-#endif
-#ifdef TROU2
-              case 0: if ((mesure & NBTROUS) && (mesure != NBTROUS)) 
-                        mesure &= ~NBTROUS;
-                      else if (!(mesure & NBTROUS))
-                        mesure |= NBTROUS;
-                      break;
-              case 1: break;
-              case 2: seuiltrou = seuiltrou + increment;
-                      sprintf(ButtonStrings[2][1], "%d", seuiltrou);
-                      break;
-              case 3: seuiltrou = seuiltrou - increment;
-                      if (seuiltrou < 0) seuiltrou = 0;
-                      sprintf(ButtonStrings[2][1], "%d", seuiltrou);
-                      break;
-#endif
-              case 4: increment = 10000;
-                      break;
-              case 5: goto ReSegment;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-#ifdef VERSION_EXPERIMENTALE
-    case 3: switch(xx)
-            {
-              case 0: if ((mesure & ROOTDIST) && (mesure != ROOTDIST)) 
-                        mesure &= ~ROOTDIST;
-                      else if (!(mesure & ROOTDIST))
-                        mesure |= ROOTDIST;
-                      break;
-              case 1: break;
-              case 2: seuilrdist = seuilrdist + increment;
-                      if (seuilrdist > NDG_MAX) seuilrdist = NDG_MAX;
-                      sprintf(ButtonStrings[3][1], "%d", seuilrdist);
-                      break;
-              case 3: seuilrdist = seuilrdist - increment;
-                      if (seuilrdist < NDG_MIN) seuilrdist = NDG_MIN;
-                      sprintf(ButtonStrings[3][1], "%d", seuilrdist);
-                      break;
-              case 4: 
-              case 5: 
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    case 4: switch(xx)
-            {
-              case 0: if ((mesure & CIRCULARITE) && (mesure != CIRCULARITE)) 
-                        mesure &= ~CIRCULARITE;
-                      else if (!(mesure & CIRCULARITE))
-                        mesure |= CIRCULARITE;
-                      break;
-              case 1: break;
-              case 2: seuilcirc = seuilcirc + increment;
-                      if (seuilcirc > 100) seuilcirc = 100;
-                      sprintf(ButtonStrings[4][1], "%d", seuilcirc);
-                      break;
-              case 3: seuilcirc = seuilcirc - increment;
-                      if (seuilcirc < 0) seuilcirc = 0;
-                      sprintf(ButtonStrings[4][1], "%d", seuilcirc);
-                      break;
-              case 4: 
-              case 5: 
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    case 5: switch(xx)
-            {
-              case 0: if ((mesure & DENSTROUS) && (mesure != DENSTROUS)) 
-                        mesure &= ~DENSTROUS;
-                      else if (!(mesure & DENSTROUS))
-                        mesure |= DENSTROUS;
-                      break;
-              case 1: break;
-              case 2: seuildtrou = seuildtrou + increment;
-                      if (seuildtrou > 1000) seuildtrou = 1000;
-                      sprintf(ButtonStrings[5][1], "%d", seuildtrou);
-                      break;
-              case 3: seuildtrou = seuildtrou - increment;
-                      if (seuildtrou < 0) seuildtrou = 0;
-                      sprintf(ButtonStrings[5][1], "%d", seuildtrou);
-                      break;
-              case 4: 
-              case 5: 
-              case 6: break;
-            } /* switch(xx) */
-            break;
-#ifdef MOMENTS
-    case 6: switch(xx)
-            {
-              case 0: if ((mesure & EXCENTRICITE) && (mesure != EXCENTRICITE)) 
-                        mesure &= ~EXCENTRICITE;
-                      else if (!(mesure & EXCENTRICITE))
-                        mesure |= EXCENTRICITE;
-                      break;
-              case 1: break;
-              case 2: seuilexcen = seuilexcen + increment;
-                      if (seuilexcen > 255) seuilexcen = 255;
-                      sprintf(ButtonStrings[6][1], "%d", seuilexcen);
-                      break;
-              case 3: seuilexcen = seuilexcen - increment;
-                      if (seuilexcen < 0) seuilexcen = 0;
-                      sprintf(ButtonStrings[6][1], "%d", seuilexcen);
-                      break;
-              case 4: 
-              case 5: 
-              case 6: break;
-            } /* switch(xx) */
-            break;
-#endif
-#endif
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      free(ButtonStrings[i][k]);
-} /* if (interactif) */
-
-  for (x = 0; x < N; x++) F[x] = TEMP[x];
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  free(TEMP);
-  free(I);
-  free(SURF);
-  free(PROF);
-  free(DERPROF);
-  free(VOL);
-#ifdef VERSION_EXPERIMENTALE
-  free(PER);
-  free(RDIST);
-  free(TROU);
-#ifdef MOMENTS
-  free(EXCEN);
-#endif
-#endif
-  IndicsTermine();
-  FahTermine(FAH);
-  LifoTermine(LIFO);
-  free(CBT);
-  free(M);
-  return(1);
-}
diff -r 8b1af7363833 src/lib/lsegment3di.c
--- a/src/lib/lsegment3di.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1223 +0,0 @@
-/* $Id: lsegment3di.c,v 1.1.1.1 2008-11-25 08:01:41 mcouprie Exp $ */
-/* operateur interactif de segmentation par seuillage pour image 3d numerique */
-/* utilise une File d'Attente Hierarchique */
-/* utilise un arbre des bassins versants (captation basin tree, CBT) */
-/* Michel Couprie - juillet 1997 */
-/* version 0.2 du 05/8/97 */
-/* 
-   5/07/97 : affichage en niveaux de gris
-   25/08/97 : nettoyage et unification 
-   1/2/98 : retire   UnSetAll(x);   apres        ncc = 0; x = FahPop(FAH);
-            remplace
-               n = FirstSon(CBT, y + 1) - FirstSon(CBT, y);
-            par
-               if (y < nbcell - 1)
-                 n = FirstSon(CBT, y + 1) - FirstSon(CBT, y);
-               else
-                 n = nbcell - 2 - FirstSon(CBT, y);
-   4/11/99 : nouvelle construction de l'arbre : travaille au niveau des plateaux et
-             non plus des pixels
-
-   20/4/00 : corrige bug 
-*/
-
-#define ZOOM4
-
-#define PARANO                 /* even paranoid people have ennemies */
-#define VERBOSE
-
-/*
-#define MAXIMISE
-*/
-
-/*
-#define DEBUG
-#define TRACEIMAGE
-*/
-#define TRACEPOP
-#define TRACEPUSH
-#define TRACEBAISSE
-#define TRACEETIQ
-#define SEGMENT
-#define TRACECBT
-
-/*
-#define NOSURFVOL
-*/
-
-/*
-   Methode : 
-
-===============================================
-1ere etape : CONSTRUCTION DU CBT
-===============================================
-  entree : une image F
-  sortie : le CBT, l'application M: Dom(F) -> CBT
-
-  M <- etiquettes des minima de F
-  nminima <- nombre de minima de F
-  init(CBT, nminima)
-  pour tout point x de Dom(F)
-    si x appartient a un minimum
-      SetData(CBT, M[x], SOURCE[x] + 1);
-      pour tout y dans gamma(x)
-        si y n'appartient pas a un minimum et pas deja dans FAH
-          FahPush(FAH, y, SOURCE[y]);
-        finsi
-      finpour
-    finsi
-  finpour
-
-  tant que FAH non vide
-    x = FahPop(FAH);
-    etiqcc = liste des M[y], y dans gamma(x)
-    diffanc = liste des ancetres differents des etiquettes de etiqcc dans le CBT
-    si |diffanc| == 1
-      M[x] = first(diffanc)
-    sinon
-      si il existe une ou des cellules de niveau F[x]+1 dans gamma(x)
-        new = fusion de ces cellules
-      sinon
-        new = CreateCell(CBT)
-      M[x] = new
-      SetData(CBT, new, F[x] + 1)
-      pour tout a dans diffanc 
-        SetFather(CBT, a, new)
-      finpour
-    fin si
-    pour tout y dans gamma(x) pas deja dans FAH
-      si M[y] == 0
-        FahPush(FAH, y, SOURCE[y]);
-      finsi
-    finpour
-  fintantque
-
-===============================================
-2eme etape: 
-===============================================
-
-  en parallele avec la construction du CBT, on a recueilli une "mesure" (MU)
-  des bassins versants.
-
-  ici cette mesure est la surface de la plus grande coupe d'un BV avant sa fusion
-  avec un autre.
-
-  l'algorithme de segmentation est alors:
-
-  1ERE ETAPE : SELECTIONNE LE NB MAX DE CC PERTINENTES
-
-  init:  ranger au niveau 0 de la FAH les feuilles du CBT
-
-  tant que FAH non vide faire
-    k = FAHNIVEAU()
-    x = FAHPOP()
-    si MU[c] >= seuil alors
-      marque les ancetres de x "INVALIDE"
-      marque x "PERTINENT"
-    sinon
-      si pere(x) existe et non INVALIDE alors FAHPUSH(pere(x), k+1) finsi
-    finsi
-  fintantque
-
-  2EME ETAPE : MAXIMISE AU SENS DE L'INCLUSION
-
-  Re-init:  ranger a leur niveau data dans la FAH les cellules PERTINENTes
-
-  I = arbre inverse
-
-  tant que FAH non vide faire
-    x = FAHPOP()
-    y = pere(x)
-    si y existe alors 
-      k = FirstSon(y)
-      n = FirstSon(y + 1) - FirstSon(y)
-      nbfilspert = 0
-      pour i de 0 a n-1 faire
-        si Label(I[k+i]) == PERTINENT
-          nbfilspert++ finsi finpour
-      si nbfilspert == 1 alors
-        Label(x) = NONMARQUE
-        Label(y) = PERTINENT
-        FahPush(y, Data(y))
-      finsi
-    finsi
-  fintantque
-
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcfah.h>
-#include <mclifo.h>
-#include <mcindic.h>
-#include <mccbt.h>
-#include <mcxbib.h>
-#include <llabelextrema.h>
-#include <lsegment3di.h>
-
-#define EN_FAH 0
-#define MINIMUM 1
-#define CC_EN_FAH 2
-
-#define NONMARQUE 0
-#define INVALIDE 1
-#define PERTINENT 2
-
-#define MARQUE1    2
-#define MARQUE2    3
-
-/* ==================================== */
-static int32_t NotIn(
-  int32_t e,
-  int32_t *list,                   
-  int32_t n)                       
-/* ==================================== */
-{
-/* renvoie 1 si e n'est pas dans list, 0 sinon */
-/* e : l'element a rechercher */
-/* list : la liste (tableau d'entiers) */
-/* n : le nombre d'elements dans la liste */
-  while (n > 0)
-    if (list[--n] == e) return 0;
-  return 1;
-} /* NotIn() */
-
-/* ==================================== */
-int32_t lsegment3di(struct xvimage *image, int32_t connex)
-/* ==================================== */
-{
-  char buf[128];
-  register int32_t i;                       /* index muet */
-  register int32_t x;                       /* index muet de pixel */
-  register int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t w;                       /* index muet (generalement un voisin de x) */
-  register int32_t k;                       /* index muet */
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t d = depth(image);        /* nb plans */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *temp;        /* image de travail et resultat */
-  uint8_t *TEMP;
-  struct xvimage *lab;
-  uint32_t *M;            /* l'image d'etiquettes de composantes connexes */
-  int32_t *T;                      /* table de correspondance pour regularisation */
-  int32_t *I;                      /* pour l'arbre inverse */
-  int32_t nminima;                 /* nombre de minima differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  cbtcell * CBT;               /* arbre des bassins versants (Catchment Basin Tree) */
-  int32_t nbcell;
-  int32_t nbmaxcell;
-  Lifo * LIFO;                 /* pour parcourir un plateau */
-  int32_t *etiqcc;                 /* etiquettes au voisinage d'un plateau */
-  int32_t nccmax;                  /* nombre max. d'etiquettes pouvant voisiner un plateau */
-  int32_t h;
-  int32_t tailleplateau;
-  int32_t ncc;
-  int32_t new;
-  int32_t prof;
-  int32_t *PROF;                   /* pour le stockage de la profondeur */
-#ifndef NOSURFVOL
-  int32_t *SURF;                   /* pour le stockage de la surface */
-  int32_t *DERPROF;                /* pour le stockage de la derniere profondeur */
-  int32_t *VOL;                    /* pour le stockage du volume */
-#endif
-  int32_t seuilsurf = 1;
-  int32_t seuilprof = 0;
-  int32_t seuilvol = 0;
-  int32_t mesure = PROFONDEUR;
-  int32_t increment = 1;
-  int32_t maximise = 0;
-  int32_t iplan = 0;
-#define NBBUTTONS 7
-#define NBLIGBUTT 4
-#define BOXWIDTH 70
-#define BOXHEIGHT 20
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int32_t xx, yy;
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT;
-  int32_t Width = rs;
-  int32_t ImageHeight = cs;
-  int32_t ImageWidth = rs;
-  int32_t nsave = 0;
-
-#ifdef ZOOM4
-  Height += cs;
-  Width += rs;
-  ImageHeight += cs;
-  ImageWidth += rs;
-#endif
-
-  if (BoxWidth * NBBUTTONS > Width) Width = BoxWidth * NBBUTTONS;
-  
-#ifdef COLOR
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-#else
-  InitGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-#endif
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-#ifndef NOSURFVOL
-  strcpy(ButtonStrings[0][0], " SURF");
-#else
-  strcpy(ButtonStrings[0][0], "     ");
-#endif
-  sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "  1  ");
-  strcpy(ButtonStrings[0][5], " 10  ");
-  strcpy(ButtonStrings[0][6], " MIN ");
-
-  strcpy(ButtonStrings[1][0], " PROF");
-  sprintf(ButtonStrings[1][1], "%d", seuilprof);
-  strcpy(ButtonStrings[1][2], "  +  ");
-  strcpy(ButtonStrings[1][3], "  -  ");
-  strcpy(ButtonStrings[1][4], " 100 ");
-  strcpy(ButtonStrings[1][5], " 1000");
-  strcpy(ButtonStrings[1][6], "     ");
-
-#ifndef NOSURFVOL
-  strcpy(ButtonStrings[2][0], " VOL ");
-#else
-  strcpy(ButtonStrings[2][0], "     ");
-#endif
-  sprintf(ButtonStrings[2][1], "%d", seuilvol);
-  strcpy(ButtonStrings[2][2], "  +  ");
-  strcpy(ButtonStrings[2][3], "  -  ");
-  strcpy(ButtonStrings[2][4], " 10K ");
-  strcpy(ButtonStrings[2][5], " 100K");
-  strcpy(ButtonStrings[2][6], " SAVE");
-
-  strcpy(ButtonStrings[3][0], " PLAN");
-  sprintf(ButtonStrings[3][1], "%d", iplan);
-  strcpy(ButtonStrings[3][2], "  +  ");
-  strcpy(ButtonStrings[3][3], "  -  ");
-  strcpy(ButtonStrings[3][4], "1000K");
-  strcpy(ButtonStrings[3][5], " OK  ");
-  strcpy(ButtonStrings[3][6], " QUIT");
-
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "lsegment3di() : CreeFah failed\n");
-      return(0);
-  }
-
-  LIFO = CreeLifoVide(N);
-  if (LIFO == NULL)
-  {   fprintf(stderr, "lsegment3di() : CreeLifoVide failed\n");
-      return(0);
-  }
-
-  lab = allocimage(NULL, rs, cs, d, VFF_TYP_4_BYTE);
-  if (lab == NULL)
-  {   
-    fprintf(stderr, "lsegment3di: allocimage failed\n");
-    return 0;
-  }
-  M = ULONGDATA(lab);
-
-  if (!llabelextrema(image, connex, LABMIN, lab, &nminima))
-  {   
-    fprintf(stderr, "lsegment3di: llabelextrema failed\n");
-    return 0;
-  }
-  nminima -= 1;  /* le label 0 ne represente pas un minimum */
-
-  nbcell = nminima+1;  /* +1 : pour le decalage entre no minima et no neuds - 20/4/00 */
-  nbmaxcell = nbcell * 2;  /* 21/4/00: nbcell au lieu de nminima */
-  CBT = (cbtcell *)calloc(1,nbmaxcell * sizeof(cbtcell));
-  if (CBT == NULL)
-  {   fprintf(stderr, "lsegment3di() : malloc failed for CBT\n");
-      return(0);
-  }
-
-#ifdef VERBOSE
-  fprintf(stderr, "nminima = %d\n", nminima);
-#endif
-
-  PROF = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  if (PROF == NULL)
-  {   fprintf(stderr, "lsegment3di() : calloc failed\n");
-      return(0);
-  }
-#ifndef NOSURFVOL
-  SURF = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  if (SURF == NULL)
-  {   fprintf(stderr, "lsegment3di() : calloc failed\n");
-      return(0);
-  }
-  DERPROF = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  VOL = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  if ((DERPROF == NULL) || (VOL == NULL))
-  {   fprintf(stderr, "lsegment3di() : calloc failed\n");
-      return(0);
-  }
-#endif
-
-  /* calcul des tailles des minima (histogramme des labels) */
-#ifndef NOSURFVOL
-  for (x = 0; x < N; x++) SURF[M[x]] += 1;
-  for (x = 0; x < N; x++) DERPROF[M[x]] = F[x] + 1;
-#endif
-
-  nccmax = 2*N / 3;  /* majore la longueur de la frontiere exterieure d'un plateau */
-  etiqcc = (int32_t *)calloc(1,nccmax * sizeof(int32_t));
-  if (etiqcc == NULL)
-  {   fprintf(stderr, "lsegment() : malloc failed for etiqcc\n");
-      return(0);
-  }
-
-  /* ================================================ */
-  /*                CONSTRUCTION DU CBT               */
-  /* ================================================ */
-
-  InitCbt(CBT, nbcell);
-  
-  FahPush(FAH, -1, 0);               /* force la creation du niveau 0 dans la Fah. */
-                                     /* NECESSAIRE pour eviter la creation prematuree */
-                                     /* de la file d'urgence */ 
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] != 0)                   /* le pixel appartient a un minimum */
-    {
-      Set(x, MINIMUM);
-      SetData(CBT, M[x], F[x]);     /* conceptuellement : F[x] + 1 */
-
-      switch (connex)
-      {
-      case 6:
-        for (k = 0; k <= 10; k += 2)       /* parcourt les 6 voisins */
-        {                                  /* si un voisin n'est pas deja dans la FAH */
-          y = voisin6(x, k, rs, n, N);     /* et n'est pas dans un minimum, on le met en FAH */
-          if ((y != -1) && (! IsSet(y, EN_FAH)) && (M[y] == 0))
-	  {
-            FahPush(FAH, y, F[y]);
-            Set(y, EN_FAH);
-          } /* if y */
-        } /* for k */
-        break;
-
-      case 18:
-        for (k = 0; k < 18; k++)           /* parcourt les 18 voisins */
-        {                                  /* si un voisin n'est pas deja dans la FAH */
-          y = voisin18(x, k, rs, n, N);    /* et n'est pas dans un minimum, on le met en FAH */
-          if ((y != -1) && (! IsSet(y, EN_FAH)) && (M[y] == 0))
-	  {
-            FahPush(FAH, y, F[y]);
-            Set(y, EN_FAH);
-          } /* if y */
-        } /* for k */
-        break;
-
-      case 26:
-        for (k = 0; k < 26; k++)           /* parcourt les 26 voisins */
-        {                                  /* si un voisin n'est pas deja dans la FAH */
-          y = voisin26(x, k, rs, n, N);    /* et n'est pas dans un minimum, on le met en FAH */
-          if ((y != -1) && (! IsSet(y, EN_FAH)) && (M[y] == 0))
-	  {
-            FahPush(FAH, y, F[y]);
-            Set(y, EN_FAH);
-#ifdef DEBUG
-  printf("Init: empile y = (%d,%d,%d) voisin de x = (%d,%d,%d)\n", 
-                y%rs, (y%n)/rs, y/n, x%rs, (x%n)/rs, x/n);
-#endif
-          } /* if y */
-        } /* for k */
-        break;
-
-      } /* switch (connex) */
-    } /* if (M[x] != 0) */
-  } /* for x */
-
-  x = FahPop(FAH);
-#ifdef PARANO
-  if (x != -1)
-  {   
-     printf("segment3di() : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n");
-     return(0);
-  }
-#endif
-
-  /* ================================================================= */
-  /* INONDATION */
-  /* ================================================================= */
-
-  while (! FahVide(FAH))
-  {
-    x = FahPop(FAH);
-#ifdef DEBUG
-  printf("FAH POP x = (%d,%d,%d)\n", 
-                   x%rs, (x%n)/rs, x/n);
-#endif
-    if (M[x] == 0)
-    {
-      ncc = 0;
-      h = F[x];
-      tailleplateau = 0;
-      /* 1er parcours du plateau de x : enregistre les etiquettes voisines */
-      /* les points du plateau sont marques (MARQUE1) */
-      /* les points voisins du plateau sont marques (MARQUE2) */
-
-      Set(x, MARQUE1);
-      LifoPush(LIFO, x);
-      while (! LifoVide(LIFO))
-      {
-        w = LifoPop(LIFO);     /* w est un point du h-plateau */
-#ifdef DEBUG
-  printf("Lifo Pop w = (%d,%d,%d), plateau de x = (%d,%d,%d)\n", 
-                   w%rs, (w%n)/rs, w/n, x%rs, (x%n)/rs, x/n);
-#endif
-        tailleplateau++;
-        switch (connex)
-        {
-          case 6:
-            for (k = 0; k <= 10; k += 2) /* parcourt les 6 voisins */
-            {
-              y = voisin6(w, k, rs, n, N);
-              if (y != -1)
-              {
-                if  ((M[y] != 0) && (!IsSet(y, MARQUE2)))
-                {
-                  if (ncc >= nccmax)
-                  {   
-                    printf("segment() : ncc = %d ; nccmax = %d\n", ncc, nccmax);
-                    return(0);
-                  }
-                  if (NotIn(M[y], etiqcc, ncc))
-		  {
-                    etiqcc[ncc] = M[y];
-                    ncc += 1;
-		  }
-                  Set(y, MARQUE2);
-                }
-                if ((F[y] == h) && (!IsSet(y, MARQUE1)))
-                {
-                  Set(y, MARQUE1);
-                  LifoPush(LIFO, y);
-                }
-              } /* if (y != -1) */
-            } /* for (k = 0; k < 8; k += incr_vois) */
-            break;
-          case 18:
-            for (k = 0; k < 18; k++) /* parcourt les 18 voisins */
-            {
-              y = voisin18(w, k, rs, n, N);
-              if (y != -1)
-              {
-                if  ((M[y] != 0) && (!IsSet(y, MARQUE2)))
-                {
-                  if (ncc >= nccmax)
-                  {   
-                    printf("segment() : ncc = %d ; nccmax = %d\n", ncc, nccmax);
-                    return(0);
-                  }
-                  if (NotIn(M[y], etiqcc, ncc))
-		  {
-                    etiqcc[ncc] = M[y];
-                    ncc += 1;
-		  }
-                  Set(y, MARQUE2);
-                }
-                if ((F[y] == h) && (!IsSet(y, MARQUE1)))
-                {
-                  Set(y, MARQUE1);
-                  LifoPush(LIFO, y);
-                }
-              } /* if (y != -1) */
-            } /* for (k = 0; k < 8; k += incr_vois) */
-            break;
-          case 26:
-            for (k = 0; k < 26; k++) /* parcourt les 26 voisins */
-            {
-              y = voisin26(w, k, rs, n, N);
-              if (y != -1)
-              {
-                if  ((M[y] != 0) && (!IsSet(y, MARQUE2)))
-                {
-                  if (ncc >= nccmax)
-                  {   
-                    printf("segment() : ncc = %d ; nccmax = %d\n", ncc, nccmax);
-                    return(0);
-                  }
-                  if (NotIn(M[y], etiqcc, ncc))
-		  {
-                    etiqcc[ncc] = M[y];
-                    ncc += 1;
-		  }
-                  Set(y, MARQUE2);
-                }
-                if ((F[y] == h) && (!IsSet(y, MARQUE1)))
-                {
-                  Set(y, MARQUE1);
-                  LifoPush(LIFO, y);
-                }
-              } /* if (y != -1) */
-            } /* for (k = 0; k < 8; k += incr_vois) */
-            break;
-	} /* switch (connex) */
-      } /* while (! LifoVide(LIFO)) */
-      ncc = DiffAnc(CBT, ncc, etiqcc);
-
-#ifdef PARANO
-      if (ncc == 0)
-      {
-        fprintf(stderr, "segment3di() : construction arbre : PAS DE cc DANS LE VOISINAGE !!!\n"); 
-        fprintf(stderr, "x = (%d,%d,%d)\n", x%rs, (x%n)/rs, x/n);
-        return(0);  
-      } else
-#endif
-      if (ncc == 1)
-      {
-        /* 2nd parcours du plateau de x : positionne les etiquettes M */
-        /* les points du plateau sont demarques (MARQUE1) */
-        /* les points voisins du plateau sont demarques (MARQUE2) */
-        /* les voisins du plateau sont eventuellement mis en FAH */
-
-        UnSet(x, MARQUE1);
-        LifoPush(LIFO, x);
-        while (! LifoVide(LIFO))
-        {
-          int32_t masque = 0, imasque = 1;
-
-          w = LifoPop(LIFO);     /* w est un point du h-plateau */
-          M[w] = etiqcc[0];
-          switch (connex)
-          {
-            case 6:
-              for (k = 0; k <= 10; k += 2) /* parcourt les 6 voisins */
-              {
-                y = voisin6(w, k, rs, n, N);
-                if (y != -1)
-                {
-                  UnSet(y, MARQUE2);
-                  if ((! IsSet(y, EN_FAH)) && (M[y] == 0) && (!IsSet(y, MARQUE1)))
-                  {
-                    FahPush(FAH, y, F[y]);
-                    Set(y, EN_FAH);
-                  }
-                  if ((F[y] == h) && (IsSet(y, MARQUE1)))
-                  {
-                    UnSet(y, MARQUE1);
-                    LifoPush(LIFO, y);
-                  }
-                } /* if (y != -1) */
-              } /* for (k = 0; ... */
-              break;
-            case 18:
-              for (k = 0; k < 18; k++) /* parcourt les 18 voisins */
-              {
-                y = voisin18(w, k, rs, n, N);
-                if (y != -1)
-                {
-                  UnSet(y, MARQUE2);
-                  if ((! IsSet(y, EN_FAH)) && (M[y] == 0) && (!IsSet(y, MARQUE1)))
-                  {
-                    FahPush(FAH, y, F[y]);
-                    Set(y, EN_FAH);
-                  }
-                  if ((F[y] == h) && (IsSet(y, MARQUE1)))
-                  {
-                    UnSet(y, MARQUE1);
-                    LifoPush(LIFO, y);
-                  }
-                } /* if (y != -1) */
-              } /* for (k = 0; ... */
-              break;
-            case 26:
-              for (k = 0; k < 26; k++) /* parcourt les 26 voisins */
-              {
-                y = voisin26(w, k, rs, n, N);
-                if (y != -1)
-                {
-                  UnSet(y, MARQUE2);
-                  if ((! IsSet(y, EN_FAH)) && (M[y] == 0) && (!IsSet(y, MARQUE1)))
-                  {
-                    FahPush(FAH, y, F[y]);
-                    Set(y, EN_FAH);
-#ifdef DEBUG
-  printf("empile y = (%d,%d,%d) voisin de w = (%d,%d,%d)\n", 
-                   y%rs, (y%n)/rs, y/n, w%rs, (w%n)/rs, w/n);
-#endif
-                  }
-                  if ((F[y] == h) && (IsSet(y, MARQUE1)))
-                  {
-                    UnSet(y, MARQUE1);
-                    LifoPush(LIFO, y);
-                  }
-                } /* if (y != -1) */
-              } /* for (k = 0; ... */
-              break;
-	  } /* switch (connex) */
-        } /* while (! LifoVide(LIFO)) */
-
-        /* mise a jour de la surface, profondeur, volume pour le plateau */
-#ifndef NOSURFVOL
-        SURF[M[w]] += tailleplateau;
-        if (F[w] + 1 > DERPROF[M[w]])
-        {
-          VOL[M[w]] += SURF[M[w]] * (F[w] + 1 - DERPROF[M[w]]);
-          DERPROF[M[w]] = F[w] + 1;
-        }
-#endif
-      } /* if (ncc == 1) */
-      else
-      {
-        new = CreateCell(CBT, &nbcell, nbmaxcell);
-        SetData(CBT, new, F[x]);     /* conceptuellement : F[x] + 1 */
-        for (i = 0; i < ncc; i++) SetFather(CBT, etiqcc[i], new);
-
-        /* 2nd parcours du plateau de x : positionne les etiquettes M */
-        /* les points du plateau sont demarques (MARQUE1) */
-        /* les points voisins du plateau sont demarques (MARQUE2) */
-        /* les voisins du plateau sont eventuellement mis en FAH */
-
-        UnSet(x, MARQUE1);
-        LifoPush(LIFO, x);
-        while (! LifoVide(LIFO))
-        {
-          int32_t masque = 0, imasque = 1;
-
-          w = LifoPop(LIFO);     /* w est un point du h-plateau */
-          UnSet(w, MARQUE1);
-          M[w] = new;
-          switch (connex)
-          {
-            case 6:
-              for (k = 0; k <= 10; k += 2) /* parcourt les 6 voisins */
-              {
-                y = voisin6(w, k, rs, n, N);
-                if (y != -1)
-                {
-                  UnSet(y, MARQUE2);
-                  if ((! IsSet(y, EN_FAH)) && (M[y] == 0) && (!IsSet(y, MARQUE1)))
-                  {
-                    FahPush(FAH, y, F[y]);
-                    Set(y, EN_FAH);
-                  }
-                  if ((F[y] == h) && (IsSet(y, MARQUE1)))
-                  {
-                    UnSet(y, MARQUE1);
-                    LifoPush(LIFO, y);
-                  }
-                } /* if (y != -1) */
-              } /* for (k = 0; ... */
-              break;
-            case 18:
-              for (k = 0; k < 18; k++) /* parcourt les 18 voisins */
-              {
-                y = voisin18(w, k, rs, n, N);
-                if (y != -1)
-                {
-                  UnSet(y, MARQUE2);
-                  if ((! IsSet(y, EN_FAH)) && (M[y] == 0) && (!IsSet(y, MARQUE1)))
-                  {
-                    FahPush(FAH, y, F[y]);
-                    Set(y, EN_FAH);
-                  }
-                  if ((F[y] == h) && (IsSet(y, MARQUE1)))
-                  {
-                    UnSet(y, MARQUE1);
-                    LifoPush(LIFO, y);
-                  }
-                } /* if (y != -1) */
-              } /* for (k = 0; ... */
-              break;
-            case 26:
-              for (k = 0; k < 26; k++) /* parcourt les 26 voisins */
-              {
-                y = voisin26(w, k, rs, n, N);
-                if (y != -1)
-                {
-                  UnSet(y, MARQUE2);
-                  if ((! IsSet(y, EN_FAH)) && (M[y] == 0) && (!IsSet(y, MARQUE1)))
-                  {
-                    FahPush(FAH, y, F[y]);
-                    Set(y, EN_FAH);
-#ifdef DEBUG
-  printf("newcell: empile y = (%d,%d,%d) voisin de w = (%d,%d,%d)\n", 
-                   y%rs, (y%n)/rs, y/n, w%rs, (w%n)/rs, w/n);
-#endif
-                  }
-                  if ((F[y] == h) && (IsSet(y, MARQUE1)))
-                  {
-                    UnSet(y, MARQUE1);
-                    LifoPush(LIFO, y);
-                  }
-                } /* if (y != -1) */
-              } /* for (k = 0; ... */
-              break;
-	  } /* switch (connex) */
-        } /* while (! LifoVide(LIFO)) */
-
-#ifndef NOSURFVOL
-        SURF[M[x]] = tailleplateau;
-#endif
-        prof = 0;
-        for (i = 0; i < ncc; i++)
-        {
-          k = PROF[etiqcc[i]]+F[x]-Data(CBT,etiqcc[i]); /* conceptuellement : F[x] + 1 */
-          if (k > prof) prof = k;
-#ifndef NOSURFVOL
-          SURF[M[x]] += SURF[etiqcc[i]];
-          if (F[x] + 1 > DERPROF[etiqcc[i]])
-          {
-            VOL[etiqcc[i]] += SURF[etiqcc[i]] * (F[x] + 1 - DERPROF[etiqcc[i]]);
-            DERPROF[etiqcc[i]] = F[x] + 1;
-          }
-          VOL[M[x]] += VOL[etiqcc[i]];
-#endif
-        } /* for i */
-        PROF[M[x]] = prof;
-#ifndef NOSURFVOL
-        DERPROF[M[x]] = F[x] + 1;
-#endif
-      } /* else if (ncc == 1) */
-    } /* if (!IsSet(x, TRAITE)) */
-  } /* while (! FahVide(FAH)) */
-  /* FIN INONDATION */
-
-#ifdef VERBOSE
-  printf("FIN DE LA CONSTRUCTION DE L'ARBRE DES COMPOSANTES\n");
-#endif
-
-  free(etiqcc);
-
-  T = Regularise(CBT, nminima, nbcell);
-
-  for (x = 0; x < N; x++)
-    if ((M[x] >= nminima) && (T[M[x] - nminima]))
-      M[x] = T[M[x] - nminima]; /* nouvelle etiquette pour le point x */
-
-  free(T);
-
-#ifdef PARANO
-  for (i = 0; i < nbcell; i++)
-    if (Label(CBT,i)) printf("ERROR : label = %d\n", Label(CBT, i));
-#endif
-
-#ifdef VERBOSE
-  printf("FIN DE LA REGULARISATION DE L'ARBRE DES COMPOSANTES\n");
-#endif
-
-  /* ================================================ */
-  /* SEGMENTATION                               */
-  /* ================================================ */
-
-  temp = allocimage(NULL, rs, cs, d, VFF_TYP_1_BYTE);
-  if (temp == NULL)
-  {   fprintf(stderr, "lsegmenti() : allocimage failed\n");
-      return(0);
-  }
-  TEMP = UCHARDATA(temp);
-
-  /* pour la mesure de la profondeur, il faut rajouter la difference de niveau avec le pere */
-  /* on remplace donc les MU dans l'arbre */
-  for (x = 1; x < nbcell; x++) UnSetAll(x);
-  FahFlush(FAH);
-  for (i = 1; i < nminima+1; i++) FahPush(FAH, i, 0);
-  while (! FahVide(FAH))
-  {
-    k = FahNiveau(FAH);
-    x = FahPop(FAH);
-    y = Father(CBT,x);
-    if (y != NIL)
-    { 
-      PROF[x] += ((Data(CBT,y) - 1) - Data(CBT,x));
-      if (!IsSet(y, EN_FAH))
-      { 
-        Set(y, EN_FAH);
-        FahPush(FAH, y, k + 1); 
-      }
-    }
-    else PROF[x] = NDG_MAX - NDG_MIN; /* prof. maximum pour la racine */
-  } 
-
-  I = InverseCBT(CBT, nminima, nbcell);
-
-/*  1ERE ETAPE : SELECTIONNE LE NB MAX DE CC PERTINENTES */
-
-ReSegment:
-  /* init:  ranger au niveau 0 de la FAH les feuilles du CBT */
-  FahFlush(FAH);
-  for (i = 1; i < nminima+1; i++) FahPush(FAH, i, 0);
-
-  while (! FahVide(FAH))
-  {
-    k = FahNiveau(FAH);
-    x = FahPop(FAH);
-
-    if (Label(CBT,x) == NONMARQUE)
-    {
-      if (((PROF[x] >= seuilprof) || (!(mesure & PROFONDEUR))) 
-#ifndef NOSURFVOL
-          && ((SURF[x] >= seuilsurf) || (!(mesure & SURFACE)))
-          && ((VOL[x] >= seuilvol) || (!(mesure & VOLUME)))
-#endif
-         )
-      {
-        Label(CBT,x) = PERTINENT;
-        y = Father(CBT,x);
-        while ((y != NIL) && (Label(CBT,y) != INVALIDE))
-        {
-          Label(CBT,y) = INVALIDE;
-          y = Father(CBT,y);
-        } /* while ((y != NIL) && (Label(CBT,y) != INVALIDE)) */
-      } /* if (MU[x] >= seuil) */
-      else
-      {
-        y = Father(CBT,x);
-        if ((y != NIL) && (Label(CBT,y) != INVALIDE))
-          FahPush(FAH, y, k + 1);
-      } /* else if (MU[x] >= seuil) */
-    } /* if (Label(CBT,x) != INVALIDE) */
-  } /* while (! FahVide(FAH)) */
-
-/*  2EME ETAPE : MAXIMISE AU SENS DE L'INCLUSION */
-
-  if (maximise)
-  {
-    FahFlush(FAH);
-    for (x = 1; x < nbcell - 1; x++)   /* pas la racine */
-      if (Label(CBT, x) == PERTINENT)
-        FahPush(FAH, x, Data(CBT, x));
-
-    while (! FahVide(FAH))
-    {
-      int32_t n, nbfilspert;
-
-      x = FahPop(FAH);
-      y = Father(CBT, x);
-      k = FirstSon(CBT, y);
-      if (y < nbcell - 1)              /* pas la racine */
-        n = FirstSon(CBT, y + 1) - FirstSon(CBT, y);
-      else
-        n = nbcell - 2 - FirstSon(CBT, y);
-      nbfilspert = 0;
-      for (i = 0; i < n; i++)
-        if ((Label(CBT, I[k+i]) == PERTINENT) || (Label(CBT, I[k+i]) == INVALIDE))
-          nbfilspert++;
-      if (nbfilspert == 1)
-      {
-        Label(CBT, x) = NONMARQUE;
-        Label(CBT, y) = PERTINENT;
-        FahPush(FAH, y, Data(CBT, y));
-      } /* if (nbfilspert == 1) */
-    } /* while (! FahVide(FAH)) */
-  } /* if (maximise) */
-
-/* RECUPERATION DE LA SEGMENTATION */
-
-  for (i = 0; i < N; i++)
-  {
-    x = M[i];
-
-    while ((x != NIL) && (Label(CBT,x) == NONMARQUE)) 
-      x = Father(CBT,x);
-    if (Label(CBT,x) == PERTINENT)
-      TEMP[i] = 255;
-    else
-      TEMP[i] = 0;
-  } /* for x */  
-
-  FahFlush(FAH);
-  for (i = 0; i < nbcell; i++) Label(CBT,i) = 0;
-
-/* ===========================================================
-    affichage : 
-   ===========================================================
-
-    <------- rs ------>     
-    ------------------- .
-    |                 | .
-    |                 | .
-    |                 | .
-    |      image      | cs
-    |                 | .
-    |                 | .
-    |                 | .
-    --------------------------------------------------
-    | SURF | 111  |  +   |  -   |  1   |  10  | MAX  |        BoxHeight
-    --------------------------------------------------
-    | PROF | 111  |  +   |  -   | 100  | 1000 |      |        BoxHeight
-    --------------------------------------------------
-    | VOL  | 111  |  +   |  -   | 10K  | 100K | SAVE |        BoxHeight
-    --------------------------------------------------
-    | PLAN | 111  |  +   |  -   | 1000K|  OK  | QUIT |        BoxHeight
-    --------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-ReDisplayImage:
-
-  /* send output to the screen */
-#ifdef COLOR
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-  {
-    if (TEMP[x])    
-      Color(MC_RED);
-    else
-      Color(F[x]/4);
-#ifdef ZOOM4
-    Point(2*((x%n)%rs), 2*((x%n)/rs));
-    Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-    Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-    Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-#else
-    Point((x%n)%rs, (x%n)/rs);
-#endif
-  }
-#else
-  ColToWhite();
-  FRectangle(0, 0, ImageWidth, ImageHeight);
-  ColToBlack();
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-    if (TEMP[x])
-    {   
-#ifdef ZOOM4
-      Point(2*((x%n)%rs), 2*((x%n)/rs));
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs));
-      Point(2*((x%n)%rs), 2*((x%n)/rs)+1);
-      Point(2*((x%n)%rs)+1, 2*((x%n)/rs)+1);
-#else
-      Point((x%n)%rs, (x%n)/rs);
-#endif
-    }
-#endif
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, ImageHeight + i * BoxHeight, k * BoxWidth, ImageHeight + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, ImageHeight + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  switch (increment)
-  {
-    case 1: FRectangle(4 * BoxWidth, ImageHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, ImageHeight + BoxHeight - 2, ButtonStrings[0][4]);
-            ColToBlack();
-            break;
-   case 10: FRectangle(5 * BoxWidth, ImageHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, ImageHeight + BoxHeight - 2, ButtonStrings[0][5]);
-            ColToBlack();
-            break;
-  case 100: FRectangle(4 * BoxWidth, ImageHeight + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, ImageHeight + 2*BoxHeight - 2, ButtonStrings[1][4]);
-            ColToBlack();
-            break;
- case 1000: FRectangle(5 * BoxWidth, ImageHeight + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, ImageHeight + 2*BoxHeight - 2, ButtonStrings[1][5]);
-            ColToBlack();
-            break;
-case 10000: FRectangle(4 * BoxWidth, ImageHeight + 2*BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, ImageHeight + 3*BoxHeight - 2, ButtonStrings[2][4]);
-            ColToBlack();
-            break;
-case 100000: FRectangle(5 * BoxWidth, ImageHeight + 2*BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, ImageHeight + 3*BoxHeight - 2, ButtonStrings[2][5]);
-            ColToBlack();
-            break;
-case 1000000: FRectangle(4 * BoxWidth, ImageHeight + 3*BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, ImageHeight + 4*BoxHeight - 2, ButtonStrings[3][4]);
-            ColToBlack();
-            break;
-  } /* switch (increment) */
-
-  if (mesure & SURFACE)
-  {
-    FRectangle(0, ImageHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + BoxHeight - 2, ButtonStrings[0][0]);
-    ColToBlack();
-  }
-  if (mesure & PROFONDEUR)
-  {
-    FRectangle(0, ImageHeight + BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 2*BoxHeight - 2, ButtonStrings[1][0]);
-    ColToBlack();
-  }
-  if (mesure & VOLUME)
-  {
-    FRectangle(0, ImageHeight + 2*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 3*BoxHeight - 2, ButtonStrings[2][0]);
-    ColToBlack();
-  }
-
-  FlushGraphics();  
-
-  WaitMouseEvent(&xx, &yy);
-
-  xx /= BoxWidth;
-  yy -= ImageHeight;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: 
-#ifndef NOSURFVOL
-                      if ((mesure & SURFACE) && (mesure != SURFACE)) 
-                        mesure &= ~SURFACE;
-                      else if (!(mesure & SURFACE))
-                        mesure |= SURFACE;
-#endif
-                      break;
-              case 1: break;
-              case 2: seuilsurf = seuilsurf + increment;
-                      sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-                      break;
-              case 3: seuilsurf = seuilsurf - increment;
-                      if (seuilsurf < 1) seuilsurf = 1;
-                      sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-                      break;
-              case 4: increment = 1;
-                      break;
-              case 5: increment = 10;
-                      break;
-              case 6: maximise = !maximise;
-                      if (maximise)
-                        sprintf(ButtonStrings[0][6], " MAX");
-                      else
-                        sprintf(ButtonStrings[0][6], " MIN");
-                      break;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: if ((mesure & PROFONDEUR) && (mesure != PROFONDEUR)) 
-                        mesure &= ~PROFONDEUR;
-                      else if (!(mesure & PROFONDEUR))
-                        mesure |= PROFONDEUR;
-                      break;
-              case 1: break;
-              case 2: seuilprof = seuilprof + increment;
-                      sprintf(ButtonStrings[1][1], "%d", seuilprof);
-                      break;
-              case 3: seuilprof = seuilprof - increment;
-                      if (seuilprof < 0) seuilprof = 0;
-                      sprintf(ButtonStrings[1][1], "%d", seuilprof);
-                      break;
-              case 4: increment = 100;
-                      break;
-              case 5: increment = 1000;
-                      break;
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    case 2: switch(xx)
-            {
-              case 0: 
-#ifndef NOSURFVOL
-                      if ((mesure & VOLUME) && (mesure != VOLUME)) 
-                        mesure &= ~VOLUME;
-                      else if (!(mesure & VOLUME))
-                        mesure |= VOLUME;
-#endif
-                      break;
-              case 1: break;
-              case 2: seuilvol = seuilvol + increment;
-                      sprintf(ButtonStrings[2][1], "%d", seuilvol);
-                      break;
-              case 3: seuilvol = seuilvol - increment;
-                      if (seuilvol < 0) seuilvol = 0;
-                      sprintf(ButtonStrings[2][1], "%d", seuilvol);
-                      break;
-              case 4: increment = 10000;
-                      break;
-              case 5: increment = 100000;
-                      break;
-              case 6: 
-                      sprintf(buf, "tmp_segment3di_%d", nsave);
-                      writeimage(temp, buf);
-                      nsave++;
-                      break;
-            } /* switch(xx) */
-            break;
-    case 3: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: iplan++;
-                      if (iplan > d-1) iplan = d-1;
-                      sprintf(ButtonStrings[3][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 3: iplan--;
-                      if (iplan < 0) iplan = 0;
-                      sprintf(ButtonStrings[3][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 4: increment = 1000000;
-                      break;
-              case 5: ColToWhite();
-                      FRectangle(10, 0, 160, 30);
-                      ColToBlack();
-                      String(20, 20, "processing..."); 
-                      FlushGraphics();  
-                      goto ReSegment;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-
-  for (x = 0; x < N; x++) F[x] = TEMP[x];
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      free(ButtonStrings[i][k]);
-  freeimage(temp);
-  free(I);
-  free(PROF);
-#ifndef NOSURFVOL
-  free(SURF);
-  free(DERPROF);
-  free(VOL);
-#endif
-  IndicsTermine();
-  FahTermine(FAH);
-  LifoTermine(LIFO);
-  free(CBT);
-  freeimage(lab);
-  return(1);
-}
diff -r 8b1af7363833 src/lib/lsegmenti.c
--- a/src/lib/lsegmenti.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1741 +0,0 @@
-/* $Id: lsegmenti.c,v 1.1.1.1 2008-11-25 08:01:41 mcouprie Exp $ */
-/* operateur interactif de segmentation */
-/* utilise une File d'Attente Hierarchique */
-/* utilise un arbre des composantes (anciennement nomme captation basin tree, CBT) */
-/* Michel Couprie - novembre 1996 */
-/* version 3.3 du 25/8/97 */
-/*
-  20/1/97 : correction de la mesure de la profondeur 
-  5/08/97 : affichage en niveaux de gris
-  25/O8/97 : connexites 4 ou 8
-  01/09/97 : zoom (x 4)
-  1/2/98 : - retire   UnSetAll(x);   apres        ncc = 0; x = FahPop(FAH);
-           - remplace
-               n = FirstSon(CBT, y + 1) - FirstSon(CBT, y);
-             par
-               if (y < nbcell - 1)
-                 n = FirstSon(CBT, y + 1) - FirstSon(CBT, y);
-               else
-                 n = nbcell - 2 - FirstSon(CBT, y);
-           - nouvelle construction de l'arbre : travaille au niveau des plateaux et
-             non plus des pixels
-  14/3/98 : ajoute le perimetre et l'indice de circularite
-            la circularite est definie dans le continu par le rapport :
-                                          2
-                     4 . PI . Surf / Perim        et vaut 1 pour un disque. 
-
-            en discret, une etude empirique donne les facteurs K1 ou K2 a la place de 4.PI,
-            avec K1 = 256/21 pour Perim <= 16, et K2 = 13924/757 sinon.
-  18/3/98 : etude de la signature des attributs 
-  20/3/98 : ajout de l'attribut "distance a la racine" (RDIST)
-  28/3/98 : ajout de l'attribut "nombre de trous" (TROU)
-  29/3/98 : corrige le bug de SURF
-  29/3/98 : ajout de l'attribut "densite de trous" (DTROU = TROU*10000/SURF)
-  08/4/98 : ajout de l'attribut excentricite
-  24/5/98 : reconstruction
-*/
-
-#define PARANO                 /* even paranoid people have ennemies */
-#define VERBOSE
-
-#define VOL2
-#define MAXCOND
-
-/*
-#define ZOOM4
-#define DEBUGSURF
-#define TRACECBT
-*/
-
-/*
-   Methode : 
-
-===============================================
- CONSTRUCTION DU CBT
-===============================================
-  entree : une image F
-  sortie : le CBT, l'application M: Dom(F) -> CBT
-
-  M <- etiquettes des minima de F
-  nminima <- nombre de minima de F
-  init(CBT, nminima)
-  pour tout point x de Dom(F)
-    si x appartient a un minimum
-      SetData(CBT, M[x], F[x] + 1);
-      pour tout y dans gamma4(x)
-        si y n'appartient pas a un minimum et pas deja dans FAH
-          FahPush(FAH, y, F[y]);
-        finsi
-      finpour
-    finsi
-  finpour
-
-  tant que FAH non vide
-    x = FahPop(FAH);
-    etiqcc = liste des M[y], y dans le voisinage du plateau de x
-    diffanc = liste des ancetres differents des etiquettes de etiqcc dans le CBT
-    si |diffanc| == 1
-      M[x] = first(diffanc)
-    sinon
-      new = CreateCell(CBT)
-      M[x] = new
-      SetData(CBT, new, F[x] + 1)
-      pour tout a dans diffanc 
-        SetFather(CBT, a, new)
-      finpour
-    fin si
-    pour tout y dans gamma4(x) pas deja dans FAH
-      si M[y] == 0
-        FahPush(FAH, y, F[y]);
-      finsi
-    finpour
-  fintantque
-
-  regularise(CBT) 
-
-===============================================
- SEGMENTATION
-===============================================
-
-  en parallele avec la construction du CBT, on a recueilli une "mesure" (MU)
-  des bassins versants.
-
-  ici cette mesure est la surface de la plus grande coupe d'un BV avant sa fusion
-  avec un autre.
-
-  l'algorithme de segmentation est alors:
-
-  1ERE ETAPE : SELECTIONNE LE NB MAX DE CC PERTINENTES
-
-  init:  ranger au niveau 0 de la FAH les feuilles du CBT
-
-  tant que FAH non vide faire
-    k = FAHNIVEAU()
-    x = FAHPOP()
-    si MU[c] >= seuil alors
-      marque les ancetres de x "INVALIDE"
-      marque x "PERTINENT"
-    sinon
-      si pere(x) existe et non INVALIDE alors FAHPUSH(pere(x), k+1) finsi
-    finsi
-  fintantque
-
-  2EME ETAPE (FACULTATIVE) : MAXIMISE AU SENS DE L'INCLUSION 
-
-  Re-init:  ranger a leur niveau data dans la FAH les cellules PERTINENTes
-
-  I = arbre inverse
-
-  tant que FAH non vide faire
-    x = FAHPOP()
-    y = pere(x)
-    si y existe alors 
-      k = FirstSon(y)
-      n = FirstSon(y + 1) - FirstSon(y)
-      nbfilspert = 0
-      pour i de 0 a n-1 faire
-        si Label(I[k+i]) == PERTINENT
-          nbfilspert++ finsi finpour
-      si nbfilspert == 1 alors
-        Label(x) = NONMARQUE
-        Label(y) = PERTINENT
-        FahPush(y, Data(y))
-      finsi
-    finsi
-  fintantque
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <math.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mclifo.h>
-#include <mcfah.h>
-#include <mcindic.h>
-#include <mccbt.h>
-#include <mctopo.h>
-#include <mcxbib.h>
-#include <lsegmenti.h>
-
-#define EN_FAH     0
-#define MINIMUM    1
-#define MARQUE1    2
-#define MARQUE2    3
-#define MARQUETROU 4
-
-#define NONMARQUE  0
-#define INVALIDE   1
-#define PERTINENT  2
-
-#define K1 (256.0/21.0)
-#define K2 (13924.0/757.0)
-
-#include <unistd.h>
-/* ==================================== */
-static void visualise(int32_t tabres[], char * c, int32_t x, int32_t y)
-/* ==================================== */
-{
-  int32_t i, lastv;
-  FILE *fd = NULL;
-  char filename[32];
-/*
-  for (i = 0; i < 256; i++)
-    if (tabres[i] != -1)
-      printf("%d:%d ", i, tabres[i]);
-  printf("\n");
-*/
-  sprintf(filename, "_%s_%d_%d.sign", c, x, y);
-  fd = fopen(filename, "w");
-  if (!fd)
-  {
-    fprintf(stderr, "lsegmenti: unable to open file: %s\n", filename);
-    exit (0);
-  }
-  fprintf(fd, "\"%s\n", c);
-  fprintf(fd, "%d %d\n", 0, 0);
-  lastv = 0;
-  for (i = 0; i < 256; i++)
-    if (tabres[i] != -1)
-    {
-      fprintf(fd, "%d %d\n", i, lastv);
-      fprintf(fd, "move %d %d\n", i, tabres[i]);
-      lastv = tabres[i];
-    }
-  fprintf(fd, "%d %d\n", 255, lastv);
-
-  if (fork() == 0) /* fils - processus xgraph */
-  {
-    execlp("xgraph", "xgraph", "=400x180+0+0", "-lw", "4", filename, NULL);
-    perror("xgraph");
-  }
-
-  fclose(fd);
-} /* visualise() */
-
-#ifdef MOMENTS
-/* ==================================== */
-int32_t excentricity(double mx1, double my1, double mx2, double my2, 
-                 double mxy2, int32_t n)
-/* ==================================== */
-{
-  double Mx2, My2, Mxy2, delta;
-  double lambda1, lambda2;
-
-  /* moments d'ordre 2 */
-  Mx2 = mx2 - mx1 * mx1 / n;  
-  My2 = my2 - my1 * my1 / n;  
-  Mxy2 = mxy2 - mx1 * my1 / n;
-
-  /* calcul des valeurs propres de la matrice des covariances */
-  delta = (Mx2 - My2) * (Mx2 - My2) + 4 * Mxy2 * Mxy2;
-  lambda1 = (Mx2 + My2 + sqrt(delta)) / 2.0;
-  lambda2 = (Mx2 + My2 - sqrt(delta)) / 2.0;
-#ifdef DEBUGEXCEN
-  printf("Mx2 = %g ; My2 = %g ; Mxy2 = %g ; delta = %g\n", Mx2, My2, Mxy2, delta);
-  printf("lambda1 = %g ; lambda2 = %g\n", lambda1, lambda2);
-#endif
-  if (lambda2 < 0.0)
-  {
-    fprintf(stderr, "excentricity : valeur propre negative : %g\n", lambda2);
-    return 0;
-  }
-  return 255 - (int32_t)(lambda2 * 255 / lambda1);
-} /* excentricity() */
-#endif
-
-/* ==================================== */
-static
-int32_t circ(int32_t area, int32_t perim)
-/* ==================================== */
-{
-  int32_t val_attrib;
-  if (perim <= 30)
-    val_attrib = (int32_t)(100 * K1 * (double)area / (double)(perim * perim));
-  else
-    val_attrib = (int32_t)(100 * K2 * (double)area / (double)(perim * perim));
-  if (val_attrib > 100) return 100;
-  return val_attrib;
-} /* circ() */
-
-/* ==================================== */
-static
-int32_t dtrou(int32_t area, int32_t trou)
-/* ==================================== */
-{
-  return (10000 * trou) / area;
-} /* dtrou() */
-
-/* ==================================== */
-static
-void signature(int32_t mesure, int32_t X, int32_t Y, int32_t * M, cbtcell * CBT, int32_t rs, 
-               int32_t *SURF, int32_t *PROF, int32_t *VOL, int32_t *PER, 
-               uint8_t *RDIST, int32_t *TROU, uint8_t *EXCEN)
-/* ==================================== */
-{
-  int32_t tabres[256];
-  int32_t i;
-
-  for (i = 0; i < 256; i++) tabres[i] = -1;
-
-  if (mesure & PROFONDEUR)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)] = PROF[i]; i = Father(CBT, i); }
-    visualise(tabres, "prof", X, Y);
-  }
-  if (mesure & SURFACE)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)] = SURF[i]; i = Father(CBT, i); }
-    visualise(tabres, "surf", X, Y);
-  }
-  if (mesure & VOLUME)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)] = VOL[i]; i = Father(CBT, i); }
-    visualise(tabres, "vol", X, Y);
-  }
-  if (mesure & PERIMETRE)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)] = PER[i]; i = Father(CBT, i); }
-    visualise(tabres, "perim", X, Y);
-  }
-  if (mesure & CIRCULARITE)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)]=circ(SURF[i],PER[i]); i=Father(CBT,i); }
-    visualise(tabres, "circ", X, Y);
-  }
-  if (mesure & ROOTDIST)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)]= RDIST[i]; i=Father(CBT,i); }
-    visualise(tabres, "rdist", X, Y);
-  }
-  if (mesure & NBTROUS)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)]= TROU[i]; i=Father(CBT,i); }
-    visualise(tabres, "trou", X, Y);
-  }
-  if (mesure & DENSTROUS)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)]= dtrou(SURF[i],TROU[i]); i=Father(CBT,i); }
-    visualise(tabres, "dtrou", X, Y);
-  }
-#ifdef MOMENTS
-  if (mesure & EXCENTRICITE)
-  {
-    i = M[Y * rs + X];
-    while (i != NIL) { tabres[Data(CBT,i)]= EXCEN[i]; i=Father(CBT,i); }
-    visualise(tabres, "excen", X, Y);
-  }
-#endif
-} /* signature() */
-
-
-/* ==================================== */
-static
-void printcomp(int32_t X, int32_t Y, int32_t * M, cbtcell * CBT, int32_t rs,
-               int32_t *SURF, int32_t *PROF, int32_t *VOL, int32_t *PER, 
-               uint8_t *RDIST, int32_t *TROU, uint8_t *EXCEN)
-/* ==================================== */
-{
-  int32_t x = M[Y*rs + X];
-  printf("niveau %d (%d, point %d,%d) \n", 
-          Data(CBT, x), x, X, Y);
-
-  while ((x != NIL) && (Label(CBT,x) == NONMARQUE)) 
-    x = Father(CBT,x);
-  if (Label(CBT,x) == PERTINENT)
-    printf("composante PERTINENTE de niveau %d (%d, point %d,%d) \n", 
-            Data(CBT, x), x, X, Y);
-  else
-    printf("composante NON PERTINENTE de niveau %d (%d, point %d,%d) \n", 
-            Data(CBT, x), x, X, Y);
-#ifdef MOMENTS
-  printf("PROF\tSURF\tVOL(K)\tPER\tCIRC\tRDIST\tTROU\tDTROU\tEXCEN\n");
-  printf("%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", 
-          PROF[x], SURF[x], VOL[x]/1000, PER[x], circ(SURF[x],PER[x]), 
-          RDIST[x], TROU[x], dtrou(SURF[x],TROU[x]), EXCEN[x]);
-#else
-  printf("PROF\tSURF\tVOL(K)\tPER\tCIRC\tRDIST\tTROU\tDTROU\n");
-  printf("%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", 
-          PROF[x], SURF[x], VOL[x]/1000, PER[x], circ(SURF[x],PER[x]), 
-          RDIST[x], TROU[x], dtrou(SURF[x],TROU[x]));
-#endif
-} /* printcomp() */
-
-/* ==================================== */
-int32_t contribperim(int32_t w, uint8_t *F, uint8_t h, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t t4mm, t4m, t8p, t8pp;
-  if ((w%rs==rs-1) || (w<rs) || (w%rs==0) || (w>=N-rs)) return 1; /* point de bord */
-  nbtopoh(F, w, h, rs, N, &t4mm, &t4m, &t8p, &t8pp);
-  return t8pp;  /* les points de T8pp=n sont comptes n fois dans le perimetre */
-} /* contribperim() */
-
-/* ==================================== */
-int32_t lsegmenti(struct xvimage *image, int32_t connex)
-/* ==================================== */
-{
-  register int32_t i, k, l;        /* index muet */
-  register int32_t w, x, y, z;     /* index muet de pixel */
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *CONTRIPER;    /* pour le calcul du perimetre */
-  uint8_t *TEMP;         /* pour la recuperation de la segmentation */
-  int32_t *M;                     /* l'image d'etiquettes de composantes connexes */
-  int32_t label;
-  int32_t *T;                      /* table de correspondance pour regularisation */
-  int32_t *I;                      /* pour l'inversion du CBT */
-  int32_t nminima;                 /* nombre de minima differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  Lifo * LIFO;                 /* pour parcourir un plateau */
-  cbtcell * CBT;               /* arbre des bassins versants (Catchment Basin Tree) */
-  int32_t nbcell;
-  int32_t nbmaxcell;
-  int32_t *etiqcc;
-  int32_t nccmax;
-  int32_t ncc;
-  int32_t new;
-  int32_t prof;
-  int32_t *SURF;                   /* pour le stockage de la surface */
-  int32_t *PROF;                   /* pour le stockage de la profondeur */
-  int32_t *DERPROF;                /* pour le stockage de la derniere profondeur */
-  int32_t *VOL;                    /* pour le stockage du volume */
-  int32_t *PER;                    /* pour le stockage du perimetre */
-  int32_t *TROU;                   /* pour le stockage du nombre de trous */
-  uint8_t *RDIST;        /* pour le stockage de la dist. a la racine */
-#ifdef MOMENTS
-  uint8_t *EXCEN;        /* pour le stockage de l'excentricite */
-  double *mx1;                 /* moments */
-  double *my1;                 /*    -    */
-  double *mx2;                 /*    -    */
-  double *my2;                 /*    -    */
-  double *mxy2;                /*    -    */
-#endif
-  int32_t seuilsurf = 1;
-  int32_t seuilprof = 0;
-  int32_t seuilvol = 0;
-  int32_t seuilperim = 0;
-  int32_t seuilcirc = 0;
-  int32_t seuilrdist = 0;
-  int32_t seuiltrou = 0;
-  int32_t seuildtrou = 0;
-  int32_t seuilexcen = 0;
-  int32_t mesure = PROFONDEUR|SURFACE;  /* conjonction des mesures utilisees (defaut: prof+surf) */
-  int32_t increment = 1;
-  int32_t maximise = 0;
-  int32_t conjonction = 1;
-  int32_t incr_vois;
-  int32_t h;
-  int32_t tailleplateau;
-#define NBBUTTONS 7
-#define NBLIGBUTT 7
-#define BOXWIDTH 70
-#define BOXHEIGHT 20
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int32_t xx, yy;
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT;
-  int32_t Width = rs;
-  int32_t ImageHeight = cs;
-  int32_t ImageWidth = rs;
-
-#ifdef VOL2
-  mesure |= VOLUME;
-#endif
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lsegmenti: cette version ne traite pas les images volumiques\n");
-    exit(0);
-  }
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-    default: 
-      fprintf(stderr, "lsegmenti: mauvaise connexite: %d\n", connex);
-      return 0;
-  } /* switch (connex) */
-
-#ifdef ZOOM4
-  Height += cs;
-  Width += rs;
-  ImageHeight += cs;
-  ImageWidth += rs;
-#endif
-  if (BoxWidth * NBBUTTONS > Width) Width = BoxWidth * NBBUTTONS;
-  
-#ifdef COLOR
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-#else
-  InitGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-#endif
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], " SURF");
-  sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "  1  ");
-  strcpy(ButtonStrings[0][5], " 10  ");
-  strcpy(ButtonStrings[0][6], " MIN ");
-
-  strcpy(ButtonStrings[1][0], " PROF");
-  sprintf(ButtonStrings[1][1], "%d", seuilprof);
-  strcpy(ButtonStrings[1][2], "  +  ");
-  strcpy(ButtonStrings[1][3], "  -  ");
-  strcpy(ButtonStrings[1][4], " 100 ");
-  strcpy(ButtonStrings[1][5], " 1000");
-  strcpy(ButtonStrings[1][6], "  ET ");
-
-#ifdef VOL2
-  strcpy(ButtonStrings[2][0], " VOL ");
-  sprintf(ButtonStrings[2][1], "%d", seuilvol);
-#endif
-#ifdef PER2
-  strcpy(ButtonStrings[2][0], " PER ");
-  sprintf(ButtonStrings[2][1], "%d", seuilperim);
-#endif
-#ifdef TROU2
-  strcpy(ButtonStrings[2][0], " TROU");
-  sprintf(ButtonStrings[2][1], "%d", seuiltrou);
-#endif
-  strcpy(ButtonStrings[2][2], "  +  ");
-  strcpy(ButtonStrings[2][3], "  -  ");
-  strcpy(ButtonStrings[2][4], "10000");
-  strcpy(ButtonStrings[2][5], " OK  ");
-  strcpy(ButtonStrings[2][6], " QUIT");
-
-  strcpy(ButtonStrings[3][0], "RDIST");
-  sprintf(ButtonStrings[3][1], "%d", seuilrdist);
-  strcpy(ButtonStrings[3][2], "  +  ");
-  strcpy(ButtonStrings[3][3], "  -  ");
-  strcpy(ButtonStrings[3][4], "     ");
-  strcpy(ButtonStrings[3][5], "     ");
-  strcpy(ButtonStrings[3][6], "     ");
-
-  strcpy(ButtonStrings[4][0], " CIRC");
-  sprintf(ButtonStrings[4][1], "%d", seuilcirc);
-  strcpy(ButtonStrings[4][2], "  +  ");
-  strcpy(ButtonStrings[4][3], "  -  ");
-  strcpy(ButtonStrings[4][4], "     ");
-  strcpy(ButtonStrings[4][5], "     ");
-  strcpy(ButtonStrings[4][6], "     ");
-
-  strcpy(ButtonStrings[5][0], "DTROU");
-  sprintf(ButtonStrings[5][1], "%d", seuildtrou);
-  strcpy(ButtonStrings[5][2], "  +  ");
-  strcpy(ButtonStrings[5][3], "  -  ");
-  strcpy(ButtonStrings[5][4], "     ");
-  strcpy(ButtonStrings[5][5], "     ");
-  strcpy(ButtonStrings[5][6], "     ");
-#ifdef MOMENTS
-  strcpy(ButtonStrings[6][0], "EXCEN");
-  sprintf(ButtonStrings[6][1], "%d", seuilexcen);
-  strcpy(ButtonStrings[6][2], "  +  ");
-  strcpy(ButtonStrings[6][3], "  -  ");
-  strcpy(ButtonStrings[6][4], "     ");
-  strcpy(ButtonStrings[6][5], "     ");
-  strcpy(ButtonStrings[6][6], "     ");
-#endif
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "lsegmenti() : CreeFah failed\n");
-      return(0);
-  }
-
-  LIFO = CreeLifoVide(N);
-  if (LIFO == NULL)
-  {   fprintf(stderr, "lsegmenti() : CreeLifoVide failed\n");
-      return(0);
-  }
-
-  CONTRIPER = (uint8_t *)calloc(N, sizeof(char));
-  if (CONTRIPER == NULL)
-  {   fprintf(stderr, "lsegmenti() : calloc failed for CONTRIPER\n");
-      return(0);
-  }
-
-  /* =================================================== */
-  /* CALCUL DES ETIQUETTES DES MINIMA  */
-  /* =================================================== */
-
-  M = (int32_t *)calloc(1,N * sizeof(int32_t));
-  if (M == NULL)
-  {   fprintf(stderr, "lsegmenti() : malloc failed for M\n");
-      return(0);
-  }
-
-  /* le LABEL M initialement est mis a -1 */
-  for (x = 0; x < N; x++) M[x] = -1;
-
-  nminima = 0;
-
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] == -1)          /* on trouve un point x non etiquete */
-    {
-      nminima += 1;              /* on cree un numero d'etiquette */
-      M[x] = nminima;
-      LifoPush(LIFO, x);         /* on va parcourir le plateau auquel appartient x */
-      while (! LifoVide(LIFO))
-      {
-        w = LifoPop(LIFO);
-        label = M[w];
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if (y != -1)
-          {
-            if ((label > 0) && (F[y] < F[w]))
-            { /* w non dans un minimum */
-              label = 0;
-              nminima -= 1;
-              M[w] = label;
-              LifoPush(LIFO, w);
-            } 
-            else
-            if (F[y] == F[w])
-            {
-              if (((label > 0) && (M[y] == -1)) ||
-                  ((label == 0) && (M[y] != 0)))
-              {
-                M[y] = label;
-                LifoPush(LIFO, y);
-              } /* if .. */
-            } /* if F ... */
-          } /* if (y != -1) */
-        } /* for k ... */
-      } /* while (! LifoVide(LIFO)) */
-    } /* if (M[x] == -1) */
-  } /* for (x = 0; x < N; x++) */
-
-  if (nminima < 2)
-  {   fprintf(stderr, "lsegmenti() : only 1 minimum - image probably empty\n");
-      return(0);
-  }
-  nminima += 1; /* pour le niveau 0 */
-
-  /* ================================================ */
-  /*                CONSTRUCTION DU CBT               */
-  /* ================================================ */
-
-  /* initialisation */
-  /* ============== */
-
-  nbmaxcell = nminima * 2;
-  CBT = (cbtcell *)calloc(1,nbmaxcell * sizeof(cbtcell));
-  if (CBT == NULL)
-  {   fprintf(stderr, "lsegmenti() : malloc failed for CBT\n");
-      return(0);
-  }
-
-  SURF    = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  PROF    = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  DERPROF = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  VOL     = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  PER     = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  TROU    = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  RDIST   = (uint8_t *)calloc(1,nbmaxcell * sizeof(char));
-  if ((SURF==NULL) || (PROF==NULL) || (DERPROF==NULL) || (VOL==NULL) || 
-      (PER==NULL) || (TROU==NULL) || (RDIST==NULL))
-  {   fprintf(stderr, "lsegmenti() : calloc failed\n");
-      return(0);
-  }
-#ifdef MOMENTS
-  EXCEN   = (uint8_t *)calloc(1,nbmaxcell * sizeof(char));
-  if (EXCEN==NULL)
-  {   fprintf(stderr, "lsegmenti() : calloc failed\n");
-      return(0);
-  }
-  mx1  = (double *)calloc(nbmaxcell, sizeof(double));   /* init a 0 */
-  my1  = (double *)calloc(nbmaxcell, sizeof(double));   /* init a 0 */
-  mx2  = (double *)calloc(nbmaxcell, sizeof(double));   /* init a 0 */
-  my2  = (double *)calloc(nbmaxcell, sizeof(double));   /* init a 0 */
-  mxy2 = (double *)calloc(nbmaxcell, sizeof(double));   /* init a 0 */
-  if ((mx1==NULL) || (my1==NULL) || (mx2==NULL) || (my2==NULL) || (mxy2==NULL))
-  {   fprintf(stderr, "lsegmenti() : calloc failed\n");
-      return(0);
-  }
-#endif
-  /* initialise les attributs des minima */
-  for (x = 0; x < N; x++) 
-    if (M[x]) 
-    {
-      SURF[M[x]] += 1;
-      DERPROF[M[x]] = F[x] + 1;
-#ifdef MOMENTS
-      mx1[M[x]] += x%rs; 
-      my1[M[x]] += x/rs; 
-      mx2[M[x]] += (x%rs) * (x%rs); 
-      my2[M[x]] += (x/rs) * (x/rs);
-      mxy2[M[x]] += (x%rs) * (x/rs);
-#endif
-    }
-  for (x = 0; x < N; x++) /* pour le perimetre et les trous */
-  {
-    if (M[x] > 0)
-    {
-      CONTRIPER[x] = contribperim(x, F, F[x], rs, N);
-      if (!IsSet(x, MARQUETROU))
-      {
-        int32_t nbtrous = 0;
-        Set(x, MARQUETROU);
-        LifoPush(LIFO, x); /* on va parcourir le plateau auquel appartient x */
-        while (! LifoVide(LIFO))
-        {
-          w = LifoPop(LIFO);
-          for (k = 0; k < 8; k += incr_vois)
-          {
-            y = voisin(w, k, rs, N);
-            if ((y != -1) && (M[y] == M[x]) && (!IsSet(y, MARQUETROU)))
-            {
-              int32_t masque = 0, imasque = 1;
-              /* fabrique le masque des voisins de y MARQUES */
-              for (l = 0; l < 8; l += 1)
-              {
-                z = voisin(y, l, rs, N);
-                if ((z != -1) && (M[z] == M[y]) && IsSet(z, MARQUETROU))
-                  masque |= imasque; 
-                imasque = imasque << 1;
-              } /* for l ... */
-              if (connex == 4) 
-                { nbtrous += (t4(masque) - 1); if (t8b(masque) == 0) nbtrous--; }
-              else
-                { nbtrous += (t8(masque) - 1); if (t4b(masque) == 0) nbtrous--; }
-              Set(y, MARQUETROU);
-              LifoPush(LIFO, y);
-            } /* if (!IsSet(x, MARQUETROU)) */
-          } /* for k ... */
-        } /* while (! LifoVide(LIFO)) */
-        TROU[M[x]] = nbtrous;
-      } /* if (!IsSet(x, MARQUETROU) */
-    } /* if (M[x] > 0) */
-  } /* for (x = 0; x < N; x++) */
-  for (x = 0; x < N; x++) if (M[x]) PER[M[x]] += CONTRIPER[x];
-
-  nccmax = 2*N / 3;  /* majore la longueur de la frontiere exterieure d'un plateau */
-  etiqcc = (int32_t *)calloc(1,nccmax * sizeof(int32_t));
-  if (etiqcc == NULL)
-  {   fprintf(stderr, "lsegmenti() : malloc failed for etiqcc\n");
-      return(0);
-  }
-
-  nbcell = nminima;
-  InitCbt(CBT, nbcell);
-
-  /* init. inondation */
-  /* ================ */
-  
-  FahPush(FAH, -1, 0);               /* force la creation du niveau 0 dans la Fah. */
-                                     /* NECESSAIRE pour eviter la creation prematuree */
-                                     /* de la file d'urgence */ 
-  for (x = 0; x < N; x++)
-  {
-    if (M[x] != 0)                   /* le pixel appartient a un minimum */
-    {
-      Set(x, MINIMUM);
-      SetData(CBT, M[x], F[x]);     /* conceptuellement : F[x] + 1 */
-      for (k = 0; k < 8; k += incr_vois)
-      {                              /* si un voisin n'est pas deja dans la FAH */
-        y = voisin(x, k, rs, N);     /* et n'est pas dans un minimum, on le met en FAH */
-        if ((y != -1) && (! IsSet(y, EN_FAH)) && (M[y] == 0))
-	{
-          FahPush(FAH, y, F[y]);
-          Set(y, EN_FAH);
-        } /* if y */
-      } /* for k */
-    } /* if (M[x] != 0) */
-  } /* for x */
-
-  x = FahPop(FAH);
-#ifdef PARANO
-  if (x != -1)
-  {   
-     printf("segmenti() : ORDRE FIFO NON RESPECTE PAR LA FAH !!!\n");
-     return(0);
-  }
-#endif
-
-  /* ================================================================= */
-  /* INONDATION */
-  /* ================================================================= */
-
-  while (! FahVide(FAH))
-  {
-    x = FahPop(FAH);
-
-    if (M[x] == 0)
-    {
-      ncc = 0;
-      h = F[x];
-      tailleplateau = 0;
-      /* 1er parcours du plateau de x : enregistre les etiquettes voisines */
-      /* les points du plateau sont marques (MARQUE1) */
-      /* les points voisins du plateau sont marques (MARQUE2) */
-
-      Set(x, MARQUE1);
-      LifoPush(LIFO, x);
-      while (! LifoVide(LIFO))
-      {
-        w = LifoPop(LIFO);     /* w est un point du h-plateau */
-        tailleplateau++;
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if (y != -1)
-          {
-            if  ((M[y] != 0) && (!IsSet(y, MARQUE2)))
-            {
-              if (ncc >= nccmax)
-              {   
-                printf("segmenti() : ncc = %d ; nccmax = %d\n", ncc, nccmax);
-                return(0);
-              }
-              etiqcc[ncc] = M[y];
-              ncc += 1;
-              Set(y, MARQUE2);
-            }
-            if ((F[y] == h) && (!IsSet(y, MARQUE1)))
-            {
-              Set(y, MARQUE1);
-              LifoPush(LIFO, y);
-            }
-          } /* if (y != -1) */
-        } /* for (k = 0; k < 8; k += incr_vois) */
-      } /* while (! LifoVide(LIFO)) */
-      ncc = DiffAnc(CBT, ncc, etiqcc);
-
-#ifdef PARANO
-      if (ncc == 0)
-      {
-        printf("segmenti() : construction cbt : PAS DE cc DANS LE VOISINAGE !!!\n"); 
-        return(0);  
-      } else
-#endif
-      if (ncc == 1)
-      {
-        /* 2nd parcours du plateau de x : positionne les etiquettes M */
-        /* les points du plateau sont demarques (MARQUE1) */
-        /* les points voisins du plateau sont demarques (MARQUE2) */
-        /* les voisins du plateau sont eventuellement mis en FAH */
-
-        UnSet(x, MARQUE1);
-        LifoPush(LIFO, x);
-        while (! LifoVide(LIFO))
-        {
-          int32_t masque = 0, imasque = 1;
-
-          w = LifoPop(LIFO);     /* w est un point du h-plateau */
-          M[w] = etiqcc[0];
-          for (k = 0; k < 8; k += incr_vois)
-          {
-            y = voisin(w, k, rs, N);
-            if (y != -1)
-            {
-              UnSet(y, MARQUE2);
-              if ((! IsSet(y, EN_FAH)) && (M[y] == 0) && (!IsSet(y, MARQUE1)))
-              {
-                FahPush(FAH, y, F[y]);
-                Set(y, EN_FAH);
-              }
-              if ((F[y] == h) && (IsSet(y, MARQUE1)))
-              {
-                UnSet(y, MARQUE1);
-                LifoPush(LIFO, y);
-              }
-            } /* if (y != -1) */
-          } /* for (k = 0; k < 8; k += incr_vois) */
-
-          /* mise a jour du perimetre pour w */
-          for (k = 0; k < 8; k += 1)
-          {
-            y = voisin(w, k, rs, N);
-            if (y != -1)
-            {
-              if (F[y] < h)
-              {
-#ifdef DEBUGPERI
-printf("ncc=%d h=%d p=%d,%d M=%d vois=%d,%d -%d", ncc, h, w%rs, w/rs, M[w], y%rs, y/rs, CONTRIPER[y]);
-#endif
-                PER[M[w]] -= CONTRIPER[y];   /* mise a jour du perimetre */
-                CONTRIPER[y] = contribperim(y, F, h, rs, N);
-#ifdef DEBUGPERI
-printf(" +%d\n", CONTRIPER[y]);
-#endif
-                PER[M[w]] += CONTRIPER[y];
-              }
-            } /* if (y != -1) */
-          } /* for (k = 0; k < 8; k += 1) */
-
-          CONTRIPER[w] = contribperim(w, F, h, rs, N);
-#ifdef DEBUGPERI
-printf("p=%d,%d +%d\n", w%rs, w/rs, CONTRIPER[w]);
-#endif
-          PER[M[w]] += CONTRIPER[w]; 
-
-          /* mise a jour du nombre de trous pour w */
-          /* fabrique le masque des voisins de w appartenant a la composante */
-          for (k = 0; k < 8; k += 1)
-          {
-            y = voisin(w, k, rs, N);
-            if ((y != -1) && IsAnc(CBT, M[w], M[y]))
-              masque |= imasque; 
-            imasque = imasque << 1;
-          } /* for k ... */
-          if (connex == 4) 
-            { TROU[M[w]] += (t4(masque) - 1); if (t8b(masque) == 0) TROU[M[w]]--; }
-          else
-            { TROU[M[w]] += (t8(masque) - 1); if (t4b(masque) == 0) TROU[M[w]]--; }
-#ifdef DEBUGTROU
-printf("ncc=%d: M=%d, p=%d,%d h=%d masque=%x t4=%d t8b=%d, nbtrous=%d\n", ncc, M[w], w%rs, w/rs, F[w], masque, t4(masque), t8b(masque), TROU[M[w]]);
-#endif
-
-#ifdef MOMENTS
-          /* mise a jour des moments pour w */
-          mx1[M[w]] += w%rs; 
-          my1[M[w]] += w/rs; 
-          mx2[M[w]] += (w%rs) * (w%rs); 
-          my2[M[w]] += (w/rs) * (w/rs);
-          mxy2[M[w]] += (w%rs) * (w/rs);
-#endif
-        } /* while (! LifoVide(LIFO)) */
-
-        /* mise a jour de la surface, profondeur, volume pour le plateau */
-        SURF[M[w]] += tailleplateau;
-#ifdef DEBUGSURF
-printf("pl. h=%d; ncc = %d; M=%d; taille =%d\n", h, ncc, M[w], tailleplateau);
-#endif
-        if (F[w] + 1 > DERPROF[M[w]])
-        {
-          VOL[M[w]] += SURF[M[w]] * (F[w] + 1 - DERPROF[M[w]]);
-          DERPROF[M[w]] = F[w] + 1;
-        }
-#ifdef MOMENTS
-        EXCEN[M[w]] = excentricity(mx1[M[w]], my1[M[w]], mx2[M[w]], 
-                                   my2[M[w]], mxy2[M[w]], SURF[M[w]]);
-#endif
-      } /* if (ncc == 1) */
-      else
-      {
-        int32_t p = 0;                   /* pour la mise a jour du perimetre */
-        new = CreateCell(CBT, &nbcell, nbmaxcell);
-        SetData(CBT, new, F[x]);     /* conceptuellement : F[x] + 1 */
-        for (i = 0; i < ncc; i++) SetFather(CBT, etiqcc[i], new);
-
-        /* 2nd parcours du plateau de x : positionne les etiquettes M */
-        /* les points du plateau sont demarques (MARQUE1) */
-        /* les points voisins du plateau sont demarques (MARQUE2) */
-        /* les voisins du plateau sont eventuellement mis en FAH */
-
-        UnSet(x, MARQUE1);
-        LifoPush(LIFO, x);
-        while (! LifoVide(LIFO))
-        {
-          int32_t masque = 0, imasque = 1;
-
-          w = LifoPop(LIFO);     /* w est un point du h-plateau */
-          UnSet(w, MARQUE1);
-          M[w] = new;
-          for (k = 0; k < 8; k += incr_vois)
-          {
-            y = voisin(w, k, rs, N);
-            if (y != -1)
-            {
-              UnSet(y, MARQUE2);
-              if ((! IsSet(y, EN_FAH)) && (M[y] == 0) && (!IsSet(y, MARQUE1)))
-              {
-                FahPush(FAH, y, F[y]);
-                Set(y, EN_FAH);
-              }
-              if ((F[y] == h) && (IsSet(y, MARQUE1)))
-              {
-                UnSet(y, MARQUE1);
-                LifoPush(LIFO, y);
-              }
-            } /* if (y != -1) */
-          } /* for (k = 0; k < 8; k += incr_vois) */
-
-          /* mise a jour du perimetre pour w */
-          for (k = 0; k < 8; k += 1)
-          {
-            y = voisin(w, k, rs, N);
-            if (y != -1)
-            {
-              if (F[y] < h)
-              {
-#ifdef DEBUGPERI
-printf("ncc=%d h=%d p=%d,%d M=%d vois=%d,%d -%d", ncc, h, w%rs, w/rs, M[w], y%rs, y/rs, CONTRIPER[y]);
-#endif
-                p -= CONTRIPER[y];   /* mise a jour du perimetre */
-                CONTRIPER[y] = contribperim(y, F, h, rs, N);
-#ifdef DEBUGPERI
-printf(" +%d\n", CONTRIPER[y]);
-#endif
-                p += CONTRIPER[y];
-              }
-            } /* if (y != -1) */
-          } /* for (k = 0; k < 8; k += 1) */
-          CONTRIPER[w] = contribperim(w, F, h, rs, N);
-#ifdef DEBUGPERI
-printf("p=%d,%d +%d\n", w%rs, w/rs, CONTRIPER[w]);
-#endif
-          p += CONTRIPER[w]; 
-
-          /* mise a jour du nombre de trous pour w */
-          /* fabrique le masque des voisins de w appartenant a la composante */
-          for (k = 0; k < 8; k += 1)
-          {
-            y = voisin(w, k, rs, N);
-            if ((y != -1) && IsAnc(CBT, new, M[y]))
-              masque |= imasque; 
-            imasque = imasque << 1;
-          } /* for k ... */
-          if (connex == 4) 
-            { TROU[new] += (t4(masque) - 1); if (t8b(masque) == 0) TROU[new]--; }
-          else
-            { TROU[new] += (t8(masque) - 1); if (t4b(masque) == 0) TROU[new]--; }
-#ifdef DEBUGTROU
-printf("ncc=%d: M=%d, p=%d,%d h=%d masque=%x t4=%d t8b=%d, nbtrous=%d\n", ncc, new, w%rs, w/rs, F[w], masque, t4(masque), t8b(masque), TROU[new]);
-#endif
-#ifdef MOMENTS
-          /* mise a jour des moments pour w */
-          mx1[new] += w%rs; 
-          my1[new] += w/rs; 
-          mx2[new] += (w%rs) * (w%rs); 
-          my2[new] += (w/rs) * (w/rs);
-          mxy2[new] += (w%rs) * (w/rs);
-#endif
-        } /* while (! LifoVide(LIFO)) */
-
-        PER[M[x]] = p;
-#ifdef DEBUGPERI
-printf("ncc=%d M=%d PER=%d\n", ncc, M[w], p);
-#endif
-        SURF[M[x]] = tailleplateau;
-#ifdef DEBUGSURF
-printf("pl. h=%d; ncc = %d; M=%d; taille =%d\n", h, ncc, M[x], tailleplateau);
-#endif
-        prof = 0;
-        for (i = 0; i < ncc; i++)
-        {
-          SURF[M[x]] += SURF[etiqcc[i]];
-#ifdef MOMENTS
-          mx1[M[x]] += mx1[etiqcc[i]];
-          my1[M[x]] += my1[etiqcc[i]];
-          mx2[M[x]] += mx2[etiqcc[i]];
-          my2[M[x]] += my2[etiqcc[i]];
-          mxy2[M[x]] += mxy2[etiqcc[i]];
-#endif
-#ifdef DEBUGSURF
-printf("   ajoute %d venant de %d\n", SURF[etiqcc[i]], etiqcc[i]);
-#endif
-          k = PROF[etiqcc[i]]+F[x]-Data(CBT,etiqcc[i]); /* conceptuellement : F[x] + 1 */
-          if (k > prof) prof = k;
-          if (F[x] + 1 > DERPROF[etiqcc[i]])
-          {
-            VOL[etiqcc[i]] += SURF[etiqcc[i]] * (F[x] + 1 - DERPROF[etiqcc[i]]);
-            DERPROF[etiqcc[i]] = F[x] + 1;
-          }
-          VOL[M[x]] += VOL[etiqcc[i]];
-          TROU[M[x]] += TROU[etiqcc[i]];
-#ifdef DEBUGTROU
-printf("ncc=%d M=%d TROU += %d (venant de %d)\n", ncc, M[x], TROU[etiqcc[i]], etiqcc[i]);
-#endif
-          PER[M[x]] += PER[etiqcc[i]];
-#ifdef DEBUGPERI
-printf("ncc=%d M=%d PER += %d (venant de %d)\n", ncc, M[x], PER[etiqcc[i]], etiqcc[i]);
-#endif
-        } /* for i */
-        PROF[M[x]] = prof;
-        DERPROF[M[x]] = F[x] + 1;
-        TROU[M[x]] -= (ncc - 1);
-#ifdef DEBUGTROU
-printf("ncc=%d M=%d TROU[M[x]] = %d\n", ncc, M[x], TROU[M[x]]);
-#endif
-#ifdef MOMENTS
-        EXCEN[M[x]] = excentricity(mx1[M[x]], my1[M[x]], mx2[M[x]], 
-                                   my2[M[x]], mxy2[M[x]], SURF[M[x]]);
-#endif
-      } /* else if (ncc == 1) */
-    } /* if (!IsSet(x, TRAITE)) */
-  } /* while (! FahVide(FAH)) */
-  /* FIN INONDATION */
-
-  free(etiqcc);
-  free(CONTRIPER);
-#ifdef MOMENTS
-  free(mx1);
-  free(my1);
-  free(mx2);
-  free(my2);
-  free(mxy2);
-#endif
-  FahFlush(FAH);
-
-#ifdef VERBOSE
-  printf("FIN DE LA CONSTRUCTION DU CBT\n");
-#endif
-
-  T = Regularise(CBT, nminima, nbcell);
-
-  for (x = 0; x < N; x++)
-    if ((M[x] >= nminima) && (T[M[x] - nminima]))
-    {
-      M[x] = T[M[x] - nminima]; /* nouvelle etiquette pour le point x */
-    }
-
-#ifdef VERBOSE
-  printf("FIN DE LA REGULARISATION DU CBT\n");
-#endif
-
-  free(T);
-
-#ifdef PARANO
-  for (i = 0; i < nbcell; i++)
-    if (Label(CBT,i)) printf("ERROR : label = %d\n", Label(CBT, i));
-#endif
-
-#ifdef TRACECBT
-    PrintCbt(CBT, nbcell);
-    for (i = 0; i < N; i++)
-    {
-      if (i % rs == 0) printf("\n");
-      printf("%3d ", M[i]);
-    }
-    printf("\n");
-    printf("SURF = ");
-    for (i = 1; i < nbcell; i++)
-      printf("%3d ", SURF[i]);
-    printf("\n");
-#endif
-
-  /* ================================================ */
-  /* CALCUL DE RDIST                               */
-  /* ================================================ */
-
-  I = InverseCBT(CBT, nminima, nbcell);
-
-  /* calcule l'attribut "distance a la racine RDIST" */
-  /* methode : propogation descendante, en largeur, a partir de la racine. */
-
-  FahFlush(FAH);
-  FahPush(FAH, nbcell - 1, 0);   /* empile la racine */
-  RDIST[nbcell - 1] = 0;
-
-  while (! FahVide(FAH))
-  {
-    int32_t n;
-    x = FahPop(FAH);
-    k = FirstSon(CBT, x);
-    if (k != NIL)
-    {
-      if (x < nbcell - 1)              /* x non racine */
-        n = FirstSon(CBT, x + 1) - FirstSon(CBT, x);
-      else
-        n = nbcell - 2 - FirstSon(CBT, x);
-      for (i = 0; i < n; i++)
-      {
-        FahPush(FAH, I[k + i], 0);
-        RDIST[ I[k + i] ] = RDIST[x] + 1;
-      } 
-    } /* if (k != NIL) */
-  } /* while (! FahVide(FAH)) */
-
-  /* ================================================ */
-  /* SEGMENTATION                               */
-  /* ================================================ */
-
-  /* pour la mesure de la profondeur, il faut rajouter la difference de niveau avec le pere */
-  /* on remplace donc les PROF dans l'arbre */
-  for (x = 1; x < nbcell; x++) UnSetAll(x);
-  FahFlush(FAH);
-  for (i = 1; i < nminima+1; i++) FahPush(FAH, i, 0);
-  while (! FahVide(FAH))
-  {
-    k = FahNiveau(FAH);
-    x = FahPop(FAH);
-    y = Father(CBT,x);
-    if (y != NIL)
-    { 
-      PROF[x] += ((Data(CBT,y) - 1) - Data(CBT,x));
-      if (!IsSet(y, EN_FAH))
-      { 
-        Set(y, EN_FAH);
-        FahPush(FAH, y, k + 1); 
-      }
-    }
-    else PROF[x] = NDG_MAX - NDG_MIN; /* prof. maximum pour la racine */
-  } /* while (! FahVide(FAH)) */
-
-ReSegment:
-  /* init:  ranger au niveau 0 de la FAH les feuilles du CBT */
-  FahFlush(FAH);
-  for (i = 0; i < nbcell; i++) Label(CBT,i) = NONMARQUE;
-  for (i = 1; i < nminima+1; i++) FahPush(FAH, i, 0);
-
-  if (conjonction)
-  {
-    while (! FahVide(FAH))
-    {
-      k = FahNiveau(FAH);
-      x = FahPop(FAH);
-      y = Father(CBT,x);
-  
-      if (Label(CBT,x) == NONMARQUE)
-      {
-        if (((SURF[x] >= seuilsurf) || (!(mesure & SURFACE))) &&
-            ((PROF[x] >= seuilprof) || (!(mesure & PROFONDEUR))) &&
-            ((PER[x] >= seuilperim) || (!(mesure & PERIMETRE))) &&
-            ((TROU[x] >= seuiltrou) || (!(mesure & NBTROUS))) &&
-            ((RDIST[x] <= seuilrdist) || (!(mesure & ROOTDIST))) &&
-#ifdef MOMENTS
-            ((EXCEN[x] >= seuilexcen) || (!(mesure & EXCENTRICITE))) &&
-#endif
-            ((dtrou(SURF[x], TROU[x]) <= seuildtrou) || (!(mesure & DENSTROUS))) &&
-            ((circ(SURF[x], PER[x]) >= seuilcirc) || (!(mesure & CIRCULARITE))) &&
-            ((VOL[x] >= seuilvol) || (!(mesure & VOLUME))))
-        {
-          Label(CBT,x) = PERTINENT;
-          while ((y != NIL) && (Label(CBT,y) != INVALIDE))
-          {
-            Label(CBT,y) = INVALIDE;
-            y = Father(CBT,y);
-          } /* while ((y != NIL) && (Label(CBT,y) != INVALIDE)) */
-        } /* if (MU[x] >= seuil) */
-        else
-          if ((y != NIL) && (Label(CBT,y) != INVALIDE))
-            FahPush(FAH, y, k + 1);
-      } /* if (Label(CBT,x) != INVALIDE) */
-    } /* while (! FahVide(FAH)) */
-  } /* if (conjonction) */
-  else
-  {
-    while (! FahVide(FAH))
-    {
-      k = FahNiveau(FAH);
-      x = FahPop(FAH);
-      y = Father(CBT,x);
-  
-      if (Label(CBT,x) == NONMARQUE)
-      {
-        if (((SURF[x] >= seuilsurf) && (mesure & SURFACE)) ||
-            ((PROF[x] >= seuilprof) && (mesure & PROFONDEUR)) ||
-            ((PER[x] >= seuilperim) && (!(mesure & PERIMETRE))) ||
-            ((TROU[x] >= seuilperim) && (!(mesure & NBTROUS))) ||
-            ((RDIST[x] <= seuilrdist) && (!(mesure & ROOTDIST))) ||
-#ifdef MOMENTS
-            ((EXCEN[x] >= seuilexcen) && (!(mesure & EXCENTRICITE))) ||
-#endif
-            ((dtrou(SURF[x], TROU[x]) <= seuildtrou) && (!(mesure & DENSTROUS))) ||
-            ((circ(SURF[x], PER[x]) >= seuilcirc) && (!(mesure & CIRCULARITE))) ||
-            ((VOL[x] >= seuilvol) && (mesure & VOLUME)))
-        {
-          Label(CBT,x) = PERTINENT;
-          while ((y != NIL) && (Label(CBT,y) != INVALIDE))
-          {
-            Label(CBT,y) = INVALIDE;
-            y = Father(CBT,y);
-          } /* while ((y != NIL) && (Label(CBT,y) != INVALIDE)) */
-        } /* if (MU[x] >= seuil) */
-        else
-          if ((y != NIL) && (Label(CBT,y) != INVALIDE))
-            FahPush(FAH, y, k + 1);
-      } /* if (Label(CBT,x) != INVALIDE) */
-    } /* while (! FahVide(FAH)) */
-  } /* else if (conjonction) */
-
-  if (maximise)
-  {
-    /*  2EME ETAPE : MAXIMISE AU SENS DE L'INCLUSION */
-
-    FahFlush(FAH);
-    for (x = 1; x < nbcell - 1; x++)   /* pas la racine */
-      if (Label(CBT, x) == PERTINENT)
-        FahPush(FAH, x, Data(CBT, x)); /* empile les composantes pertinentes */
-
-    while (! FahVide(FAH))
-    {
-      int32_t n, nbfilspert;
-  
-      x = FahPop(FAH);
-      y = Father(CBT, x);
-      k = FirstSon(CBT, y);
-      if (y < nbcell - 1)              /* pas la racine */
-        n = FirstSon(CBT, y + 1) - FirstSon(CBT, y);
-      else
-        n = nbcell - 2 - FirstSon(CBT, y);
-      nbfilspert = 0;
-      for (i = 0; i < n; i++)
-        if ((Label(CBT, I[k+i]) == PERTINENT) || (Label(CBT, I[k+i]) == INVALIDE))
-          nbfilspert++;
-#ifdef MAXCOND
-      if ((nbfilspert == 1)  /* si y, le pere de x, n'a pas d'autre fils pertinent */
-          && (circ(SURF[y], PER[y]) >= seuilcirc)) /* et s'il est circulaire */
-#else
-      if (nbfilspert == 1)  /* si y, le pere de x, n'a pas d'autre fils pertinent */
-#endif
-      {                     /* alors demarque x et marque y pertinent */
-        Label(CBT, x) = NONMARQUE;
-        Label(CBT, y) = PERTINENT;
-        FahPush(FAH, y, Data(CBT, y));
-      } /* if (nbfilspert == 1) */
-    } /* while (! FahVide(FAH)) */
-  } /* if (maximise) */
-
-/* RECUPERATION DE LA SEGMENTATION */
-
-  TEMP = (uint8_t *)calloc(1,N * sizeof(char));
-  if (TEMP == NULL)
-  {   fprintf(stderr, "lsegmenti() : malloc failed for TEMP\n");
-      return(0);
-  }
-
-  for (i = 0; i < N; i++)
-  {
-    x = M[i];
-
-    while ((x != NIL) && (Label(CBT,x) == NONMARQUE)) 
-      x = Father(CBT,x);
-    if (Label(CBT,x) == PERTINENT)
-      TEMP[i] = 255;
-    else
-      TEMP[i] = 0;
-  } /* for x */  
-
-/* ===========================================================
-    affichage : 
-   ===========================================================
-
-    <------- rs ------>     
-    ------------------- .
-    |                 | .
-    |                 | .
-    |                 | .
-    |      image      | cs
-    |                 | .
-    |                 | .
-    |                 | .
-    --------------------------------------------------
-    | SURF | 111  |  +   |  -   |  1   |  10  | MAX  |        BoxHeight
-    --------------------------------------------------
-    | PROF | 111  |  +   |  -   | 100  | 1000 |  ET  |        BoxHeight
-    --------------------------------------------------
-    | VOL  | 111  |  +   |  -   | 10000|  OK  | QUIT |        BoxHeight
-    --------------------------------------------------
-    | RDIST| 111  |  +   |  -   |      |      |      |        BoxHeight
-    --------------------------------------------------
-    | CIRC | 111  |  +   |  -   |      |      |      |        BoxHeight
-    --------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-  /* send output to the screen */
-#ifdef COLOR
-  for (x = 0; x < N; x++)
-  {
-    if (TEMP[x])    
-      Color(MC_RED);
-    else
-      Color(F[x]/4);
-#ifdef ZOOM4
-    Point(2*(x%rs), 2*(x/rs));
-    Point(2*(x%rs)+1, 2*(x/rs));
-    Point(2*(x%rs), 2*(x/rs)+1);
-    Point(2*(x%rs)+1, 2*(x/rs)+1);
-#else
-    Point(x%rs, x/rs);
-#endif
-  }
-#else
-  ColToWhite();
-  FRectangle(0, 0, ImageWidth, ImageHeight);
-  ColToBlack();
-  for (x = 0; x < N; x++)
-    if (TEMP[x])
-    {
-#ifdef ZOOM4
-      Point(2*(x%rs), 2*(x/rs));
-      Point(2*(x%rs)+1, 2*(x/rs));
-      Point(2*(x%rs), 2*(x/rs)+1);
-      Point(2*(x%rs)+1, 2*(x/rs)+1);
-#else
-      Point(x%rs, x/rs);
-#endif
-    }
-#endif
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, ImageHeight, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, ImageHeight + i * BoxHeight, Width, ImageHeight + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, ImageHeight + i * BoxHeight, k * BoxWidth, ImageHeight + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, ImageHeight + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  switch (increment)
-  {
-    case 1: FRectangle(4 * BoxWidth, ImageHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, ImageHeight + BoxHeight - 2, ButtonStrings[0][4]);
-            ColToBlack();
-            break;
-   case 10: FRectangle(5 * BoxWidth, ImageHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, ImageHeight + BoxHeight - 2, ButtonStrings[0][5]);
-            ColToBlack();
-            break;
-  case 100: FRectangle(4 * BoxWidth, ImageHeight + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, ImageHeight + 2*BoxHeight - 2, ButtonStrings[1][4]);
-            ColToBlack();
-            break;
- case 1000: FRectangle(5 * BoxWidth, ImageHeight + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, ImageHeight + 2*BoxHeight - 2, ButtonStrings[1][5]);
-            ColToBlack();
-            break;
-case 10000: FRectangle(4 * BoxWidth, ImageHeight + 2*BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, ImageHeight + 3*BoxHeight - 2, ButtonStrings[2][4]);
-            ColToBlack();
-            break;
-  } /* switch (increment) */
-
-  if (mesure & SURFACE)
-  {
-    FRectangle(0, ImageHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + BoxHeight - 2, ButtonStrings[0][0]);
-    ColToBlack();
-  }
-  if (mesure & PROFONDEUR)
-  {
-    FRectangle(0, ImageHeight + BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 2*BoxHeight - 2, ButtonStrings[1][0]);
-    ColToBlack();
-  }
-#ifdef VOL2
-  if (mesure & VOLUME)
-#endif
-#ifdef PER2
-  if (mesure & PERIMETRE)
-#endif
-#ifdef TROU2
-  if (mesure & NBTROUS)
-#endif
-  {
-    FRectangle(0, ImageHeight + 2*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 3*BoxHeight - 2, ButtonStrings[2][0]);
-    ColToBlack();
-  }
-  if (mesure & ROOTDIST)
-  {
-    FRectangle(0, ImageHeight + 3*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 4*BoxHeight - 2, ButtonStrings[3][0]);
-    ColToBlack();
-  }
-  if (mesure & CIRCULARITE)
-  {
-    FRectangle(0, ImageHeight + 4*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 5*BoxHeight - 2, ButtonStrings[4][0]);
-    ColToBlack();
-  }
-  if (mesure & DENSTROUS)
-  {
-    FRectangle(0, ImageHeight + 5*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 6*BoxHeight - 2, ButtonStrings[5][0]);
-    ColToBlack();
-  }
-#ifdef MOMENTS
-  if (mesure & EXCENTRICITE)
-  {
-    FRectangle(0, ImageHeight + 6*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, ImageHeight + 7*BoxHeight - 2, ButtonStrings[6][0]);
-    ColToBlack();
-  }
-#endif
-
-  FlushGraphics();  
-
-  WaitMouseEvent(&xx, &yy);
-
-  if ((xx < ImageWidth) && (yy < ImageHeight))
-  {
-#ifdef MOMENTS
-    signature(mesure, xx, yy, M, CBT, rs, SURF, PROF, VOL, PER, RDIST, TROU, EXCEN);
-    printcomp(xx, yy, M, CBT, rs, SURF, PROF, VOL, PER, RDIST, TROU, EXCEN);
-#else
-    signature(mesure, xx, yy, M, CBT, rs, SURF, PROF, VOL, PER, RDIST, TROU, NULL);
-    printcomp(xx, yy, M, CBT, rs, SURF, PROF, VOL, PER, RDIST, TROU, NULL);
-#endif
-  }
-  xx /= BoxWidth;
-  yy -= ImageHeight;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: if ((mesure & SURFACE) && (mesure != SURFACE)) 
-                        mesure &= ~SURFACE;
-                      else if (!(mesure & SURFACE))
-                        mesure |= SURFACE;
-                      break;
-              case 1: break;
-              case 2: seuilsurf = seuilsurf + increment;
-                      sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-                      break;
-              case 3: seuilsurf = seuilsurf - increment;
-                      if (seuilsurf < 1) seuilsurf = 1;
-                      sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-                      break;
-              case 4: increment = 1;
-                      break;
-              case 5: increment = 10;
-                      break;
-              case 6: maximise = !maximise;
-                      if (maximise)
-                        sprintf(ButtonStrings[0][6], " MAX");
-                      else
-                        sprintf(ButtonStrings[0][6], " MIN");
-                      break;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: if ((mesure & PROFONDEUR) && (mesure != PROFONDEUR)) 
-                        mesure &= ~PROFONDEUR;
-                      else if (!(mesure & PROFONDEUR))
-                        mesure |= PROFONDEUR;
-                      break;
-              case 1: break;
-              case 2: seuilprof = seuilprof + increment;
-                      sprintf(ButtonStrings[1][1], "%d", seuilprof);
-                      break;
-              case 3: seuilprof = seuilprof - increment;
-                      if (seuilprof < 0) seuilprof = 0;
-                      sprintf(ButtonStrings[1][1], "%d", seuilprof);
-                      break;
-              case 4: increment = 100;
-                      break;
-              case 5: increment = 1000;
-                      break;
-              case 6: conjonction = !conjonction;
-                      if (conjonction)
-                        sprintf(ButtonStrings[1][6], "  ET");
-                      else
-                        sprintf(ButtonStrings[1][6], "  OU");
-                      break;
-            } /* switch(xx) */
-            break;
-    case 2: switch(xx)
-            {
-#ifdef VOL2
-              case 0: if ((mesure & VOLUME) && (mesure != VOLUME)) 
-                        mesure &= ~VOLUME;
-                      else if (!(mesure & VOLUME))
-                        mesure |= VOLUME;
-                      break;
-              case 1: break;
-              case 2: seuilvol = seuilvol + increment;
-                      sprintf(ButtonStrings[2][1], "%d", seuilvol);
-                      break;
-              case 3: seuilvol = seuilvol - increment;
-                      if (seuilvol < 0) seuilvol = 0;
-                      sprintf(ButtonStrings[2][1], "%d", seuilvol);
-                      break;
-#endif
-#ifdef PER2
-              case 0: if ((mesure & PERIMETRE) && (mesure != PERIMETRE)) 
-                        mesure &= ~PERIMETRE;
-                      else if (!(mesure & PERIMETRE))
-                        mesure |= PERIMETRE;
-                      break;
-              case 1: break;
-              case 2: seuilperim = seuilperim + increment;
-                      sprintf(ButtonStrings[2][1], "%d", seuilperim);
-                      break;
-              case 3: seuilperim = seuilperim - increment;
-                      if (seuilperim < 0) seuilperim = 0;
-                      sprintf(ButtonStrings[2][1], "%d", seuilperim);
-                      break;
-#endif
-#ifdef TROU2
-              case 0: if ((mesure & NBTROUS) && (mesure != NBTROUS)) 
-                        mesure &= ~NBTROUS;
-                      else if (!(mesure & NBTROUS))
-                        mesure |= NBTROUS;
-                      break;
-              case 1: break;
-              case 2: seuiltrou = seuiltrou + increment;
-                      sprintf(ButtonStrings[2][1], "%d", seuiltrou);
-                      break;
-              case 3: seuiltrou = seuiltrou - increment;
-                      if (seuiltrou < 0) seuiltrou = 0;
-                      sprintf(ButtonStrings[2][1], "%d", seuiltrou);
-                      break;
-#endif
-              case 4: increment = 10000;
-                      break;
-              case 5: goto ReSegment;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-    case 3: switch(xx)
-            {
-              case 0: if ((mesure & ROOTDIST) && (mesure != ROOTDIST)) 
-                        mesure &= ~ROOTDIST;
-                      else if (!(mesure & ROOTDIST))
-                        mesure |= ROOTDIST;
-                      break;
-              case 1: break;
-              case 2: seuilrdist = seuilrdist + increment;
-                      if (seuilrdist > NDG_MAX) seuilrdist = NDG_MAX;
-                      sprintf(ButtonStrings[3][1], "%d", seuilrdist);
-                      break;
-              case 3: seuilrdist = seuilrdist - increment;
-                      if (seuilrdist < NDG_MIN) seuilrdist = NDG_MIN;
-                      sprintf(ButtonStrings[3][1], "%d", seuilrdist);
-                      break;
-              case 4: 
-              case 5: 
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    case 4: switch(xx)
-            {
-              case 0: if ((mesure & CIRCULARITE) && (mesure != CIRCULARITE)) 
-                        mesure &= ~CIRCULARITE;
-                      else if (!(mesure & CIRCULARITE))
-                        mesure |= CIRCULARITE;
-                      break;
-              case 1: break;
-              case 2: seuilcirc = seuilcirc + increment;
-                      if (seuilcirc > 100) seuilcirc = 100;
-                      sprintf(ButtonStrings[4][1], "%d", seuilcirc);
-                      break;
-              case 3: seuilcirc = seuilcirc - increment;
-                      if (seuilcirc < 0) seuilcirc = 0;
-                      sprintf(ButtonStrings[4][1], "%d", seuilcirc);
-                      break;
-              case 4: 
-              case 5: 
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    case 5: switch(xx)
-            {
-              case 0: if ((mesure & DENSTROUS) && (mesure != DENSTROUS)) 
-                        mesure &= ~DENSTROUS;
-                      else if (!(mesure & DENSTROUS))
-                        mesure |= DENSTROUS;
-                      break;
-              case 1: break;
-              case 2: seuildtrou = seuildtrou + increment;
-                      if (seuildtrou > 1000) seuildtrou = 1000;
-                      sprintf(ButtonStrings[5][1], "%d", seuildtrou);
-                      break;
-              case 3: seuildtrou = seuildtrou - increment;
-                      if (seuildtrou < 0) seuildtrou = 0;
-                      sprintf(ButtonStrings[5][1], "%d", seuildtrou);
-                      break;
-              case 4: 
-              case 5: 
-              case 6: break;
-            } /* switch(xx) */
-            break;
-#ifdef MOMENTS
-    case 6: switch(xx)
-            {
-              case 0: if ((mesure & EXCENTRICITE) && (mesure != EXCENTRICITE)) 
-                        mesure &= ~EXCENTRICITE;
-                      else if (!(mesure & EXCENTRICITE))
-                        mesure |= EXCENTRICITE;
-                      break;
-              case 1: break;
-              case 2: seuilexcen = seuilexcen + increment;
-                      if (seuilexcen > 255) seuilexcen = 255;
-                      sprintf(ButtonStrings[6][1], "%d", seuilexcen);
-                      break;
-              case 3: seuilexcen = seuilexcen - increment;
-                      if (seuilexcen < 0) seuilexcen = 0;
-                      sprintf(ButtonStrings[6][1], "%d", seuilexcen);
-                      break;
-              case 4: 
-              case 5: 
-              case 6: break;
-            } /* switch(xx) */
-            break;
-#endif
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-
-  for (x = 0; x < N; x++) F[x] = TEMP[x];
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      free(ButtonStrings[i][k]);
-  free(TEMP);
-  free(I);
-  free(SURF);
-  free(PROF);
-  free(DERPROF);
-  free(VOL);
-  free(PER);
-  free(RDIST);
-  free(TROU);
-#ifdef MOMENTS
-  free(EXCEN);
-#endif
-  IndicsTermine();
-  FahTermine(FAH);
-  LifoTermine(LIFO);
-  free(CBT);
-  free(M);
-  return(1);
-}
diff -r 8b1af7363833 src/lib/lsegmentlignes.c.new
--- a/src/lib/lsegmentlignes.c.new	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,322 +0,0 @@
-/* operateur de segmentation de structures lineaires */
-/* utilise une File d'Attente Hierarchique */
-/* Michel Couprie - janvier 1998 */
-
-#define PARANO                 /* even paranoid people have ennemies */
-#define VERBOSE
-
-/*
-   Methode : 
-
-   1/ etiquetage des minima (M != 0)
-
-   2/ selection des minima lineaires (sans point multiples) :
-      - les voisins des minimas lineaires sont mis dans la FAH
-
-   3/ inondation :
-      tq !fahvide
-        x = fahpop
-        h = F[x]
-        parcours du h-plateau de x : 
-          si tous les points du h-plateau 
-             et tous les points etiquetes du voisinage du h-plateau
-             sont de degre < 2
-            etiquette les points du h-plateau
-            empile les voisins > du h-plateau
-*/
-
-#include <stdio.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcfah.h>
-#include <mclifo.h>
-#include <mcindic.h>
-#include <llabelextrema.h>
-#include <lsegmentlignes.h>
-
-#define EN_FAH 0
-#define MARQUE1 1
-#define TRAITE 2
-
-/* ==================================== */
-int lsegmentlignes(
-        struct xvimage *image,
-        int connex,
-        int seuil)
-/* ==================================== */
-{
-  register int i;                       /* index muet */
-  register int x;                       /* index muet de pixel */
-  register int y;                       /* index muet (generalement un voisin de x) */
-  register int z;                       /* index muet de pixel */
-  register int w;                       /* index muet de pixel */
-  register int k;                       /* index muet */
-  register int l;                       /* index muet */
-  register int h;
-  int rs = rowsize(image);     /* taille ligne */
-  int cs = colsize(image);     /* taille colonne */
-  int N = rs * cs;             /* taille image */
-  unsigned char *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *lab;         /* l'image d'etiquettes de composantes connexes */
-  unsigned long *M;            /* l'image d'etiquettes de composantes connexes (data) */
-  unsigned char *V;            /* l'image des nombres de voisins */
-  int *NBPTMULT;               /* pour le stockage du nombre de points multiples 
-                                  des composantes
-                               */
-  int nminima;                 /* nombre de minima differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  Lifo * LIFO;                 /* pour parcourir un plateau */
-  Lifo * PLAT;                 /* pour memoriser les pts d'un plateau */
-  Lifo * VPLAT;                /* pour memoriser les voisins d'un plateau */
-  int incr_vois;
-  int nbmult;
-  int lineaire;
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lsegmentlignes: cette version ne traite pas les images volumiques\n");
-    exit(0);
-  }
-
-  switch (connex)
-  {
-    case 4: incr_vois = 2; break;
-    case 8: incr_vois = 1; break;
-    default: 
-      fprintf(stderr, "lsegmentlignes: mauvaise connexite: %d\n", connex);
-      return 0;
-  } /* switch (connex) */
-
-  IndicsInit(N);
-  FAH = CreeFahVide(N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "lsegmentlignes() : CreeFah failed\n");
-      return(0);
-  }
-
-  LIFO = CreeLifoVide(N/4);
-  PLAT = CreeLifoVide(N/4);
-  VPLAT = CreeLifoVide(N/4);
-  if ((LIFO == NULL) || (PLAT == NULL) || (VPLAT == NULL))
-  {   fprintf(stderr, "lsegmentlignes() : CreeLifoVide failed\n");
-      return(0);
-  }
-
-  lab = allocimage(NULL, rs, cs, 1, VFF_TYP_4_BYTE);
-  if (lab == NULL)
-  {   
-    fprintf(stderr, "lsegmentlignes: allocimage failed\n");
-    return 0;
-  }
-  M = ULONGDATA(lab);
-
-  if (!llabelextrema(image, connex, LABMIN, lab, &nminima))
-  {   
-    fprintf(stderr, "lsegmentlignes: llabelextrema failed\n");
-    return 0;
-  }
-
-  NBPTMULT = (int *)calloc(nminima, sizeof(int));   /* init a 0 */
-  if (NBPTMULT == NULL)
-  {   fprintf(stderr, "lsegmentlignes() : malloc failed for NBPTMULT\n");
-      return(0);
-  }
-
-  V = (unsigned char *)calloc(N, sizeof(char));   /* init a 0 */
-  if (V == NULL)
-  {   fprintf(stderr, "lsegmentlignes() : malloc failed for V\n");
-      return(0);
-  }
-
-/*
-   2/ selection des minima lineaires (sans point multiples) :
-      - les voisins des minimas lineaires sont mis dans la FAH
-*/
-
-  for (x = 0; x < N; x++)
-  {
-    if ((M[x]) && (!IsSet(x, TRAITE)))
-    {     
-      h = F[x];
-      lineaire = 1;
-
-      /* 1er parcours du plateau de x */ 
-      LifoPush(LIFO, x);       
-      while (! LifoVide(LIFO))
-      {
-        w = LifoPop(LIFO);
-        i = 0;                 /* pour compter la nb de voisins de w dans la comp. */
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if ((y != -1) && (M[y] == M[w])) i++;     /* compte le nb de voisins */
-          if ((y != -1) && (F[y] == h) && (!IsSet(y, MARQUE1)))
-          {
-            Set(y, MARQUE1);
-            LifoPush(LIFO, y);
-          }
-        } /* for (k = 0; k < 8; k += incr_vois) */
-        if (i > 2) lineaire = 0; else V[w] = i;
-      } /* while (! LifoVide(LIFO)) */
-
-      LifoPush(LIFO, x);       /* 2nd parcours du plateau de x */ 
-      while (! LifoVide(LIFO))
-      {
-        w = LifoPop(LIFO);
-        if (!lineaire) M[w] = 0;
-        Set(w, TRAITE);
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if ((y != -1) && (F[y] == h) && (IsSet(y, MARQUE1)))
-          {
-            UnSet(y, MARQUE1);
-            LifoPush(LIFO, y);
-          }
-          if (lineaire && (y != -1) && (F[y] > h) && (!IsSet(y, EN_FAH)))
-          {
-            Set(y, EN_FAH);
-            FahPush(FAH, y, F[y]);
-          }
-        } /* for (k = 0; k < 8; k += incr_vois) */
-      } /* while (! LifoVide(LIFO)) */
-    } /* if (M[x]) */
-  } /* for (x = 0; x < N; x++) */
-
-/*
-   3/ inondation :
-      tq !fahvide
-        x = fahpop
-        h = F[x]
-        parcours du h-plateau de x : 
-          si tous les points du h-plateau 
-             et tous les points etiquetes du voisinage du h-plateau
-             sont de degre < 2
-            etiquette les points du h-plateau
-*/
-
-  while(!FahVide(FAH))
-  {
-    x = FahPop(FAH);
-    if (!IsSet(x, TRAITE))
-    {     
-      h = F[x];
-
-      /* 1er parcours du plateau de x : on memorise, dans les files PLAT et VPLAT, */
-      /* les points du plateau et les points voisins du plateau qui sont etiquetes. */
-
-      LifoFlush(PLAT);
-      LifoFlush(VPLAT);
-      LifoPush(LIFO, x);
-      while (! LifoVide(LIFO))
-      {
-        w = LifoPop(LIFO);     /* w est un point du h-plateau */
-        LifoPush(PLAT, w);
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if (y != -1)
-          {
-            if (M[y]) LifoPush(VPLAT, y);
-            if ((F[y] == h) && (!IsSet(y, MARQUE1)))
-            {
-              Set(y, MARQUE1);
-              LifoPush(LIFO, y);
-            }
-          } /* if (y != -1) */
-        } /* for (k = 0; k < 8; k += incr_vois) */
-      } /* while (! LifoVide(LIFO)) */
-
-      /* parcours du plateau : on met a jour les V (nb de voisins dans la (future?) comp) */
-      /* (on retire en meme temps MARQUE1) */
-      for (i = 0; i < PLAT->Sp; i++)
-      {
-        w = PLAT->Pts[i];
-        UnSet(w, MARQUE1);
-        V[w] = 0;
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if ((y != -1) && (M[y] || (F[y] == h))) V[w]++;
-        } /* for (k = 0; k < 8; k += incr_vois) */
-      } /* for (i = 0; i < PLAT->Sp; i++) */
-
-      /* parcours des voisins etiquetes du plateau */
-      /* on met a jour les V (nb de voisins dans la (future?) comp) */
-      for (i = 0; i < VPLAT->Sp; i++)
-      {
-        w = VPLAT->Pts[i];
-        V[w] = 0;
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if ((y != -1) && (M[y] || (F[y] == h))) V[w]++;
-        } /* for (k = 0; k < 8; k += incr_vois) */
-      } /* for (i = 0; i < PLAT->Sp; i++) */
-
-      /* verifie la condition "lineaire" pour les points de PLAT et de VPLAT : */
-      /* les points de degre n > 2 doivent posseder dans leur voisinage n-2 points extremite */
-      lineaire = 1;
-      for (i = 0; i < PLAT->Sp; i++)
-      {
-        w = PLAT->Pts[i];
-        if (V[w] > 2) { lineaire = 0; break; }
-      } /* for (i = 0; i < PLAT->Sp; i++) */
-      if (lineaire) for (i = 0; i < VPLAT->Sp; i++)
-      {
-        w = VPLAT->Pts[i];
-        if (V[w] > 2) { lineaire = 0; break; }
-      } /* for (i = 0; i < VPLAT->Sp; i++) */
-
-      /* si la condition "lineaire" est vraie, on etiquette les points de PLAT */
-      /* et on empile les voisins > du plateau dans la FAH */
-      if (lineaire) for (i = 0; i < PLAT->Sp; i++)
-      {
-        w = PLAT->Pts[i];
-        M[w] = nminima+1;
-        Set(w, TRAITE);
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if ((y != -1) && (F[y] > h) && (!IsSet(y, EN_FAH))) 
-          {
-            Set(y, EN_FAH);
-            FahPush(FAH, y, F[y]);
-          }
-        } /* for (k = 0; k < 8; k += incr_vois) */
-      } /* for (i = 0; i < PLAT->Sp; i++) */
-
-      /* si la condition "lineaire" est fausse, on remet a jour les V des points de VPLAT */
-      else for (i = 0; i < VPLAT->Sp; i++)
-      {
-        w = VPLAT->Pts[i];
-        V[w] = 0;
-        for (k = 0; k < 8; k += incr_vois)
-        {
-          y = voisin(w, k, rs, N);
-          if ((y != -1) && M[y]) V[w]++;
-        } /* for (k = 0; k < 8; k += incr_vois) */
-      } /* for (i = 0; i < VPLAT->Sp; i++) */
-
-    } /* if (!IsSet(x, TRAITE)) */
-  } /* while(!FahVide(FAH)) */
-
-  for (x = 0; x < N; x++)
-    if (M[x]) F[x] = NDG_MAX;
-    else      F[x] = NDG_MIN;
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  free(V);
-  free(NBPTMULT);
-  IndicsTermine();
-  FahTermine(FAH);
-  LifoTermine(LIFO);
-  LifoTermine(PLAT);
-  LifoTermine(VPLAT);
-  freeimage(lab);
-  return(1);
-}
-
diff -r 8b1af7363833 src/lib/lsegmentnumi.c
--- a/src/lib/lsegmentnumi.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,712 +0,0 @@
-/* $Id: lsegmentnumi.c,v 1.1.1.1 2008-11-25 08:01:41 mcouprie Exp $ */
-/* operateur interactif de segmentation numerique par seuillage */
-/* utilise une File d'Attente Hierarchique */
-/* utilise un arbre des bassins versants (captation basin tree, CBT) */
-/* Michel Couprie - juin 1997 */
-/* version 1.1 du 05/8/97 */
-/*
-  5/08/97 : affichage en niveaux de gris
-  25/08/97 : nettoyage et unification
-*/
-/*
-#define TRACECBT
-*/
-
-/*
-Principe: l'idee est d'appliquer l'operateur de segmentation binaire
-  sur un "gradient" de l'image originale. 
-
-Pour eviter tous les problemes lies aux gradients discrets habituels, on considerera
-  le gradient comme non nul seulement aux frontieres de pixels de l'image originale
-  (ou aux points de la maille derivee, cf. []) :
-
-  image O:                                         image G:
-
-  ------------------------------------             ------------------------------------
-  |      |      |      |      |      |             |      |      |      |      |      |
-  |  1   |  1   |  12  |  8   |  16  |             |  0   0  0  11  0   4  0   8  0   |
-  |      |      |      |      |      |             |      |      |      |      |      |
-  ------------------------------------             ---1------0------0------1------12---
-  |      |      |      |      |      |             |      |      |      |      |      |
-  |  0   |  1   |  12  |  7   |  4   |             |  0   1  0  11  0   5  0   3  0   |
-  |      |      |      |      |      |             |      |      |      |      |      |
-  ------------------------------------             ---0------3------8------3------3----
-  |      |      |      |      |      |             |      |      |      |      |      |
-  |  0   |  4   |  4   |  4   |  7   |             |  0   4  0   0  0   0  0   3  0   |
-  |      |      |      |      |      |             |      |      |      |      |      |
-  ------------------------------------             ------------------------------------
-
-Les minima du gradient sont lies aux plateaux de l'image originale. 
-
-Contrairement a la situation de la segmentation binaire, les plateaux sont "en contact"
-  les uns avec les autres, separes seulement par la ligne de gradient d'epaisseur nulle.
-
-Il faut etiqueter les plateaux de O et construire le CBT du gradient:
-
-  image E:                                     CBT:
-
-  ------------------------------------    1   2   3   4   5   6   7   8   9        niveau
-  |      |      |      |      |      |    10              10                          1
-  |  1   |  1   |  2   |  3   |  4   |            11          11                      1
-  |      |      |      |      |      |    12                  12  12  12  12          3
-  ------------------------------------        13              13                      5       
-  |      |      |      |      |      |        14      14                              8
-  |  5   |  1   |  2   |  6   |  7   |
-  |      |      |      |      |      |
-  ------------------------------------
-  |      |      |      |      |      |
-  |  5   |  8   |  8   |  8   |  9   |
-  |      |      |      |      |      |
-  ------------------------------------
-
-On selectionnera ensuite les "coupes consistantes" (representant les plateaux devant
-  "fusionner") par la methode desormais classique.
-
-Il ne restera plus qu'a decider du sort des plateaux fusionnant: quelle valeur leur
-  donner ? idees de variantes: le min, le max, la valeur du plateau le plus etendu,
-  la moyenne ponderee par la surface.
-*/
-
-#define PARANO                 /* even paranoid people have ennemies */
-#define VERBOSE
-
-/*
-   Methode : 
-
-===============================================
-1ere etape : CONSTRUCTION DU CBT DU GRADIENT
-===============================================
-  entree : une image F, N = |Dom(F)|
-  sortie : le CBT, l'application M: Dom(F) -> CBT
-
-  M <- etiquettes des minima du gradient de F (ie - des plateaux de F)
-  nminima <- nombre de minima du gradient de F
-  init(CBT, nminima)
-
-  pour tout point x de Dom(F)
-    y = VoisinEst(x)
-    si y existe ET M[x] != M[y] alors
-      g = abs(F[y] - F[x])
-      FahPush(FAH, x, g)
-    finsi
-    y = VoisinSud(x)
-    si y existe ET M[x] != M[y] alors
-      g = abs(F[y] - F[x])
-      FahPush(FAH, x + N, g)   ;; il faudra retirer N pour recuperer la coord. du pixel 
-    finsi
-  finpour
-
-
-  tant que FAH non vide
-    g = FahNiveau(FAH)
-    x = FahPop(FAH)
-    etiqcc[0] = M[x]
-    si x < N et VoisinEst(x) existe alors etiqcc[1] = M[VoisinEst(x)] finsi
-    si x >= N et VoisinSud(x) existe alors etiqcc[1] = M[VoisinSud(x)] finsi
-
-    diffanc = liste des ancetres differents des etiquettes de etiqcc dans le CBT
-    si |diffanc| > 1
-      new = CreateCell(CBT)
-      SetData(CBT, new, g)
-      pour tout a dans diffanc 
-        SetFather(CBT, a, new)
-      finpour
-    fin si
-  fintantque
-
-===============================================
-2eme etape: 
-===============================================
-
-  en parallele avec la construction du CBT, on a recueilli une "mesure" (MU)
-  des bassins versants.
-
-  ici cette mesure est la surface de la plus grande coupe d'un BV avant sa fusion
-  avec un autre.
-
-  l'algorithme de segmentation est alors:
-
-  1ERE ETAPE : SELECTIONNE LE NB MAX DE CC PERTINENTES
-
-  init:  ranger au niveau 0 de la FAH les feuilles du CBT
-
-  tant que FAH non vide faire
-    k = FAHNIVEAU()
-    x = FAHPOP()
-    si MU[c] >= seuil alors
-      marque les ancetres de x "PERTINENT"
-      marque x "PERTINENT"
-    sinon
-      si pere(x) existe et non PERTINENT alors FAHPUSH(pere(x), k+1) finsi
-    finsi
-  fintantque
-
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcfah.h>
-#include <mcindic.h>
-#include <mccbt.h>
-#include <mcxbib.h>
-#include <mcutil.h>
-#include <llabelplateaux.h>
-#include <lsegmentnumi.h>
-#include <unistd.h>
-
-#define EN_FAH 0
-
-#define NONMARQUE 0
-#define INVALIDE  1
-#define PERTINENT 2
-
-/* ==================================== */
-int32_t lsegmentnumi(struct xvimage *image, struct xvimage *result)
-/* 
-   L'image resultat "result" est une image d'entiers longs. 
-   Elle servira temporairement a stocker les etiquettes de 4-plateaux. 
-*/
-/* ==================================== */
-{
-  register int32_t i;                       /* index muet */
-  register int32_t x;                       /* index muet de pixel */
-  register int32_t y;                       /* index muet (generalement un voisin de x) */
-  register int32_t z;                       /* index muet (generalement un voisin de y) */
-  register int32_t k;                       /* index muet */
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  uint32_t *M = ULONGDATA(result);
-  struct xvimage *temp;
-  uint32_t *TEMP; 
-  int32_t *MU;                     /* pour la mesure des regions */
-  int32_t *PROF;                   /* pour la mesure des regions */
-  int32_t *T;                      /* table de correspondance pour regularisation */
-  int32_t *I;                      /* pour l'arbre inverse */
-  int32_t nminima;                 /* nombre de minima differents */
-  Fah * FAH;                   /* la file d'attente hierarchique */
-  cbtcell * CBT;               /* arbre des bassins versants (Catchment Basin Tree) */
-  int32_t nbcell;
-  int32_t nbmaxcell;
-  int32_t etiqcc[4];
-  int32_t ncc;
-  int32_t new;
-  int32_t prof;
-  int32_t tmp;
-  int32_t seuilsurf = 1;
-  int32_t seuilprof = 0;
-  int32_t seuilvol = 0;
-  int32_t mesure = SURFACE;
-  int32_t increment = 1;
-  int32_t nbcomp = 0;              /* nombre de composantes selectionnees */
-#define NBBUTTONS 7
-#define NBLIGBUTT 3
-#define BOXWIDTH 70
-#define BOXHEIGHT 20
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int32_t xx, yy;
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT;
-  int32_t Width = rs;
-  if (BoxWidth * NBBUTTONS > Width) Width = BoxWidth * NBBUTTONS;
-  
-#ifdef COLOR
-  InitColorGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-#else
-  InitGraphics(0, 0, /* x, y */
-               Width, Height); /* w, h */
-#endif
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], " SURF");
-  sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "  1  ");
-  strcpy(ButtonStrings[0][5], " 10  ");
-  strcpy(ButtonStrings[0][6], " SEG ");
-
-  strcpy(ButtonStrings[1][0], " PROF");
-  sprintf(ButtonStrings[1][1], "%d", seuilprof);
-  strcpy(ButtonStrings[1][2], "  +  ");
-  strcpy(ButtonStrings[1][3], "  -  ");
-  strcpy(ButtonStrings[1][4], " 100 ");
-  strcpy(ButtonStrings[1][5], " 1000");
-  strcpy(ButtonStrings[1][6], "     ");
-
-  strcpy(ButtonStrings[2][0], " VOL ");
-  sprintf(ButtonStrings[2][1], "%d", seuilvol);
-  strcpy(ButtonStrings[2][2], "  +  ");
-  strcpy(ButtonStrings[2][3], "  -  ");
-  strcpy(ButtonStrings[2][4], "10000");
-  strcpy(ButtonStrings[2][5], " OK  ");
-  strcpy(ButtonStrings[2][6], " QUIT");
-
-  if (depth(image) != 1) 
-  {
-    fprintf(stderr, "lsegmentnumi: cette version ne traite pas les images volumiques\n");
-    exit(0);
-  }
-  
-  IndicsInit(N*4);
-
-  FAH = CreeFahVide(2*N+1);
-  if (FAH == NULL)
-  {   fprintf(stderr, "lsegmentnumi() : CreeFah failed\n");
-      return(0);
-  }
-
-  temp = allocimage(NULL, rowsize(image), colsize(image), depth(image), VFF_TYP_4_BYTE);
-  if (temp == NULL)
-  {   
-    fprintf(stderr, "lsegmentnumi: allocimage failed\n");
-    exit(0);
-  }
-  TEMP = ULONGDATA(temp);
-
-  if (!llabelplateaux(image, 4, temp, &nminima))
-  {   
-    fprintf(stderr, "lsegmentnumi: llabelplateaux failed\n");
-    return 0;
-  }
-
-  nbcell = nminima + 1;
-  nbmaxcell = nbcell * 2;
-  CBT = (cbtcell *)calloc(1,nbmaxcell * sizeof(cbtcell));
-  if (CBT == NULL)
-  {   fprintf(stderr, "lsegmentnumi() : malloc failed for CBT\n");
-      return(0);
-  }
-
-  MU = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  PROF = (int32_t *)calloc(nbmaxcell, sizeof(int32_t));   /* init a 0 */
-  if ((MU == NULL) || (PROF == NULL))
-  {   fprintf(stderr, "lsegmentnumi() : malloc failed for MU or PROF\n");
-      return(0);
-  }
-  /* calcul des tailles des minima (histogramme des labels) */
-  for (x = 0; x < N; x++) MU[TEMP[x]] += 1;
-
-  /* ================================================ */
-  /*                CONSTRUCTION DU CBT               */
-  /* ================================================ */
-
-  InitCbt(CBT, nbcell);
-  
-  FahPush(FAH, -1, 0);               /* force la creation du niveau 0 dans la Fah. */
-                                     /* NECESSAIRE pour eviter la creation prematuree */
-                                     /* de la file d'urgence */ 
-  for (x = 0; x < N; x++)
-  {
-    y = voisin(x, EST, rs, N);
-    if ((y != -1) && (TEMP[x] != TEMP[y]))
-      FahPush(FAH, x, abs((int32_t)SOURCE[y] - (int32_t)SOURCE[x]));
-    y = voisin(x, SUD, rs, N);
-    if ((y != -1) && (TEMP[x] != TEMP[y]))
-      FahPush(FAH, N + x, abs((int32_t)SOURCE[y] - (int32_t)SOURCE[x]));
-  } /* for x */
-
-  x = FahPop(FAH);
-
-  /* INONDATION */
-  while (! FahVide(FAH))
-  {
-    ncc = 0;
-    k = FahNiveau(FAH);
-    x = FahPop(FAH);
-
-    etiqcc[ncc] = TEMP[x%N];
-    ncc += 1;
-    
-    if (x < N)
-    {
-      y = voisin(x, EST, rs, N);
-      if (y != 1) 
-      {
-        etiqcc[ncc] = TEMP[y];
-        ncc += 1;
-      }
-    }
-    else /* x >= N */
-    {
-      y = voisin(x - N, SUD, rs, N);
-      if (y != 1) 
-      {
-        etiqcc[ncc] = TEMP[y];
-        ncc += 1;
-      }
-    } /* else if (x < N) */
-
-    ncc = DiffAnc(CBT, ncc, etiqcc);
-
-    if (ncc > 1)
-    {
-      new = CreateCell(CBT, &nbcell, nbmaxcell);
-      SetData(CBT, new, k);
-      prof = 0;
-      for (i = 0; i < ncc; i++)
-      {
-        MU[new] += MU[etiqcc[i]];
-        tmp = PROF[etiqcc[i]] + k - Data(CBT,etiqcc[i]);
-        if (tmp > prof) prof = tmp;
-        SetFather(CBT, etiqcc[i], new);
-      } /* for i */
-      PROF[new] = prof;
-    } /* if (ncc > 1) */
-
-  } /* while (! FahVide(FAH)) */
-  /* FIN INONDATION */
-
-  T = Regularise(CBT, nminima+1, nbcell);
-  free(T);
-
-#ifdef PARANO
-  for (i = 0; i < nbcell; i++)
-    if (Label(CBT,i)) printf("ERROR : label = %d\n", Label(CBT, i));
-#endif
-
-#ifdef TRACECBT
-  PrintCbt(CBT, nbcell);
-  for (i = 0; i < N; i++)
-  {
-    if (i % rs == 0) printf("\n");
-    printf("%3d ", TEMP[i]);
-  }
-  printf("\n");
-
-  printf("MU   = ");
-  for (i = 1; i < nbcell; i++)
-    printf("%3d ", MU[i]);
-  printf("\n");
-
-  printf("PROF = ");
-  for (i = 1; i < nbcell; i++)
-    printf("%3d ", PROF[i]);
-  printf("\n");
-#endif
-
-  /* ================================================ */
-  /* SEGMENTATION                               */
-  /* ================================================ */
-
-  I = InverseCBT(CBT, nminima+1, nbcell);
-
-  /* pour la mesure de la profondeur, il faut rajouter la difference de niveau avec le pere */
-  for (x = 1; x < nbcell; x++) UnSetAll(x);
-  FahFlush(FAH);
-  for (i = 1; i < nminima+1; i++) FahPush(FAH, i, 0);
-  while (! FahVide(FAH))
-  {
-    k = FahNiveau(FAH);
-    x = FahPop(FAH);
-    y = Father(CBT,x);
-    if (y != NIL)
-    { 
-      PROF[x] += (Data(CBT,y) - Data(CBT,x));
-      if (!IsSet(y, EN_FAH))
-      {
-        Set(y, EN_FAH);
-        FahPush(FAH, y, k + 1); 
-      }
-    }
-    else PROF[x] = NDG_MAX - NDG_MIN; /* prof. maximum pour la racine */
-  }
-
-#ifdef TRACECBT
-  printf("PROF = ");
-  for (i = 1; i < nbcell; i++)
-    printf("%3d ", PROF[i]);
-  printf("\n");
-#endif
-
-ReSegment:
-
-  for (i = 0; i < nbcell; i++) Label(CBT,i) = NONMARQUE;
-
-/*  1ERE ETAPE : SELECTIONNE LE NB MAX DE CC PERTINENTES */
-
-  /* init:  ranger au niveau 0 de la FAH les feuilles du CBT */
-  FahFlush(FAH);
-  for (i = 1; i < nminima+1; i++) FahPush(FAH, i, 0);
-  nbcomp = 0;
-
-  while (! FahVide(FAH))
-  {
-    k = FahNiveau(FAH);
-    x = FahPop(FAH);
-
-    if (Label(CBT,x) == NONMARQUE)
-    {
-      if (((MU[x] >= seuilsurf)          || !(mesure & SURFACE)) &&
-          ((PROF[x] >= seuilprof)        || !(mesure & PROFONDEUR)) &&
-          ((MU[x] * PROF[x] >= seuilvol) || !(mesure & VOLUME)))
-      {
-        Label(CBT,x) = PERTINENT;
-        y = Father(CBT,x);
-        while ((y != NIL) && (Label(CBT,y) != INVALIDE))
-        {
-          Label(CBT,y) = INVALIDE;
-          y = Father(CBT,y);
-        } /* while ((y != NIL) && (Label(CBT,y) != INVALIDE)) */
-      } /* if (((MU[x] >= seuilsurf) && ... */
-      else
-      {
-        y = Father(CBT,x);
-        if ((y != NIL) && (Label(CBT,y) != INVALIDE))
-          FahPush(FAH, y, k + 1);
-      } /* else if (((MU[x] >= seuilsurf) && ... */
-    } /* if (Label(CBT,x) != INVALIDE) */
-  } /* while (! FahVide(FAH)) */
-
-/* RECUPERATION DE LA SEGMENTATION */
-
-  for (x = 1; x < nbcell; x++) Aux(CBT,x) = 0; /* pour la renumerotation */
-  nbcomp = 1;                                  /* pour la renumerotation */
-
-  for (i = 0; i < N; i++)
-  {
-    x = TEMP[i];
-    
-    while ((x != NIL) && (Label(CBT,x) == NONMARQUE)) 
-      x = Father(CBT,x);
-    if (Label(CBT,x) == PERTINENT)
-    {
-      if (Aux(CBT, x) == 0) Aux(CBT, x) = nbcomp++;
-      M[i] = Aux(CBT, x);
-    }
-    else
-    {
-      M[i] = 0;
-    }
-  } /* for i */  
-
-/* ===========================================================
-    affichage : 
-   ===========================================================
-
-    <------- rs ------>     
-    ------------------- .
-    |                 | .
-    |                 | .
-    |                 | .
-    |      image      | cs
-    |                 | .
-    |                 | .
-    |                 | .
-    --------------------------------------------------
-    | SURF | 111  |  +   |  -   |  1   |  10  | SEG  |        BoxHeight
-    --------------------------------------------------
-    | PROF | 111  |  +   |  -   | 100  | 1000 |      |        BoxHeight
-    --------------------------------------------------
-    | VOL  | 111  |  +   |  -   | 10000|  OK  | QUIT |        BoxHeight
-    --------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-  /* send output to the screen */
-#ifdef COLOR
-  for (x = 0; x < N; x++)
-  {
-    if (M[x])
-      Color((M[x] % 10) + 64);  
-    else
-      Color(SOURCE[x]/4);
-    Point(x%rs, x/rs);
-  }
-#else
-  ColToWhite();
-  FRectangle(0, 0, rs, cs);
-  ColToBlack();
-  for (x = 0; x < N; x++)
-    if (M[x])
-    {
-      Col((M[x] % 10) + 2);  
-      Point(x%rs, x/rs);
-    }
-#endif
-
-  sprintf(ButtonStrings[1][6], "%d", nbcomp-1);
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, cs, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, cs + i * BoxHeight, Width, cs + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, cs + i * BoxHeight, k * BoxWidth, cs + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, cs + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  switch (increment)
-  {
-    case 1: FRectangle(4 * BoxWidth, cs, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, cs + BoxHeight - 2, ButtonStrings[0][4]);
-            ColToBlack();
-            break;
-   case 10: FRectangle(5 * BoxWidth, cs, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, cs + BoxHeight - 2, ButtonStrings[0][5]);
-            ColToBlack();
-            break;
-  case 100: FRectangle(4 * BoxWidth, cs + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, cs + 2*BoxHeight - 2, ButtonStrings[1][4]);
-            ColToBlack();
-            break;
- case 1000: FRectangle(5 * BoxWidth, cs + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, cs + 2*BoxHeight - 2, ButtonStrings[1][5]);
-            ColToBlack();
-            break;
-case 10000: FRectangle(4 * BoxWidth, cs + 2*BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, cs + 3*BoxHeight - 2, ButtonStrings[2][4]);
-            ColToBlack();
-            break;
-  } /* switch (increment) */
-
-  if (mesure & SURFACE)
-  {
-    FRectangle(0, cs, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, cs + BoxHeight - 2, ButtonStrings[0][0]);
-    ColToBlack();
-  }
-  if (mesure & PROFONDEUR)
-  {
-    FRectangle(0, cs + BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, cs + 2*BoxHeight - 2, ButtonStrings[1][0]);
-    ColToBlack();
-  }
-  if (mesure & VOLUME)
-  {
-    FRectangle(0, cs + 2*BoxHeight, BoxWidth, BoxHeight);
-    ColToWhite();
-    String(0 + 3, cs + 3*BoxHeight - 2, ButtonStrings[2][0]);
-    ColToBlack();
-  }
-
-  FlushGraphics();  
-
-  WaitMouseEvent(&xx, &yy);
-
-  xx /= BoxWidth;
-  yy -= cs;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: if ((mesure & SURFACE) && (mesure != SURFACE)) 
-                        mesure &= ~SURFACE;
-                      else if (!(mesure & SURFACE))
-                        mesure |= SURFACE;
-                      break;
-              case 1: break;
-              case 2: seuilsurf = seuilsurf + increment;
-                      sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-                      break;
-              case 3: seuilsurf = seuilsurf - increment;
-                      if (seuilsurf < 1) seuilsurf = 1;
-                      sprintf(ButtonStrings[0][1], "%d", seuilsurf);
-                      break;
-              case 4: increment = 1;
-                      break;
-              case 5: increment = 10;
-                      break;
-              case 6: 
-                      writeimage(image,"_tmplsni1");
-                      writeimage(result,"_tmplsni2");
-                      if (fork() == 0) /* fils - processus reconsreg */
-                      {
-                        execlp("reconsreg", "reconsreg", "_tmplsni1", "_tmplsni2", NULL);
-                        perror("reconsreg");
-                      }
-                      break;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: if ((mesure & PROFONDEUR) && (mesure != PROFONDEUR)) 
-                        mesure &= ~PROFONDEUR;
-                      else if (!(mesure & PROFONDEUR))
-                        mesure |= PROFONDEUR;
-                      break;
-              case 1: break;
-              case 2: seuilprof = seuilprof + increment;
-                      sprintf(ButtonStrings[1][1], "%d", seuilprof);
-                      break;
-              case 3: seuilprof = seuilprof - increment;
-                      if (seuilprof < 0) seuilprof = 0;
-                      sprintf(ButtonStrings[1][1], "%d", seuilprof);
-                      break;
-              case 4: increment = 100;
-                      break;
-              case 5: increment = 1000;
-                      break;
-            } /* switch(xx) */
-            break;
-    case 2: switch(xx)
-            {
-              case 0: if ((mesure & VOLUME) && (mesure != VOLUME)) 
-                        mesure &= ~VOLUME;
-                      else if (!(mesure & VOLUME))
-                        mesure |= VOLUME;
-                      break;
-              case 1: break;
-              case 2: seuilvol = seuilvol + increment;
-                      sprintf(ButtonStrings[2][1], "%d", seuilvol);
-                      break;
-              case 3: seuilvol = seuilvol - increment;
-                      if (seuilvol < 0) seuilvol = 0;
-                      sprintf(ButtonStrings[2][1], "%d", seuilvol);
-                      break;
-              case 4: increment = 10000;
-                      break;
-              case 5: goto ReSegment;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
- 
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      free(ButtonStrings[i][k]);
-  freeimage(temp);
-  free(I);
-  free(CBT);
-  free(MU);
-  free(PROF);
-  FahTermine(FAH);
-  IndicsTermine();
-  return(1);
-}
diff -r 8b1af7363833 src/lib/lseuili.c
--- a/src/lib/lseuili.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,252 +0,0 @@
-/* $Id: lseuili.c,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-/* seuillage interactif */
-/* Michel Couprie - decembre 1996 */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mcxbib.h>
-#include <lseuili.h>
-
-/* ==================================== */
-int32_t lseuili(struct xvimage *image)
-/* ==================================== */
-{
-  register int32_t i;              /* index muet */
-  int32_t k;                       /* index muet */
-  register int32_t x;              /* index muet de pixel */
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t d = depth(image);        /* nb plans */
-  int32_t n = rs * cs;             /* taille plan */
-  int32_t N = n * d;               /* taille image */
-  uint8_t *SOURCE = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *TEMP;
-  int32_t seuilinf = 128;
-  int32_t seuilsup = NDG_MAX;
-  int32_t increment = 1;
-  int32_t iplan = 0;
-
-#define NBBUTTONS 7
-#define NBLIGBUTT 3
-#define BOXWIDTH 70
-#define BOXHEIGHT 20
-  char * ButtonStrings[NBLIGBUTT][NBBUTTONS];
-  int32_t xx, yy;
-  int32_t BoxWidth = BOXWIDTH;
-  int32_t BoxHeight = BOXHEIGHT;
-  int32_t Height = cs + BoxHeight * NBLIGBUTT;
-  int32_t Width = 2*rs;
-  if (BoxWidth * NBBUTTONS > Width) Width = BoxWidth * NBBUTTONS;
-  
-  InitColorGraphics(0, 0, /* x, y */
-                    Width, Height); /* w, h */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      ButtonStrings[i][k] = (char *)calloc(1,16);
-
-  strcpy(ButtonStrings[0][0], " INF ");
-  sprintf(ButtonStrings[0][1], "%d", seuilinf);
-  strcpy(ButtonStrings[0][2], "  +  ");
-  strcpy(ButtonStrings[0][3], "  -  ");
-  strcpy(ButtonStrings[0][4], "  1  ");
-  strcpy(ButtonStrings[0][5], "  5  ");
-  strcpy(ButtonStrings[0][6], "     ");
-
-  strcpy(ButtonStrings[1][0], " SUP ");
-  sprintf(ButtonStrings[1][1], "%d", seuilsup);
-  strcpy(ButtonStrings[1][2], "  +  ");
-  strcpy(ButtonStrings[1][3], "  -  ");
-  strcpy(ButtonStrings[1][4], " 10  ");
-  strcpy(ButtonStrings[1][5], " 20  ");
-  strcpy(ButtonStrings[1][6], "     ");
-
-  strcpy(ButtonStrings[2][0], " PLAN");
-  sprintf(ButtonStrings[2][1], "%d", iplan);
-  strcpy(ButtonStrings[2][2], "  +  ");
-  strcpy(ButtonStrings[2][3], "  -  ");
-  strcpy(ButtonStrings[2][4], "     ");
-  strcpy(ButtonStrings[2][5], "  OK ");
-  strcpy(ButtonStrings[2][6], " QUIT");
-
-  TEMP = (uint8_t *)calloc(1,N * sizeof(char));
-  if (TEMP == NULL)
-  {   fprintf(stderr, "lseuili() : malloc failed for TEMP\n");
-      return(0);
-  }
-
-ReSeuil:
-  for (x = 0; x < N; x++)
-    if ((SOURCE[x] >= seuilinf) && (SOURCE[x] <= seuilsup))
-      TEMP[x] = 255;
-    else
-      TEMP[x] = 0;
-
-/*
-    affichage : 
-
-    <------- rs ------> <------- rs ------>     
-    ------------------- -------------------.
-    |                 | |                 |.
-    |                 | |                 |.
-    |                 | |                 |.
-    |      image      | |     image       |cs
-    |       ndg       | |      bin        |.
-    |                 | |                 |.
-    |                 | |                 |.
-    -------------------------------------------------
-    | inf  | 111  |  +   |  -   |  1   |  5  |      | BoxHeight
-    -------------------------------------------------
-    | sup  | 111  |  +   |  -   |  10  |  20 |      | BoxHeight
-    -------------------------------------------------
-    | plan | 111  |  +   |  -   |      |  OK | QUIT | BoxHeight
-    -------------------------------------------------
-    <------>
-    BoxWidth
-
-*/
-
-ReDisplayImage:
-
-  /* send output to the screen */
-  FRectangle(0, 0, 2*rs, cs);
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-  {
-    Color(SOURCE[x]/4);
-    Point((x%n)%rs, (x%n)/rs);
-  }
-  ColToWhite();
-  for (x = iplan * n; x < (iplan+1)*n; x++)
-    if (TEMP[x])    
-      Point(rs+(x%n)%rs, (x%n)/rs);
-  ColToBlack();
-
-ReDisplay:
-
-  ColToWhite();
-  FRectangle(0, cs, BoxWidth * NBBUTTONS, BoxHeight * NBLIGBUTT);
-  ColToBlack();
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-  {
-    Line(0, cs + i * BoxHeight, Width, cs + i * BoxHeight);
-    for (k = 0; k < NBBUTTONS; k++) 
-    {
-      Line(k * BoxWidth, cs + i * BoxHeight, k * BoxWidth, cs + (i+1) * BoxHeight);
-      String(k * BoxWidth + 3, cs + (i+1) * BoxHeight - 2, ButtonStrings[i][k]);
-    }
-  }
-
-  switch (increment)
-  {
-    case 1: FRectangle(4 * BoxWidth, cs, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, cs + BoxHeight - 2, ButtonStrings[0][4]);
-            ColToBlack();
-            break;
-    case 5: FRectangle(5 * BoxWidth, cs, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, cs + BoxHeight - 2, ButtonStrings[0][5]);
-            ColToBlack();
-            break;
-   case 10: FRectangle(4 * BoxWidth, cs + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(4 * BoxWidth + 3, cs + 2*BoxHeight - 2, ButtonStrings[1][4]);
-            ColToBlack();
-            break;
-   case 20: FRectangle(5 * BoxWidth, cs + BoxHeight, BoxWidth, BoxHeight);
-            ColToWhite();
-            String(5 * BoxWidth + 3, cs + 2*BoxHeight - 2, ButtonStrings[1][5]);
-            ColToBlack();
-            break;
-  } /* switch (increment) */
-
-  FlushGraphics();  
-
-  WaitMouseEvent(&xx, &yy);
-
-  xx /= BoxWidth;
-  yy -= cs;
-  yy /= BoxHeight;
-
-  switch(yy)
-  {
-    case 0: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: seuilinf += increment;
-                      if (seuilinf > NDG_MAX) seuilinf = NDG_MAX;
-                      sprintf(ButtonStrings[0][1], "%d", seuilinf);
-                      break;
-              case 3: seuilinf -= increment;
-                      if (seuilinf < NDG_MIN) seuilinf = NDG_MIN;
-                      sprintf(ButtonStrings[0][1], "%d", seuilinf);
-                      break;
-              case 4: increment = 1;
-                      break;
-              case 5: increment = 5;
-                      break;
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    case 1: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: seuilsup += increment;
-                      if (seuilsup > NDG_MAX) seuilsup = NDG_MAX;
-                      sprintf(ButtonStrings[1][1], "%d", seuilsup);
-                      break;
-              case 3: seuilsup -= increment;
-                      if (seuilsup < NDG_MIN) seuilsup = NDG_MIN;
-                      sprintf(ButtonStrings[1][1], "%d", seuilsup);
-                      break;
-              case 4: increment = 10;
-                      break;
-              case 5: increment = 20;
-                      break;
-              case 6: break;
-            } /* switch(xx) */
-            break;
-    case 2: switch(xx)
-            {
-              case 0: break;
-              case 1: break;
-              case 2: iplan++;
-                      if (iplan > d-1) iplan = d-1;
-                      sprintf(ButtonStrings[2][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 3: iplan--;
-                      if (iplan < 0) iplan = 0;
-                      sprintf(ButtonStrings[2][1], "%d", iplan);
-                      goto ReDisplayImage;
-              case 4: increment = 1000000;
-                      break;
-              case 5: goto ReSeuil;
-              case 6: goto Terminate;
-            } /* switch(xx) */
-            break;
-  } /* switch(yy) */
-  goto ReDisplay;
-
-Terminate:
-  TerminateGraphics();
-
-  for (x = 0; x < N; x++) SOURCE[x] = TEMP[x];
-
-  /* ================================================ */
-  /* UN PEU DE MENAGE                                 */
-  /* ================================================ */
-
-  for (i = 0; i < NBLIGBUTT; i++) 
-    for (k = 0; k < NBBUTTONS; k++) 
-      free(ButtonStrings[i][k]);
-  free(TEMP);
-  return(1);
-}
-
diff -r 8b1af7363833 src/lib/lskel2graph.c~
--- a/src/lib/lskel2graph.c~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,248 +0,0 @@
-/*
-Copyright ESIEE (2009) 
-
-m.couprie@esiee.fr
-
-This software is an image processing library whose purpose is to be
-used primarily for research and teaching.
-
-This software is governed by the CeCILL  license under French law and
-abiding by the rules of distribution of free software. You can  use, 
-modify and/ or redistribute the software under the terms of the CeCILL
-license as circulated by CEA, CNRS and INRIA at the following URL
-"http://www.cecill.info". 
-
-As a counterpart to the access to the source code and  rights to copy,
-modify and redistribute granted by the license, users are provided only
-with a limited warranty  and the software's author,  the holder of the
-economic rights,  and the successive licensors  have only  limited
-liability. 
-
-In this respect, the user's attention is drawn to the risks associated
-with loading,  using,  modifying and/or developing or reproducing the
-software by the user in light of its specific status of free software,
-that may mean  that it is complicated to manipulate,  and  that  also
-therefore means  that it is reserved for developers  and  experienced
-professionals having in-depth computer knowledge. Users are therefore
-encouraged to load and test the software's suitability as regards their
-requirements in conditions enabling the security of their systems and/or 
-data to be ensured and,  more generally, to use and operate it in the 
-same conditions as regards security. 
-
-The fact that you are presently reading this means that you have had
-knowledge of the CeCILL license and that you accept its terms.
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <assert.h>
-
-#include "mccodimage.h"
-#include "mcimage.h"
-#include "mcgraphe.h"
-#include "mcskelcurv.h"
-#include "lskelcurv.h"
-#include "lskel2graph.h"
-
-/* ====================================================================== */
-graphe * 
-lskel2graph( skel * S, int32_t mode )
-/* ====================================================================== */
-{
-#undef F_NAME
-#define F_NAME "lskel2graph"
-
-    graphe * g;
-
-    if (mode == 0)
-	g = lskel2graph0(S);
-    else if (mode == 1)
-	g = lskel2graph1(S);
-    else
-    {
-	printf("bad mode");
-	return NULL;
-    }
-
-    return g;
-} // lskel2graph0
-
-
-/* ====================================================================== */
-graphe * lskel2graph0(skel * S)
-/* ====================================================================== */
-// Les sommets du graphe sont les points isolÃ©s,  les extrÃ©mitÃ©s, les arcs et les jonctions.
-// Pour les jonctions, et les arcs, on prend pour coordonnÃ©es le barycentre des points.
-{
-#undef F_NAME
-#define F_NAME "lskel2graph0"
-  graphe * G;
-  int32_t i, rs, ps, v, n;
-  double x, y, z;
-  int32_t nsom, ncurv;
-  SKC_pt_pcell p;
-  SKC_adj_pcell a;
-
-  rs = S->rs;
-  ps = rs * S->cs;
-  ncurv = S->e_curv - S->e_end;
-  nsom  = S->e_junc;
-
-  G = InitGraphe(nsom, ncurv * 4);
-
-  // pts isolÃ©s  
-  for (i = 0; i < S->e_isol; i++)
-  {
-    p = S->tskel[i].pts;
-    assert(p != NULL);
-    v = p->val;
-    G->x[i] = (double)(v % rs);
-    G->y[i] = (double)((v % ps) / rs);
-    G->z[i] = (double)(v / ps);
-    assert(p->next == NULL);
-  }
-  // pts extrÃ©mitÃ©s  
-  for (i = S->e_isol; i < S->e_end; i++)
-  {
-    p = S->tskel[i].pts;
-    assert(p != NULL);
-    v = p->val;
-    G->x[i] = (double)(v % rs);
-    G->y[i] = (double)((v % ps) / rs);
-    G->z[i] = (double)(v / ps);
-    assert(p->next == NULL);
-  }
-  // pts de courbe
-  for (i = S->e_end; i < S->e_curv; i++)
-  {
-    a = S->tskel[i].adj; 
-    assert(a != NULL);
-    v = a->val;
-    AjouteArc(G, i, v);
-    AjouteArc(G, v, i);
-
-    a = a->next;
-    assert(a != NULL);
-    v = a->val;
-    AjouteArc(G, i, v);
-    AjouteArc(G, v, i);
-
-    a = a->next;
-    assert(a == NULL);
-
-    x = y = z = 0.0;
-    for (p = S->tskel[i].pts, n = 0; p != NULL; p = p->next, n++)
-    {
-      v = p->val;
-      x += (double)(v % rs);
-      y += (double)((v % ps) / rs);
-      z += (double)(v / ps);
-    }
-    assert(n > 0);
-    G->x[i] = x / n;
-    G->y[i] = y / n;
-    G->z[i] = z / n;    
-  }
-  // pts de jonction
-  for (i = S->e_curv; i < S->e_junc; i++)
-  {
-    x = y = z = 0.0;
-    for (p = S->tskel[i].pts, n = 0; p != NULL; p = p->next, n++)
-    {
-      v = p->val;
-      x += (double)(v % rs);
-      y += (double)((v % ps) / rs);
-      z += (double)(v / ps);
-    }
-    assert(n > 0);
-    G->x[i] = x / n;
-    G->y[i] = y / n;
-    G->z[i] = z / n;
-  }
-
-  return G;
-} // lskel2graph()
-
-/* ====================================================================== */
-graphe * lskel2graph1(skel * S)
-/* ====================================================================== */
-// Les sommets du graphe sont les points isolÃ©s,  les extrÃ©mitÃ©s et les jonctions.
-// Pour les jonctions, et les arcs, on prend pour coordonnÃ©es le barycentre des points.
-{
-#undef F_NAME
-#define F_NAME "lskel2graph1"
-  graphe * G;
-  int32_t i, rs, ps, v, v2, n;
-  double x, y, z;
-  int32_t nsom, ncurv;
-  SKC_pt_pcell p;
-  SKC_adj_pcell a;
-
-  rs = S->rs;
-  ps = rs * S->cs;
-  ncurv = S->e_curv - S->e_end;
-  nsom  = S->e_junc - ncurv;
-
-  G = InitGraphe(nsom, ncurv * 2);
-
-  // pts isolÃ©s  
-  for (i = 0; i < S->e_isol; i++)
-  {
-    p = S->tskel[i].pts;
-    assert(p != NULL);
-    v = p->val;
-    G->x[i] = (double)(v % rs);
-    G->y[i] = (double)((v % ps) / rs);
-    G->z[i] = (double)(v / ps);
-    assert(p->next == NULL);
-  }
-  // pts extrÃ©mitÃ©s  
-  for (i = S->e_isol; i < S->e_end; i++)
-  {
-    p = S->tskel[i].pts;
-    assert(p != NULL);
-    v = p->val;
-    G->x[i] = (double)(v % rs);
-    G->y[i] = (double)((v % ps) / rs);
-    G->z[i] = (double)(v / ps);
-    assert(p->next == NULL);
-  }
-  // pts de courbe
-  for (i = S->e_end; i < S->e_curv; i++)
-  {
-    a = S->tskel[i].adj; 
-    assert(a != NULL);
-    v = a->val;
-    if (IS_JUNC(v)) v = v - ncurv;
-
-    a = a->next;
-    assert(a != NULL);
-    v2 = a->val;
-    if (IS_JUNC(v2)) v2 = v2 - ncurv;
-    AjouteArc(G, v, v2);
-    AjouteArc(G, v2, v);
-
-    a = a->next;
-    assert(a == NULL);
-  }
-  // pts de jonction
-  for (i = S->e_curv; i < S->e_junc; i++)
-  {
-    x = y = z = 0.0;
-    for (p = S->tskel[i].pts, n = 0; p != NULL; p = p->next, n++)
-    {
-      v = p->val;
-      x += (double)(v % rs);
-      y += (double)((v % ps) / rs);
-      z += (double)(v / ps);
-    }
-    assert(n > 0);
-    G->x[i-ncurv] = x / n;
-    G->y[i-ncurv] = y / n;
-    G->z[i-ncurv] = z / n;
-  }
-
-  return G;
-} // lskel2graph1()
diff -r 8b1af7363833 src/lib/lskeletons.c
--- a/src/lib/lskeletons.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lskeletons.c	Mon Jan 13 15:50:10 2014 +0100
@@ -513,7 +513,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (testabaisse4bin(F, x, rs, N))          /* modifie l'image le cas echeant */
       {
@@ -534,7 +534,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (testabaisse8bin(F, x, rs, N))          /* modifie l'image le cas echeant */
       {
@@ -657,7 +657,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (testabaisse4bin(F, x, rs, N))          /* modifie l'image le cas echeant */
       {
@@ -684,7 +684,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (testabaisse8bin(F, x, rs, N))          /* modifie l'image le cas echeant */
       {
@@ -822,7 +822,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (testabaisse6bin(F, x, rs, ps, N))      /* modifie l'image le cas echeant */
       {
@@ -843,7 +843,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (testabaisse26bin(F, x, rs, ps, N))         /* modifie l'image le cas echeant */
       {
@@ -968,7 +968,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (testabaisse6bin(F, x, rs, ps, N))      /* modifie l'image le cas echeant */
       {
@@ -995,7 +995,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (testabaisse26bin(F, x, rs, ps, N))         /* modifie l'image le cas echeant */
       {
@@ -1151,7 +1151,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (testabaisse6lab(F, x, rs, ps, N))      /* modifie l'image le cas echeant */
       {
@@ -1178,7 +1178,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (testabaisse26lab(F, x, rs, ps, N))         /* modifie l'image le cas echeant */
       {
@@ -1426,14 +1426,14 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      prio = (int32_t)mcrbt_RbtMinLevel(RBT) / 10;
+      prio = (int32_t)RbtMinLevel(RBT) / 10;
       oldprio = prio;
 
       while (!mcrbt_RbtVide(RBT) && (prio == oldprio)) 
       {
-        x = mcrbt_RbtPopMin(RBT);
+        x = RbtPopMin(RBT);
         FifoPush(FIFO1, x);
-        if (!mcrbt_RbtVide(RBT)) prio = (int32_t)mcrbt_RbtMinLevel(RBT) / 10;
+        if (!mcrbt_RbtVide(RBT)) prio = (int32_t)RbtMinLevel(RBT) / 10;
       } 
 
       while (!FifoVide(FIFO1))
@@ -1495,14 +1495,14 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      prio = (int32_t)mcrbt_RbtMinLevel(RBT) / 10;
+      prio = (int32_t)RbtMinLevel(RBT) / 10;
       oldprio = prio;
 
       while (!mcrbt_RbtVide(RBT) && (prio == oldprio)) 
       {
-        x = mcrbt_RbtPopMin(RBT);
+        x = RbtPopMin(RBT);
         FifoPush(FIFO1, x);
-        if (!mcrbt_RbtVide(RBT)) prio = (int32_t)mcrbt_RbtMinLevel(RBT) / 10;
+        if (!mcrbt_RbtVide(RBT)) prio = (int32_t)RbtMinLevel(RBT) / 10;
       } 
 
       while (!FifoVide(FIFO1))
@@ -1785,14 +1785,14 @@
 
     while (!mcrbt_RbtVide(RBT))
     {
-      prio = (int32_t)mcrbt_RbtMinLevel(RBT) / 10;
+      prio = (int32_t)RbtMinLevel(RBT) / 10;
       oldprio = prio;
 
       while (!mcrbt_RbtVide(RBT) && (prio == oldprio)) 
       {
-        x = mcrbt_RbtPopMin(RBT);
+        x = RbtPopMin(RBT);
         FifoPush(FIFO1, x);
-        if (!mcrbt_RbtVide(RBT)) prio = (int32_t)mcrbt_RbtMinLevel(RBT) / 10;
+        if (!mcrbt_RbtVide(RBT)) prio = (int32_t)RbtMinLevel(RBT) / 10;
       } 
 
       while (!FifoVide(FIFO1))
@@ -1856,7 +1856,7 @@
   {           
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if ((! IsSet(x,CONTRAINTE)) && testabaisse26bin(F, x, rs, ps, N))
       {
@@ -2125,14 +2125,14 @@
 
     while (!mcrbt_RbtVide(RBT))
     {
-      prio = (int32_t)mcrbt_RbtMinLevel(RBT) / 10;
+      prio = (int32_t)RbtMinLevel(RBT) / 10;
       oldprio = prio;
 
       while (!mcrbt_RbtVide(RBT) && (prio == oldprio)) 
       {
-        x = mcrbt_RbtPopMin(RBT);
+        x = RbtPopMin(RBT);
         FifoPush(FIFO1, x);
-        if (!mcrbt_RbtVide(RBT)) prio = (int32_t)mcrbt_RbtMinLevel(RBT) / 10;
+        if (!mcrbt_RbtVide(RBT)) prio = (int32_t)RbtMinLevel(RBT) / 10;
       } 
 
       while (!FifoVide(FIFO1))
@@ -2196,7 +2196,7 @@
   {           
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if ((! IsSet(x,CONTRAINTE)) && testabaisse26bin(F, x, rs, ps, N))
       {
@@ -2380,7 +2380,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       top4(F, x, rs, N, &t, &tb);
       if ((tmin <= t) && (t <= tmax) && (tbmin <= tb) && (tb <= tbmax))
@@ -2409,7 +2409,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       top8(F, x, rs, N, &t, &tb);
       if ((tmin <= t) && (t <= tmax) && (tbmin <= tb) && (tb <= tbmax))
@@ -2583,7 +2583,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       mctopo3d_top6(F, x, rs, ps, N, &t, &tb);
       if ((tmin <= t) && (t <= tmax) && (tbmin <= tb) && (tb <= tbmax))
@@ -2612,7 +2612,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       mctopo3d_top18(F, x, rs, ps, N, &t, &tb);
       if ((tmin <= t) && (t <= tmax) && (tbmin <= tb) && (tb <= tbmax))
@@ -2641,7 +2641,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       mctopo3d_top26(F, x, rs, ps, N, &t, &tb);
       if ((tmin <= t) && (t <= tmax) && (tbmin <= tb) && (tb <= tbmax))
@@ -2823,8 +2823,8 @@
 
     while (!mcrbt_RbtVide(RBT))
     {
-      prio = mcrbt_RbtMinLevel(RBT); 
-      x = mcrbt_RbtPopMin(RBT);
+      prio = RbtMinLevel(RBT); 
+      x = RbtPopMin(RBT);
       if (I[x]) goto finwhile;
       if (prio < P[x]) goto finwhile;
       if (testabaisse8bin(F, x, rs, N))          /* modifie l'image le cas echeant */
@@ -2865,8 +2865,8 @@
     mctopo3d_init_topo3d();
     while (!mcrbt_RbtVide(RBT))
     {
-      prio = mcrbt_RbtMinLevel(RBT); 
-      x = mcrbt_RbtPopMin(RBT);
+      prio = RbtMinLevel(RBT); 
+      x = RbtPopMin(RBT);
       if (I[x]) goto finwhile26;
       if (prio < P[x]) goto finwhile26;
       if (testabaisse26bin(F, x, rs, ps, N))          /* modifie l'image le cas echeant */
@@ -3100,7 +3100,7 @@
   {           
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       config = encodevois(x, F, rs, ps, N);
 
@@ -3277,7 +3277,7 @@
       nbiter++;
       while (!mcrbt_RbtVide(RBT))
       {
-	x = mcrbt_RbtPopMin(RBT);
+	x = RbtPopMin(RBT);
 	config = encodevois(x, F, rs, ps, N);
 	if (((nbiter < niseuil) || (!IsEnd(config))) && testabaisse6bin(F, x, rs, ps, N)) nbdel++;
       } /* while (!mcrbt_RbtVide(RBT)) */
@@ -3299,7 +3299,7 @@
       nbiter++;
       while (!mcrbt_RbtVide(RBT))
       {
-	x = mcrbt_RbtPopMin(RBT);
+	x = RbtPopMin(RBT);
 	config = encodevois(x, F, rs, ps, N);
 	if (((nbiter < niseuil) || (!IsEnd(config))) && testabaisse18bin(F, x, rs, ps, N)) nbdel++;
       } /* while (!mcrbt_RbtVide(RBT)) */
@@ -3322,10 +3322,10 @@
       while (!mcrbt_RbtVide(RBT))
       {
 #ifdef DEBUG_lskelend3d
-	{ int32_t lev = mcrbt_RbtMinLevel(RBT);
+	{ int32_t lev = RbtMinLevel(RBT);
 	printf("pop: prio %d ", lev); }
 #endif	
-	x = mcrbt_RbtPopMin(RBT);
+	x = RbtPopMin(RBT);
 #ifdef DEBUG_lskelend3d
 	printf("; point %d (%d,%d,%d)\n", x, x % rs, (x % ps) / rs, x / ps);
 #endif
@@ -3429,7 +3429,7 @@
       nbiter++;
       while (!mcrbt_RbtVide(RBT))
       {
-	x = mcrbt_RbtPopMin(RBT);
+	x = RbtPopMin(RBT);
 	if (((nbiter < niseuil) || (nbvois4(F, x, rs, N) != 1)) && testabaisse4bin(F, x, rs, N)) nbdel++;
       } /* while (!mcrbt_RbtVide(RBT)) */
       for (x = 0; x < N; x++)
@@ -3450,7 +3450,7 @@
       nbiter++;
       while (!mcrbt_RbtVide(RBT))
       {
-	x = mcrbt_RbtPopMin(RBT);
+	x = RbtPopMin(RBT);
 	if (((nbiter < niseuil) || (nbvois8(F, x, rs, N) != 1)) && testabaisse8bin(F, x, rs, N)) nbdel++;
       } /* while (!mcrbt_RbtVide(RBT)) */
       for (x = 0; x < N; x++)
@@ -3553,7 +3553,7 @@
       nbiter++;
       while (!mcrbt_RbtVide(RBT))
       {
-	x = mcrbt_RbtPopMin(RBT);
+	x = RbtPopMin(RBT);
 	if (((nbiter < niseuil) || (mctopo3d_nbvoislab6(F, x, rs, ps, N) > 1)) && testabaisse6lab(F, x, rs, ps, N)) nbdel++;
       } /* while (!mcrbt_RbtVide(RBT)) */
       for (x = 0; x < N; x++)
@@ -3574,7 +3574,7 @@
       nbiter++;
       while (!mcrbt_RbtVide(RBT))
       {
-	x = mcrbt_RbtPopMin(RBT);
+	x = RbtPopMin(RBT);
 	if (((nbiter < niseuil) || (mctopo3d_nbvoislab18(F, x, rs, ps, N) > 1)) && testabaisse18lab(F, x, rs, ps, N)) nbdel++;
       } /* while (!mcrbt_RbtVide(RBT)) */
       for (x = 0; x < N; x++)
@@ -3595,7 +3595,7 @@
       nbiter++;
       while (!mcrbt_RbtVide(RBT))
       {
-	x = mcrbt_RbtPopMin(RBT);
+	x = RbtPopMin(RBT);
 	if (((nbiter < niseuil) || (mctopo3d_nbvoislab26(F, x, rs, ps, N) > 1)) && testabaisse26lab(F, x, rs, ps, N)) nbdel++;
       } /* while (!mcrbt_RbtVide(RBT)) */
       for (x = 0; x < N; x++)
@@ -4072,7 +4072,7 @@
 
   while (!mcrbt_RbtVide(RBT))
   {
-    curprio = mcrbt_RbtMinLevel(RBT);
+    curprio = RbtMinLevel(RBT);
 #define DEBUG_lskelPSG2
 #ifdef DEBUG_lskelPSG2
       printf("entering loop, curprio: %g\n", curprio);
@@ -4080,7 +4080,7 @@
     if (curprio >= val) break;
     do
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
 #ifdef DEBUG_lskelPSG2
       printf("pop: %d\n", x);
 #endif
@@ -4090,7 +4090,7 @@
 	RlifoPush(&RLIFO, x);
 	C[x] = 1;
       }
-    } while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == curprio));
+    } while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == curprio));
 
     for (i = 0; i < RLIFO->Sp; i++)
     {
@@ -4256,21 +4256,21 @@
 
   while (!mcrbt_RbtVide(RBT))
   {
-    curprio = mcrbt_RbtMinLevel(RBT);
+    curprio = RbtMinLevel(RBT);
 #ifdef DEBUG_lskelPSG3
   printf("%s: curprio = %g\n", F_NAME, curprio);
 #endif
     if (curprio >= val) break;
     do
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (mctopo3d_simple26(F, x, rs, ps, N))
       {
 	RlifoPush(&RLIFO, x);
 	C[x] = 1;
       }
-    } while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == curprio));
+    } while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == curprio));
 
     for (i = 0; i < RLIFO->Sp; i++)
     {
@@ -4967,7 +4967,7 @@
 
   while (!mcrbt_RbtVide(RBT))
   {
-    curprio = mcrbt_RbtMinLevel(RBT);
+    curprio = RbtMinLevel(RBT);
 //#define DEBUG_lskelCKG2
 #ifdef DEBUG_lskelCKG2
       printf("entering loop, curprio: %g\n", curprio);
@@ -4975,7 +4975,7 @@
     if (curprio >= val) break;
     do
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
 #ifdef DEBUG_lskelCKG2
       printf("pop: %d\n", x);
 #endif
@@ -4985,7 +4985,7 @@
 	RlifoPush(&RLIFO, x);
 	F[x] = CAN;
       }
-    } while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == curprio));
+    } while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == curprio));
 
     for (i = 0; i < RLIFO->Sp; i++) { x = RLIFO->Pts[i]; CrucialPass1(F, x, rs, N); }
     for (i = 0; i < RLIFO->Sp; i++) { x = RLIFO->Pts[i]; if (F[x] != CAN) F[x] = OBJ; }    
@@ -5058,10 +5058,7 @@
   index_t rs = rowsize(imageprio); /* taille ligne */
   index_t cs = colsize(imageprio); /* taille colonne */
   index_t N = rs * cs;             /* taille image */
-  int32_t *P = NULL;   /* l'image de priorites (cas int32) */
-  uint8_t *PB = NULL;  /* l'image de priorites (cas uint8) */
   float   *PF = NULL;  /* l'image de priorites (cas float) */
-  double  *PD = NULL;  /* l'image de priorites (cas double) */
   Rbt * RBT;
   index_t taillemaxrbt;
   uint8_t *F = UCHARDATA(image);   /* objet */
@@ -5070,25 +5067,11 @@
 
   ONLY_2D(image);
   ACCEPTED_TYPES1(image, VFF_TYP_1_BYTE);  
-  ACCEPTED_TYPES4(imageprio, VFF_TYP_1_BYTE, VFF_TYP_4_BYTE, VFF_TYP_FLOAT, VFF_TYP_DOUBLE);
+  ACCEPTED_TYPES1(imageprio, VFF_TYP_FLOAT);
   COMPARE_SIZE(image, imageprio);
 
   IndicsInit(N);
-
-  if (datatype(imageprio) == VFF_TYP_4_BYTE) 
-    P = SLONGDATA(imageprio); 
-  else if (datatype(imageprio) == VFF_TYP_1_BYTE) 
-    PB = UCHARDATA(imageprio); 
-  else if (datatype(imageprio) == VFF_TYP_FLOAT) 
-    PF = FLOATDATA(imageprio); 
-  else if (datatype(imageprio) == VFF_TYP_DOUBLE) 
-    PD = DOUBLEDATA(imageprio); 
-  else 
-  {
-    fprintf(stderr, "%s: datatype(imageprio) must be uint8_t, int32_t, float or double\n", F_NAME);
-    return(0);
-  }
-
+  PF = FLOATDATA(imageprio); 
   taillemaxrbt = 2 * cs +  2 * rs;
   /* cette taille est indicative, le RBT est realloue en cas de depassement */
   RBT = mcrbt_CreeRbtVide(taillemaxrbt);
@@ -5117,13 +5100,7 @@
     if (F[x]) F[x] = OBJ;
     if (F[x] && bordext8(F, x, rs, N))
     {
-      switch(datatype(imageprio))
-      {
-        case VFF_TYP_4_BYTE: mcrbt_RbtInsert(&RBT, P[x], x); break;
-        case VFF_TYP_1_BYTE: mcrbt_RbtInsert(&RBT, PB[x], x); break;
-        case VFF_TYP_FLOAT : mcrbt_RbtInsert(&RBT, PF[x], x); break;
-        case VFF_TYP_DOUBLE: mcrbt_RbtInsert(&RBT, PD[x], x); break;
-      }
+      mcrbt_RbtInsert(&RBT, PF[x], x);
       Set(x, EN_RBT);
     }
   }
@@ -5135,15 +5112,15 @@
   incrprio = DOUBLE_MIN; // this value will only increase during execution
   while (!mcrbt_RbtVide(RBT))
   {
-    curprio = mcrbt_RbtMinLevel(RBT);
+    curprio = RbtMinLevel(RBT);
     if (curprio > incrprio) incrprio = curprio;
-//#define DEBUG_lskelCKG2
+#define DEBUG_lskelCKG2
 #ifdef DEBUG_lskelCKG2
     printf("entering loop, curprio = %g, incrprio = %g\n", curprio, incrprio);
 #endif
     do
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
 #ifdef DEBUG_lskelCKG2
       printf("pop: %d\n", x);
 #endif
@@ -5153,7 +5130,7 @@
 	RlifoPush(&RLIFO, x);
 	F[x] = CAN;
       }
-    } while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == curprio));
+    } while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == curprio));
 
     for (i = 0; i < RLIFO->Sp; i++) { x = RLIFO->Pts[i]; CrucialPass1(F, x, rs, N); }
     for (i = 0; i < RLIFO->Sp; i++) { x = RLIFO->Pts[i]; if (F[x] != CAN) F[x] = OBJ; }    
@@ -5174,13 +5151,7 @@
           y = voisin(x, k, rs, N);
           if ((y != -1) && (F[y]) && (! IsSet(y, EN_RBT)))
           {
-	    switch(datatype(imageprio))
-	    {
-	      case VFF_TYP_4_BYTE: mcrbt_RbtInsert(&RBT, P[y], y); break;
-	      case VFF_TYP_1_BYTE: mcrbt_RbtInsert(&RBT, PB[y], y); break;
-	      case VFF_TYP_FLOAT : mcrbt_RbtInsert(&RBT, PF[y], y); break;
-	      case VFF_TYP_DOUBLE: mcrbt_RbtInsert(&RBT, PD[y], y); break;
-	    }
+	    mcrbt_RbtInsert(&RBT, PF[y], y);
 #ifdef DEBUG_lskelCKG2
 	    printf("push: %d\n", y);
 #endif
@@ -5196,20 +5167,18 @@
       if (IsSet(x, NONCRUCIAL)) 
       {
 	F[x] = 0;
-	switch(datatype(imageprio))
-	{
-	case VFF_TYP_4_BYTE: P[x] = (int32_t)incrprio; break;
-	case VFF_TYP_1_BYTE: PB[x] = (uint8_t)incrprio; break;
-	case VFF_TYP_FLOAT : PF[x] = (float)incrprio; break;
-	case VFF_TYP_DOUBLE: PD[x] = incrprio; break;
-	}
+	PF[x] = (float)incrprio;
       }
+      else
+	PF[x] = -1;
     }
 
     RlifoFlush(RLIFO);
 
   } // while (!mcrbt_RbtVide(RBT))
 
+  for (x = 0; x < N; x++) if (PF[x] == -1) PF[x] = (float)incrprio + 1;
+
   /* ================================================ */
   /* UN PEU DE MENAGE                                 */
   /* ================================================ */
@@ -5226,6 +5195,7 @@
 /* ==================================== */
 // EXPERIMENTAL - Ne pas utiliser dans des applications
 // the result is in imageprio : a "topological map"
+// A FAIRE: TRAITER LES POINTS NON DETRUITS - VOIR lskelCKG2map
 #undef F_NAME
 #define F_NAME "lskelCKG3map"
 { 
@@ -5314,7 +5284,7 @@
   incrprio = DOUBLE_MIN; // this value will only increase during execution
   while (!mcrbt_RbtVide(RBT))
   {
-    curprio = mcrbt_RbtMinLevel(RBT);
+    curprio = RbtMinLevel(RBT);
     if (curprio > incrprio) incrprio = curprio;
 //#define DEBUG_lskelCKG2
 #ifdef DEBUG_lskelCKG2
@@ -5322,7 +5292,7 @@
 #endif
     do
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
 #ifdef DEBUG_lskelCKG2
       printf("pop: %d\n", x);
 #endif
@@ -5332,7 +5302,7 @@
 	RlifoPush(&RLIFO, x);
 	F[x] = CAN;
       }
-    } while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == curprio));
+    } while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == curprio));
 
     for (i = 0; i < RLIFO->Sp; i++) { x = RLIFO->Pts[i]; CrucialPass3d2(F, x, rs, ps, N); }
     for (i = 0; i < RLIFO->Sp; i++) { x = RLIFO->Pts[i]; if (F[x] != CAN) F[x] = OBJ; }    
@@ -5496,7 +5466,7 @@
 
   while (!mcrbt_RbtVide(RBT))
   {
-    curprio = mcrbt_RbtMinLevel(RBT);
+    curprio = RbtMinLevel(RBT);
 //#define DEBUG_lskelCKG3
 #ifdef DEBUG_lskelCKG3
       printf("entering loop, curprio: %g\n", curprio);
@@ -5504,7 +5474,7 @@
     if (curprio >= val) break;
     do
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
 #ifdef DEBUG_lskelCKG3
       printf("pop: %d\n", x);
 #endif
@@ -5514,7 +5484,7 @@
 	RlifoPush(&RLIFO, x);
 	F[x] = CAN;
       }
-    } while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == curprio));
+    } while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == curprio));
 
     for (i = 0; i < RLIFO->Sp; i++) { x = RLIFO->Pts[i]; CrucialPass3d2(F, x, rs, ps, N); }
     for (i = 0; i < RLIFO->Sp; i++) { x = RLIFO->Pts[i]; if (F[x] != CAN) F[x] = OBJ; }    
diff -r 8b1af7363833 src/lib/lskeletons_new._notused_c
--- a/src/lib/lskeletons_new._notused_c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lskeletons_new._notused_c	Mon Jan 13 15:50:10 2014 +0100
@@ -1,4 +1,37 @@
-/* $Id: lskeletons_new.c,v 1.1.1.1 2008-11-25 08:01:40 mcouprie Exp $ */
+/*
+Copyright ESIEE (2009) 
+
+m.couprie@esiee.fr
+
+This software is an image processing library whose purpose is to be
+used primarily for research and teaching.
+
+This software is governed by the CeCILL  license under French law and
+abiding by the rules of distribution of free software. You can  use, 
+modify and/ or redistribute the software under the terms of the CeCILL
+license as circulated by CEA, CNRS and INRIA at the following URL
+"http://www.cecill.info". 
+
+As a counterpart to the access to the source code and  rights to copy,
+modify and redistribute granted by the license, users are provided only
+with a limited warranty  and the software's author,  the holder of the
+economic rights,  and the successive licensors  have only  limited
+liability. 
+
+In this respect, the user's attention is drawn to the risks associated
+with loading,  using,  modifying and/or developing or reproducing the
+software by the user in light of its specific status of free software,
+that may mean  that it is complicated to manipulate,  and  that  also
+therefore means  that it is reserved for developers  and  experienced
+professionals having in-depth computer knowledge. Users are therefore
+encouraged to load and test the software's suitability as regards their
+requirements in conditions enabling the security of their systems and/or 
+data to be ensured and,  more generally, to use and operate it in the 
+same conditions as regards security. 
+
+The fact that you are presently reading this means that you have had
+knowledge of the CeCILL license and that you accept its terms.
+*/
 /* Michel Couprie -  juillet 2001 */
 
 #include <stdio.h>
@@ -145,7 +178,7 @@
     return(0);
   }
   if (datatype(imageprio) == VFF_TYP_4_BYTE) 
-    P = ULONGDATA(imageprio); 
+    P = SLONGDATA(imageprio); 
   else 
   {
     fprintf(stderr, "%s() : datatype(imageprio) must be uint32_t\n", F_NAME);
@@ -274,7 +307,7 @@
     return(0);
   }
   if (datatype(imageprio) == VFF_TYP_4_BYTE) 
-    P = ULONGDATA(imageprio); 
+    P = SLONGDATA(imageprio); 
   else 
   {
     fprintf(stderr, "%s() : datatype(imageprio) must be uint32_t\n", F_NAME);
@@ -427,7 +460,7 @@
     return(0);
   }
   if (datatype(imageprio) == VFF_TYP_4_BYTE) 
-    P = ULONGDATA(imageprio); 
+    P = SLONGDATA(imageprio); 
   else 
   {
     fprintf(stderr, "%s() : datatype(imageprio) must be uint32_t\n", F_NAME);
@@ -560,7 +593,7 @@
     return(0);
   }
   if (datatype(imageprio) == VFF_TYP_4_BYTE) 
-    P = ULONGDATA(imageprio); 
+    P = SLONGDATA(imageprio); 
   else 
   {
     fprintf(stderr, "%s() : datatype(imageprio) must be uint32_t\n", F_NAME);
@@ -706,7 +739,7 @@
     return(0);
   }
   if (datatype(imageprio) == VFF_TYP_4_BYTE) 
-    P = ULONGDATA(imageprio); 
+    P = SLONGDATA(imageprio); 
   else 
   {
     fprintf(stderr, "%s() : datatype(imageprio) must be uint32_t\n", F_NAME);
@@ -989,7 +1022,7 @@
     return(0);
   }
   if (datatype(imageprio) == VFF_TYP_4_BYTE) 
-    P = ULONGDATA(imageprio); 
+    P = SLONGDATA(imageprio); 
   else 
   {
     fprintf(stderr, "%s() : datatype(imageprio) must be uint32_t\n", F_NAME);
@@ -1247,7 +1280,7 @@
     return(0);
   }
   if (datatype(imageprio) == VFF_TYP_4_BYTE) 
-    P = ULONGDATA(imageprio); 
+    P = SLONGDATA(imageprio); 
   else 
   {
     fprintf(stderr, "%s() : datatype(imageprio) must be uint32_t\n", F_NAME);
@@ -1508,7 +1541,7 @@
     return(0);
   }
   if (datatype(imageprio) == VFF_TYP_4_BYTE) 
-    P = ULONGDATA(imageprio); 
+    P = SLONGDATA(imageprio); 
   else 
   {
     fprintf(stderr, "%s() : datatype(imageprio) must be uint32_t\n", F_NAME);
@@ -1683,7 +1716,7 @@
     return(0);
   }
   if (datatype(imageprio) == VFF_TYP_4_BYTE) 
-    P = ULONGDATA(imageprio); 
+    P = SLONGDATA(imageprio); 
   else 
   {
     fprintf(stderr, "%s() : datatype(imageprio) must be uint32_t\n", F_NAME);
@@ -1856,7 +1889,7 @@
     fprintf(stderr, "%s(): allocimage failed\n", F_NAME);
     return 0;
   }
-  P = ULONGDATA(imageprio); 
+  P = SLONGDATA(imageprio); 
 
   if (!ldistquadSaito(image, imageprio))
   {   
diff -r 8b1af7363833 src/lib/lskelpar.c
--- a/src/lib/lskelpar.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lskelpar.c	Mon Jan 13 15:50:10 2014 +0100
@@ -191,11 +191,13 @@
 #include <stdint.h>
 #include <string.h>
 #include <sys/types.h>
+#include <pinktypes.h>
 #include <stdlib.h>
 #include <assert.h>
 #include <mccodimage.h>
 #include <mcimage.h>
 #include <mctopo.h>
+#include <mcrbt.h>
 #include <mcutil.h>
 #include <lskelpar.h>
 
@@ -206,6 +208,9 @@
 //#define ETUDE
 //#define ANIMATE
 
+#define PERS_INIT_VAL 0
+#define PERS_INFTY_VAL FLOAT_MAX
+
 #define I_INHIBIT     1
 
 #define S_OBJECT      1
@@ -3303,7 +3308,6 @@
   return 0;
 } /* mc_match2() */
 
-#ifdef NOT_USED
 /* ==================================== */
 static int32_t mc_match3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
 /* ==================================== */
@@ -3315,28 +3319,6 @@
   for (i = 0; i < 4; i++)
   {
     if ((v[0] != 0) || (!IS_SIMPLE(v[1])) || (!IS_SIMPLE(v[2]))) goto fail;
-    if ((v2[0] != 0) || (v2[3] != 0) || (v2[4] != 0) ||
-	(v[3] != 0) || (v[4] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mc_match3() */
-#endif
-
-/* ==================================== */
-static int32_t mc_match3b(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 0) || (!IS_SIMPLE(v[1])) || (!IS_SIMPLE(v[2]))) goto fail;
     if ((v2[3] != 0) || (v2[4] != 0) ||
 	(v[3] != 0) || (v[4] != 0)) goto fail;
     return 1;
@@ -3345,9 +3327,8 @@
     rotate90_vois2(v2);
   }
   return 0;
-} /* mc_match3b() */
-
-#ifdef NOT_USED
+} /* mc_match3() */
+
 /* ==================================== */
 static int32_t mc_match4(uint8_t *F, int32_t x, int32_t rs, int32_t N)
 /* ==================================== */
@@ -3359,51 +3340,6 @@
   for (i = 0; i < 4; i++)
   {
     if ((!IS_SIMPLE(v[0])) || (!IS_SIMPLE(v[1])) || (v[2] != 0)) goto fail;
-    if ((v2[0] != 0) || (v2[1] != 0) || (v2[4] != 0) ||
-	(v[3] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mc_match4() */
-#endif
-
-#ifdef NOT_USED
-/* ==================================== */
-static int32_t mc_match5(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((!IS_SIMPLE(v[0])) || (v[1] != 0) || (!IS_SIMPLE(v[2]))) goto fail;
-    if ((v2[1] != 0) || (v2[3] != 0) ||
-	(v[3] != 0) || (v[4] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mc_match5() */
-#endif
-
-/* ==================================== */
-static int32_t mc_match4b(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((!IS_SIMPLE(v[0])) || (!IS_SIMPLE(v[1])) || (v[2] != 0)) goto fail;
     if ((v2[0] != 0) || (v2[1] != 0) ||
 	(v[6] != 0) || (v[7] != 0)) goto fail;
     return 1;
@@ -3412,10 +3348,10 @@
     rotate90_vois2(v2);
   }
   return 0;
-} /* mc_match4b() */
-
-/* ==================================== */
-static int32_t mc_match5b(uint8_t *F, int32_t x, int32_t rs, int32_t N)
+} /* mc_match4() */
+
+/* ==================================== */
+static int32_t mc_match5(uint8_t *F, int32_t x, int32_t rs, int32_t N)
 /* ==================================== */
 {
   int32_t i;
@@ -3430,7 +3366,7 @@
     rotate90_vois(v);
   }
   return 0;
-} /* mc_match5b() */
+} /* mc_match5() */
 
 /* ==================================== */
 static int32_t mc_match6(uint8_t *F, int32_t x, int32_t rs, int32_t N)
@@ -3584,9 +3520,9 @@
       {
 	m1 = mc_match1(F, i, rs, N);
 	m2 = mc_match2(F, i, rs, N);
-	m3 = mc_match3b(F, i, rs, N);
-	m4 = mc_match4b(F, i, rs, N);
-	m5 = mc_match5b(F, i, rs, N);
+	m3 = mc_match3(F, i, rs, N);
+	m4 = mc_match4(F, i, rs, N);
+	m5 = mc_match5(F, i, rs, N);
 	m6 = mc_match6(F, i, rs, N);
 	if (m1 || m2 || m3 || m4 || m5 || m6)
 	{
@@ -3675,9 +3611,9 @@
       {
 	m1 = mc_match1(F, i, rs, N);
 	m2 = mc_match2(F, i, rs, N);
-	m3 = mc_match3b(F, i, rs, N);
-	m4 = mc_match4b(F, i, rs, N);
-	m5 = mc_match5b(F, i, rs, N);
+	m3 = mc_match3(F, i, rs, N);
+	m4 = mc_match4(F, i, rs, N);
+	m5 = mc_match5(F, i, rs, N);
 	m6 = mc_match6(F, i, rs, N);
 	if (m1 || m2 || m3 || m4 || m5 || m6)
 	{
@@ -3808,9 +3744,9 @@
       {
 	m1 = mc_match1(X, i, rs, N);
 	m2 = mc_match2(X, i, rs, N);
-	m3 = mc_match3b(X, i, rs, N);
-	m4 = mc_match4b(X, i, rs, N);
-	m5 = mc_match5b(X, i, rs, N);
+	m3 = mc_match3(X, i, rs, N);
+	m4 = mc_match4(X, i, rs, N);
+	m5 = mc_match5(X, i, rs, N);
 	m6 = mc_match6(X, i, rs, N);
 	if (m1 || m2 || m3 || m4 || m5 || m6)
 	{
@@ -3949,9 +3885,9 @@
       {
 	m1 = mc_match1(X, i, rs, N);
 	m2 = mc_match2(X, i, rs, N);
-	m3 = mc_match3b(X, i, rs, N);
-	m4 = mc_match4b(X, i, rs, N);
-	m5 = mc_match5b(X, i, rs, N);
+	m3 = mc_match3(X, i, rs, N);
+	m4 = mc_match4(X, i, rs, N);
+	m5 = mc_match5(X, i, rs, N);
 	m6 = mc_match6(X, i, rs, N);
 	if (m1 || m2 || m3 || m4 || m5 || m6)
 	{
@@ -4239,9 +4175,9 @@
 	m2 = bertrand_match2(F, i, rs, N);
 	mc1 = mc_match1b(F, i, rs, N);
 	mc2 = mc_match2(F, i, rs, N);
-	mc3 = mc_match3b(F, i, rs, N);
-	mc4 = mc_match4b(F, i, rs, N);
-	mc5 = mc_match5b(F, i, rs, N);
+	mc3 = mc_match3(F, i, rs, N);
+	mc4 = mc_match4(F, i, rs, N);
+	mc5 = mc_match5(F, i, rs, N);
 	mc6 = mc_match6(F, i, rs, N);
 	if (m1 || m2)
 	{
@@ -4309,11 +4245,11 @@
 /*
 Squelette asymétrique curviligne
 Algo ACK2b données: S (image), I (inhibit), n (n_steps), p (isthmus_persistence)
-Pour tout x de S faire T[x] := -1
+Pour tout x de S faire T[x] := PERS_INIT_VAL
 Pour i := 0; i < n; i++
   C := points de courbe de S
-  Pour tout x de C tq T[x] == -1 faire T[x] := i
-  I := I \cup {x | T[x] > -1 et (i - T[x]) >= p}
+  Pour tout x de C tq T[x] == PERS_INIT_VAL faire T[x] := i
+  I := I \cup {x | T[x] > PERS_INIT_VAL et (i - T[x]) >= p}
   P := pixels simples pour S et pas dans I
   C1 := pixels 1-D-cruciaux (cruc_asym_match1)
   C0 := pixels 0-D-cruciaux (cruc_asym_match0)
@@ -4357,7 +4293,7 @@
   for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
 
   T = (int16_t *)malloc(N * sizeof(int16_t)); assert(T != NULL);
-  for (i = 0; i < N; i++) T[i] = -1;
+  for (i = 0; i < N; i++) T[i] = PERS_INIT_VAL;
 
   /* ================================================ */
   /*               DEBUT ALGO                         */
@@ -4379,7 +4315,7 @@
       if (IS_OBJECT(S[i]))
       {    
 	top8(S, i, rs, N, &top, &topb);
-	if ((top > 1) && (T[i] == -1))
+	if ((top > 1) && (T[i] == PERS_INIT_VAL))
 	  T[i] = (int16_t)step;
       }
     }
@@ -4405,9 +4341,9 @@
 	m2 = bertrand_match2(F, i, rs, N);
 	mc1 = mc_match1b(F, i, rs, N);
 	mc2 = mc_match2(F, i, rs, N);
-	mc3 = mc_match3b(F, i, rs, N);
-	mc4 = mc_match4b(F, i, rs, N);
-	mc5 = mc_match5b(F, i, rs, N);
+	mc3 = mc_match3(F, i, rs, N);
+	mc4 = mc_match4(F, i, rs, N);
+	mc5 = mc_match5(F, i, rs, N);
 	mc6 = mc_match6(F, i, rs, N);
 	if (m1 || m2)
 	{
@@ -5060,7 +4996,7 @@
 } /* lskelAK2() */
 
 /* ==================================== */
-static int32_t ros_match(uint8_t *F, int32_t x, int32_t rs, int32_t N)
+static int32_t ros_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
 /* ==================================== */
 /*
   D D D     avec origine = (1,1) et valeurs des pixels D quelconques
@@ -5081,7 +5017,33 @@
     rotate90_vois(v);
   }
   return 0;
-} /* ros_match() */
+} /* ros_match1() */
+
+/* ==================================== */
+static int32_t ros_match2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
+/* ==================================== */
+/*
+  D 0 0     avec origine = (1,1)
+  D P 1
+  D 0 0
+ */
+{
+  int32_t i;
+  uint8_t v[8];
+  extract_vois(F, x, rs, N, v);
+  for (i = 0; i < 4; i++)
+  {
+    if (v[1] != 0) goto fail;
+    if (v[2] != 0) goto fail;
+    if (v[6] != 0) goto fail;
+    if (v[7] != 0) goto fail;
+    if (!v[0]) goto fail;
+    return 1;
+  fail:
+    rotate90_vois(v);
+  }
+  return 0;
+} /* ros_match2() */
 
 /* ==================================== */
 static int32_t ros_north(uint8_t *F, int32_t x, int32_t rs, int32_t N)
@@ -5152,7 +5114,7 @@
 		       int32_t nsteps,
 		       struct xvimage *inhibit)
 /* ==================================== */
-// Rosenfeld : algo directionnel
+// Rosenfeld : algo directionnel (ordre NSEW)
 #undef F_NAME
 #define F_NAME "lskelrosenfeld"
 {
@@ -5191,25 +5153,25 @@
 
     memset(T, 0, N);
     for (i = 0; i < N; i++)
-      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_north(F, i, rs, N) && !ros_match(F, i, rs, N))
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_north(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
       { nonstab = 1; T[i] = 1; }
     for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
 
     memset(T, 0, N);
     for (i = 0; i < N; i++)
-      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_south(F, i, rs, N) && !ros_match(F, i, rs, N))
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_south(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
       { nonstab = 1; T[i] = 1; }
     for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
 
     memset(T, 0, N);
     for (i = 0; i < N; i++)
-      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_east(F, i, rs, N) && !ros_match(F, i, rs, N))
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_east(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
       { nonstab = 1; T[i] = 1; }
     for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
 
     memset(T, 0, N);
     for (i = 0; i < N; i++)
-      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_west(F, i, rs, N) && !ros_match(F, i, rs, N))
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_west(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
       { nonstab = 1; T[i] = 1; }
     for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
 
@@ -5225,6 +5187,162 @@
   return(1);
 } /* lskelrosenfeld() */
 
+/* ==================================== */
+int32_t lskelrosenfeld_var1(struct xvimage *image,
+		       int32_t nsteps,
+		       struct xvimage *inhibit)
+/* ==================================== */
+// Rosenfeld : algo directionnel (variante : ordre WESN)
+#undef F_NAME
+#define F_NAME "lskelrosenfeld_var1"
+{
+  int32_t i;
+  int32_t rs = rowsize(image);     /* taille ligne */
+  int32_t cs = colsize(image);     /* taille colonne */
+  int32_t N = rs * cs;             /* taille image */
+  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
+  struct xvimage *tmp = copyimage(image);
+  uint8_t *T = UCHARDATA(tmp);
+  int32_t step, nonstab;
+
+  if (inhibit != NULL)
+  {
+    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
+    return 0;
+  }
+
+  if (nsteps == -1) nsteps = 1000000000;
+
+  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
+
+  /* ================================================ */
+  /*               DEBUT ALGO                         */
+  /* ================================================ */
+
+  step = 0;
+  nonstab = 1;
+  while (nonstab && (step < nsteps))
+  {
+    nonstab = 0;
+    step++;
+#ifdef VERBOSE
+    printf("step %d\n", step);
+#endif
+
+    memset(T, 0, N);
+    for (i = 0; i < N; i++)
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_west(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
+      { nonstab = 1; T[i] = 1; }
+    for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
+
+    memset(T, 0, N);
+    for (i = 0; i < N; i++)
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_east(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
+      { nonstab = 1; T[i] = 1; }
+    for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
+
+    memset(T, 0, N);
+    for (i = 0; i < N; i++)
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_south(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
+      { nonstab = 1; T[i] = 1; }
+    for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
+
+    memset(T, 0, N);
+    for (i = 0; i < N; i++)
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_north(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
+      { nonstab = 1; T[i] = 1; }
+    for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
+
+  }
+
+#ifdef VERBOSE1
+    printf("number of steps: %d\n", step);
+#endif
+
+  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
+
+  freeimage(tmp);
+  return(1);
+} /* lskelrosenfeld_var1() */
+
+/* ==================================== */
+int32_t lskelrosenfeld_var2(struct xvimage *image,
+		       int32_t nsteps,
+		       struct xvimage *inhibit)
+/* ==================================== */
+// Rosenfeld : algo directionnel (variante : ordre ENWS)
+#undef F_NAME
+#define F_NAME "lskelrosenfeld_var2"
+{
+  int32_t i;
+  int32_t rs = rowsize(image);     /* taille ligne */
+  int32_t cs = colsize(image);     /* taille colonne */
+  int32_t N = rs * cs;             /* taille image */
+  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
+  struct xvimage *tmp = copyimage(image);
+  uint8_t *T = UCHARDATA(tmp);
+  int32_t step, nonstab;
+
+  if (inhibit != NULL)
+  {
+    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
+    return 0;
+  }
+
+  if (nsteps == -1) nsteps = 1000000000;
+
+  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
+
+  /* ================================================ */
+  /*               DEBUT ALGO                         */
+  /* ================================================ */
+
+  step = 0;
+  nonstab = 1;
+  while (nonstab && (step < nsteps))
+  {
+    nonstab = 0;
+    step++;
+#ifdef VERBOSE
+    printf("step %d\n", step);
+#endif
+
+    memset(T, 0, N);
+    for (i = 0; i < N; i++)
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_east(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
+      { nonstab = 1; T[i] = 1; }
+    for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
+
+    memset(T, 0, N);
+    for (i = 0; i < N; i++)
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_north(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
+      { nonstab = 1; T[i] = 1; }
+    for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
+
+    memset(T, 0, N);
+    for (i = 0; i < N; i++)
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_west(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
+      { nonstab = 1; T[i] = 1; }
+    for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
+
+    memset(T, 0, N);
+    for (i = 0; i < N; i++)
+      if ((F[i] == 1) && simple8(F, i, rs, N) && ros_south(F, i, rs, N) && !ros_match1(F, i, rs, N) && !ros_match2(F, i, rs, N))
+      { nonstab = 1; T[i] = 1; }
+    for (i = 0; i < N; i++) if (T[i] == 1) F[i] = 0;
+
+  }
+
+#ifdef VERBOSE1
+    printf("number of steps: %d\n", step);
+#endif
+
+  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
+
+  freeimage(tmp);
+  return(1);
+} /* lskelrosenfeld_var2() */
+
 
 //Detects endpoints of type 1, 2, 3 as defined in "Parallel connectivity preserving thinning algorithms", by Hall
 int32_t is_hall_2dendpoint(struct xvimage* img, uint32_t x, uint32_t rs, uint32_t N, uint32_t type)
@@ -6260,7 +6378,6 @@
 /*
 Squelette symétrique curviligne basé sur les isthmes 1D
 Algo CK2 données: S (image), I (inhibit), n (n_steps)
-Pour tout x de S faire T[x] := -1
 Pour i := 0; i < n; i++
   C := points de courbe (isthmes) de S
   I := I \cup C
@@ -6338,9 +6455,9 @@
       {
 	m1 = mc_match1(F, i, rs, N);
 	m2 = mc_match2(F, i, rs, N);
-	m3 = mc_match3b(F, i, rs, N);
-	m4 = mc_match4b(F, i, rs, N);
-	m5 = mc_match5b(F, i, rs, N);
+	m3 = mc_match3(F, i, rs, N);
+	m4 = mc_match4(F, i, rs, N);
+	m5 = mc_match5(F, i, rs, N);
 	m6 = mc_match6(F, i, rs, N);
 	if (m1 || m2 || m3 || m4 || m5 || m6)
 	{
@@ -6378,3 +6495,410 @@
   freeimage(tmp);
   return(1);
 } /* lskelCK2() */
+
+/* ==================================== */
+int32_t lskelCK2_pers_old(struct xvimage *image, 
+			  struct xvimage *persistence)
+/* ==================================== */
+// calcule la fonction persistence de la méthode CK2
+// VERSION SANS CONTROLE TOPOLOGIQUE - OBSOLETE
+#undef F_NAME
+#define F_NAME "lskelCK2_pers_old"
+{
+  int32_t i;
+  int32_t rs = rowsize(image);     /* taille ligne */
+  int32_t cs = colsize(image);     /* taille colonne */
+  int32_t N = rs * cs;             /* taille image */
+  uint8_t *F = UCHARDATA(image);   /* l'image de depart */
+  struct xvimage *tmp = copyimage(image);
+  struct xvimage *inhibit;
+  uint8_t *I;
+  uint8_t *T = UCHARDATA(tmp);
+  int32_t step, nonstab, nsteps;
+  int32_t m1, m2, m3, m4, m5, m6;
+  float *P = FLOATDATA(persistence); /* résultat */
+
+  inhibit = copyimage(image); 
+  razimage(inhibit);
+  I = UCHARDATA(inhibit);
+
+  nsteps = 1000000000;
+
+  for (i = 0; i < N; i++) if (F[i]) F[i] = S_OBJECT; // normalize values
+  for (i = 0; i < N; i++) P[i] = PERS_INIT_VAL;
+
+  /* ================================================ */
+  /*               DEBUT ALGO                         */
+  /* ================================================ */
+
+  step = 0;
+  nonstab = 1;
+  while (nonstab)
+  {
+    nonstab = 0;
+    step++;
+#ifdef VERBOSE
+    printf("step %d\n", step);
+#endif
+    memset(T, 0, N);
+
+    for (i = 0; i < N; i++)
+      if (F[i] && simple8(F, i, rs, N))
+	SET_SIMPLE(F[i]);
+
+    for (i = 0; i < N; i++) // detecte les isthmes
+      if (F[i])
+      {
+	if (IS_SIMPLE(F[i]) && mc_match1(F, i, rs, N))
+	  I[i] = I_INHIBIT;
+	else if (t8(mask(F, i, rs, N)) > 1)
+	  I[i] = I_INHIBIT;
+      }
+
+    // ENREGISTRE LA DATE DE NAISSANCE DES ISTHMES
+    for (i = 0; i < N; i++)
+    {
+      if ((P[i] == PERS_INIT_VAL) && (I[i] == I_INHIBIT)) P[i] = (float)step;
+    }
+
+    for (i = 0; i < N; i++)
+      if (IS_SIMPLE(F[i]))
+      {
+	m1 = mc_match1(F, i, rs, N);
+	m2 = mc_match2(F, i, rs, N);
+	m3 = mc_match3(F, i, rs, N);
+	m4 = mc_match4(F, i, rs, N);
+	m5 = mc_match5(F, i, rs, N);
+	m6 = mc_match6(F, i, rs, N);
+	if (m1 || m2 || m3 || m4 || m5 || m6)
+	{
+	  T[i] = 1; // preserve point
+	}
+      }
+
+    for (i = 0; i < N; i++)
+      if (IS_SIMPLE(F[i]) && !T[i]) 
+      { 
+	F[i] = 0; 
+	nonstab = 1; 
+	if (P[i] != PERS_INIT_VAL) P[i] = (float)step - P[i]; else P[i] = 0;
+      }
+    for (i = 0; i < N; i++) if (F[i]) F[i] = S_OBJECT;
+  }
+
+#ifdef VERBOSE1
+    printf("number of steps: %d\n", step);
+#endif
+
+  for (i = 0; i < N; i++) 
+    if (F[i]) 
+    {
+      F[i] = NDG_MAX; // normalize values
+      P[i] = PERS_INFTY_VAL;
+    }
+
+  freeimage(tmp);
+  return(1);
+} /* lskelCK2_pers_old() */
+
+/* ==================================== */
+static int32_t clique0_match(uint8_t *F, uint8_t *Y, int32_t x, int32_t rs, int32_t N)
+/* ==================================== */
+/*
+  3 2 1
+  4 . 0
+  5 6 7
+
+A B   origine C (forcément dans F et pas dans Y)
+C D   au moins AD ou BC dans F
+      tous les pts dans F sont hors de Y
+
+ */
+{
+  int32_t i;
+  uint8_t f[8];
+  uint8_t y[8];
+  extract_vois(F, x, rs, N, f);
+  extract_vois(Y, x, rs, N, y);
+  for (i = 0; i < 4; i++)
+  {
+    if (f[0] && y[0]) goto fail;
+    if (f[1] && y[1]) goto fail;
+    if (f[2] && y[2]) goto fail;
+    if (!f[1] && (!f[0] || !f[2])) goto fail;
+    return 1;
+  fail:
+    rotate90_vois(f);
+    rotate90_vois(y);
+  }
+  return 0;
+} /* clique0_match() */
+
+/* ==================================== */
+static int32_t clique1_match(uint8_t *F, uint8_t *Y, int32_t x, int32_t rs, int32_t N)
+/* ==================================== */
+/*
+  3 2 1
+  4 . 0
+  5 6 7
+
+A A   avec x : dans F mais pas dans Y
+x x   origine : premier x (dans F mais pas dans Y, déjà testé)
+B B   (+ rotation 90)
+
+  1-critique : au moins un des A et au moins un des B non nuls
+  critique mais pas 1-critique : A et B tous nuls
+
+  Si 1-critique (isthme) retourne 2
+  Sinon si critique retourne 1
+  Sinon retourne 0
+ */
+{
+  int32_t i;
+  uint8_t f[8];
+  uint8_t y[8];
+  extract_vois(F, x, rs, N, f);
+  extract_vois(Y, x, rs, N, y);
+  for (i = 0; i < 4; i++)
+  {
+    if (!f[0] || y[0]) goto fail;
+    if ((f[1] == 0) && (f[2] == 0) && (f[6] == 0) && (f[7] == 0)) return 1;
+    if ((f[1] == 0) && (f[2] == 0)) goto fail;
+    if ((f[6] == 0) && (f[7] == 0)) goto fail;
+    return 2;
+  fail:
+    rotate90_vois(f);
+    rotate90_vois(y);
+  }
+  return 0;
+} /* clique1_match() */
+
+/* ==================================== */
+static void D_Crucial_Isthmes(uint8_t *F, uint8_t *K, int32_t rs, int32_t N, uint8_t *Y, uint8_t *Z, uint8_t *A, uint8_t *B)
+/* ==================================== */
+{
+#undef F_NAME
+#define F_NAME "D_Crucial_Isthmes"
+  int32_t i, r;
+  memcpy(Y, K, N);
+  memset(Z, 0, N);
+  memset(A, 0, N);
+  memset(B, 0, N);
+  // dim = 2
+  for (i = 0; i < N; i++)
+    if (F[i] && (K[i] || !simple8(F, i, rs, N)))
+    {
+#ifdef DEBUG_D_Crucial_Isthmes
+printf("2-crucial %d %d\n", i % rs, i / rs);
+#endif
+if (i == 236*rs + 57) printf("2-crucial %d %d\n", i % rs, i / rs);
+      A[i] = 1;
+      if (!K[i] && t8(mask(F, i, rs, N)) > 1)
+      {
+#ifdef DEBUG_D_Crucial_Isthmes
+printf("isthme mince %d %d\n", i % rs, i / rs);
+#endif
+        B[i] = 1;
+      }
+    }
+  for (i = 0; i < N; i++) { if (A[i]) Y[i] = 1; if (B[i]) Z[i] = 1; }
+    
+  // dim = 1
+  for (i = 0; i < N; i++)
+    if (F[i] && !Y[i])
+    {
+      r = clique1_match(F, Y, i, rs, N);
+      if (r > 0)
+      {	
+#ifdef DEBUG_D_Crucial_Isthmes
+printf("1-crucial %d %d\n", i % rs, i / rs);
+#endif
+if (i == 236*rs + 57) printf("1-crucial %d %d\n", i % rs, i / rs);
+	A[i] = 1;
+	if (r > 1) 
+	{
+#ifdef DEBUG_D_Crucial_Isthmes
+printf("isthme epais %d %d\n", i % rs, i / rs);
+#endif
+	  B[i] = 1;
+	}
+      }
+    }
+  for (i = 0; i < N; i++) { if (A[i]) Y[i] = 1; if (B[i]) Z[i] = 1; }
+
+  // dim = 0
+  for (i = 0; i < N; i++)
+    if (F[i] && !Y[i] && clique0_match(F, Y, i, rs, N))
+    {
+#ifdef DEBUG_D_Crucial_Isthmes
+printf("0-crucial %d %d\n", i % rs, i / rs);
+#endif
+if (i == 236*rs + 57) printf("0-crucial %d %d\n", i % rs, i / rs);
+      Y[i] = 1;
+    }
+  for (i = 0; i < N; i++) { if (A[i]) Y[i] = 1; if (B[i]) Z[i] = 1; }
+} // D_Crucial_Isthmes()
+
+/* ==================================== */
+int32_t lskelCK2_pers(struct xvimage *image, 
+		      struct xvimage *persistence)
+/* ==================================== */
+/* Hiérarchie de squelettes basées sur la persistence des isthmes 1D - version symétrique
+ 
+   // ETAPE 1 : calcul des persistences et du squelette à persistence 0
+   step = 0;
+   foreach x in X do P(x) = 0;
+   repeat
+     step++;
+     Y = D_crucial(X,0); Z = Isthmes(X,0,1); 
+     foreach x in Z such that P(x) = 0 do P(x) = step;
+     foreach x in X \ Y such that P(x) > 0 do P(x) = step - P(x);
+     X = Y
+   until stability
+   foreach x in X do P(x) = +infty
+   X = {x such that P(x) > 0}
+
+   // ETAPE 2 : contrôle topologique sur toutes les coupes de la fonction P
+   foreach x in X do InsertQueue(Q,x,P(x));
+   repeat
+     lambda = MinValQueue(Q);
+     T = PopMinSetQueue(Q,lambda);
+     Y = D_crucial(X,X \ T)
+     foreach x in T inter Y do // non-deletable candidates
+       psi = +infty
+       foreach y in Gamma*(x) such that InQueue(Q,y) do
+         psi = min(psi,P(y));
+       P(x) = psi
+       InsertQueue(Q,x,psi);
+     X = Y
+   until lambda = +infty
+
+ */
+#undef F_NAME
+#define F_NAME "lskelCK2_pers"
+{
+  int32_t x;
+  int32_t rs = rowsize(image);     /* taille ligne */
+  int32_t cs = colsize(image);     /* taille colonne */
+  int32_t N = rs * cs;             /* taille image */
+  uint8_t *X = UCHARDATA(image);   /* l'image de depart */
+  struct xvimage *Yimage = copyimage(image);
+  struct xvimage *Zimage = copyimage(image);
+  struct xvimage *Kimage = copyimage(image);
+  struct xvimage *Aimage = copyimage(image);
+  struct xvimage *Bimage = copyimage(image);
+  uint8_t *A = UCHARDATA(Aimage);
+  uint8_t *B = UCHARDATA(Bimage);
+  uint8_t *Y = UCHARDATA(Yimage);
+  uint8_t *Z = UCHARDATA(Zimage);
+  uint8_t *K = UCHARDATA(Kimage);
+  int32_t step, ndel, nsteps;
+  float *P = FLOATDATA(persistence); /* résultat */
+  Rbt * Q;
+  index_t taillemaxrbt;
+
+  taillemaxrbt = 2 * rs +  2 * cs;
+  /* cette taille est indicative, le RBT est realloue en cas de depassement */
+  Q = mcrbt_CreeRbtVide(taillemaxrbt);
+  if (Q == NULL)
+  {
+    fprintf(stderr, "%s: mcrbt_CreeRbtVide failed\n", F_NAME);
+    return(0);
+  }
+
+  nsteps = 1000000000;
+  for (x = 0; x < N; x++) if (X[x]) X[x] = S_OBJECT; // normalize values
+
+  //   step = 0; K = empty; 
+  step = 0;
+  razimage(Kimage);
+  // foreach x in X do P(x) = 0;
+  for (x = 0; x < N; x++) P[x] = PERS_INIT_VAL;
+
+  /* ================================================ */
+  /*               DEBUT ALGO                         */
+  /* ================================================ */
+
+  do
+  {
+    ndel = 0;
+    step++;
+//if (step > 10) goto stop;
+#define VERBOSE
+#ifdef VERBOSE
+    printf("step %d\n", step);
+#endif
+
+    // Y = D_crucial(X,0); Z = Isthmes(X,0,1);
+    D_Crucial_Isthmes(X, K, rs, N, Y, Z, A, B);
+
+    // foreach x in Z such that P(x) = 0 do P(x) = step;
+    for (x = 0; x < N; x++)
+      if (Z[x] && (P[x] == PERS_INIT_VAL)) 
+      {
+	P[x] = (float)step;
+      }
+
+    // foreach x in X \ Y such that P(x) > 0 do
+    for (x = 0; x < N; x++)
+      if (X[x] && !Y[x] && (P[x] != PERS_INIT_VAL)) 
+      { 
+	// P(x) = step - P(x);
+	P[x] = (float)step - P[x];
+      }
+
+    // X = Y
+    for (x = 0; x < N; x++) 
+      if (X[x])
+      { 
+	if (Y[x])
+	  X[x] = S_OBJECT;
+	else
+	{
+	  X[x] = 0;
+	  ndel++; 
+	}
+      }
+
+#ifdef VERBOSE
+    printf("ndel = %d\n", ndel);
+#endif
+
+  } while (ndel > 0);
+
+stop:;
+
+#ifdef VERBOSE1
+    printf("number of steps: %d\n", step);
+#endif
+
+    for (x = 0; x < N; x++) if (X[x]) P[x] = PERS_INFTY_VAL;
+
+    for (x = 0; x < N; x++) if (P[x] > 0) X[x] = S_OBJECT;
+
+
+
+
+
+
+
+
+
+
+
+
+
+  for (x = 0; x < N; x++) 
+    if (X[x]) 
+    {
+      X[x] = NDG_MAX; // normalize values
+    }
+
+  mcrbt_RbtTermine(Q);
+  freeimage(Aimage);
+  freeimage(Bimage);
+  freeimage(Yimage);
+  freeimage(Zimage);
+  freeimage(Kimage);
+  return(1);
+} /* lskelCK2_pers() */
diff -r 8b1af7363833 src/lib/lskelpar.c.sav
--- a/src/lib/lskelpar.c.sav	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,4505 +0,0 @@
-/* $Id: lskelpar.c.sav,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-/* 
-   Algorithmes 2D "fully parallel" de squelettisation :
-
-   - Pavlidis
-   - Eckhardt
-   - Couprie ultime
-   - Couprie curviligne
-   - Couprie curviligne avec reconstruction
-   - Rutovitz
-   - Zhang & Wang
-   - Han & La & Rhee (merdique et peu int32_téressant)
-   - Guo & Hall
-   - Chin & Wan & Stover & Iverson
-   - Jang & Chin
-   - Jang & Chin (mc correction)
-   - MNS_preservation
-   - Jang & Chin rec
-   - Choy & Choy & Siu
-   - Manzanera and Bernard
-   - Manzanera and Bernard (variante gb)
-   - Hall
-   - Wu and Tsai
-   - Bertrand curviligne avec reconstruction
-   - Bertrand ultime (MK2)
-   - Bertrand avec inclusion de l'axe médian (AK2)
-
-   Couprie ultime:
-     input/output F
-     repeat until stability
-       for all x do if simple8(x) then F[x] = 2
-       for all x do if (m1(x) v m2(x) v m3(x) v m4(x) v m5(x) v m6(x)) then T[x] = 1
-       for all x do 
-         if (F[x]=2) then
-           if not T[x] then F[x] = 0 else F[x] = 1
-
-     m1 : match   A 2 B   avec origine = 1 0 et [au moins un des A et au moins un des B non nuls]
-                  A 2 B   ou [A et B tous nuls] (+ rotation 90)
-
-     m2 : match   x 0 0 x   avec origine = 1 2 et x = don't care
-                  0 2 2 0   (+ rotations 90, 180, 270)
-		  0 2 2 0
-		  x 0 0 x
-
-     m3: match   x 0 0 x   avec origine = 1 2 et x = don't care
-                 0 2 2 x   (+ rotations 90, 180, 270)
-	         0 2 0 x
-		 x x x x
-
-     m4: match   x x x x   avec origine = 1 2 et x = don't care
-                 x 0 2 0   (+ rotations 90, 180, 270)
-		 x 2 2 0
-		 x 0 0 x
-
-     m5: match   x x x x   avec origine = 1 2 et x = don't care
-                 0 2 0 x   (+ rotations 90, 180, 270)
-		 0 2 2 x
-		 x 0 0 x
-
-     m6 : match   2 0      avec origine = 1 1
-                  0 2      (+ rotations 90, 180, 270)
-
-   Couprie curviligne:
-     input/output F
-     repeat until stability
-       for all x do if simple8(x) and not end(x) then F[x] = 2
-       for all x do if (m1(x) v m2(x) v m3(x) v m4(x) v m5(x) v m6(x)) then T[x] = 1
-       for all x do 
-         if (F[x]=2) then
-           if not T[x] then F[x] = 0 else F[x] = 1
-
-     end : match   0 0 x   ou    0 x 1    avec origine = 1 1 et x = don't care
-                   0 1 1         0 1 x
-                   0 0 x         0 0 0
-
-     VARIANTE:
-
-     end2: match   0 0 p   ou    0 x 1    avec origine = 1 1 et x = don't care
-                   0 1 1         0 1 x    et not (p = 1 and q = 1)
-                   0 0 q         0 0 0
-
-     end2: match   0 0 0   ou    0 x 1   ou   0 1 x   avec origine = 1 1 et x = don't care
-                   0 1 1         0 1 x        0 1 1
-                   0 0 0         0 0 0        0 0 0
-
-   Couprie curviligne avec reconstruction:
-     input/output X
-     Y = emptyset
-     repeat until stability
-       I = Interior(X \ Y)
-       D = Dilat(I) Inter [X \ Y]
-       E = Y Union [X \ D]
-       for all x do if simple8(x) and x not in E then X[x] = 2
-       for all x do if (m1(x) v m2(x) v m3(x) v m4(x) v m5(x) v m6(x)) then T[x] = 1
-       for all x do 
-         if (X[x]=2) then
-           if not T[x] then X[x] = 0 else X[x] = 1
-       Y = X \ I
-
-   MNS_preservation:
-     input/output F
-     repeat until stability
-       for all x do if simple8(x) then F[x] = 2
-       for all x do if (m1(x) v m2(x) v m3(x) v m4(x) v m5(x) v m6(x)) then T[x] = 1
-       for all x do 
-         if (F[x]=2) then
-           if not T[x] then F[x] = 0 else F[x] = 1
-
-     m1 : match   A 2 B   avec origine = 1 0 et [au moins un des A et au moins un des B non nuls]
-                  A 2 B   ou [A et B tous nuls] (+ rotation 90)
-
-		  (preuve équivalence par programme : Squel2D/ronse.c)
-
-     m2 : match   0 0 0 0   avec origine = 1 2 et x = don't care
-                  0 2 2 0   (+ rotations 90, 180, 270)
-		  0 2 2 0
-		  0 0 0 0
-
-     m3 : match   0 0 0 0   avec origine = 1 2 et x = don't care
-                  0 2 2 0   (+ rotations 90, 180, 270)
-		  0 2 0 0
-		  0 0 0 x
-
-     m4 : match   x 0 0 0   avec origine = 1 2 et x = don't care
-                  0 0 2 0   (+ rotations 90, 180, 270)
-		  0 2 2 0
-		  0 0 0 0
-
-     m5 : match   0 0 0 x   avec origine = 1 2 et x = don't care
-                  0 2 0 0   (+ rotations 90, 180, 270)
-		  0 2 2 0
-		  0 0 0 0
-
-		  (preuve suffisant papier de Ronse)
-
-     m6 : match   x 0 0 0   avec origine = 1 2 et x = don't care
-                  0 0 2 0   (+ rotations 90, 180, 270)
-                  0 2 0 0
-		  0 0 0 x
-
-		  (preuve suffisant par programme : Squel2D/ronse.c)
-
-   Michel Couprie - juillet 2001 
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mctopo.h>
-#include <mcindic.h>
-#include <mcutil.h>
-#include <lskelpar.h>
-
-//#define DEBUG_PAV
-//#define DEBUG_MC
-//#define VERBOSE1
-//#define ETUDE
-//#define ANIMATE
-
-static int32_t jangrec_match23(uint8_t *F, int32_t x, int32_t rs, int32_t N);
-static int32_t jang_match27b(uint8_t *F, int32_t x, int32_t rs, int32_t N);
-static int32_t jang_match28b(uint8_t *F, int32_t x, int32_t rs, int32_t N);
-
-
-/* ==================================== */
-void extract_vois(
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t N,                       /* taille image */
-  uint8_t *vois)    
-/* 
-  retourne dans "vois" les valeurs des 8 voisins de p, dans l'ordre suivant: 
-
-		3	2	1			
-		4	p	0
-		5	6	7
-  le point p ne doit pas être un point de bord de l'image
-*/
-/* ==================================== */
-{
-#undef F_NAME
-#define F_NAME "extract_vois"
-  register uint8_t * ptr = img+p;
-  if ((p%rs==rs-1) || (p<rs) || (p%rs==0) || (p>=N-rs)) /* point de bord */
-  {
-    printf("%s: ERREUR: point de bord\n", F_NAME);
-    exit(0);
-  }
-  vois[0] = *(ptr+1);
-  vois[1] = *(ptr+1-rs);
-  vois[2] = *(ptr-rs);
-  vois[3] = *(ptr-rs-1);
-  vois[4] = *(ptr-1);
-  vois[5] = *(ptr-1+rs);
-  vois[6] = *(ptr+rs);
-  vois[7] = *(ptr+rs+1);
-} /* extract_vois() */
-
-/* ==================================== */
-void print_vois(uint8_t *vois)    
-/* 
-   affiche vois (debug)
-*/
-/* ==================================== */
-{
-  printf("vois = %d %d %d %d %d %d %d %d\n", 
-	 vois[0], vois[1], vois[2], vois[3], vois[4], vois[5], vois[6], vois[7]);
-} /* print_vois() */
-
-/* ==================================== */
-void rotate45_vois(uint8_t *vois)    
-/* 
-   effectue une rotation du voisinage "vois" de 45 degres dans le sens 
-   trigonométrique
-*/
-/* ==================================== */
-{
-  uint8_t tmp = vois[0];
-  vois[0] = vois[7]; vois[7] = vois[6]; vois[6] = vois[5]; vois[5] = vois[4];
-  vois[4] = vois[3]; vois[3] = vois[2]; vois[2] = vois[1]; vois[1] = tmp;
-} /* rotate45_vois() */
-
-/* ==================================== */
-void rotate90_vois(uint8_t *vois)    
-/* 
-   effectue une rotation du voisinage "vois" de 90 degres dans le sens 
-   trigonométrique
-*/
-/* ==================================== */
-{
-  rotate45_vois(vois); rotate45_vois(vois);
-} /* rotate90_vois() */
-
-/* ==================================== */
-int32_t extract_vois2(
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t N,                       /* taille image */
-  uint8_t *vois)    
-/* 
-  retourne dans "vois" les valeurs des 16 voisins d'ordre 2 de p, dans l'ordre suivant: 
-
-		6   5   4   3   2			
-		7   X   X   X   1			
-		8   X   p   X   0
-		9   X   X   X   15			
-		10  11  12  13  14
-  le point p doit être à une distance minimale de 2 du bord de l'image
-*/
-/* ==================================== */
-{
-#undef F_NAME
-#define F_NAME "extract_vois2"
-  register uint8_t * ptr = img+p;
-  register int32_t rs2 = rs + rs;
-  if ((p%rs>=rs-2) || (p<rs2) || (p%rs<2) || (p>=N-rs2)) /* point de bord */
-  {
-#ifdef PARANO
-    printf("%s: ERREUR: point de bord\n", F_NAME);
-    exit(0);
-#else
-    return 0;
-#endif
-  }
-  vois[0] = *(ptr+2);
-  vois[1] = *(ptr+2-rs);
-  vois[2] = *(ptr+2-rs2);
-  vois[3] = *(ptr+1-rs2);
-  vois[4] = *(ptr-rs2);
-  vois[5] = *(ptr-1-rs2);
-  vois[6] = *(ptr-2-rs2);
-  vois[7] = *(ptr-2-rs);
-  vois[8] = *(ptr-2);
-  vois[9] = *(ptr-2+rs);
-  vois[10] = *(ptr-2+rs2);
-  vois[11] = *(ptr-1+rs2);
-  vois[12] = *(ptr+rs2);
-  vois[13] = *(ptr+1+rs2);
-  vois[14] = *(ptr+2+rs2);
-  vois[15] = *(ptr+2+rs);
-  return 1;
-} /* extract_vois2() */
-
-/* ==================================== */
-void rotate90_vois2(uint8_t *vois)    
-/* 
-   effectue une rotation du voisinage d'ordre 2 "vois" de 90 degres dans le sens 
-   trigonométrique
-*/
-/* ==================================== */
-{
-  uint8_t tmp;
-  tmp = vois[0]; vois[0] = vois[12]; vois[12] = vois[8]; vois[8] = vois[4]; vois[4] = tmp;
-  tmp = vois[1]; vois[1] = vois[13]; vois[13] = vois[9]; vois[9] = vois[5]; vois[5] = tmp;
-  tmp = vois[2]; vois[2] = vois[14]; vois[14] = vois[10]; vois[10] = vois[6]; vois[6] = tmp;
-  tmp = vois[3]; vois[3] = vois[15]; vois[15] = vois[11]; vois[11] = vois[7]; vois[7] = tmp;
-} /* rotate90_vois2() */
-
-/* ==================================== */
-static int32_t pav_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  A A A   avec origine = 1 1 et au moins un des A et au moins un des B non nuls
-  0 P 0
-  B B B
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] != 0) goto fail;
-    if ((v[1] == 0) && (v[2] == 0) && (v[3] == 0)) goto fail;
-    if (v[4] != 0) goto fail;
-    if ((v[5] == 0) && (v[6] == 0) && (v[7] == 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* pav_match1() */
-
-/* ==================================== */
-static int32_t pav_match2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  D D D     avec origine = 1 1 et valeurs des pixels D quelconques
-  D P 0
-  D 0 2
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] != 0) goto fail;
-    //    if ((v[1] == 0) && (v[2] == 0) && (v[3] == 0) && (v[4] == 0) && (v[5] == 0)) goto fail;
-    if (v[6] != 0) goto fail;
-    if (v[7] != 2) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* pav_match2() */
-
-/* ==================================== */
-static int32_t pav_match3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-// condition for "tentatively multiple" points
-/*
-  A A C   avec origine = 1 1 et au moins un des A et au moins un des B 
-  0 2 2   et au moins un des C non nuls - de plus si les deux C sont non
-  B B C   nuls, alors les pixels A et B peuvent être quelconques
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  if ((v[0] != 1) && (v[1] != 1) && (v[2] != 1) && (v[3] != 1) && 
-      (v[4] != 1) && (v[5] != 1) && (v[6] != 1) && (v[7] != 1)) return 1;
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] != 2) goto fail;
-    if (v[4] != 0) goto fail;
-    if ((v[1] == 0) && (v[7] == 0)) goto fail;
-    if ((v[1] != 0) && (v[7] != 0)) return 1;
-    if ((v[2] == 0) && (v[3] == 0)) goto fail;
-    if ((v[5] == 0) && (v[6] == 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* pav_match3() */
-
-/* ==================================== */
-static int32_t pav_match3b(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-// condition for "tentatively multiple" points
-/*
-  A A C   avec origine = 1 1 et au moins un des A OU au moins un des B OU au moins un des C non nuls
-  0 2 2
-  B B C
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  if ((v[0] != 1) && (v[1] != 1) && (v[2] != 1) && (v[3] != 1) && 
-      (v[4] != 1) && (v[5] != 1) && (v[6] != 1) && (v[7] != 1)) return 1;
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] != 2) goto fail;
-    if (v[4] != 0) goto fail;
-    if ((v[1] != 0) || (v[7] != 0)) return 1;
-    if ((v[2] != 0) || (v[3] != 0)) return 1;
-    if ((v[5] != 0) || (v[6] != 0)) return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* pav_match3b() */
-
-/* ==================================== */
-static int32_t pav_match4(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-// condition for "corner" points
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] != 2) goto fail;
-    if ((v[1] != 0) || (v[2] != 0) || (v[3] != 0) || 
-	(v[4] != 0) || (v[5] != 0)) goto fail;
-    if (v[6] != 2) goto fail;
-    if (v[7] == 0) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* pav_match4() */
-
-/* ==================================== */
-static int32_t pav_multiple(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t m1 = pav_match1(F, x, rs, N);
-  int32_t m2 = pav_match2(F, x, rs, N);
-  int32_t m3 = pav_match3(F, x, rs, N);
-  int32_t m4 = pav_match4(F, x, rs, N);
-#ifdef DEBUG_PAV
-  if (m1 || m2 || m3 || m4)
-    printf("point %d,%d : m1 = %d; m2 = %d; m3 = %d; m4 = %d\n", 
-	   x % rs, x / rs, m1, m2, m3, m4);
-#endif
-  return m1 || m2 || m3 || m4;
-} /* pav_multiple() */
-
-/* ==================================== */
-int32_t lskelpavlidis(struct xvimage *image, 
-		  int32_t nsteps,
-		  struct xvimage *inhibit)
-/* ==================================== */
-// T. Pavlidis : "A flexible parallel thinning algorithm"
-// see also T. Pavlidis : "An asynchronous thinning algorithm - CGIP 1982"
-#undef F_NAME
-#define F_NAME "lskelpavlidis"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  while (step < nsteps)
-  {
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) if (F[i] && bordext4(F, i, rs, N)) F[i] = 2;
-    for (i = 0; i < N; i++) if ((F[i] == 2) && pav_multiple(F, i, rs, N)) T[i] = 1;
-#ifdef DEBUG_PAV
-    printf("\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", F[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", T[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-    for (i = 0; i < N; i++) if ((F[i] == 2) && !T[i]) break;
-    if (i == N) break;
-    for (i = 0; i < N; i++) if ((F[i] == 1) || T[i]) F[i] = 1; else F[i] = 0;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelpavlidis() */
-
-/* ==================================== */
-int32_t lskelpavlidis1(struct xvimage *image, 
-		  int32_t pixel)
-/* ==================================== */
-// T. Pavlidis : "A flexible parallel thinning algorithm"
-// see also T. Pavlidis : "An asynchronous thinning algorithm - CGIP 1982"
-// Une étape - un seul point testé
-#undef F_NAME
-#define F_NAME "lskelpavlidis1"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  memset(T, 0, N);
-  for (i = 0; i < N; i++) if (F[i] && bordext4(F, i, rs, N)) F[i] = 2;
-  for (i = 0; i < N; i++) if ((F[i] == 2) && pav_multiple(F, i, rs, N)) T[i] = 1;
-  if ((F[pixel] == 2) && !T[pixel]) F[pixel] = 0;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelpavlidis1() */
-
-/* ==================================== */
-static int32_t eck_perfect(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i = x % rs; 
-  int32_t j = x / rs; 
-  if ((F[j*rs + i-1] == 2) && (F[j*rs + i+1] == 0)) return 1;
-  if ((F[j*rs + i+1] == 2) && (F[j*rs + i-1] == 0)) return 1;
-  if ((F[(j-1)*rs + i] == 2) && (F[(j+1)*rs + i] == 0)) return 1;
-  if ((F[(j+1)*rs + i] == 2) && (F[(j-1)*rs + i] == 0)) return 1;
-  return 0;
-} /* eck_perfect() */
-
-/* ==================================== */
-int32_t lskeleckhardt(struct xvimage *image, 
-		  int32_t nsteps,
-		  struct xvimage *inhibit)
-/* ==================================== */
-// Eckhardt and Maderlechner : "Invariant thinning"
-#undef F_NAME
-#define F_NAME "lskeleckhardt"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) if (F[i] && nbvois4(F, i, rs, N) == 4) F[i] = 2;
-    for (i = 0; i < N; i++) 
-      if ((F[i] == 1) && simple8(F, i, rs, N) && eck_perfect(F, i, rs, N))
-      {
-	nonstab = 1;
-	T[i] = 1;
-      }
-#ifdef DEBUG_ECK
-    printf("\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", F[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", T[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-    for (i = 0; i < N; i++) 
-      if (T[i] == 1) F[i] = 0; 
-      else if (F[i]) F[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskeleckhardt() */
-
-/* ==================================== */
-static int32_t crossing_nb(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-// retourne le nombre de transitions 1 -> 0 dans la liste ordonnée et cyclique des voisins
-{
-  int32_t i, n = 0;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 8; i++) if (v[i] && !v[(i+1)%8]) n++;
-  return n;
-} /* crossing_nb() */
-
-/* ==================================== */
-static int32_t rutovitz_match(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-#undef F_NAME
-#define F_NAME "rutovitz_match"
-  int32_t i, n;
-  uint8_t v[8];
-  if (!F[x]) return 0;
-  n = nbvois8(F, x, rs, N);
-  //  if ((n < 2) || (n > 6)) return 0; // cond. donnée par Zhang et Wang
-  if (n < 2) return 0;
-  if (crossing_nb(F, x, rs, N) != 1) return 0;
-  extract_vois(F, x, rs, N, v);
-  if ((x < rs) || (x%rs == rs-1))
-  {
-    fprintf(stderr, "%s: object must not hit the frame\n", F_NAME);
-    exit(0);
-  }
-  n = crossing_nb(F, x-rs, rs, N);
-  if ((n == 1) && v[2] && v[0] && v[4]) return 0;
-  n = crossing_nb(F, x+1, rs, N);
-  if ((n == 1) && v[2] && v[0] && v[6]) return 0;
-  return 1;
-} /* rutovitz_match() */
-
-/* ==================================== */
-int32_t lskelrutovitz(struct xvimage *image, 
-		  int32_t nsteps,
-		  struct xvimage *inhibit)
-/* ==================================== */
-// described in Zhang & Wang : "A modified parallel thinning algorithm"
-#undef F_NAME
-#define F_NAME "lskelrutovitz"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if (rutovitz_match(F, i, rs, N))
-	//if (rutovitz_match(F, i, rs, N) && !jangrec_match23(F, i, rs, N)) // correction mc
-      {
-	nonstab = 1;
-	T[i] = 1;
-      }
-    for (i = 0; i < N; i++) 
-      if (T[i] == 1) F[i] = 0; 
-      else if (F[i]) F[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelrutovitz() */
-
-/* ==================================== */
-static int32_t zhangwang_match(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-#undef F_NAME
-#define F_NAME "zhangwang_match"
-  int32_t i, n;
-  uint8_t v[8];
-  if (!F[x]) return 0;
-  n = nbvois8(F, x, rs, N);
-  if ((n < 2) || (n > 6)) return 0;
-  if (crossing_nb(F, x, rs, N) != 1) return 0;
-  extract_vois(F, x, rs, N, v);
-  if ((x < rs+rs) || (x%rs >= rs-2))
-  {
-    fprintf(stderr, "%s: object must not hit the 2 pixel-thick frame\n", F_NAME);
-    exit(0);
-  }
-  if ((F[x-(rs+rs)] == 0) && v[2] && v[0] && v[4]) return 0;
-  if ((F[x+2]       == 0) && v[2] && v[0] && v[6]) return 0;
-  return 1;
-} /* zhangwang_match() */
-
-/* ==================================== */
-int32_t lskelzhangwang(struct xvimage *image, 
-		  int32_t nsteps,
-		  struct xvimage *inhibit)
-/* ==================================== */
-// described in Zhang & Wang : "A modified parallel thinning algorithm"
-#undef F_NAME
-#define F_NAME "lskelzhangwang"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if (zhangwang_match(F, i, rs, N))
-	//if (zhangwang_match(F, i, rs, N) && !jangrec_match23(F, i, rs, N)) // correction mc
-      {
-	nonstab = 1;
-	T[i] = 1;
-      }
-    for (i = 0; i < N; i++) 
-      if (T[i] == 1) F[i] = 0; 
-      else if (F[i]) F[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelzhangwang() */
-
-/* ==================================== */
-static int32_t hanlarhee_match2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i, n;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-
-  // at least one neighbor must be greater than or equal to 3
-  for (i = 0; i < 8; i++) if (v[i] >= 3) break;
-  if (i == 8) return 0;
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0])&&(v[1])&&(!v[2])&&(!v[3])&&(!v[4])&&(!v[5])&&(!v[6])&&(!v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((!v[0])&&(v[1])&&(v[2])&&(!v[3])&&(!v[4])&&(!v[5])&&(!v[6])&&(!v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0])&&(!v[1])&&(v[2])&&(!v[3])&&(!v[4])&&(!v[5])&&(!v[6])&&(!v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  return 0;
-} /* hanlarhee_match2() */
-
-/* ==================================== */
-static int32_t hanlarhee_match3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i, n;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-
-  // at least one neighbor must be greater than or equal to 7
-  for (i = 0; i < 8; i++) if (v[i] >= 7) break;
-  if (i == 8) return 0;
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0])&&(v[1])&&(v[2])&&(!v[3])&&(!v[4])&&(!v[5])&&(!v[6])&&(!v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((!v[0])&&(v[1])&&(v[2])&&(v[3])&&(!v[4])&&(!v[5])&&(!v[6])&&(!v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  if ((v[0])&&(!v[1])&&(!v[2])&&(!v[3])&&(!v[4])&&(v[5])&&(v[6])&&(!v[7])) return 1;
-  if ((!v[0])&&(!v[1])&&(!v[2])&&(v[3])&&(v[4])&&(!v[5])&&(v[6])&&(!v[7])) return 1;
-  if ((v[0])&&(v[1])&&(!v[2])&&(!v[3])&&(!v[4])&&(!v[5])&&(v[6])&&(!v[7])) return 1;
-  if ((!v[0])&&(!v[1])&&(!v[2])&&(!v[3])&&(v[4])&&(!v[5])&&(v[6])&&(v[7])) return 1;
-
-  return 0;
-} /* hanlarhee_match3() */
-
-/* ==================================== */
-static int32_t hanlarhee_match4(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i, n;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0])&&(v[1])&&(v[2])&&(v[3])&&(!v[4])&&(!v[5])&&(!v[6])&&(!v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((!v[0])&&(v[1])&&(v[2])&&(v[3])&&(v[4])&&(!v[5])&&(!v[6])&&(!v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  if ((v[0])&&(v[1])&&(!v[2])&&(!v[3])&&(!v[4])&&(v[5])&&(v[6])&&(!v[7])) return 1;
-  if ((!v[0])&&(!v[1])&&(!v[2])&&(v[3])&&(v[4])&&(!v[5])&&(v[6])&&(v[7])) return 1;
-
-  return 0;
-} /* hanlarhee_match4() */
-
-/* ==================================== */
-static int32_t hanlarhee_match5(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i, n;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-
-  // at least one neighbor must be equal to 8
-  for (i = 0; i < 8; i++) if (v[i] == 8) break;
-  if (i == 8) return 0;
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0])&&(v[1])&&(v[2])&&(v[3])&&(v[4])&&(!v[5])&&(!v[6])&&(!v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((!v[0])&&(v[1])&&(v[2])&&(v[3])&&(v[4])&&(v[5])&&(!v[6])&&(!v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  return 0;
-} /* hanlarhee_match5() */
-
-/* ==================================== */
-static int32_t hanlarhee_match6(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i, n;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-
-  // at least one neighbor must be equal to 8
-  for (i = 0; i < 8; i++) if (v[i] == 8) break;
-  if (i == 8) return 0;
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0])&&(v[1])&&(v[2])&&(v[3])&&(v[4])&&(v[5])&&(!v[6])&&(!v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((!v[0])&&(v[1])&&(v[2])&&(v[3])&&(v[4])&&(v[5])&&(v[6])&&(!v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  return 0;
-} /* hanlarhee_match6() */
-
-/* ==================================== */
-static int32_t hanlarhee_match7(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i, n;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-
-  // at least two neighbors must be equal to 8
-  n = 0;
-  for (i = 0; i < 8; i++) if (v[i] == 8) n++;
-  if (n < 2) return 0;
-
-  for (i = 0; i < 4; i++)
-  {
-    if ((!v[0])&&(v[1])&&(v[2])&&(v[3])&&(v[4])&&(v[5])&&(v[6])&&(v[7])) return 1;
-    rotate90_vois(v);
-  }
-
-  return 0;
-} /* hanlarhee_match7() */
-
-/* ==================================== */
-static int32_t hanlarhee_match(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i, n;
-  uint8_t v[8];
-  switch (F[x])
-  {
-  case 0: return 0;
-  case 1: 
-    extract_vois(F, x, rs, N, v);
-    for (i = 0; i < 8; i++)
-      if (v[i] >= 3) return 1;
-    return 0;
-  case 2: return hanlarhee_match2(F, x, rs, N);
-  case 3: return hanlarhee_match3(F, x, rs, N);
-  case 4: return hanlarhee_match4(F, x, rs, N);
-  case 5: return hanlarhee_match5(F, x, rs, N);
-  case 6: return hanlarhee_match6(F, x, rs, N);
-  case 7: return hanlarhee_match7(F, x, rs, N);
-  case 8: return 0;
-  }
-} /* hanlarhee_match() */
-
-/* ==================================== */
-int32_t lskelhanlarhee(struct xvimage *image, 
-		  int32_t nsteps,
-		  struct xvimage *inhibit)
-/* ==================================== */
-// described in Han, La & Rhee : "An efficient fully parallel algorithm"
-#undef F_NAME
-#define F_NAME "lskelhanlarhee"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  struct xvimage *nbn = copyimage(image); 
-  uint8_t *B = UCHARDATA(nbn);
-  int32_t step, nonstab;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) if (F[i]) B[i] = nbvois8(F, i, rs, N);
-    for (i = 0; i < N; i++) 
-      if (F[i] && hanlarhee_match(B, i, rs, N))
-      {
-	nonstab = 1;
-	T[i] = 1;
-      }
-    for (i = 0; i < N; i++) 
-      if (T[i] == 1) F[i] = 0; 
-      else if (F[i]) F[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  freeimage(nbn);
-  return(1);
-} /* lskelhanlarhee() */
-
-#undef F_NAME
-#define F_NAME "lskelguohall"
-
-/* ==================================== */
-static int32_t guohall_L(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  int32_t q1, q2;
-  if ((x+rs+rs >= N) || (x%rs < 2))
-  {
-    fprintf(stderr, "%s: object must not hit the 2 pixel-thick frame\n", F_NAME);
-    exit(0);
-  }
-  q1 = F[x-2]; q2 = F[x+rs+rs];
-  extract_vois(F, x, rs, N, v);
-  return (((!v[2] && v[6] && !q2) &&
-	   (v[1] || v[0] || v[7]) &&
-	   (v[3] || v[4] || v[5])) ||
-	  (!v[0] && v[4] && !q1));
-} /* guohall_L() */
-
-/* ==================================== */
-static int32_t guohall_d1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  int32_t q1, q2;
-  if ((x+rs+rs >= N) || (x%rs < 2))
-  {
-    fprintf(stderr, "%s: object must not hit the 2 pixel-thick frame\n", F_NAME);
-    exit(0);
-  }
-  q1 = F[x-2]; q2 = F[x+rs+rs];
-  extract_vois(F, x, rs, N, v);
-  return (!v[2] && v[4] && v[5] && v[6] && v[7] && v[0] && !q2);
-} /* guohall_d1() */
-
-/* ==================================== */
-static int32_t guohall_d2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  int32_t q1, q2;
-  if ((x+rs+rs >= N) || (x%rs < 2))
-  {
-    fprintf(stderr, "%s: object must not hit the 2 pixel-thick frame\n", F_NAME);
-    exit(0);
-  }
-  q1 = F[x-2]; q2 = F[x+rs+rs];
-  extract_vois(F, x, rs, N, v);
-  return (!v[0] && v[2] && v[3] && v[4] && v[5] && v[6] && !q1);
-} /* guohall_d2() */
-
-/* ==================================== */
-static int32_t guohall_d3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  int32_t q1, q2;
-  if ((x+rs+rs >= N) || (x%rs < 2))
-  {
-    fprintf(stderr, "%s: object must not hit the 2 pixel-thick frame\n", F_NAME);
-    exit(0);
-  }
-  q1 = F[x-2]; q2 = F[x+rs+rs];
-  extract_vois(F, x, rs, N, v);
-  return (!v[0] && !v[1] && !v[2] && !v[3] && v[4] && v[5] && v[6] && !v[7] && !q1 && !q2);
-} /* guohall_d3() */
-
-/* ==================================== */
-static int32_t guohall_b1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  return (!v[0] && !v[1] && !v[2] && v[4] && !v[5] && v[6]);
-} /* guohall_b1() */
-
-/* ==================================== */
-static int32_t guohall_b2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  return (!v[2] && !v[3] && !v[4] && v[6] && !v[7] && v[0]);
-} /* guohall_b2() */
-
-/* ==================================== */
-int32_t lskelguohall(struct xvimage *image, 
-		 int32_t nsteps,
-		 struct xvimage *inhibit,
-		 int32_t variante)
-/* ==================================== */
-// described in Guo & Hall : "Fast fully parallel thinning algorithms"
-#undef F_NAME
-#define F_NAME "lskelguohall"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-
-    switch (variante)
-    {
-    case 1:
-      for (i = 0; i < N; i++) 
-	if (F[i] && bordext4(F, i, rs, N) && (nbvois8(F, i, rs, N) > 2) 
-	    && (crossing_nb(F, i, rs, N) == 1) && !guohall_L(F, i, rs, N)) 
-	{
-	  nonstab = 1;
-	  T[i] = 1;
-	}
-      for (i = 0; i < N; i++) 
-	if (T[i] == 1) F[i] = 0; 
-	else if (F[i]) F[i] = 1;
-      break;
-    case 2:
-      for (i = 0; i < N; i++) 
-	if (F[i] && bordext4(F, i, rs, N) && (nbvois8(F, i, rs, N) > 2) 
-	    && (crossing_nb(F, i, rs, N) == 1) && !guohall_d1(F, i, rs, N)
-	    && !guohall_d2(F, i, rs, N) && !guohall_d3(F, i, rs, N))
-	{
-	  nonstab = 1;
-	  T[i] = 1;
-	}
-      for (i = 0; i < N; i++) 
-	if (T[i] == 1) F[i] = 0; 
-	else if (F[i]) F[i] = 1;
-      break;
-    case 3:
-      for (i = 0; i < N; i++) 
-	if (F[i] && 
-	    ((bordext4(F, i, rs, N) && (nbvois8(F, i, rs, N) > 2) 
-	     && (crossing_nb(F, i, rs, N) == 1) && !guohall_d1(F, i, rs, N)
-	     && !guohall_d2(F, i, rs, N) && !guohall_d3(F, i, rs, N)) ||
-	     guohall_b1(F, i, rs, N) || guohall_b2(F, i, rs, N)))
-	{
-	  nonstab = 1;
-	  T[i] = 1;
-	}
-      for (i = 0; i < N; i++) 
-	if (T[i] == 1) F[i] = 0; 
-	else if (F[i]) F[i] = 1;
-      break;
-    default: 
-      fprintf(stderr, "%s: variant not implemented\n", F_NAME);
-      return 0;
-    } // switch (variante)
-
-  } // while (nonstab && (step < nsteps))
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelguohall() */
-
-/* ==================================== */
-static int32_t chinwan_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 0
-  1 P 1
-  X 1 X
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || !v[4] || !v[6]) goto fail;
-    if (v[1] || v[2] || v[3]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* chinwan_match1() */
-
-/* ==================================== */
-static int32_t chinwan_match2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  X 0 0
-  1 P 0
-  X 1 X
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[4] || !v[6]) goto fail;
-    if (v[0] || v[1] || v[2]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* chinwan_match2() */
-
-/* ==================================== */
-static int32_t chinwan_match3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  int32_t q1, q2;
-  if ((x+rs+rs >= N) || (x%rs >= rs - 2))
-  {
-    fprintf(stderr, "%s: object must not hit the 2 pixel-thick frame\n", F_NAME);
-    exit(0);
-  }
-  q1 = F[x+2]; q2 = F[x+rs+rs];
-  extract_vois(F, x, rs, N, v);
-  return ((v[0] && !v[4] && !q1) || (!v[2] && v[6] && !q2));
-} /* chinwan_match3() */
-
-/* ==================================== */
-int32_t lskelchinwan(struct xvimage *image, 
-		 int32_t nsteps,
-		 struct xvimage *inhibit)
-/* ==================================== */
-// described in Chin, Wan, Stover & Iverson : "A one-pass thinning algorithms and its parallel implementation"
-#undef F_NAME
-#define F_NAME "lskelchinwan"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-
-    for (i = 0; i < N; i++) 
-      if (F[i] && (chinwan_match1(F, i, rs, N) || chinwan_match2(F, i, rs, N)) &&
-	  !chinwan_match3(F, i, rs, N))
-      {
-	nonstab = 1;
-	T[i] = 1;
-      }
-    for (i = 0; i < N; i++) 
-      if (T[i] == 1) F[i] = 0; 
-      else if (F[i]) F[i] = 1;
-
-  } // while (nonstab && (step < nsteps))
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelchinwan() */
-
-/* ==================================== */
-static int32_t jang_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 x   avec origine = 1 1 et x = don't care
-  0 1 1
-  x 1 x
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || v[2] || v[3] || v[4] || !v[6]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* jang_match1() */
-
-/* ==================================== */
-static int32_t jang_match5(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  x 0 x   avec origine = 1 1 et x = don't care
-  1 1 1
-  1 1 1
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || v[2] || !v[4] || !v[5] || !v[6] || !v[7]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* jang_match5() */
-
-/* ==================================== */
-static int32_t jang_match9(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 0   avec origine = 1 1 et (p ou q)
-  0 1 0
-  p 1 q
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[5] && !v[7]) goto fail;
-    if (v[0] || v[1] || v[2] || v[3] || v[4] || !v[6]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* jang_match9() */
-
-/* ==================================== */
-static int32_t jang_match13(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] || v[1] || v[2] || v[3] || v[4] || v[5] || v[6] || !v[7]) goto fail;
-    if (!v2[15] || !v2[14] || !v2[13]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* jang_match13() */
-
-/* ==================================== */
-static int32_t jang_match17(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || !v[1] || !v[2] || v[3] || !v[4] || !v[5] || !v[6] || !v[7]) goto fail;
-    if (!v2[0] || !v2[1] || !v2[3] || !v2[4] || !v2[8] || !v2[9] || 
-	!v2[11] || !v2[12] || !v2[13] || !v2[14] || !v2[15]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* jang_match17() */
-
-/* ==================================== */
-static int32_t jang_match21(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (v[0] || !v[1] || !v[2] || v[3] || !v[4] || v[6] || v[7]) return 0;
-  if (v2[4] || v2[5]) return 0;
-  return 1;
-} /* jang_match21() */
-
-/* ==================================== */
-static int32_t jang_match22(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (v[0] || v[1] || v[2] || !v[4] || v[5] || !v[6] || !v[7]) return 0;
-  if (v2[11] || v2[12]) return 0;
-  return 1;
-} /* jang_match22() */
-
-/* ==================================== */
-static int32_t jang_match23(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (v[0] || v[1] || v[2] || !v[3] || !v[4] || v[5] || !v[6]) return 0;
-  if (v2[9] || v2[8]) return 0;
-  return 1;
-} /* jang_match23() */
-
-/* ==================================== */
-static int32_t jang_match24(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (v[0] || !v[2] || v[3] || !v[4] || !v[5] || v[6] || v[7]) return 0;
-  if (v2[7] || v2[8]) return 0;
-  return 1;
-} /* jang_match24() */
-
-/* ==================================== */
-static int32_t jang_match25(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (!v[0] || v[2] || !v[4] || !v[5] || !v[6] || !v[7]) return 0;
-  if (v2[12]) return 0;
-  return 1;
-} /* jang_match25() */
-
-/* ==================================== */
-static int32_t jang_match26(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (!v[0] || !v[1] || !v[2] || v[4] || !v[6] || !v[7]) return 0;
-  if (v2[0]) return 0;
-  return 1;
-} /* jang_match26() */
-
-/* ==================================== */
-static int32_t jang_match27(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || v[1] || v[2] || v[3] || v[4] || v[5] || !v[6]) goto fail;
-    if (v2[0] || v2[1] || v2[11] || v2[12] || v2[13] || v2[14] || v2[15]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* jang_match27() */
-
-/* ==================================== */
-static int32_t jang_match27b(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || v[1] || v[2] || v[3] || v[4] || v[5] || !v[6] || v[7]) goto fail;
-    if (v2[0] || v2[1] || v2[11] || v2[12] || v2[13] || v2[15]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* jang_match27b() */
-
-/* ==================================== */
-static int32_t jang_match28b(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || v[1] || v[2] || v[3] || v[4] || v[5] || !v[6] || !v[7]) goto fail;
-    if (v2[0] || v2[1] || v2[11] || v2[12] || v2[13] || v2[14] || v2[15]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* jang_match28b() */
-
-/* ==================================== */
-int32_t lskeljang(struct xvimage *image, 
-	      int32_t nsteps,
-	      struct xvimage *inhibit)
-/* ==================================== */
-// described in Jang and Chin : "One-pass parallel thinning: analysis, properties and quantitative evaluation" 1992
-#undef F_NAME
-#define F_NAME "lskeljang"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if (F[i])
-      { 
-	m1 = jang_match1(F, i, rs, N);
-	m2 = jang_match5(F, i, rs, N);
-	m3 = jang_match9(F, i, rs, N);
-	m4 = jang_match13(F, i, rs, N);
-	m5 = jang_match17(F, i, rs, N);
-	m6 = jang_match21(F, i, rs, N);
-	m7 = jang_match22(F, i, rs, N);
-	m8 = jang_match23(F, i, rs, N);
-	m9 = jang_match24(F, i, rs, N);
-	m10 = jang_match25(F, i, rs, N);
-	m11 = jang_match26(F, i, rs, N);
-	m12 = jang_match27(F, i, rs, N);
-	if ((m1 || m2 || m3 || m4 || m5) && !m6 && !m7 && !m8 && !m9 && !m10 && !m11 && !m12)
-	{
-//#define DEBUG_JANG
-#ifdef DEBUG_JANG
-	  printf("i = %d,%d : %d %d %d    %d %d %d    %d %d %d    %d %d %d\n",
-		  i%rs, i/rs, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12);
-#endif
-	  T[i] = 1; // delete point
-
-	}
-      }
-
-    for (i = 0; i < N; i++) 
-      if (T[i]) { F[i] = 0; nonstab = 1; }
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskeljang() */
-
-/* ==================================== */
-int32_t lskeljangcor(struct xvimage *image, 
-		 int32_t nsteps,
-		 struct xvimage *inhibit)
-/* ==================================== */
-// described in Jang and Chin : "One-pass parallel thinning: analysis, properties and quantitative evaluation"
-// correction by Michel Couprie
-#undef F_NAME
-#define F_NAME "lskeljang"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if (F[i])
-      { 
-	m1 = jang_match1(F, i, rs, N);
-	m2 = jang_match5(F, i, rs, N);
-	m3 = jang_match9(F, i, rs, N);
-	m4 = jang_match13(F, i, rs, N);
-	m5 = jang_match17(F, i, rs, N);
-	m6 = jang_match21(F, i, rs, N);
-	m7 = jang_match22(F, i, rs, N);
-	m8 = jang_match23(F, i, rs, N);
-	m9 = jang_match24(F, i, rs, N);
-	m10 = jang_match25(F, i, rs, N);
-	m11 = jang_match26(F, i, rs, N);
-	m12 = jang_match27b(F, i, rs, N);
-	m13 = jang_match28b(F, i, rs, N);
-	if ((m1 || m2 || m3 || m4 || m5) && !m6 && !m7 && !m8 && !m9 && !m10 && !m11 && !m12 && !m13)
-	{
-#ifdef DEBUG_JANG
-	  printf("i = %d,%d : %d %d %d    %d %d %d    %d %d %d    %d %d %d %d\n",
-		  i%rs, i/rs, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13);
-#endif
-	  T[i] = 1; // delete point
-
-	}
-      }
-
-    for (i = 0; i < N; i++) 
-      if (T[i]) { F[i] = 0; nonstab = 1; }
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskeljangcor() */
-
-/* ==================================== */
-int32_t mns_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] != 2) goto fail;
-    if ((v[1] == 0) && (v[2] == 0) && (v[6] == 0) && (v[7] == 0)) return 1;
-    if ((v[1] == 0) && (v[2] == 0)) goto fail;
-    if ((v[6] == 0) && (v[7] == 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* mns_match1() */
-
-/* ==================================== */
-int32_t mns_match2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 2) || (v[1] != 2) || (v[2] != 2)) goto fail;
-    if ((v2[0] != 0) || (v2[1] != 0) || (v2[2] != 0) ||
-	(v2[3] != 0) || (v2[4] != 0) || (v2[5] != 0) || (v2[15] != 0) ||
-	(v[3] != 0) || (v[4] != 0) || (v[5] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mns_match2() */
-
-/* ==================================== */
-int32_t mns_match3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 0) || (v[1] != 2) || (v[2] != 2)) goto fail;
-    if ((v2[0] != 0) || (v2[1] != 0) || (v2[2] != 0) ||
-	(v2[3] != 0) || (v2[4] != 0) || (v2[5] != 0) ||
-	(v[3] != 0) || (v[4] != 0) || (v[5] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mns_match3() */
-
-/* ==================================== */
-int32_t mns_match4(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 2) || (v[1] != 2) || (v[2] != 0)) goto fail;
-    if ((v2[0] != 0) || (v2[1] != 0) || (v2[2] != 0) ||
-	(v2[3] != 0) || (v2[4] != 0) || (v2[15] != 0) ||
-	(v[3] != 0) || (v[4] != 0) || (v[5] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mns_match4() */
-
-/* ==================================== */
-int32_t mns_match5(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 2) || (v[1] != 0) || (v[2] != 2)) goto fail;
-    if ((v2[0] != 0) || (v2[1] != 0) || (v2[3] != 0) ||
-	(v2[4] != 0) || (v2[5] != 0) || (v2[15] != 0) ||
-	(v[3] != 0) || (v[4] != 0) || (v[5] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mns_match5() */
-
-/* ==================================== */
-int32_t mns_match6(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 0) || (v[1] != 2) || (v[2] != 0)) goto fail;
-    if ((v2[0] != 0) || (v2[1] != 0) || (v2[2] != 0) || (v2[3] != 0) || (v2[4] != 0) ||
-	(v[3] != 0) || (v[4] != 0) || (v[5] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mns_match6() */
-
-/* ==================================== */
-int32_t lskelmns(struct xvimage *image, 
-	     int32_t nsteps,
-	     struct xvimage *inhibit)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lskelmns"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3, m4, m5, m6;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if ((F[i] == 1) && simple8(F, i, rs, N))
-	F[i] = 2;
-    for (i = 0; i < N; i++) 
-      if (F[i] == 2)
-      { 
-	m1 = mns_match1(F, i, rs, N);
-	m2 = mns_match2(F, i, rs, N);
-	m3 = mns_match3(F, i, rs, N);
-	m4 = mns_match4(F, i, rs, N);
-	m5 = mns_match5(F, i, rs, N);
-	m6 = mns_match6(F, i, rs, N);
-	if (m1 || m2 || m3 || m4 || m5 || m6)
-	{
-#ifdef DEBUG_MNS
-	  printf("point %d,%d : m1 = %d; m2 = %d; m3 = %d; m4 = %d; m5 = %d; m6 = %d\n", 
-		 i % rs, i / rs, m1, m2, m3, m4, m5, m6);
-#endif
-	  T[i] = 1; // preserve point
-	}
-      }
-
-#ifdef DEBUG_MNS
-    printf("\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", F[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", T[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-
-    for (i = 0; i < N; i++) 
-      if ((F[i] == 2) && !T[i]) { F[i] = 0; nonstab = 1; }
-    for (i = 0; i < N; i++) if (F[i]) F[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelmns() */
-
-/* ==================================== */
-static int32_t jangrec_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 q   avec origine = 1 1 et (p ou q)
-  0 1 1
-  p 1 0
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[1] && !v[5]) goto fail;
-    if (!v[0] || v[2] || v[3] || v[4] || !v[6]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* jangrec_match1() */
-
-/* ==================================== */
-static int32_t jangrec_match5(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 x   avec origine = 1 1 et x = don't care
-  0 1 1
-  x 1 1
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || v[2] || v[3] || v[4] || !v[6] || !v[7]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* jangrec_match5() */
-
-/* ==================================== */
-static int32_t jangrec_match9(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  x 0 x   avec origine = 1 1 et x = don't care
-  1 1 1
-  1 1 1
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || v[2] || !v[4] || !v[5] || !v[6] || !v[7]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* jangrec_match9() */
-
-/* ==================================== */
-static int32_t jangrec_match13(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 0   avec origine = 1 1
-  0 1 0
-  1 1 1
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] || v[1] || v[2] || v[3] || v[4] || !v[5] || !v[6] || !v[7]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* jangrec_match13() */
-
-/* ==================================== */
-static int32_t jangrec_match17(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (!v[0] || v[2] || !v[4] || !v[5] || !v[6] || !v[7]) return 0;
-  if (v2[12]) return 0;
-  return 1;
-} /* jangrec_match17() */
-
-/* ==================================== */
-static int32_t jangrec_match18(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (!v[0] || !v[1] || !v[2] || v[4] || !v[6] || !v[7]) return 0;
-  if (v2[0]) return 0;
-  return 1;
-} /* jangrec_match18() */
-
-/* ==================================== */
-static int32_t jangrec_match19(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (v[0] || !v[1] || !v[2] || v[3] || !v[4] || v[6] || v[7]) return 0;
-  if (v2[4] || v2[5]) return 0;
-  return 1;
-} /* jangrec_match19() */
-
-/* ==================================== */
-static int32_t jangrec_match20(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (v[0] || v[1] || v[2] || !v[4] || v[5] || !v[6] || !v[7]) return 0;
-  if (v2[11] || v2[12]) return 0;
-  return 1;
-} /* jangrec_match20() */
-
-/* ==================================== */
-static int32_t jangrec_match21(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (v[0] || v[1] || v[2] || !v[3] || !v[4] || v[5] || !v[6]) return 0;
-  if (v2[9] || v2[8]) return 0;
-  return 1;
-} /* jangrec_match21() */
-
-/* ==================================== */
-static int32_t jangrec_match22(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (v[0] || !v[2] || v[3] || !v[4] || !v[5] || v[6] || v[7]) return 0;
-  if (v2[7] || v2[8]) return 0;
-  return 1;
-} /* jangrec_match22() */
-
-/* ==================================== */
-static int32_t jangrec_match23(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-   0 0 0 0   avec origine = 1 1
-   0 1 1 0
-   0 1 1 0
-   0 0 0 0
-*/
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (!v[0] || v[1] || v[2] || v[3] || v[4] || v[5] || !v[6] || !v[7]) return 0;
-  if (v2[0] || v2[1] || v2[11] || v2[12] || v2[13] || v2[14] || v2[15]) return 0;
-  return 1;
-} /* jangrec_match23() */
-
-/* ==================================== */
-int32_t lskeljangrec(struct xvimage *image, 
-	      int32_t nsteps,
-	      struct xvimage *inhibit)
-/* ==================================== */
-// described in Jang and Chin : "Reconstructable  parallel thinning"
-#undef F_NAME
-#define F_NAME "lskeljangrec"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *I;            /* l'image d'inhibition (axe médian) */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11;
-
-  if (inhibit == NULL)
-  {
-    fprintf(stderr, "%s: inhibit image (medial axis) must be present\n", F_NAME);
-    return 0;
-  }
-  I = UCHARDATA(inhibit);
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if (F[i])
-      { 
-	m1 = jangrec_match1(F, i, rs, N);
-	m2 = jangrec_match5(F, i, rs, N);
-	m3 = jangrec_match9(F, i, rs, N);
-	m4 = jangrec_match13(F, i, rs, N);
-	m5 = jangrec_match17(F, i, rs, N);
-	m6 = jangrec_match18(F, i, rs, N);
-	m7 = jangrec_match19(F, i, rs, N);
-	m8 = jangrec_match20(F, i, rs, N);
-	m9 = jangrec_match21(F, i, rs, N);
-	m10 = jangrec_match22(F, i, rs, N);
-	m11 = jangrec_match23(F, i, rs, N);
-	if ((m1 || m2 || m3 || m4) && !m5 && !m6 && !m7 && !m8 && !m9 && !m10 && !m11)
-	{
-//#define DEBUG_JANG
-#ifdef DEBUG_JANG
-	  printf("i = %d,%d : %d %d %d    %d %d %d    %d %d %d    %d %d\n",
-		  i%rs, i/rs, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11);
-#endif
-	  T[i] = 1; // delete point
-
-	}
-      }
-
-    for (i = 0; i < N; i++) 
-      if (T[i] && !I[i]) { F[i] = 0; nonstab = 1; }
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskeljangrec() */
-
-/* ==================================== */
-static int32_t choy_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 x   avec origine = 1 1 et x = don't care
-  0 1 1
-  x 1 x
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || v[2] || v[3] || v[4] || !v[6]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* choy_match1() */
-
-/* ==================================== */
-static int32_t choy_match5(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  x 0 x   avec origine = 1 1 et x = don't care
-  1 1 1
-  1 1 1
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || v[2] || !v[4] || !v[5] || !v[6] || !v[7]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* choy_match5() */
-
-/* ==================================== */
-static int32_t choy_match9(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 0   avec origine = 1 1 et (p ou q)
-  0 1 0
-  p 1 q
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[5] && !v[7]) goto fail;
-    if (v[0] || v[1] || v[2] || v[3] || v[4] || !v[6]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* choy_match9() */
-
-/* ==================================== */
-static int32_t choy_matchb1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  x 0 x
-  1 1 1
-  1 1 1
-    0
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  return v[0] && !v[2] && v[4] && v[5] && v[6] && v[7] && !v2[12];
-} /* choy_matchb1() */
-
-/* ==================================== */
-static int32_t choy_matchb2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  x 0 0
-  1 1 1
-  0 1 1
-    0
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  return v[0] && !v[1] && !v[2] && v[4] && !v[5] && v[6] && v[7] && !v2[12];
-} /* choy_matchb2() */
-
-/* ==================================== */
-static int32_t choy_matchb3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 x
-  0 1 1
-  1 1 0
-    0
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  return v[0] && !v[2] && !v[3] && !v[4] && v[5] && v[6] && !v[7] && !v2[12];
-} /* choy_matchb3() */
-
-/* ==================================== */
-static int32_t choy_matchb7(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  x 1 1
-  0 1 1 0
-  x 1 1
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  return v[0] && v[1] && v[2] && !v[4] && v[6] && v[7] && !v2[0];
-} /* choy_matchb7() */
-
-/* ==================================== */
-static int32_t choy_matchb8(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 1
-  0 1 1 0
-  x 1 0
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  return v[0] && v[1] && !v[2] && !v[3] && !v[4] && v[6] && !v[7] && !v2[0];
-} /* choy_matchb8() */
-
-/* ==================================== */
-static int32_t choy_matchb11(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-    1 0 0
-  0 1 1 0
-    0 1 x
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  return !v[0] && !v[1] && !v[2] && v[3] && v[4] && !v[5] && v[6] && !v2[8];
-} /* choy_match11() */
-
-/* ==================================== */
-static int32_t choy_matchb21(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 0
-  0 1 1 0
-  0 1 1
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  return v[0] && !v[1] && !v[2] && !v[3] && !v[4] && !v[5] && v[6] && v[7] && !v2[0];
-} /* choy_match21() */
-
-/* ==================================== */
-static int32_t choy_matchb22(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 0
-  0 1 1
-  0 1 1
-    0
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  return v[0] && !v[1] && !v[2] && !v[3] && !v[4] && !v[5] && v[6] && v[7] && !v2[12];
-} /* choy_match22() */
-
-/* ==================================== */
-static int32_t choy_matchb23(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 0
-  1 1 0
-  1 1 0
-    0
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  return !v[0] && !v[1] && !v[2] && !v[3] && v[4] && v[5] && v[6] && !v[7] && !v2[12];
-} /* choy_match23() */
-
-/* ==================================== */
-static int32_t choy_matchb24(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-    0 0 0
-  0 1 1 0
-    1 1 0
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  return !v[0] && !v[1] && !v[2] && !v[3] && v[4] && v[5] && v[6] && !v[7] && !v2[8];
-} /* choy_match24() */
-
-/* ==================================== */
-int32_t lskelchoy(struct xvimage *image, 
-	      int32_t nsteps,
-	      struct xvimage *inhibit)
-/* ==================================== */
-// described in Choy and Choy and Sui : ""
-#undef F_NAME
-#define F_NAME "lskelchoy"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if (F[i])
-      {
-	m1 = choy_match1(F, i, rs, N);
-	m2 = choy_match5(F, i, rs, N);
-	m3 = choy_match9(F, i, rs, N);
-	m4 = choy_matchb1(F, i, rs, N);
-	m5 = choy_matchb2(F, i, rs, N);
-	m6 = choy_matchb3(F, i, rs, N);
-	m7 = choy_matchb7(F, i, rs, N);
-	m8 = choy_matchb8(F, i, rs, N);
-	m9 = choy_matchb11(F, i, rs, N);
-	m10 = choy_matchb21(F, i, rs, N);
-	m11 = choy_matchb22(F, i, rs, N);
-	m12 = choy_matchb23(F, i, rs, N);
-	m13 = choy_matchb24(F, i, rs, N);
-	if ((m1 || m2 || m3) && !m4 && !m5 && !m6 && !m7 && !m8 && !m9 && !m10 && !m11 && !m12 && !m13)
-	  //if ((m1 || m2 || m3) && !m4 && !m5 && !m6 && !m7 && !m8 && !m9 && !m10 && !m11 && !m12 && !m13 &&
-	  //!jang_match27b(F, i, rs, N) && !jang_match27b(F, i, rs, N)) // correction mc
-	{
-//#define DEBUG_CHOY
-#ifdef DEBUG_CHOY
-	  printf("i = %d,%d : %d %d %d    %d %d %d    %d %d %d    %d %d %d    %d\n",
-		  i%rs, i/rs, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13);
-#endif
-	  T[i] = 1; // delete point
-
-	}
-      }
-
-    for (i = 0; i < N; i++) 
-      if (T[i]) { F[i] = 0; nonstab = 1; }
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelchoy() */
-
-/* ==================================== */
-int32_t mb_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  x x 1 x
-  0 P 1 1
-  x x 1 x
-*/
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || !v[1] || !v[7] || v[4]) goto fail;
-    if (!v2[0]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mb_match1() */
-
-/* ==================================== */
-int32_t mb_match2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 x x
-  0 P 1 x
-  x 1 1 1
-  x x 1 x
-*/
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] || v[2] || v[3] || v[4] || !v[6] || !v[7]) goto fail;
-    if (!v2[13] || !v2[15]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mb_match2() */
-
-/* ==================================== */
-int32_t mb_match3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  x x x
-  x P 0
-  x 0 1
-*/
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (!v[0] && !v[6] && v[7])  return 1;
-    rotate90_vois(v);
-  }
-  return 0;
-} /* mb_match3() */
-
-/* ==================================== */
-int32_t lskelmanz(struct xvimage *image, 
-	      int32_t nsteps,
-	      struct xvimage *inhibit,
-	      int32_t variante)
-/* ==================================== */
-// described in Manzanera and Bernard : "Improved low complexity fully parallel thinning algorithm"
-// variante = 
-//  1 : algo original
-//  2 : variante GB (seulement masques 1 et 3)
-#undef F_NAME
-#define F_NAME "lskelmanz"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if ((variante < 1) || (variante > 2))
-  {
-    fprintf(stderr, "%s: variante: must be 1 or 2\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if (F[i])
-      { 
-	m1 = mb_match1(F, i, rs, N);
-	if (variante == 1)	
-	  m2 = mb_match2(F, i, rs, N);
-	else
-	  m2 = 0;
-	m3 = mb_match3(F, i, rs, N);
-	if ((m1 || m2) && !m3)
-	{
-//#define DEBUG_MANZ
-#ifdef DEBUG_MANZ
-	  printf("i = %d,%d : %d %d %d\n",
-		  i%rs, i/rs, m1, m2, m3);
-#endif
-	  T[i] = 1; // delete point
-
-	}
-      }
-
-    for (i = 0; i < N; i++) 
-      if (T[i]) { F[i] = 0; nonstab = 1; }
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelmanz() */
-
-/* ==================================== */
-static int32_t hall_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  return ((v[0] == 2) && v[2] && v[6]);
-} /* hall_match1() */
-
-/* ==================================== */
-static int32_t hall_match2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  return ((v[6] == 2) && v[0] && v[4]);
-} /* hall_match2() */
-
-/* ==================================== */
-static int32_t hall_match3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  return ((v[6] == 2) && (v[7] == 2) && (v[0] == 2));
-} /* hall_match3() */
-
-/* ==================================== */
-int32_t lskelhall(struct xvimage *image, 
-	      int32_t nsteps,
-	      struct xvimage *inhibit,
-	      int32_t variante)
-/* ==================================== */
-// described in Hall : "Fast parallel thinning algorithms: parallel speed and connectivity preservation"
-// variante 1 : Holt et al.
-// variante 2 : variante Hall pour "mieux" préserver les diagonales (?)
-#undef F_NAME
-#define F_NAME "lskelhall"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-#ifdef VERBOSE
-  printf("nstep=%d, variante=%d\n", nsteps, variante);
-#endif
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-
-    switch (variante)
-    {
-    case 1:
-      for (i = 0; i < N; i++) 
-	if (F[i] && (nbvois8(F, i, rs, N) > 1)  && (nbvois8(F, i, rs, N) < 7) 
-	    && (crossing_nb(F, i, rs, N) == 1))
-	  F[i] = 2;
-      for (i = 0; i < N; i++) 
-	if ((F[i] == 2) && !hall_match1(F, i, rs, N) && !hall_match2(F, i, rs, N) && !hall_match3(F, i, rs, N))
-	{
-	  nonstab = 1;
-	  T[i] = 1;
-	}
-      for (i = 0; i < N; i++) 
-	if (T[i] == 1) F[i] = 0; 
-	else if (F[i]) F[i] = 1;
-      break;
-    case 2:
-      for (i = 0; i < N; i++) 
-	if (F[i] && (nbvois8(F, i, rs, N) > 2)  && (nbvois8(F, i, rs, N) < 7) 
-	    && (crossing_nb(F, i, rs, N) == 1))
-	  F[i] = 2;
-      for (i = 0; i < N; i++) 
-	if ((F[i] == 2) && !hall_match1(F, i, rs, N) && !hall_match2(F, i, rs, N) && !hall_match3(F, i, rs, N))
-	{
-	  nonstab = 1;
-	  T[i] = 1;
-	}
-
-//#define DEBUG_HALL2
-#ifdef DEBUG_HALL2
-    printf("\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", F[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", T[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-
-      for (i = 0; i < N; i++) 
-	if (T[i] == 1) F[i] = 0; 
-	else if (F[i]) F[i] = 1;
-      break;
-    default: 
-      fprintf(stderr, "%s: variant not implemented\n", F_NAME);
-      return 0;
-    } // switch (variante)
-
-  } // while (nonstab && (step < nsteps))
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelhall() */
-
-/* ==================================== */
-static int32_t wutsai_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  1 1 p   avec origine = 1 1 et (!p ou !q)
-  1 1 0
-  1 1 q
- */
-{
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  if (v[1] && v[7]) return 0;
-  if (v[0] || !v[2] || !v[3] || !v[4] || !v[5] || !v[6]) return 0;
-  return 1;
-} /* wutsai_match1() */
-
-/* ==================================== */
-static int32_t wutsai_match2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  1 1 1   avec origine = 1 1 et (!p ou !q)
-  1 1 1
-  p 0 q
- */
-{
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  if (v[5] && v[7]) return 0;
-  if (v[6] || !v[0] || !v[1] || !v[2] || !v[3] || !v[4]) return 0;
-  return 1;
-} /* wutsai_match2() */
-
-/* ==================================== */
-static int32_t wutsai_match3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  p 1 1     avec origine = 1 1 et (!p ou !q)
-  0 1 1 1
-  q 1 1
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (v[3] && v[5]) return 0;
-  if (v[4] || !v[0] || !v[1] || !v[2] || !v[6] || !v[7]) return 0;
-  if (!v2[0]) return 0;
-  return 1;
-} /* wutsai_match3() */
-
-/* ==================================== */
-static int32_t wutsai_match4(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  p 0 q     avec origine = 1 1 et (!p ou !q)
-  1 1 1
-  1 1 1
-    1
- */
-{
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  if (v[1] && v[3]) return 0;
-  if (v[2] || !v[0] || !v[4] || !v[5] || !v[6] || !v[7]) return 0;
-  if (!v2[12]) return 0;
-  return 1;
-} /* wutsai_match4() */
-
-/* ==================================== */
-static int32_t wutsai_match5(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  x 0 0   avec origine = 1 1 et x = don't care
-  1 1 0
-  x 1 x
- */
-{
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  return (!v[0] && !v[1] && !v[2] && v[4] && v[6]);
-} /* wutsai_match5() */
-
-/* ==================================== */
-static int32_t wutsai_match6(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  x 1 1   avec origine = 1 1 et x = don't care
-  0 1 1
-  0 0 x
- */
-{
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  return (v[0] && v[1] && v[2] && !v[4] && !v[5] && !v[6]);
-} /* wutsai_match6() */
-
-/* ==================================== */
-static int32_t wutsai_match7(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 1 0   avec origine = 1 1
-  0 1 1
-  0 0 0
- */
-{
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  return (v[0] && !v[1] && v[2] && !v[3] && !v[4] && !v[5] && !v[6] && !v[7]);
-} /* wutsai_match7() */
-
-/* ==================================== */
-static int32_t wutsai_match8(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  x 1 x   avec origine = 1 1 et x = don't care
-  1 1 0
-  x 0 0
- */
-{
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  return (!v[0] && v[2] && v[4] && !v[6] && !v[7]);
-} /* wutsai_match8() */
-
-/* ==================================== */
-static int32_t wutsai_match9(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 x   avec origine = 1 1 et x = don't care
-  0 1 1
-  x 1 1
- */
-{
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  return (v[0] && !v[2] && !v[3] && !v[4] && v[6] && v[7]);
-} /* wutsai_match9() */
-
-/* ==================================== */
-static int32_t wutsai_match10(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 0   avec origine = 1 1
-  0 1 1
-  0 1 0
- */
-{
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  return (v[0] && !v[1] && !v[2] && !v[3] && !v[4] && !v[5] && v[6] && !v[7]);
-} /* wutsai_match10() */
-
-/* ==================================== */
-static int32_t wutsai_match11(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-  0 0 0   avec origine = 1 1 
-  0 1 0
-  1 1 1
- */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] || v[1] || v[2] || v[3] || v[4] || !v[5] || !v[6] || !v[7]) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* wutsai_match11() */
-
-/* ==================================== */
-int32_t lskelwutsai(struct xvimage *image, 
-	      int32_t nsteps,
-	      struct xvimage *inhibit)
-/* ==================================== */
-// described in Wutsai and Wutsai and Sui : "A new one-pass parallel thinning algorithm for binary images"
-#undef F_NAME
-#define F_NAME "lskelwutsai"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if (F[i])
-      {
-	m1 = wutsai_match1(F, i, rs, N);
-	m2 = wutsai_match2(F, i, rs, N);
-	m3 = wutsai_match3(F, i, rs, N);
-	m4 = wutsai_match4(F, i, rs, N);
-	m5 = wutsai_match5(F, i, rs, N);
-	m6 = wutsai_match6(F, i, rs, N);
-	m7 = wutsai_match7(F, i, rs, N);
-	m8 = wutsai_match8(F, i, rs, N);
-	m9 = wutsai_match9(F, i, rs, N);
-	m10 = wutsai_match10(F, i, rs, N);
-	m11 = wutsai_match11(F, i, rs, N);
-	if (m1 || m2 || m3 || m4 || m5 || m6 || m7 || m8 || m9 || m10 || m11)
-	  //if ((m1 || m2 || m3 || m4 || m5 || m6 || m7 || m8 || m9 || m10 || m11) && !jangrec_match23(F, i, rs, N)) // cor. MC
-	{
-	  //#define DEBUG_WUTSAI
-#ifdef DEBUG_WUTSAI
-	  printf("i = %d,%d : %d %d %d    %d %d %d    %d %d %d    %d %d\n",
-		  i%rs, i/rs, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11);
-#endif
-	  T[i] = 1; // delete point
-	  writeimage(image, "_image");
-	}
-      }
-
-    for (i = 0; i < N; i++) 
-      if (T[i]) { F[i] = 0; nonstab = 1; }
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelwutsai() */
-
-/* ==================================== */
-int32_t mc_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-//      m1 : match   A 2 B   avec origine = 1 0 et [au moins un des A et au moins un des B non nuls]
-//                   A 2 B   ou [A et B tous nuls] (+ rotation 90)
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] != 2) goto fail;
-    if ((v[1] == 0) && (v[2] == 0) && (v[6] == 0) && (v[7] == 0)) return 1;
-    if ((v[1] == 0) && (v[2] == 0)) goto fail;
-    if ((v[6] == 0) && (v[7] == 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* mc_match1() */
-
-/* ==================================== */
-int32_t mc_match2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 2) || (v[1] != 2) || (v[2] != 2)) goto fail;
-    if ((v2[0] != 0) || (v2[1] != 0) || (v2[3] != 0) || (v2[4] != 0) ||
-	(v[3] != 0) || (v[4] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mc_match2() */
-
-/* ==================================== */
-int32_t mc_match3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 0) || (v[1] != 2) || (v[2] != 2)) goto fail;
-    if ((v2[0] != 0) || (v2[3] != 0) || (v2[4] != 0) ||
-	(v[3] != 0) || (v[4] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mc_match3() */
-
-/* ==================================== */
-int32_t mc_match4(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 2) || (v[1] != 2) || (v[2] != 0)) goto fail;
-    if ((v2[0] != 0) || (v2[1] != 0) || (v2[4] != 0) ||
-	(v[3] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mc_match4() */
-
-/* ==================================== */
-int32_t mc_match5(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 2) || (v[1] != 0) || (v[2] != 2)) goto fail;
-    if ((v2[1] != 0) || (v2[3] != 0) ||
-	(v[3] != 0) || (v[4] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mc_match5() */
-
-/* ==================================== */
-int32_t mc_match3b(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 0) || (v[1] != 2) || (v[2] != 2)) goto fail;
-    if ((v2[3] != 0) || (v2[4] != 0) ||
-	(v[3] != 0) || (v[4] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mc_match3b() */
-
-/* ==================================== */
-int32_t mc_match4b(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8], v2[16];
-  extract_vois(F, x, rs, N, v);
-  if (!extract_vois2(F, x, rs, N, v2)) return 0;
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 2) || (v[1] != 2) || (v[2] != 0)) goto fail;
-    if ((v2[0] != 0) || (v2[1] != 0) ||
-	(v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-    rotate90_vois2(v2);
-  }
-  return 0;
-} /* mc_match4b() */
-
-/* ==================================== */
-int32_t mc_match5b(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] != 2) || (v[1] != 0) || (v[2] != 2)) goto fail;
-    if ((v[3] != 0) || (v[4] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-//printf("mc_match5b : %d %d fail\n", x % rs, x / rs);
-//print_vois(v);
-  return 0;
-} /* mc_match5b() */
-
-/* ==================================== */
-int32_t mc_match6(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[3] != 2) || (v[2] != 0) || (v[4] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* mc_match6() */
-
-/* ==================================== */
-int32_t mc_end(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 8; i++)
-  {
-    if (v[0] == 0) goto fail;
-    if ((v[2] != 0) || (v[3] != 0) || (v[4] != 0) || (v[5] != 0) || (v[6] != 0)) goto fail;
-    return 1;
-  fail:
-    rotate45_vois(v);
-  }
-  return 0;
-} /* mc_end() */
-
-/* ==================================== */
-int32_t mc_maskend1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] == 0) goto fail;
-    if ((v[1] != 0) || (v[2] != 0) || (v[3] != 0) || (v[4] != 0) || (v[5] != 0) || 
-	(v[6] != 0) || (v[7] != 0)) goto fail;
-//printf("mc_maskend1 : %d %d end\n", x % rs, x / rs);
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* mc_maskend1() */
-
-/* ==================================== */
-int32_t mc_maskend2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (v[1] == 0) goto fail;
-    if ((v[3] != 0) || (v[4] != 0) || (v[5] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-//printf("mc_maskend2 : i = %d ; %d %d end\n", i, x % rs, x / rs);
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* mc_maskend2() */
-
-/* ==================================== */
-int32_t mc_maskend3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if ((v[0] == 0) || (v[2] == 0)) goto fail;
-    if ((v[3] != 0) || (v[4] != 0) || (v[5] != 0) || (v[6] != 0) || (v[7] != 0)) goto fail;
-//printf("mc_maskend3 : %d %d end\n", x % rs, x / rs);
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* mc_maskend3() */
-
-/* ==================================== */
-int32_t mc_end2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-{
-  return mc_maskend1(F, x, rs, N) || mc_maskend2(F, x, rs, N) || mc_maskend3(F, x, rs, N);
-} /* mc_end2() */
-
-/* ==================================== */
-int32_t lskelmcultime(struct xvimage *image, 
-		  int32_t nsteps,
-		  struct xvimage *inhibit)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lskelmcultime"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3, m4, m5, m6;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if ((F[i] == 1) && simple8(F, i, rs, N))
-	F[i] = 2;
-    for (i = 0; i < N; i++) 
-      if (F[i] == 2)
-      { 
-	m1 = mc_match1(F, i, rs, N);
-	m2 = mc_match2(F, i, rs, N);
-	m3 = mc_match3b(F, i, rs, N);
-	m4 = mc_match4b(F, i, rs, N);
-	m5 = mc_match5b(F, i, rs, N);
-	m6 = mc_match6(F, i, rs, N);
-	if (m1 || m2 || m3 || m4 || m5 || m6)
-	{
-#ifdef DEBUG_MC
-	  printf("point %d,%d : m1 = %d; m2 = %d; m3 = %d; m4 = %d; m5 = %d; m6 = %d\n", 
-		 i % rs, i / rs, m1, m2, m3, m4, m5, m6);
-#endif
-	  T[i] = 1; // preserve point
-	}
-      }
-
-#ifdef DEBUG_MC
-    printf("\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", F[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", T[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-
-    for (i = 0; i < N; i++) 
-      if ((F[i] == 2) && !T[i]) { F[i] = 0; nonstab = 1; }
-    for (i = 0; i < N; i++) if (F[i]) F[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelmcultime() */
-
-/* ==================================== */
-int32_t lskelmccurv(struct xvimage *image, 
-		  int32_t nsteps,
-		  struct xvimage *inhibit)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lskelmccurv"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3, m4, m5, m6;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if ((F[i] == 1) && simple8(F, i, rs, N)  && !mc_end2(F, i, rs, N))
-	F[i] = 2;
-    for (i = 0; i < N; i++) 
-      if (F[i] == 2)
-      { 
-	m1 = mc_match1(F, i, rs, N);
-	m2 = mc_match2(F, i, rs, N);
-	m3 = mc_match3b(F, i, rs, N);
-	m4 = mc_match4b(F, i, rs, N);
-	m5 = mc_match5b(F, i, rs, N);
-	m6 = mc_match6(F, i, rs, N);
-	if (m1 || m2 || m3 || m4 || m5 || m6)
-	{
-#ifdef DEBUG_MC1
-	  printf("point %d,%d : m1 = %d; m2 = %d; m3 = %d; m4 = %d; m5 = %d; m6 = %d\n", 
-		 i % rs, i / rs, m1, m2, m3, m4, m5, m6);
-#endif
-	  T[i] = 1; // preserve point
-	}
-      }
-
-#ifdef DEBUG_MC
-    printf("\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", F[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", T[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-
-    for (i = 0; i < N; i++) 
-      if ((F[i] == 2) && !T[i]) { F[i] = 0; nonstab = 1; }
-    for (i = 0; i < N; i++) if (F[i]) F[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-  freeimage(tmp);
-  return(1);
-} /* lskelmccurv() */
-
-/* ==================================== */
-int32_t lskelmccurvrec(struct xvimage *image, 
-		  int32_t nsteps,
-		  struct xvimage *inhibit)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lskelmccurvrec"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *X = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  uint8_t *M = (uint8_t *)malloc(N);
-  uint8_t *E = (uint8_t *)malloc(N);
-  uint8_t *R = (uint8_t *)malloc(N);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3, m4, m5, m6;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (X[i]) X[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  memset(M, 0, N);
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(E, 0, N);
-    for (i = 0; i < N; i++) 
-      if (T[i] && (nbvois4(T, i, rs, N) == 4)) E[i] = 1; // calcule E = eros (T)
-    memset(R, 0, N);
-    for (i = 0; i < N; i++) 
-      if (nbvois4(E, i, rs, N) >= 1) R[i] = 1;           // calcule D = Dilat(E)
-    for (i = 0; i < N; i++) 
-      if (T[i] && !R[i]) R[i] = 1; else R[i] = 0;        // calcule D = T \ Dilat(E)
-    for (i = 0; i < N; i++) T[i] = E[i];                 // T = E
-    for (i = 0; i < N; i++) if (R[i]) M[i] = 1;          // M  = M union D
-
-//#define DEBUG_MC
-
-#ifdef DEBUG_MC
-    printf("D, T\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", R[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", T[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-
-    for (i = 0; i < N; i++) 
-      if ((X[i] == 1) && simple8(X, i, rs, N) && !M[i])
-	X[i] = 2;
-
-#ifdef DEBUG_MC
-    printf("M, X\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", M[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", X[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-    
-    memset(R, 0, N);
-    for (i = 0; i < N; i++)
-      if (X[i] == 2)
-      { 
-	m1 = mc_match1(X, i, rs, N);
-	m2 = mc_match2(X, i, rs, N);
-	m3 = mc_match3b(X, i, rs, N);
-	m4 = mc_match4b(X, i, rs, N);
-	m5 = mc_match5b(X, i, rs, N);
-	m6 = mc_match6(X, i, rs, N);
-	if (m1 || m2 || m3 || m4 || m5 || m6)
-	{
-#ifdef DEBUG_MC
-	  printf("point %d,%d : m1 = %d; m2 = %d; m3 = %d; m4 = %d; m5 = %d\n", 
-		 i % rs, i / rs, m1, m2, m3, m4, m5);
-#endif
-	  R[i] = 1; // preserve point
-	}
-      }
-
-#ifdef DEBUG_MC
-    printf("X, R\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", X[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", R[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-
-    for (i = 0; i < N; i++) 
-      if ((X[i] == 2) && !R[i] && !M[i]) { X[i] = 0; nonstab = 1; }
-    for (i = 0; i < N; i++) if (X[i]) X[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (X[i]) X[i] = 255; // normalize values
-
-  freeimage(tmp);
-  free(M);
-  free(E);
-  free(R);
-  return(1);
-} /* lskelmccurvrec() */
-
-/* ==================================== */
-int32_t lskelmccurvrecold(struct xvimage *image, 
-		  int32_t nsteps,
-		  struct xvimage *inhibit)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "lskelmccurvrec"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *X = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  uint8_t *Y = (uint8_t *)malloc(N);
-  uint8_t *I = (uint8_t *)malloc(N);
-  uint8_t *D = (uint8_t *)malloc(N);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3, m4, m5, m6;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (X[i]) X[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  memset(Y, 0, N);
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-    memset(I, 0, N);
-    memset(D, 0, N);
-    for (i = 0; i < N; i++) if (X[i] && !Y[i]) T[i] = 1; // calcule T = X \ Y
-    for (i = 0; i < N; i++) 
-      if (T[i] && (nbvois4(T, i, rs, N) == 4))
-	I[i] = 1; // calcule I = interior (X \ Y)
-    for (i = 0; i < N; i++) 
-//      if (T[i] && (nbvois4(I, i, rs, N) >= 1)) // test T 
-      if (nbvois4(I, i, rs, N) >= 1)
-	D[i] = 1; // calcule D = Dilat(I) Inter [X \ Y]
-
-//#define DEBUG_MC
-
-#ifdef DEBUG_MC
-    printf("I, D\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", I[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", D[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) 
-      if (Y[i] || (X[i] && !D[i]))
-	T[i] = 1; // calcule E = Y Union [X \ D]
-    for (i = 0; i < N; i++) 
-      if ((X[i] == 1) && simple8(X, i, rs, N) && !T[i])
-	X[i] = 2;
-
-#ifdef DEBUG_MC
-    printf("E, X\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", T[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", X[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-    
-    memset(T, 0, N);
-    for (i = 0; i < N; i++)
-      if (X[i] == 2)
-      { 
-	m1 = mc_match1(X, i, rs, N);
-	m2 = mc_match2(X, i, rs, N);
-	m3 = mc_match3b(X, i, rs, N);
-	m4 = mc_match4b(X, i, rs, N);
-	m5 = mc_match5b(X, i, rs, N);
-	m6 = mc_match6(X, i, rs, N);
-	if (m1 || m2 || m3 || m4 || m5 || m6)
-	{
-#ifdef DEBUG_MC
-	  printf("point %d,%d : m1 = %d; m2 = %d; m3 = %d; m4 = %d; m5 = %d\n", 
-		 i % rs, i / rs, m1, m2, m3, m4, m5);
-#endif
-	  T[i] = 1; // preserve point
-	}
-      }
-
-#ifdef DEBUG_MC
-    printf("X, T\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", X[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", T[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-
-    for (i = 0; i < N; i++) 
-      if ((X[i] == 2) && !T[i]) { X[i] = 0; nonstab = 1; }
-    for (i = 0; i < N; i++) if (X[i]) X[i] = 1;
-    for (i = 0; i < N; i++) if (X[i] && !I[i]) Y[i] = 1;
-
-#ifdef DEBUG_MC
-    printf("X, Y\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", X[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", Y[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (X[i]) X[i] = 255; // normalize values
-
-  freeimage(tmp);
-  free(Y);
-  free(I);
-  free(D);
-  return(1);
-} /* lskelmccurvrecold() */
-
-/* ==================================== */
-int32_t bertrand_match1(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-A     A
-2*    2
-B     B
-*/
-{
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  if (v[0] != 2) return 0;
-  if ((v[1] == 0) && (v[2] == 0)) return 0;
-  if ((v[6] == 0) && (v[7] == 0)) return 0;
-  return 1;
-} /* bertrand_match1() */
-
-/* ==================================== */
-int32_t bertrand_match2(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-/*
-A   2   B
-A   2*  B
-*/
-{
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  if (v[2] != 2) return 0;
-  if ((v[0] == 0) && (v[1] == 0)) return 0;
-  if ((v[3] == 0) && (v[4] == 0)) return 0;
-  return 1;
-} /* bertrand_match1() */
-
-/* ==================================== */
-int32_t lskelbertrand_asym(struct xvimage *image, 
-	      int32_t nsteps,
-	      struct xvimage *inhibit)
-/* ==================================== */
-// described in [G. Bertrand - personnal communication - 04/08/2005]
-// algo NK^2
-#undef F_NAME
-#define F_NAME "lskelbertrand_asym"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  uint8_t *I;            /* l'image d'inhibition (axe médian) */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  int32_t step, nonstab;
-  int32_t m1, m2;
-#ifdef ETUDE
-  struct xvimage *tmp2 = copyimage(image); 
-  uint8_t *T2 = UCHARDATA(tmp2);
-  memset(T2, 0, N);
-#endif
-#ifdef ANIMATE
-  int32_t nimage = 1; 
-  char imname[128];
-#endif
-
-  if (inhibit == NULL)
-  {
-    fprintf(stderr, "%s: inhibit image (medial axis) must be present\n", F_NAME);
-    return 0;
-  }
-  I = UCHARDATA(inhibit);
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-    memset(T, 0, N);
-
-    for (i = 0; i < N; i++) 
-      if ((F[i] == 1) && simple8(F, i, rs, N)  && !I[i])
-	F[i] = 2;
-    for (i = 0; i < N; i++) 
-      if (F[i] == 2)
-      { 
-	m1 = bertrand_match1(F, i, rs, N);
-	m2 = bertrand_match2(F, i, rs, N);
-	if (m1 || m2)
-	{
-#ifdef DEBUG_BERTRAND
-	  printf("point %d,%d : m1 = %d; m2 = %d\n", 
-		 i % rs, i / rs, m1, m2);
-#endif
-	  T[i] = 1; // preserve point
-	}
-      }
-
-#ifdef DEBUG_BERTRAND
-    printf("\n");
-    for (j = 0; j < cs; j++)
-    {
-      for (i = 0; i < rs; i++) printf("%d ", F[j*rs + i]);
-      printf("      ");
-      for (i = 0; i < rs; i++) printf("%d ", T[j*rs + i]);
-      printf("\n");
-    }
-    printf("\n");
-#endif
-
-    for (i = 0; i < N; i++) 
-      if ((F[i] == 2) && !T[i]) 
-      { 
-	F[i] = 0; 
-	nonstab = 1; 
-#ifdef ETUDE
-        T2[i] = step;
-#endif
-      }
-    for (i = 0; i < N; i++) if (F[i]) F[i] = 1;
-
-#ifdef ANIMATE
-  sprintf(imname, "anim%03d.pgm", nimage); nimage++;
-  writeimage(image, imname);
-#endif
-
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-#ifdef ETUDE
-  writeimage(tmp2,"_etude");
-#endif
-
-  freeimage(tmp);
-  return(1);
-} /* lskelbertrand_asym() */
-
-/* ==================================== */
-int32_t bertrand_match3(uint8_t *F, int32_t x, int32_t rs, int32_t N)
-/* ==================================== */
-// A 2 B   avec origine = 1 0 et au moins un des A et au moins un des B non nuls
-// A 2 B   (+ rotation 90)
-{
-  int32_t i;
-  uint8_t v[8];
-  extract_vois(F, x, rs, N, v);
-  for (i = 0; i < 4; i++)
-  {
-    if (v[0] != 2) goto fail;
-    if ((v[1] == 0) && (v[2] == 0)) goto fail;
-    if ((v[6] == 0) && (v[7] == 0)) goto fail;
-    return 1;
-  fail:
-    rotate90_vois(v);
-  }
-  return 0;
-} /* bertrand_match3() */
-
-/* ==================================== */
-int32_t lskelbertrand_sym(struct xvimage *image, 
-	      int32_t nsteps,
-	      struct xvimage *inhibit)
-/* ==================================== */
-/*
-Algo CPSR1 données: S
-T := S
-Répéter jusqu'à stabilité
-     T := T \ominus \Gamma_4
-     P := pixels simples pour S et 4-voisins d'un point de T  
-     R := pixels de P qui s'apparient avec C2
-     S :=  [S  \  P]  \cup  R
-*/
-#undef F_NAME
-#define F_NAME "lskelbertrand_sym"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *F = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  uint8_t *T = UCHARDATA(t);
-  struct xvimage *r = copyimage(image); 
-  uint8_t *R = UCHARDATA(r);
-  int32_t step, nonstab;
-  int32_t m1;
-#ifdef ETUDE
-  struct xvimage *tmp2 = copyimage(image); 
-  uint8_t *T2 = UCHARDATA(tmp2);
-  memset(T2, 0, N);
-#endif
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    memset(R, 0, N);
-    for (i = 0; i < N; i++) 
-      if (T[i] && (nbvois4(T, i, rs, N) == 4)) R[i] = 1; // calcule R = eros (T)
-    for (i = 0; i < N; i++) T[i] = R[i];                 // T = eros (T)
-    for (i = 0; i < N; i++) 
-      if ((F[i] == 1) && simple8(F, i, rs, N)  && (nbvois4(T, i, rs, N) > 0))
-	F[i] = 2; //  pixels simples pour F et 4-voisins d'un point de T  
-    memset(R, 0, N);
-    for (i = 0; i < N; i++) 
-      if (F[i] == 2)
-      { 
-	m1 = bertrand_match3(F, i, rs, N);
-	if (m1)
-	{
-	  R[i] = 1; // preserve point
-	}
-      }
-
-    for (i = 0; i < N; i++) 
-      if ((F[i] == 2) && !R[i]) 
-      { 
-	F[i] = 0; 
-	nonstab = 1; 
-#ifdef ETUDE
-        T2[i] = step;
-#endif
-      }
-    for (i = 0; i < N; i++) if (F[i]) F[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (F[i]) F[i] = 255; // normalize values
-
-#ifdef ETUDE
-  writeimage(tmp2,"_etude");
-#endif
-
-  freeimage(t);
-  freeimage(r);
-  return(1);
-} /* lskelbertrand_sym() */
-
-/* ==================================== */
-int32_t lskelbertrand_asym_s(struct xvimage *image, 
-			int32_t nsteps,
-			struct xvimage *inhibit)
-/* ==================================== */
-// described in [G. Bertrand - personnal communication - 26/10/2005]
-// variante algo NK^2 (comme BK^2)
-#undef F_NAME
-#define F_NAME "lskelbertrand_asym_s"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *X = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *tmp = copyimage(image); 
-  uint8_t *T = UCHARDATA(tmp);
-  uint8_t *M = (uint8_t *)malloc(N);
-  uint8_t *E = (uint8_t *)malloc(N);
-  uint8_t *R = (uint8_t *)malloc(N);
-  int32_t step, nonstab;
-  int32_t m1, m2, m3, m4, m5, m6;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image: not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (X[i]) X[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    memset(E, 0, N);   // T = eros (T)
-    for (i = 0; i < N; i++) 
-      if (T[i] && (nbvois4(T, i, rs, N) == 4)) E[i] = 1;
-    memcpy(T, E, N);
-
-    memset(M, 0, N);
-    for (i = 0; i < N; i++) 
-      if (nbvois4(T, i, rs, N) >= 1) M[i] = 1;           // calcule M = Dilat(T)
-    for (i = 0; i < N; i++) 
-      if ((X[i] == 1) && simple8(X, i, rs, N) && M[i])
-	X[i] = 2;
-    
-    memset(R, 0, N);
-    for (i = 0; i < N; i++) 
-      if (X[i] == 2)
-      { 
-	m1 = bertrand_match1(X, i, rs, N);
-	m2 = bertrand_match2(X, i, rs, N);
-	if (m1 || m2)
-	{
-	  R[i] = 1; // preserve point
-	}
-      }
-
-    for (i = 0; i < N; i++) 
-      if ((X[i] == 2) && !R[i]) { X[i] = 0; nonstab = 1; }
-    for (i = 0; i < N; i++) if (X[i]) X[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (X[i]) X[i] = 255; // normalize values
-
-writeimage(tmp, "_T");
-
-  freeimage(tmp);
-  free(M);
-  free(E);
-  free(R);
-  return(1);
-} /* lskelbertrand_asym_s() */
-
-/* ==================================== */
-int32_t lskelMK2(struct xvimage *image, 
-	     int32_t nsteps,
-	     struct xvimage *inhibit)
-/* ==================================== */
-/*
-Algo MK2 données: S
-Répéter jusqu'à stabilité
-  P := pixels simples pour S
-  R := pixels de P qui s'apparient avec le masque C (bertrand_match3)
-  T :=  [S  \  P]  \cup  R
-  S := T \cup [S \ (T \oplus \Gamma_8*)]
-*/
-#undef F_NAME
-#define F_NAME "lskelMK2"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  uint8_t *T = UCHARDATA(t);
-  struct xvimage *r = copyimage(image); 
-  uint8_t *R = UCHARDATA(r);
-  int32_t step, nonstab;
-  int32_t m1;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    for (i = 0; i < N; i++) 
-      if ((S[i] == 1) && simple8(S, i, rs, N))
-	S[i] = 2; //  pixels simples pour S
-    memset(R, 0, N);
-    for (i = 0; i < N; i++) 
-      if (S[i] == 2)
-      { 
-	m1 = bertrand_match3(S, i, rs, N);
-	if (m1) R[i] = 1; // preserve point
-      }
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) // T := [S \ P] \cup  R
-      if ((S[i] == 1) || R[i])
-	T[i] = 1;
-    memset(R, 0, N);
-    for (i = 0; i < N; i++)
-      if (nbvois8(T, i, rs, N) >= 1) R[i] = 1; // calcule R = Dilat(T)
-    for (i = 0; i < N; i++)
-      if (T[i] || (S[i] && !R[i])) T[i] = 1; else T[i] = 0; // T := T \cup [S \ R]
-
-    for (i = 0; i < N; i++)
-      if (S[i] && !T[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 255; // normalize values
-
-  freeimage(t);
-  freeimage(r);
-  return(1);
-} /* lskelMK2() */
-
-/* ==================================== */
-int32_t lskelAK2(struct xvimage *image, 
-	     int32_t nsteps,
-	     struct xvimage *inhibit)
-/* ==================================== */
-/*
-Amincissement symétrique avec inclusion de l'axe médian
-Algo AK2 données: S
-K := \emptyset ; T := S
-Répéter jusqu'à stabilité
-  E := T \ominus \Gamma_4 
-  D := T \ [E \oplus \Gamma_4]
-  T := E
-  K := K \cup D
-  P := pixels de S \ K simples pour S
-  R := pixels de P qui s'apparient avec le masque C (bertrand_match3)
-  S := [S  \  P]  \cup  R
-*/
-#undef F_NAME
-#define F_NAME "lskelAK2"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t N = rs * cs;             /* taille image */
-  uint8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  uint8_t *T = UCHARDATA(t);
-  struct xvimage *r = copyimage(image); 
-  uint8_t *R = UCHARDATA(r);
-  struct xvimage *e = copyimage(image); 
-  uint8_t *E = UCHARDATA(e);
-  struct xvimage *d = copyimage(image); 
-  uint8_t *D = UCHARDATA(d);
-  struct xvimage *k = copyimage(image); 
-  uint8_t *K = UCHARDATA(k);
-
-  int32_t step, nonstab;
-  int32_t m1;
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 1; // normalize values
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  // K := \emptyset ; T := S
-  memset(K, 0, N);
-  memcpy(T, S, N);
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    //  E := T \ominus \Gamma_4 
-    memset(E, 0, N);
-    for (i = 0; i < N; i++) 
-      if (T[i] && (nbvois4(T, i, rs, N) == 4)) E[i] = 1;
-
-    //  D := E \oplus \Gamma_4
-    memset(D, 0, N);
-    for (i = 0; i < N; i++)
-      if (E[i] || nbvois4(E, i, rs, N) >= 1) D[i] = 1;
-
-    //  D := T \ D
-    for (i = 0; i < N; i++)
-      if (T[i] && !D[i]) D[i] = 1; else D[i] = 0;
-
-    //  T := E
-    memcpy(T, E, N);
-
-    //  K := K \cup D
-    for (i = 0; i < N; i++)
-      if (D[i]) K[i] = 1;
-    
-    //  P := pixels de S \ K simples pour S (P est représenté par les points à 2 dans S)
-    for (i = 0; i < N; i++)
-      if (S[i] && !K[i] && simple8(S, i, rs, N))
-	S[i] = 2;
-
-    //  R := pixels de P qui s'apparient avec le masque C (bertrand_match3)
-    memset(R, 0, N);
-    for (i = 0; i < N; i++) 
-      if (S[i] == 2)
-      { 
-	m1 = bertrand_match3(S, i, rs, N);
-	if (m1) R[i] = 1; // preserve point
-      }
-
-    //  D := [S  \  P]  \cup  R
-    for (i = 0; i < N; i++)
-      if ((S[i] == 1) || R[i])
-	D[i] = 1;
-
-    for (i = 0; i < N; i++) // pour  tester la stabilité
-      if (S[i] && !D[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 255; // normalize values
-
-  freeimage(t);
-  freeimage(r);
-  freeimage(e);
-  freeimage(d);
-  freeimage(k);
-  return(1);
-} /* lskelAK2() */
diff -r 8b1af7363833 src/lib/lskelpar3d.c
--- a/src/lib/lskelpar3d.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lskelpar3d.c	Mon Jan 13 15:50:10 2014 +0100
@@ -80,6 +80,8 @@
 #include <mcrlifo.h>
 #include <lskelpar3d.h>
 
+#define PERS_INIT_VAL 0
+
 #define I_INHIBIT     1
 #define I_EARLYCURVE  2
 
@@ -119,7 +121,8 @@
 
 #define MAXFLOAT	3.40282347e+38F
 
-//#define VERBOSE
+#define VERBOSE
+#define DEBUG_SKEL_CK3P
 //#define DEBUG
 #ifdef DEBUG
 int32_t trace = 1;
@@ -1245,7 +1248,11 @@
       if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
       {    
 	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
+#ifdef NEW_ISTHMUS
+	if ((top == 2) && (topb == 1)) SET_CURVE(S[i]);
+#else
 	if (top > 1) SET_CURVE(S[i]);
+#endif
       }
     }
 
@@ -3381,7 +3388,11 @@
       if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
       {    
 	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
+#ifdef NEW_ISTHMUS
+	if ((topb == 2) && (top == 1)) SET_SURF(S[i]);
+#else
 	if (topb > 1) SET_SURF(S[i]);
+#endif
       }
     }
 
@@ -4029,11 +4040,11 @@
 /*
 Squelette asymétrique curviligne
 Algo ACK3p données: S (image), I (inhibit), n (n_steps), p (isthmus_persistence)
-Pour tout x de S faire T[x] := -1
+Pour tout x de S faire T[x] := PERS_INIT_VAL
 Pour i := 0; i < n; i++
   C := points de courbe de S
-  Pour tout x de C tq T[x] == -1 faire T[x] := i
-  I := I \cup {x | T[x] > -1 et (i - T[x]) >= p}
+  Pour tout x de C tq T[x] == PERS_INIT_VAL faire T[x] := i
+  I := I \cup {x | T[x] > PERS_INIT_VAL et (i - T[x]) >= p}
   P := voxels simples pour S et pas dans I
   C2 := voxels 2-D-cruciaux (asym_match2)
   C1 := voxels 1-D-cruciaux (asym_match1)
@@ -4081,7 +4092,7 @@
   for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
 
   T = (int16_t *)malloc(N * sizeof(int16_t)); assert(T != NULL);
-  for (i = 0; i < N; i++) T[i] = -1;
+  for (i = 0; i < N; i++) T[i] = PERS_INIT_VAL;
 
   mctopo3d_init_topo3d();
 
@@ -4105,7 +4116,7 @@
       if (IS_OBJECT(S[i]))
       {    
 	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
-	if ((top > 1) && (T[i] == -1))
+	if ((top > 1) && (T[i] == PERS_INIT_VAL))
 	  T[i] = (int16_t)step;
       }
     }
@@ -4117,7 +4128,7 @@
     // MEMORISE DANS I LES ISTHMES PERSISTANTS
     for (i = 0; i < N; i++)
     { 
-      if ((T[i] >= 0) && ((step - T[i]) >= isthmus_persistence)) 
+      if ((T[i] > PERS_INIT_VAL) && ((step - T[i]) >= isthmus_persistence)) 
       { 
 	UNSET_SIMPLE(S[i]); 
 	SET_INHIBIT(I[i]); 
@@ -4176,18 +4187,18 @@
 /*
 Squelette asymétrique curviligne - fonction persistance
 Algo ACK3c données: S (image) résultat: P (persistance)
-Pour tout x de S faire P[x] := -1
+Pour tout x de S faire P[x] := PERS_INIT_VAL
 i := 0
 Répéter jusqu'à stabilité
   i := i + 1
   C := points de courbe de S
-  Pour tout x de C tq P[x] == -1 faire P[x] := i // date de naissance
+  Pour tout x de C tq P[x] == PERS_INIT_VAL faire P[x] := i // date de naissance
   D := voxels simples pour S
   C2 := voxels 2-D-cruciaux (asym_match2)
   C1 := voxels 1-D-cruciaux (asym_match1)
   C0 := voxels 0-D-cruciaux (asym_match0)
   D := D  \  [C2 \cup C1 \cup C0]
-  Pour tout x de D tq P[x] != -1 faire P[x] := i - P[x] // date de mort - date de naissance
+  Pour tout x de D tq P[x] != PERS_INIT_VAL faire P[x] := i - P[x] // date de mort - date de naissance
   S := S \ D
 Pour tout x de S faire P[x] := INFINITY
 
@@ -4213,7 +4224,7 @@
   ACCEPTED_TYPES1(persistence, VFF_TYP_FLOAT);
 
   for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  for (i = 0; i < N; i++) P[i] = -1;
+  for (i = 0; i < N; i++) P[i] = PERS_INIT_VAL;
 
   mctopo3d_init_topo3d();
 
@@ -4237,7 +4248,7 @@
       if (IS_OBJECT(S[i]))
       {    
 	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
-	if ((top > 1) && (P[i] == -1))
+	if ((top > 1) && (P[i] == PERS_INIT_VAL))
 	  P[i] = (float)step;
       }
     }
@@ -4276,7 +4287,7 @@
       {
 	S[i] = 0; 
 	nonstab = 1; 
-	if (P[i] != -1) P[i] = (float)step - P[i];
+	if (P[i] != PERS_INIT_VAL) P[i] = (float)step - P[i];
       }
     for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
   } // while (nonstab)
@@ -4300,11 +4311,11 @@
 /*
 Squelette asymétrique surfacique
 Algo ASK3a données: S (image), I (inhibit), n (n_steps), p (isthmus_persistence)
-Pour tout x de S faire T[x] := -1
+Pour tout x de S faire T[x] := PERS_INIT_VAL
 Pour i := 0; i < n; i++
   C := points de surface de S
-  Pour tout x de C tq T[x] == -1 faire T[x] := i
-  I := I \cup {x | T[x] > -1 et (i - T[x]) >= p}
+  Pour tout x de C tq T[x] == PERS_INIT_VAL faire T[x] := i
+  I := I \cup {x | T[x] > PERS_INIT_VAL et (i - T[x]) >= p}
   P := voxels simples pour S et pas dans I
   C2 := voxels 2-D-cruciaux (asym_match2)
   C1 := voxels 1-D-cruciaux (asym_match1)
@@ -4352,7 +4363,7 @@
   for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
 
   T = (int16_t *)malloc(N * sizeof(int16_t)); assert(T != NULL);
-  for (i = 0; i < N; i++) T[i] = -1;
+  for (i = 0; i < N; i++) T[i] = PERS_INIT_VAL;
 
   mctopo3d_init_topo3d();
 
@@ -4376,7 +4387,7 @@
       if (IS_OBJECT(S[i]))
       {    
 	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
-	if ((topb > 1) && (T[i] == -1))
+	if ((topb > 1) && (T[i] == PERS_INIT_VAL))
 	  T[i] = (int16_t)step;
       }
     }
@@ -4388,7 +4399,7 @@
     // MEMORISE DANS I LES ISTHMES PERSISTANTS
     for (i = 0; i < N; i++)
     { 
-      if ((T[i] >= 0) && ((step - T[i]) >= isthmus_persistence)) 
+      if ((T[i] > PERS_INIT_VAL) && ((step - T[i]) >= isthmus_persistence)) 
       { 
 	UNSET_SIMPLE(S[i]); 
 	SET_INHIBIT(I[i]); 
@@ -4448,17 +4459,21 @@
 /*
 Squelette symétrique curviligne
 Algo CK3p données: S (image), I (inhibit), n (n_steps), p (isthmus_persistence)
-Pour tout x de S faire T[x] := -1
-Pour i := 0; i < n; i++
+Pour tout x de S faire T[x] := PERS_INIT_VAL
+i := 0 
+Repeat
+  i := i + 1
   C := points de courbe de S
-  Pour tout x de C tq T[x] == -1 faire T[x] := i
-  I := I \cup {x | T[x] > -1 et (i - T[x]) >= p}
+  Pour tout x de C tq T[x] == PERS_INIT_VAL faire T[x] := i
   P := voxels simples pour S et pas dans I
   C2 := voxels 2-D-cruciaux (match2)
   C1 := voxels 1-D-cruciaux (match1)
   C0 := voxels 0-D-cruciaux (match0)
+  Z := {x non simples ou cruciaux | T[x] > PERS_INIT_VAL et (i + 1 - T[x]) >= p}
   P := P  \  [C2 \cup C1 \cup C0]
   S := S \ P
+  I := I \cup Z 
+Until stability or i = n
 
 Attention : l'objet ne doit pas toucher le bord de l'image
 */
@@ -4500,7 +4515,7 @@
   for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
 
   T = (int16_t *)malloc(N * sizeof(int16_t)); assert(T != NULL);
-  for (i = 0; i < N; i++) T[i] = -1;
+  for (i = 0; i < N; i++) T[i] = PERS_INIT_VAL;
 
   mctopo3d_init_topo3d();
 
@@ -4549,13 +4564,181 @@
 	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
 	if (top > 1) SET_CURVE(S[i]);
       }
-      if (IS_CURVE(S[i]) && (T[i] == -1)) T[i] = (int16_t)step;
+      if (IS_CURVE(S[i]) && (T[i] == PERS_INIT_VAL)) 
+      { 
+	T[i] = (int16_t)step;
+#ifdef DEBUG_SKEL_CK3P
+	printf("point %d (%d %d %d) naissance step %d\n", i, i % rs, (i % ps) / rs,  i / ps, step);
+#endif	
+      }
     }
 
+    // MARQUE LES POINTS 2-D-CRUCIAUX
+    for (i = 0; i < N; i++) 
+      if (IS_SIMPLE(S[i]))
+      { 
+	extract_vois(S, i, rs, ps, N, v);
+	if (match2(v))
+	  insert_vois(v, S, i, rs, ps, N);
+      }
+    // MARQUE LES POINTS 1-D-CRUCIAUX
+    for (i = 0; i < N; i++) 
+      if (IS_SIMPLE(S[i]))
+      { 
+	extract_vois(S, i, rs, ps, N, v);
+	if (match1(v))
+	  insert_vois(v, S, i, rs, ps, N);
+      }
+    // MARQUE LES POINTS 0-D-CRUCIAUX
+    for (i = 0; i < N; i++) 
+      if (IS_SIMPLE(S[i]))
+      { 
+	extract_vois(S, i, rs, ps, N, v);
+	if (match0(v))
+	  insert_vois(v, S, i, rs, ps, N);
+      }
+
     // MEMORISE DANS I LES ISTHMES PERSISTANTS
     for (i = 0; i < N; i++)
     { 
-      if ((T[i] >= 0) && ((step - T[i]) >= isthmus_persistence)) 
+      if (IS_OBJECT(S[i]) && (!IS_SIMPLE(S[i]) || IS_DCRUCIAL(S[i])) &&
+	  (T[i] > PERS_INIT_VAL) && ((step+1 - T[i]) >= isthmus_persistence)) 
+      {
+	SET_INHIBIT(I[i]); 
+#ifdef DEBUG_SKEL_CK3P
+	printf("point %d (%d %d %d) ajout à K\n", i, i % rs, (i % ps) / rs,  i / ps);
+#endif	
+      }
+      if (IS_INHIBIT(I[i])) UNSET_SIMPLE(S[i]);
+    }
+
+    for (i = 0; i < N; i++)
+      if (S[i] && IS_SIMPLE(S[i]) && !IS_DCRUCIAL(S[i])) 
+      {
+	S[i] = 0; 
+	nonstab = 1; 
+      }
+    for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
+  } // while (nonstab && (step < n_steps))
+
+  for (i = 0; i < N; i++) if (S[i]) S[i] = NDG_MAX;
+
+#ifdef VERBOSE1
+    printf("number of steps: %d\n", step);
+#endif
+
+  free(T);
+  mctopo3d_termine_topo3d();
+  return(1);
+} /* lskelCK3p() */
+
+/* ==================================== */
+int32_t lskelSK3p(struct xvimage *image, 
+	     int32_t n_steps,
+	     int32_t isthmus_persistence,
+	     struct xvimage *inhibit)
+/* ==================================== */
+/*
+Squelette symétrique surfacique
+Algo SK3p données: S (image), I (inhibit), n (n_steps), p (isthmus_persistence)
+Pour tout x de S faire T[x] := PERS_INIT_VAL
+Pour i := 0; i < n; i++
+  C := points de surface de S
+  Pour tout x de C tq T[x] == PERS_INIT_VAL faire T[x] := i
+  I := I \cup {x | T[x] > PERS_INIT_VAL et (i - T[x]) >= p}
+  P := voxels simples pour S et pas dans I
+  C2 := voxels 2-D-cruciaux (match2)
+  C1 := voxels 1-D-cruciaux (match1)
+  C0 := voxels 0-D-cruciaux (match0)
+  P := P  \  [C2 \cup C1 \cup C0]
+  S := S \ P
+
+Attention : l'objet ne doit pas toucher le bord de l'image
+*/
+#undef F_NAME
+#define F_NAME "lskelSK3p"
+{  
+  index_t i; // index de pixel
+  index_t rs = rowsize(image);     /* taille ligne */
+  index_t cs = colsize(image);     /* taille colonne */
+  index_t ds = depth(image);       /* nb plans */
+  index_t ps = rs * cs;            /* taille plan */
+  index_t N = ps * ds;             /* taille image */
+  uint8_t *S = UCHARDATA(image);   /* l'image de depart */
+  int16_t *T;
+  uint8_t *I;
+  int32_t step, nonstab;
+  int32_t top, topb;
+  uint8_t v[27];
+
+#ifdef VERBOSE
+  printf("%s: n_steps = %d ; isthmus_persistence = %d\n", F_NAME, n_steps, isthmus_persistence);
+#endif
+
+  assert(n_steps <= INT16_MAX);
+  if (n_steps == -1) n_steps = INT16_MAX;
+
+  if (inhibit == NULL) 
+  {
+    inhibit = copyimage(image); 
+    razimage(inhibit);
+    I = UCHARDATA(inhibit);
+  }
+  else
+  {
+    I = UCHARDATA(inhibit);
+    for (i = 0; i < N; i++) if (I[i]) I[i] = I_INHIBIT;
+  }
+
+  for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
+
+  T = (int16_t *)malloc(N * sizeof(int16_t)); assert(T != NULL);
+  for (i = 0; i < N; i++) T[i] = PERS_INIT_VAL;
+
+  mctopo3d_init_topo3d();
+
+  /* ================================================ */
+  /*               DEBUT ALGO                         */
+  /* ================================================ */
+
+  step = 0;
+  nonstab = 1;
+  while (nonstab && (step < n_steps))
+  {
+    nonstab = 0;
+    step++;
+#ifdef VERBOSE
+    printf("step %d\n", step);
+#endif
+
+    // MARQUE LES POINTS SIMPLES
+    for (i = 0; i < N; i++) 
+      if (IS_OBJECT(S[i]) && mctopo3d_simple26(S, i, rs, ps, N))
+	SET_SIMPLE(S[i]);
+
+    // MARQUE LES POINTS DE SURFACE (2)
+    for (i = 0; i < N; i++)
+      if (IS_SIMPLE(S[i]))
+      { 
+	extract_vois(S, i, rs, ps, N, v);
+	if (match2s(v))
+	  insert_vois(v, S, i, rs, ps, N);
+      }
+    // MARQUE LES POINTS DE SURFACE (3)
+    for (i = 0; i < N; i++)
+    {
+      if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
+      {    
+	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
+	if (topb > 1) SET_SURF(S[i]);
+      }
+      if (IS_SURF(S[i]) && (T[i] == PERS_INIT_VAL)) T[i] = (int16_t)step;
+    }
+
+    // MEMORISE DANS I LES ISTHMES PERSISTANTS
+    for (i = 0; i < N; i++)
+    { 
+      if ((T[i] > PERS_INIT_VAL) && ((step + 1 - T[i]) >= isthmus_persistence)) 
 	SET_INHIBIT(I[i]); 
       if (IS_INHIBIT(I[i])) UNSET_SIMPLE(S[i]);
     }
@@ -4602,22 +4785,22 @@
   free(T);
   mctopo3d_termine_topo3d();
   return(1);
-} /* lskelCK3p() */
+} /* lskelSK3p() */
 
 /* ==================================== */
-int32_t lskelSK3p(struct xvimage *image, 
+int32_t lskelSCK3p(struct xvimage *image, 
 	     int32_t n_steps,
 	     int32_t isthmus_persistence,
 	     struct xvimage *inhibit)
 /* ==================================== */
 /*
-Squelette symétrique surfacique
-Algo SK3p données: S (image), I (inhibit), n (n_steps), p (isthmus_persistence)
-Pour tout x de S faire T[x] := -1
+Squelette symétrique surfacique-curviligne
+Algo SCK3p données: S (image), I (inhibit), n (n_steps), p (isthmus_persistence)
+Pour tout x de S faire T[x] := PERS_INIT_VAL
 Pour i := 0; i < n; i++
-  C := points de surface de S
-  Pour tout x de C tq T[x] == -1 faire T[x] := i
-  I := I \cup {x | T[x] > -1 et (i - T[x]) >= p}
+  C := points de surface ou de courbe de S
+  Pour tout x de C tq T[x] == PERS_INIT_VAL faire T[x] := i
+  I := I \cup {x | T[x] > PERS_INIT_VAL et (i - T[x]) >= p}
   P := voxels simples pour S et pas dans I
   C2 := voxels 2-D-cruciaux (match2)
   C1 := voxels 1-D-cruciaux (match1)
@@ -4628,7 +4811,7 @@
 Attention : l'objet ne doit pas toucher le bord de l'image
 */
 #undef F_NAME
-#define F_NAME "lskelSK3p"
+#define F_NAME "lskelSCK3p"
 { 
   index_t i; // index de pixel
   index_t rs = rowsize(image);     /* taille ligne */
@@ -4665,7 +4848,7 @@
   for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
 
   T = (int16_t *)malloc(N * sizeof(int16_t)); assert(T != NULL);
-  for (i = 0; i < N; i++) T[i] = -1;
+  for (i = 0; i < N; i++) T[i] = PERS_INIT_VAL;
 
   mctopo3d_init_topo3d();
 
@@ -4688,29 +4871,40 @@
       if (IS_OBJECT(S[i]) && mctopo3d_simple26(S, i, rs, ps, N))
 	SET_SIMPLE(S[i]);
 
-    // MARQUE LES POINTS DE SURFACE (2)
-    for (i = 0; i < N; i++)
+    // MARQUE LES POINTS DE COURBE OU DE SURFACE(2)
+    for (i = 0; i < N; i++) 
       if (IS_SIMPLE(S[i]))
       { 
 	extract_vois(S, i, rs, ps, N, v);
 	if (match2s(v))
 	  insert_vois(v, S, i, rs, ps, N);
       }
-    // MARQUE LES POINTS DE SURFACE (3)
+
+    // MARQUE LES POINTS DE COURBE (1)
+    for (i = 0; i < N; i++) 
+      if (IS_SIMPLE(S[i]))
+      { 
+	extract_vois(S, i, rs, ps, N, v);
+	if (match1s(v))
+	  insert_vois(v, S, i, rs, ps, N);
+      }
+
+    // MARQUE LES POINTS DE COURBE OU DE SURFACE(3)
     for (i = 0; i < N; i++)
     {
       if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
       {    
 	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
+	if (top > 1) SET_CURVE(S[i]);
 	if (topb > 1) SET_SURF(S[i]);
       }
-      if (IS_SURF(S[i]) && (T[i] == -1)) T[i] = (int16_t)step;
+      if ((IS_CURVE(S[i]) || IS_SURF(S[i])) && (T[i] == PERS_INIT_VAL)) T[i] = (int16_t)step;
     }
 
     // MEMORISE DANS I LES ISTHMES PERSISTANTS
     for (i = 0; i < N; i++)
     { 
-      if ((T[i] >= 0) && ((step - T[i]) >= isthmus_persistence)) 
+      if ((T[i] > PERS_INIT_VAL) && ((step - T[i]) >= isthmus_persistence)) 
 	SET_INHIBIT(I[i]); 
       if (IS_INHIBIT(I[i])) UNSET_SIMPLE(S[i]);
     }
@@ -4757,70 +4951,55 @@
   free(T);
   mctopo3d_termine_topo3d();
   return(1);
-} /* lskelSK3p() */
+} /* lskelSCK3p() */
 
 /* ==================================== */
-int32_t lskelSCK3p(struct xvimage *image, 
-	     int32_t n_steps,
-	     int32_t isthmus_persistence,
-	     struct xvimage *inhibit)
+int32_t lskelCK3_pers(struct xvimage *image, 
+		       struct xvimage *persistence)
 /* ==================================== */
 /*
-Squelette symétrique surfacique-curviligne
-Algo SCK3p données: S (image), I (inhibit), n (n_steps), p (isthmus_persistence)
-Pour tout x de S faire T[x] := -1
-Pour i := 0; i < n; i++
-  C := points de surface ou de courbe de S
-  Pour tout x de C tq T[x] == -1 faire T[x] := i
-  I := I \cup {x | T[x] > -1 et (i - T[x]) >= p}
-  P := voxels simples pour S et pas dans I
+Squelette symétrique curviligne - fonction persistance
+Algo CK3_pers données: S (image) résultat: P (persistance)
+
+Pour tout x de S faire P[x] := PERS_INIT_VAL
+i := 0
+Répéter jusqu'à stabilité
+  i := i + 1
+  C := points de courbe de S
+  Pour tout x de C tq P[x] == PERS_INIT_VAL faire P[x] := i // date de naissance
+  D := voxels simples pour S
   C2 := voxels 2-D-cruciaux (match2)
   C1 := voxels 1-D-cruciaux (match1)
   C0 := voxels 0-D-cruciaux (match0)
-  P := P  \  [C2 \cup C1 \cup C0]
-  S := S \ P
+  D := D  \  [C2 \cup C1 \cup C0]
+  Pour tout x de D tq P[x] != PERS_INIT_VAL faire P[x] := i - P[x] // date de mort - date de naissance
+  S := S \ D
+Pour tout x de S faire P[x] := INFINITY
 
 Attention : l'objet ne doit pas toucher le bord de l'image
+
 */
 #undef F_NAME
-#define F_NAME "lskelSCK3p"
+#define F_NAME "lskelCK3_pers"
 { 
-  index_t i; // index de pixel
+  index_t i;
   index_t rs = rowsize(image);     /* taille ligne */
   index_t cs = colsize(image);     /* taille colonne */
   index_t ds = depth(image);       /* nb plans */
   index_t ps = rs * cs;            /* taille plan */
   index_t N = ps * ds;             /* taille image */
-  uint8_t *S = UCHARDATA(image);   /* l'image de depart */
-  int16_t *T;
-  uint8_t *I;
+  uint8_t *S = UCHARDATA(image);      /* l'image de depart */
+  float *P = FLOATDATA(persistence);   /* résultat */
   int32_t step, nonstab;
   int32_t top, topb;
   uint8_t v[27];
 
-#ifdef VERBOSE
-  printf("%s: n_steps = %d ; isthmus_persistence = %d\n", F_NAME, n_steps, isthmus_persistence);
-#endif
-
-  assert(n_steps <= INT16_MAX);
-  if (n_steps == -1) n_steps = INT16_MAX;
-
-  if (inhibit == NULL) 
-  {
-    inhibit = copyimage(image); 
-    razimage(inhibit);
-    I = UCHARDATA(inhibit);
-  }
-  else
-  {
-    I = UCHARDATA(inhibit);
-    for (i = 0; i < N; i++) if (I[i]) I[i] = I_INHIBIT;
-  }
+  COMPARE_SIZE(image, persistence);
+  ACCEPTED_TYPES1(image, VFF_TYP_1_BYTE);
+  ACCEPTED_TYPES1(persistence, VFF_TYP_FLOAT);
 
   for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-
-  T = (int16_t *)malloc(N * sizeof(int16_t)); assert(T != NULL);
-  for (i = 0; i < N; i++) T[i] = -1;
+  for (i = 0; i < N; i++) P[i] = PERS_INIT_VAL;
 
   mctopo3d_init_topo3d();
 
@@ -4830,7 +5009,7 @@
 
   step = 0;
   nonstab = 1;
-  while (nonstab && (step < n_steps))
+  while (nonstab)
   {
     nonstab = 0;
     step++;
@@ -4843,7 +5022,7 @@
       if (IS_OBJECT(S[i]) && mctopo3d_simple26(S, i, rs, ps, N))
 	SET_SIMPLE(S[i]);
 
-    // MARQUE LES POINTS DE COURBE OU DE SURFACE(2)
+    // DEUXIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE (2)
     for (i = 0; i < N; i++) 
       if (IS_SIMPLE(S[i]))
       { 
@@ -4852,7 +5031,7 @@
 	  insert_vois(v, S, i, rs, ps, N);
       }
 
-    // MARQUE LES POINTS DE COURBE (1)
+    // TROISIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE (1)
     for (i = 0; i < N; i++) 
       if (IS_SIMPLE(S[i]))
       { 
@@ -4861,25 +5040,22 @@
 	  insert_vois(v, S, i, rs, ps, N);
       }
 
-    // MARQUE LES POINTS DE COURBE OU DE SURFACE(3)
+    // MARQUE LES POINTS DE COURBE (3)
     for (i = 0; i < N; i++)
     {
       if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
       {    
 	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
 	if (top > 1) SET_CURVE(S[i]);
-	if (topb > 1) SET_SURF(S[i]);
       }
-      if ((IS_CURVE(S[i]) || IS_SURF(S[i])) && (T[i] == -1)) T[i] = (int16_t)step;
     }
 
-    // MEMORISE DANS I LES ISTHMES PERSISTANTS
+    // ENREGISTRE LA DATE DE NAISSANCE DES POINTS DE COURBE
     for (i = 0; i < N; i++)
-    { 
-      if ((T[i] >= 0) && ((step - T[i]) >= isthmus_persistence)) 
-	SET_INHIBIT(I[i]); 
-      if (IS_INHIBIT(I[i])) UNSET_SIMPLE(S[i]);
+    {
+      if ((P[i] == PERS_INIT_VAL) && IS_CURVE(S[i])) P[i] = (float)step;
     }
+
     // MARQUE LES POINTS 2-D-CRUCIAUX
     for (i = 0; i < N; i++) 
       if (IS_SIMPLE(S[i]))
@@ -4910,41 +5086,41 @@
       {
 	S[i] = 0; 
 	nonstab = 1; 
+	if (P[i] != PERS_INIT_VAL) P[i] = (float)step - P[i];
       }
     for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  } // while (nonstab && (step < n_steps))
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = NDG_MAX;
+  }
 
 #ifdef VERBOSE1
     printf("number of steps: %d\n", step);
 #endif
 
-  free(T);
+  for (i = 0; i < N; i++) if (S[i]) { S[i] = NDG_MAX; P[i] = MAXFLOAT; }
+
   mctopo3d_termine_topo3d();
   return(1);
-} /* lskelSCK3p() */
+} /* lskelCK3_pers() */
 
 /* ==================================== */
-int32_t lskelCK3_pers(struct xvimage *image, 
-		       struct xvimage *persistence)
+int32_t lskelSK3_pers(struct xvimage *image, 
+		      struct xvimage *persistence)
 /* ==================================== */
 /*
-Squelette symétrique curviligne - fonction persistance
-Algo CK3_pers données: S (image) résultat: P (persistance)
-
-Pour tout x de S faire P[x] := -1
+Squelette symétrique surfacique - fonction persistance
+Algo SK3_pers données: S (image) résultat: P (persistance)
+
+Pour tout x de S faire P[x] := PERS_INIT_VAL
 i := 0
 Répéter jusqu'à stabilité
   i := i + 1
-  C := points de courbe de S
-  Pour tout x de C tq P[x] == -1 faire P[x] := i // date de naissance
+  C := points de surface de S
+  Pour tout x de C tq P[x] == PERS_INIT_VAL faire P[x] := i // date de naissance
   D := voxels simples pour S
   C2 := voxels 2-D-cruciaux (match2)
   C1 := voxels 1-D-cruciaux (match1)
   C0 := voxels 0-D-cruciaux (match0)
   D := D  \  [C2 \cup C1 \cup C0]
-  Pour tout x de D tq P[x] != -1 faire P[x] := i - P[x] // date de mort - date de naissance
+  Pour tout x de D tq P[x] != PERS_INIT_VAL faire P[x] := i - P[x] // date de mort - date de naissance
   S := S \ D
 Pour tout x de S faire P[x] := INFINITY
 
@@ -4952,7 +5128,7 @@
 
 */
 #undef F_NAME
-#define F_NAME "lskelCK3_pers"
+#define F_NAME "lskelSK3_pers"
 { 
   index_t i;
   index_t rs = rowsize(image);     /* taille ligne */
@@ -4971,7 +5147,7 @@
   ACCEPTED_TYPES1(persistence, VFF_TYP_FLOAT);
 
   for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  for (i = 0; i < N; i++) P[i] = -1;
+  for (i = 0; i < N; i++) P[i] = PERS_INIT_VAL;
 
   mctopo3d_init_topo3d();
 
@@ -4994,38 +5170,28 @@
       if (IS_OBJECT(S[i]) && mctopo3d_simple26(S, i, rs, ps, N))
 	SET_SIMPLE(S[i]);
 
-    // DEUXIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE (2)
-    for (i = 0; i < N; i++) 
+    // MARQUE LES POINTS DE SURFACE (2)
+    for (i = 0; i < N; i++)
       if (IS_SIMPLE(S[i]))
       { 
 	extract_vois(S, i, rs, ps, N, v);
 	if (match2s(v))
 	  insert_vois(v, S, i, rs, ps, N);
       }
-
-    // TROISIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE (1)
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1s(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    // MARQUE LES POINTS DE COURBE (3)
+    // MARQUE LES POINTS DE SURFACE (3)
     for (i = 0; i < N; i++)
     {
       if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
       {    
 	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
-	if (top > 1) SET_CURVE(S[i]);
+	if (topb > 1) SET_SURF(S[i]);
       }
     }
 
-    // ENREGISTRE LA DATE DE NAISSANCE DES POINTS DE COURBE
+    // ENREGISTRE LA DATE DE NAISSANCE DES POINTS DE SURFACE
     for (i = 0; i < N; i++)
     {
-      if ((P[i] == -1) && IS_CURVE(S[i])) P[i] = (float)step;
+      if ((P[i] == PERS_INIT_VAL) && IS_SURF(S[i])) P[i] = (float)step;
     }
 
     // MARQUE LES POINTS 2-D-CRUCIAUX
@@ -5058,7 +5224,7 @@
       {
 	S[i] = 0; 
 	nonstab = 1; 
-	if (P[i] != -1) P[i] = (float)step - P[i];
+	if (P[i] != PERS_INIT_VAL) P[i] = (float)step - P[i];
       }
     for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
   }
@@ -5071,28 +5237,28 @@
 
   mctopo3d_termine_topo3d();
   return(1);
-} /* lskelCK3_pers() */
+} /* lskelSK3_pers() */
 
 /* ==================================== */
-int32_t lskelSK3_pers(struct xvimage *image, 
-		      struct xvimage *persistence)
+int32_t lskelSCK3_pers(struct xvimage *image, 
+		       struct xvimage *persistence)
 /* ==================================== */
 /*
-Squelette symétrique surfacique - fonction persistance
-Algo SK3_pers données: S (image) résultat: P (persistance)
-
-Pour tout x de S faire P[x] := -1
+Squelette symétrique curviligne et surfacique - fonction persistance
+Algo SCK3_pers données: S (image) résultat: P (persistance)
+
+Pour tout x de S faire P[x] := PERS_INIT_VAL
 i := 0
 Répéter jusqu'à stabilité
   i := i + 1
-  C := points de surface de S
-  Pour tout x de C tq P[x] == -1 faire P[x] := i // date de naissance
+  C := points de courbe ou de surface de S
+  Pour tout x de C tq P[x] == PERS_INIT_VAL faire P[x] := i // date de naissance
   D := voxels simples pour S
   C2 := voxels 2-D-cruciaux (match2)
   C1 := voxels 1-D-cruciaux (match1)
   C0 := voxels 0-D-cruciaux (match0)
   D := D  \  [C2 \cup C1 \cup C0]
-  Pour tout x de D tq P[x] != -1 faire P[x] := i - P[x] // date de mort - date de naissance
+  Pour tout x de D tq P[x] != PERS_INIT_VAL faire P[x] := i - P[x] // date de mort - date de naissance
   S := S \ D
 Pour tout x de S faire P[x] := INFINITY
 
@@ -5100,7 +5266,7 @@
 
 */
 #undef F_NAME
-#define F_NAME "lskelSK3_pers"
+#define F_NAME "lskelSCK3_pers"
 { 
   index_t i;
   index_t rs = rowsize(image);     /* taille ligne */
@@ -5119,7 +5285,7 @@
   ACCEPTED_TYPES1(persistence, VFF_TYP_FLOAT);
 
   for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  for (i = 0; i < N; i++) P[i] = -1;
+  for (i = 0; i < N; i++) P[i] = PERS_INIT_VAL;
 
   mctopo3d_init_topo3d();
 
@@ -5142,28 +5308,40 @@
       if (IS_OBJECT(S[i]) && mctopo3d_simple26(S, i, rs, ps, N))
 	SET_SIMPLE(S[i]);
 
-    // MARQUE LES POINTS DE SURFACE (2)
-    for (i = 0; i < N; i++)
+    // DEUXIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE ET DE SURFACE (2)
+    for (i = 0; i < N; i++) 
       if (IS_SIMPLE(S[i]))
       { 
 	extract_vois(S, i, rs, ps, N, v);
 	if (match2s(v))
 	  insert_vois(v, S, i, rs, ps, N);
       }
-    // MARQUE LES POINTS DE SURFACE (3)
+
+    // TROISIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE (1)
+    for (i = 0; i < N; i++) 
+      if (IS_SIMPLE(S[i]))
+      { 
+	extract_vois(S, i, rs, ps, N, v);
+	if (match1s(v))
+	  insert_vois(v, S, i, rs, ps, N);
+      }
+
+    // MARQUE LES POINTS DE COURBE ET DE SURFACE (3)
     for (i = 0; i < N; i++)
     {
       if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
       {    
 	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
+	if (top > 1) SET_CURVE(S[i]);
 	if (topb > 1) SET_SURF(S[i]);
       }
     }
 
-    // ENREGISTRE LA DATE DE NAISSANCE DES POINTS DE SURFACE
+    // ENREGISTRE LA DATE DE NAISSANCE DES POINTS DE COURBE OU DE SURFACE
     for (i = 0; i < N; i++)
     {
-      if ((P[i] == -1) && IS_SURF(S[i])) P[i] = (float)step;
+      if ((P[i] == PERS_INIT_VAL) && (IS_CURVE(S[i]) || IS_SURF(S[i]))) 
+	P[i] = (float)step;
     }
 
     // MARQUE LES POINTS 2-D-CRUCIAUX
@@ -5196,7 +5374,7 @@
       {
 	S[i] = 0; 
 	nonstab = 1; 
-	if (P[i] != -1) P[i] = (float)step - P[i];
+	if (P[i] != PERS_INIT_VAL) P[i] = (float)step - P[i];
       }
     for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
   }
@@ -5209,154 +5387,4 @@
 
   mctopo3d_termine_topo3d();
   return(1);
-} /* lskelSK3_pers() */
-
-/* ==================================== */
-int32_t lskelSCK3_pers(struct xvimage *image, 
-		       struct xvimage *persistence)
-/* ==================================== */
-/*
-Squelette symétrique curviligne et surfacique - fonction persistance
-Algo SCK3_pers données: S (image) résultat: P (persistance)
-
-Pour tout x de S faire P[x] := -1
-i := 0
-Répéter jusqu'à stabilité
-  i := i + 1
-  C := points de courbe ou de surface de S
-  Pour tout x de C tq P[x] == -1 faire P[x] := i // date de naissance
-  D := voxels simples pour S
-  C2 := voxels 2-D-cruciaux (match2)
-  C1 := voxels 1-D-cruciaux (match1)
-  C0 := voxels 0-D-cruciaux (match0)
-  D := D  \  [C2 \cup C1 \cup C0]
-  Pour tout x de D tq P[x] != -1 faire P[x] := i - P[x] // date de mort - date de naissance
-  S := S \ D
-Pour tout x de S faire P[x] := INFINITY
-
-Attention : l'objet ne doit pas toucher le bord de l'image
-
-*/
-#undef F_NAME
-#define F_NAME "lskelSCK3_pers"
-{ 
-  index_t i;
-  index_t rs = rowsize(image);     /* taille ligne */
-  index_t cs = colsize(image);     /* taille colonne */
-  index_t ds = depth(image);       /* nb plans */
-  index_t ps = rs * cs;            /* taille plan */
-  index_t N = ps * ds;             /* taille image */
-  uint8_t *S = UCHARDATA(image);      /* l'image de depart */
-  float *P = FLOATDATA(persistence);   /* résultat */
-  int32_t step, nonstab;
-  int32_t top, topb;
-  uint8_t v[27];
-
-  COMPARE_SIZE(image, persistence);
-  ACCEPTED_TYPES1(image, VFF_TYP_1_BYTE);
-  ACCEPTED_TYPES1(persistence, VFF_TYP_FLOAT);
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  for (i = 0; i < N; i++) P[i] = -1;
-
-  mctopo3d_init_topo3d();
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab)
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    // MARQUE LES POINTS SIMPLES
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]) && mctopo3d_simple26(S, i, rs, ps, N))
-	SET_SIMPLE(S[i]);
-
-    // DEUXIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE ET DE SURFACE (2)
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2s(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    // TROISIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE (1)
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1s(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    // MARQUE LES POINTS DE COURBE ET DE SURFACE (3)
-    for (i = 0; i < N; i++)
-    {
-      if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
-      {    
-	mctopo3d_top26(S, i, rs, ps, N, &top, &topb);
-	if (top > 1) SET_CURVE(S[i]);
-	if (topb > 1) SET_SURF(S[i]);
-      }
-    }
-
-    // ENREGISTRE LA DATE DE NAISSANCE DES POINTS DE COURBE OU DE SURFACE
-    for (i = 0; i < N; i++)
-    {
-      if ((P[i] == -1) && (IS_CURVE(S[i]) || IS_SURF(S[i]))) 
-	P[i] = (float)step;
-    }
-
-    // MARQUE LES POINTS 2-D-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 1-D-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 0-D-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match0(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    for (i = 0; i < N; i++)
-      if (S[i] && IS_SIMPLE(S[i]) && !IS_DCRUCIAL(S[i])) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-	if (P[i] != -1) P[i] = (float)step - P[i];
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) { S[i] = NDG_MAX; P[i] = MAXFLOAT; }
-
-  mctopo3d_termine_topo3d();
-  return(1);
 } /* lskelSCK3_pers() */
diff -r 8b1af7363833 src/lib/lskelpar3d.c.sav
--- a/src/lib/lskelpar3d.c.sav	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,2271 +0,0 @@
-/* $Id: lskelpar3d.c.sav,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-/* 
-   Algorithmes 3D "fully parallel" de squelettisation
-*/
-
-#include <stdio.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mccodimage.h>
-#include <mcimage.h>
-#include <mctopo.h>
-#include <mctopo3d.h>
-#include <mcindic.h>
-#include <mcutil.h>
-#include <lskelpar3d.h>
-
-#define S_OBJECT      1
-#define S_SIMPLE      2
-#define S_2M_CRUCIAL  4
-#define S_1M_CRUCIAL  8
-#define S_0M_CRUCIAL 16
-#define S_CURVE      32
-#define S_SURF       64
-#define S_SELECTED  128
-
-#define IS_OBJECT(f)     (f&S_OBJECT)
-#define IS_SIMPLE(f)     (f&S_SIMPLE)
-#define IS_2M_CRUCIAL(f) (f&S_2M_CRUCIAL)
-#define IS_1M_CRUCIAL(f) (f&S_1M_CRUCIAL)
-#define IS_0M_CRUCIAL(f) (f&S_0M_CRUCIAL)
-#define IS_CURVE(f)      (f&S_CURVE)
-#define IS_SURF(f)       (f&S_SURF)
-#define IS_SELECTED(f)   (f&S_SELECTED)
-
-#define SET_OBJECT(f)     (f|=S_OBJECT)
-#define SET_SIMPLE(f)     (f|=S_SIMPLE)
-#define SET_2M_CRUCIAL(f) (f|=S_2M_CRUCIAL)
-#define SET_1M_CRUCIAL(f) (f|=S_1M_CRUCIAL)
-#define SET_0M_CRUCIAL(f) (f|=S_0M_CRUCIAL)
-#define SET_CURVE(f)      (f|=S_CURVE)
-#define SET_SURF(f)       (f|=S_SURF)
-#define SET_SELECTED(f)   (f|=S_SELECTED)
-
-#define UNSET_OBJECT(f)     (f&=~S_OBJECT)
-#define UNSET_SIMPLE(f)     (f&=~S_SIMPLE)
-#define UNSET_2M_CRUCIAL(f) (f&=~S_2M_CRUCIAL)
-#define UNSET_1M_CRUCIAL(f) (f&=~S_1M_CRUCIAL)
-#define UNSET_0M_CRUCIAL(f) (f&=~S_0M_CRUCIAL)
-
-#define VERBOSE
-//#define DEBUG
-#ifdef DEBUG
-int32_t trace = 1;
-#endif
-
-/* ==================================== */
-static void extract_vois(
-  u_int8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N,                       /* taille image */
-  u_int8_t *vois)    
-/* 
-  retourne dans "vois" les valeurs des 27 voisins de p, dans l'ordre suivant: 
-
-               12      11      10       
-               13       8       9
-               14      15      16
-
-		3	2	1			
-		4      26	0
-		5	6	7
-
-               21      20      19
-               22      17      18
-               23      24      25
-
-  le point p ne doit pas être un point de bord de l'image
-*/
-/* ==================================== */
-{
-#undef F_NAME
-#define F_NAME "extract_vois"
-  register u_int8_t * ptr = img+p;
-  if ((p%rs==rs-1) || (p%ps<rs) || (p%rs==0) || (p%ps>=ps-rs) || 
-      (p < ps) || (p >= N-ps)) /* point de bord */
-  {
-    printf("%s: ERREUR: point de bord\n", F_NAME);
-    exit(0);
-  }
-  vois[ 0] = *(ptr+1);
-  vois[ 1] = *(ptr+1-rs);
-  vois[ 2] = *(ptr-rs);
-  vois[ 3] = *(ptr-rs-1);
-  vois[ 4] = *(ptr-1);
-  vois[ 5] = *(ptr-1+rs);
-  vois[ 6] = *(ptr+rs);
-  vois[ 7] = *(ptr+rs+1);
-
-  vois[ 8] = *(ptr-ps);
-  vois[ 9] = *(ptr-ps+1);
-  vois[10] = *(ptr-ps+1-rs);
-  vois[11] = *(ptr-ps-rs);
-  vois[12] = *(ptr-ps-rs-1);
-  vois[13] = *(ptr-ps-1);
-  vois[14] = *(ptr-ps-1+rs);
-  vois[15] = *(ptr-ps+rs);
-  vois[16] = *(ptr-ps+rs+1);
-
-  vois[17] = *(ptr+ps);
-  vois[18] = *(ptr+ps+1);
-  vois[19] = *(ptr+ps+1-rs);
-  vois[20] = *(ptr+ps-rs);
-  vois[21] = *(ptr+ps-rs-1);
-  vois[22] = *(ptr+ps-1);
-  vois[23] = *(ptr+ps-1+rs);
-  vois[24] = *(ptr+ps+rs);
-  vois[25] = *(ptr+ps+rs+1);
-
-  vois[26] = *(ptr);
-} /* extract_vois() */
-
-/* ==================================== */
-static void insert_vois(
-  u_int8_t *vois,			
-  u_int8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */    
-/* 
-  recopie vois dans le voisinage de p
-  le point p ne doit pas être un point de bord de l'image
-*/
-/* ==================================== */
-{
-#undef F_NAME
-#define F_NAME "insert_vois"
-  register u_int8_t * ptr = img+p;
-  if ((p%rs==rs-1) || (p%ps<rs) || (p%rs==0) || (p%ps>=ps-rs) || 
-      (p < ps) || (p >= N-ps)) /* point de bord */
-  {
-    printf("%s: ERREUR: point de bord\n", F_NAME);
-    exit(0);
-  }
-  *(ptr+1) = vois[ 0];
-  *(ptr+1-rs) = vois[ 1];
-  *(ptr-rs) = vois[ 2];
-  *(ptr-rs-1) = vois[ 3];
-  *(ptr-1) = vois[ 4];
-  *(ptr-1+rs) = vois[ 5];
-  *(ptr+rs) = vois[ 6];
-  *(ptr+rs+1) = vois[ 7];
-
-  *(ptr-ps) = vois[ 8];
-  *(ptr-ps+1) = vois[ 9];
-  *(ptr-ps+1-rs) = vois[10];
-  *(ptr-ps-rs) = vois[11];
-  *(ptr-ps-rs-1) = vois[12];
-  *(ptr-ps-1) = vois[13];
-  *(ptr-ps-1+rs) = vois[14];
-  *(ptr-ps+rs) = vois[15];
-  *(ptr-ps+rs+1) = vois[16];
-
-  *(ptr+ps) = vois[17];
-  *(ptr+ps+1) = vois[18];
-  *(ptr+ps+1-rs) = vois[19];
-  *(ptr+ps-rs) = vois[20];
-  *(ptr+ps-rs-1) = vois[21];
-  *(ptr+ps-1) = vois[22];
-  *(ptr+ps-1+rs) = vois[23];
-  *(ptr+ps+rs) = vois[24];
-  *(ptr+ps+rs+1) = vois[25];
-
-  *(ptr) = vois[26];
-} /* insert_vois() */
-
-/* ==================================== */
-static void print_vois(u_int8_t *vois)    
-/* 
-   affiche vois (debug)
-*/
-/* ==================================== */
-{
-  printf("%2d %2d %2d     %2d %2d %2d     %2d %2d %2d\n", 
-	 vois[12],vois[11],vois[10],vois[3],vois[2],vois[1],vois[21],vois[20],vois[19]);
-  printf("%2d %2d %2d     %2d %2d %2d     %2d %2d %2d\n", 
-	 vois[13],vois[8],vois[9],vois[4],vois[26],vois[0],vois[22],vois[17],vois[18]);
-  printf("%2d %2d %2d     %2d %2d %2d     %2d %2d %2d\n\n", 
-	 vois[14],vois[15],vois[16],vois[5],vois[6],vois[7],vois[23],vois[24],vois[25]);
-} /* print_vois() */
-
-/* ==================================== */
-static void isometrieXZ_vois(u_int8_t *vois) 
-// effectue une isométrie du voisinage "vois" par échange des axes X et Z (+ symétries)
-// cette isométrie est de plus une involution
-/* ==================================== */
-{
-  u_int8_t v[26];
-  int32_t i;
-  v[ 0] = vois[17];  v[ 1] = vois[20];  v[ 2] = vois[ 2];  v[ 3] = vois[11];
-  v[ 4] = vois[ 8];  v[ 5] = vois[15];  v[ 6] = vois[ 6];  v[ 7] = vois[24];
-  v[ 8] = vois[ 4];  v[ 9] = vois[22];  v[10] = vois[21];  v[11] = vois[ 3];
-  v[12] = vois[12];  v[13] = vois[13];  v[14] = vois[14];  v[15] = vois[ 5];
-  v[16] = vois[23];  v[17] = vois[ 0];  v[18] = vois[18];  v[19] = vois[19];
-  v[20] = vois[ 1];  v[21] = vois[10];  v[22] = vois[ 9];  v[23] = vois[16];
-  v[24] = vois[ 7];  v[25] = vois[25];
-  for (i = 0; i < 26; i++) vois[i] = v[i];
-} /* isometrieXZ_vois() */
-
-/* ==================================== */
-static void isometrieYZ_vois(u_int8_t *vois)
-// effectue une isométrie du voisinage "vois" par échange des axes Y et Z (+ symétries)  
-// cette isométrie est de plus une involution
-/* ==================================== */
-{
-  u_int8_t v[26];
-  int32_t i;
-  v[ 0] = vois[ 0];  v[ 1] = vois[18];  v[ 2] = vois[17];  v[ 3] = vois[22];
-  v[ 4] = vois[ 4];  v[ 5] = vois[13];  v[ 6] = vois[ 8];  v[ 7] = vois[ 9];
-  v[ 8] = vois[ 6];  v[ 9] = vois[ 7];  v[10] = vois[25];  v[11] = vois[24];
-  v[12] = vois[23];  v[13] = vois[ 5];  v[14] = vois[14];  v[15] = vois[15];
-  v[16] = vois[16];  v[17] = vois[ 2];  v[18] = vois[ 1];  v[19] = vois[19];
-  v[20] = vois[20];  v[21] = vois[21];  v[22] = vois[ 3];  v[23] = vois[12];
-  v[24] = vois[11];  v[25] = vois[10];
-  for (i = 0; i < 26; i++) vois[i] = v[i];
-} /* isometrieYZ_vois() */
-
-/* ==================================== */
-int32_t match_end(u_int8_t *v)
-/* ==================================== */
-/*
-               12      11      10
-               13       8       9
-               14      15      16
-
-		3	2	1
-		4      26	0
-		5	6	7
-
-               21      20      19
-               22      17      18
-               23      24      25
-
-Teste si au moins un des points 12, 11, 13, 8, 3, 2, 4 est objet et tous les autres fond
-(aussi avec les isométries). 
-*/
-{
-  u_int8_t t;
-#ifdef DEBUG
-  if (trace)
-  {  
-    printf("match_end\n");
-    print_vois(v);
-  }
-#endif
-
-  if ((v[19] || v[20] || v[18] || v[17] || v[2] || v[1] || v[0]) &&
-      !v[3 ] && !v[4 ] && !v[21] && !v[22] && 
-      !v[25] && !v[24] && !v[7 ] && !v[6 ] && !v[23] && !v[5] && 
-      !v[12] && !v[11] && !v[10] && !v[13] && 
-      !v[8 ] && !v[9 ] && !v[14] && !v[15] && !v[16]) return 1;
-
-  if ((v[21] || v[20] || v[22] || v[17] || v[2] || v[3] || v[4]) &&
-      !v[1 ] && !v[0 ] && !v[19] && !v[18] && 
-      !v[23] && !v[24] && !v[5 ] && !v[6 ] && !v[25] && !v[7] && 
-      !v[12] && !v[11] && !v[10] && !v[13] && 
-      !v[8 ] && !v[9 ] && !v[14] && !v[15] && !v[16]) return 1;
-
-  if ((v[17] || v[22] || v[24] || v[23] || v[4] || v[5] || v[6]) &&
-      !v[2 ] && !v[3 ] && !v[20] && !v[21] && 
-      !v[18] && !v[25] && !v[0 ] && !v[7 ] && !v[19] && !v[1] && 
-      !v[12] && !v[11] && !v[10] && !v[13] && 
-      !v[8 ] && !v[9 ] && !v[14] && !v[15] && !v[16]) return 1;
-
-  if ((v[17] || v[18] || v[24] || v[25] || v[0] || v[7] || v[6]) &&
-      !v[2 ] && !v[1 ] && !v[20] && !v[19] && 
-      !v[22] && !v[23] && !v[4 ] && !v[5 ] && !v[21] && !v[3] && 
-      !v[12] && !v[11] && !v[10] && !v[13] && 
-      !v[8 ] && !v[9 ] && !v[14] && !v[15] && !v[16]) return 1;
-
-  if ((v[9 ] || v[8] || v[16] || v[15] || v[0] || v[7] || v[6]) &&
-      !v[10] && !v[11] && !v[1 ] && !v[2 ] && 
-      !v[13] && !v[14] && !v[4 ] && !v[5 ] && !v[12] && !v[3] && 
-      !v[21] && !v[20] && !v[19] && !v[22] && 
-      !v[17] && !v[18] && !v[23] && !v[24] && !v[25]) return 1;
-
-  if ((v[13] || v[8] || v[14] || v[15] || v[4] || v[5] || v[6]) &&
-      !v[12] && !v[11] && !v[3 ] && !v[2 ] && 
-      !v[9 ] && !v[16] && !v[0 ] && !v[7 ] && !v[10] && !v[1] && 
-      !v[21] && !v[20] && !v[19] && !v[22] && 
-      !v[17] && !v[18] && !v[23] && !v[24] && !v[25]) return 1;
-
-  if ((v[11] || v[10] || v[8] || v[9] || v[2] || v[1] || v[0]) &&
-      !v[12] && !v[13] && !v[3 ] && !v[4 ] && 
-      !v[15] && !v[16] && !v[6 ] && !v[7 ] && !v[14] && !v[5] && 
-      !v[21] && !v[20] && !v[19] && !v[22] && 
-      !v[17] && !v[18] && !v[23] && !v[24] && !v[25]) return 1;
-
-  if ((v[12] || v[11] || v[13] || v[8] || v[3 ] || v[2 ] || v[4 ]) &&
-      !v[10] && !v[9 ] && !v[1 ] && !v[0 ] && 
-      !v[14] && !v[15] && !v[5 ] && !v[6 ] && !v[16] && !v[7] && 
-      !v[21] && !v[20] && !v[19] && !v[22] && 
-      !v[17] && !v[18] && !v[23] && !v[24] && !v[25]) return 1;
-
-  return 0;
-} // match_end()
-
-/* ==================================== */
-int32_t match_vois2(u_int8_t *v)
-/* ==================================== */
-/*
-               12      11      10       
-               13       8       9
-               14      15      16
-
-		3	2	1			
-		4      26	0
-		5	6	7
-Teste si les conditions suivantes sont réunies:
-1: v[8] et v[26] doivent être dans l'objet et simples
-2: for i = 0 to 7 do w[i] = v[i] || v[i+9] ; w[0...7] doit être non 2D-simple
-Si le test réussit, les points 8, 26 sont marqués 2M_CRUCIAL
-*/
-{
-  u_int8_t t;
-#ifdef DEBUG
-  if (trace)
-  {  
-    printf("match_vois2\n");
-    print_vois(v);
-  }
-#endif
-  if (!IS_SIMPLE(v[8]) || !IS_SIMPLE(v[26])) return 0;
-  if (v[0] || v[9]) t = 1; else t = 0;
-  if (v[1] || v[10]) t |= 2;
-  if (v[2] || v[11]) t |= 4;
-  if (v[3] || v[12]) t |= 8;
-  if (v[4] || v[13]) t |= 16;
-  if (v[5] || v[14]) t |= 32;
-  if (v[6] || v[15]) t |= 64;
-  if (v[7] || v[16]) t |= 128;
-  if ((t4b(t) == 1) && (t8(t) == 1)) return 0; // simple 2D
-  SET_2M_CRUCIAL(v[8]);
-  SET_2M_CRUCIAL(v[26]);
-#ifdef DEBUG
-  if (trace)
-    printf("match !\n");
-#endif
-  return 1;
-} // match_vois2()
-
-/* ==================================== */
-int32_t match_vois2s(u_int8_t *v)
-/* ==================================== */
-/*
-               12      11      10       
-               13       8       9
-               14      15      16
-
-		3	2	1			
-		4      26	0
-		5	6	7
-Pour les conditions de courbe et de surface.
-Teste si les deux conditions suivantes sont réunies:
-1: v[8] et v[26] doivent être simples
-2: for i = 0 to 7 do w[i] = v[i] || v[i+9] ; w[0...7] doit être non 2D-simple
-Si le test réussit, alors les points 8, 26 sont marqués 2M_CRUCIAL, de plus:
-  Si t4b(w[0...7]) == 0 alors les points 8, 26 sont marqués SURF
-  Sinon, si t8(w[0...7]) > 1 alors les points 8, 26 sont marqués CURVE
-*/
-{
-  u_int8_t t;
-#ifdef DEBUG
-  if (trace)
-  {  
-    printf("match_vois2s\n");
-    print_vois(v);
-  }
-#endif
-  if (!IS_SIMPLE(v[8]) || !IS_SIMPLE(v[26])) return 0;
-  if (v[0] || v[9]) t = 1; else t = 0;
-  if (v[1] || v[10]) t |= 2;
-  if (v[2] || v[11]) t |= 4;
-  if (v[3] || v[12]) t |= 8;
-  if (v[4] || v[13]) t |= 16;
-  if (v[5] || v[14]) t |= 32;
-  if (v[6] || v[15]) t |= 64;
-  if (v[7] || v[16]) t |= 128;
-  if ((t4b(t) == 1) && (t8(t) == 1)) return 0; // simple 2D
-  SET_2M_CRUCIAL(v[8]);
-  SET_2M_CRUCIAL(v[26]);
-  if (t4b(t) == 0) { SET_SURF(v[8]); SET_SURF(v[26]); }
-  else if (t8(t) > 1) 
-  { 
-    SET_CURVE(v[8]); 
-    SET_CURVE(v[26]); 
-  }
-#ifdef DEBUG
-  if (trace)
-    printf("match !\n");
-#endif
-  return 1;
-} // match_vois2s()
-
-/* ==================================== */
-int32_t match_vois1(u_int8_t *v)
-/* ==================================== */
-// A A  P1 P2  B B
-// A A  P3 P4  B B
-// avec pour localisations possibles :
-// 12 11   3  2   21 20 
-// 13  8   4 26   22 17
-// et :
-// 11 10    2 1   20 19
-//  8  9   26 0   17 18
-//
-// Teste si les trois conditions suivantes sont réunies:
-// 1: (P1 et P4) ou (P2 et P3)
-// 2: tous les points Pi non nuls doivent être simples et non marqués 2M_CRUCIAL
-// 3: A et B sont tous nuls ou [au moins un A non nul et au moins un B non nul]
-// Si le test réussit, les points Pi non nuls sont marques 1M_CRUCIAL
-{
-  int32_t ret = 0;
-#ifdef DEBUG
-  if (trace)
-  {  
-    printf("match_vois1\n");
-    print_vois(v);
-  }
-#endif
-  if (!((v[2] && v[4]) || (v[3] && v[26]))) goto next1;
-  if ((IS_OBJECT(v[2])  && (!IS_SIMPLE(v[2])  || IS_2M_CRUCIAL(v[2]))) ||
-      (IS_OBJECT(v[3])  && (!IS_SIMPLE(v[3])  || IS_2M_CRUCIAL(v[3]))) ||
-      (IS_OBJECT(v[4])  && (!IS_SIMPLE(v[4])  || IS_2M_CRUCIAL(v[4]))) ||
-      (IS_OBJECT(v[26]) && (!IS_SIMPLE(v[26]) || IS_2M_CRUCIAL(v[26])))) goto next1;
-  if ((v[12] || v[11] || v[13] || v[8] || v[21] || v[20] || v[22] || v[17]) &&
-      ((!v[12] && !v[11] && !v[13] && !v[8]) || 
-       (!v[21] && !v[20] && !v[22] && !v[17]))) goto next1;
-  if (v[2])  SET_1M_CRUCIAL(v[2]);
-  if (v[3])  SET_1M_CRUCIAL(v[3]);
-  if (v[4])  SET_1M_CRUCIAL(v[4]);
-  if (v[26]) SET_1M_CRUCIAL(v[26]);
-  ret = 1;
- next1:
-  if (!((v[2] && v[0]) || (v[1] && v[26]))) goto next2;
-  if ((IS_OBJECT(v[2])  && (!IS_SIMPLE(v[2])  || IS_2M_CRUCIAL(v[2]))) ||
-      (IS_OBJECT(v[1])  && (!IS_SIMPLE(v[1])  || IS_2M_CRUCIAL(v[1]))) ||
-      (IS_OBJECT(v[0])  && (!IS_SIMPLE(v[0])  || IS_2M_CRUCIAL(v[0]))) ||
-      (IS_OBJECT(v[26]) && (!IS_SIMPLE(v[26]) || IS_2M_CRUCIAL(v[26])))) goto next2;
-  if ((v[10] || v[11] || v[9] || v[8] || v[19] || v[20] || v[18] || v[17]) &&
-      ((!v[10] && !v[11] && !v[9] && !v[8]) || 
-       (!v[19] && !v[20] && !v[18] && !v[17]))) goto next2;
-  if (v[2])  SET_1M_CRUCIAL(v[2]);
-  if (v[1])  SET_1M_CRUCIAL(v[1]);
-  if (v[0])  SET_1M_CRUCIAL(v[0]);
-  if (v[26]) SET_1M_CRUCIAL(v[26]);
-  ret = 1;
- next2:
-#ifdef DEBUG
-  if (trace && ret)
-    printf("match !\n");
-#endif
-  return ret;
-} // match_vois1()
-
-/* ==================================== */
-int32_t match_vois1s(u_int8_t *v)
-/* ==================================== */
-// A A  P1 P2  B B
-// A A  P3 P4  B B
-// avec pour localisations possibles :
-// 12 11   3  2   21 20 
-// 13  8   4 26   22 17
-// et :
-// 11 10    2 1   20 19
-//  8  9   26 0   17 18
-//
-// Pour la condition de courbe. 
-// Teste si les trois conditions suivantes sont réunies:
-// 1: (P1 et P4) ou (P2 et P3)
-// 2: tous les points Pi non nuls doivent être simples et non 2M_CRUCIAL
-// 3: au moins un A non nul et au moins un B non nul
-// Si le test réussit, les points Pi non nuls sont marques CURVE
-{
-  int32_t ret = 0;
-#ifdef DEBUG
-  if (trace)
-  {  
-    printf("match_vois1\n");
-    print_vois(v);
-  }
-#endif
-  if (!((v[2] && v[4]) || (v[3] && v[26]))) goto next1;
-  if ((IS_OBJECT(v[2])  && (!IS_SIMPLE(v[2]) || IS_2M_CRUCIAL(v[2]))) ||
-      (IS_OBJECT(v[3])  && (!IS_SIMPLE(v[3]) || IS_2M_CRUCIAL(v[3]))) ||
-      (IS_OBJECT(v[4])  && (!IS_SIMPLE(v[4]) || IS_2M_CRUCIAL(v[4]))) ||
-      (IS_OBJECT(v[26]) && (!IS_SIMPLE(v[26]) || IS_2M_CRUCIAL(v[26])))) goto next1;
-  if ((!v[12] && !v[11] && !v[13] && !v[8]) || 
-      (!v[21] && !v[20] && !v[22] && !v[17])) goto next1;
-  if (v[2])  SET_CURVE(v[2]);
-  if (v[3])  SET_CURVE(v[3]);
-  if (v[4])  SET_CURVE(v[4]);
-  if (v[26]) SET_CURVE(v[26]);
-  ret = 1;
- next1:
-  if (!((v[2] && v[0]) || (v[1] && v[26]))) goto next2;
-  if ((IS_OBJECT(v[2])  && (!IS_SIMPLE(v[2]) || IS_2M_CRUCIAL(v[2]))) ||
-      (IS_OBJECT(v[1])  && (!IS_SIMPLE(v[1]) || IS_2M_CRUCIAL(v[1]))) ||
-      (IS_OBJECT(v[0])  && (!IS_SIMPLE(v[0]) || IS_2M_CRUCIAL(v[0]))) ||
-      (IS_OBJECT(v[26]) && (!IS_SIMPLE(v[26]) || IS_2M_CRUCIAL(v[26])))) goto next2;
-  if ((!v[10] && !v[11] && !v[9] && !v[8]) || 
-      (!v[19] && !v[20] && !v[18] && !v[17])) goto next2;
-  if (v[2])  SET_CURVE(v[2]);
-  if (v[1])  SET_CURVE(v[1]);
-  if (v[0])  SET_CURVE(v[0]);
-  if (v[26]) SET_CURVE(v[26]);
-  ret = 1;
- next2:
-#ifdef DEBUG
-  if (trace)
-    printf("match !\n");
-#endif
-  return ret;
-} // match_vois1s()
-
-/* ==================================== */
-int32_t match_vois0(u_int8_t *v)
-/* ==================================== */
-/*
-               12      11
-               13       8
-
-		3	2
-		4      26
-
-Teste si les conditions suivantes sont réunies:
-1: au moins un des ensembles {12,26}, {11,4}, {13,2}, {8,3} est inclus dans l'objet, et
-2: les points non nuls sont tous simples, non marqués 2M_CRUCIAL et non marqués 1M_CRUCIAL
-Si le test réussit, les points non nuls sont marqués 0M_CRUCIAL
-*/
-{
-  u_int8_t t;
-#ifdef DEBUG
-  if (trace)
-  {  
-    printf("match_vois0\n");
-    print_vois(v);
-  }
-#endif
-  if (!((v[12]&&v[26]) || (v[11]&&v[4]) || (v[13]&&v[2]) || (v[8]&&v[3]) )) return 0;
-
-  if (v[12] && (!IS_SIMPLE(v[12]) || IS_2M_CRUCIAL(v[12]) || IS_1M_CRUCIAL(v[12]))) return 0;
-  if (v[26] && (!IS_SIMPLE(v[26]) || IS_2M_CRUCIAL(v[26]) || IS_1M_CRUCIAL(v[26]))) return 0;
-  if (v[11] && (!IS_SIMPLE(v[11]) || IS_2M_CRUCIAL(v[11]) || IS_1M_CRUCIAL(v[11]))) return 0;
-  if (v[ 4] && (!IS_SIMPLE(v[ 4]) || IS_2M_CRUCIAL(v[ 4]) || IS_1M_CRUCIAL(v[ 4]))) return 0;
-  if (v[13] && (!IS_SIMPLE(v[13]) || IS_2M_CRUCIAL(v[13]) || IS_1M_CRUCIAL(v[13]))) return 0;
-  if (v[ 2] && (!IS_SIMPLE(v[ 2]) || IS_2M_CRUCIAL(v[ 2]) || IS_1M_CRUCIAL(v[ 2]))) return 0;
-  if (v[ 8] && (!IS_SIMPLE(v[ 8]) || IS_2M_CRUCIAL(v[ 8]) || IS_1M_CRUCIAL(v[ 8]))) return 0;
-  if (v[ 3] && (!IS_SIMPLE(v[ 3]) || IS_2M_CRUCIAL(v[ 3]) || IS_1M_CRUCIAL(v[ 3]))) return 0;
-
-  if (v[12]) SET_0M_CRUCIAL(v[12]);
-  if (v[26]) SET_0M_CRUCIAL(v[26]);
-  if (v[11]) SET_0M_CRUCIAL(v[11]);
-  if (v[ 4]) SET_0M_CRUCIAL(v[ 4]);
-  if (v[13]) SET_0M_CRUCIAL(v[13]);
-  if (v[ 2]) SET_0M_CRUCIAL(v[ 2]);
-  if (v[ 8]) SET_0M_CRUCIAL(v[ 8]);
-  if (v[ 3]) SET_0M_CRUCIAL(v[ 3]);
-#ifdef DEBUG
-  if (trace)
-    printf("match !\n");
-#endif
-  return 1;
-} // match_vois0()
-
-/* ==================================== */
-int32_t match2(u_int8_t *v)
-/* ==================================== */
-{
-  int32_t i, ret = 0;
-  if (match_vois2(v)) ret = 1;
-  isometrieXZ_vois(v);
-  if (match_vois2(v)) ret = 1;
-  isometrieXZ_vois(v);
-  isometrieYZ_vois(v);
-  if (match_vois2(v)) ret = 1;
-  isometrieYZ_vois(v);
-  return ret;
-} /* match2() */
-
-/* ==================================== */
-int32_t match2s(u_int8_t *v)
-/* ==================================== */
-{
-  int32_t i, ret = 0;
-  if (match_vois2s(v)) ret = 1;
-  isometrieXZ_vois(v);
-  if (match_vois2s(v)) ret = 1;
-  isometrieXZ_vois(v);
-  isometrieYZ_vois(v);
-  if (match_vois2s(v)) ret = 1;
-  isometrieYZ_vois(v);
-  return ret;
-} /* match2s() */
-
-/* ==================================== */
-int32_t match1(u_int8_t *v)
-/* ==================================== */
-{
-  int32_t i, ret = 0;
-  if (match_vois1(v)) ret = 1;
-  isometrieXZ_vois(v);
-  if (match_vois1(v)) ret = 1;
-  isometrieXZ_vois(v);
-  isometrieYZ_vois(v);
-  if (match_vois1(v)) ret = 1;
-  isometrieYZ_vois(v);
-  return ret;
-} /* match1() */
-
-/* ==================================== */
-int32_t match1s(u_int8_t *v)
-/* ==================================== */
-{
-  int32_t i, ret = 0;
-  if (match_vois1s(v)) ret = 1;
-  isometrieXZ_vois(v);
-  if (match_vois1s(v)) ret = 1;
-  isometrieXZ_vois(v);
-  isometrieYZ_vois(v);
-  if (match_vois1s(v)) ret = 1;
-  isometrieYZ_vois(v);
-  return ret;
-} /* match1s() */
-
-/* ==================================== */
-int32_t match0(u_int8_t *v)
-/* ==================================== */
-{
-  int32_t i, ret = 0;
-  if (match_vois0(v)) ret = 1;
-  return ret;
-} /* match0() */
-
-/* ==================================== */
-int32_t lskelMK3(struct xvimage *image, 
-	     int32_t nsteps,
-	     struct xvimage *inhibit)
-/* ==================================== */
-/*
-Squelette symétrique ultime
-Algo MK3 données: S
-Répéter jusqu'à stabilité
-  P := voxels simples pour S
-  R := voxels de P à préserver (match2, match1)
-  T :=  [S  \  P]  \cup  R
-  S := T \cup [S \ (T \oplus \Gamma_26*)]
-*/
-#undef F_NAME
-#define F_NAME "lskelMK3"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t ds = depth(image);       /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  u_int8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  u_int8_t *T = UCHARDATA(t);
-  struct xvimage *r = copyimage(image); 
-  u_int8_t *R = UCHARDATA(r);
-  int32_t step, nonstab;
-  u_int8_t v[27];
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-
-  init_topo3d();
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    // PREMIERE SOUS-ITERATION : MARQUE LES POINTS SIMPLES
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]) && simple26(S, i, rs, ps, N))
-	SET_SIMPLE(S[i]);
-#ifdef DEBUG
-writeimage(image,"_S");
-#endif
-    // DEUXIEME SOUS-ITERATION : MARQUE LES CLIQUES CRUCIALES CORRESPONDANT AUX 2-FACES
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-#ifdef DEBUG
-memset(R, 0, N);
-for (i = 0; i < N; i++) if (IS_2M_CRUCIAL(S[i])) R[i] = 255;
-writeimage(r,"_M2");
-#endif
-
-    // TROISIEME SOUS-ITERATION : MARQUE LES CLIQUES CRUCIALES CORRESPONDANT AUX 1-FACES
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-#ifdef DEBUG
-printf("%d %d %d\n", i % rs, (i % ps) / rs, i / ps);
-#endif
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-#ifdef DEBUG
-memset(R, 0, N);
-for (i = 0; i < N; i++) if (IS_1M_CRUCIAL(S[i])) R[i] = 255;
-writeimage(r,"_M1");
-#endif
-
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) // T := [S \ P] \cup  R, où R représente les pts marqués
-      if ((S[i] && !IS_SIMPLE(S[i])) || IS_2M_CRUCIAL(S[i]) || IS_1M_CRUCIAL(S[i]))
-	T[i] = 1;
-#ifdef DEBUG
-writeimage(t,"_T");
-#endif
-
-    memset(R, 0, N);
-    for (i = 0; i < N; i++)
-      if (nbvoiso26(T, i, rs, ps, N) >= 1) R[i] = 1; // calcule R = Dilat(T)
-    for (i = 0; i < N; i++)
-      if (T[i] || (S[i] && !R[i])) T[i] = 1; else T[i] = 0; // T := T \cup [S \ R]
-
-    for (i = 0; i < N; i++)
-      if (S[i] && !T[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 255; // normalize values
-
-  freeimage(t);
-  freeimage(r);
-  termine_topo3d();
-  return(1);
-} /* lskelMK3() */
-
-/* ==================================== */
-int32_t lskelEK3(struct xvimage *image, 
-	     int32_t nsteps,
-	     struct xvimage *inhibit)
-/* ==================================== */
-/*
-Squelette symétrique curviligne basé sur les extrémités
-Algo EK3 données: S
-Répéter jusqu'à stabilité
-  E := points extrémité de S
-  P := voxels simples pour S et pas dans E
-  C2 := voxels 2M-cruciaux (match2)
-  C1 := voxels 1M-cruciaux (match1)
-  C0 := voxels 0M-cruciaux (match0)
-  P := P  \  [C2 \cup C1 \cup C0]
-  S := S \ P
-*/
-#undef F_NAME
-#define F_NAME "lskelEK3"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t ds = depth(image);       /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  u_int8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  u_int8_t *T = UCHARDATA(t);
-  u_int8_t *I;
-  int32_t step, nonstab;
-  int32_t top, topb;
-  u_int8_t v[27];
-
-  if (inhibit == NULL) 
-  {
-    inhibit = copyimage(image); 
-    razimage(inhibit);
-  }
-  I = UCHARDATA(inhibit);
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-
-  init_topo3d();
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    // AJOUTE LES EXTREMITES DANS I
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match_end(v)) I[i] = 1;
-      }
-
-    // MARQUE LES POINTS SIMPLES NON DANS I
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]) && !I[i] && simple26(S, i, rs, ps, N))
-	SET_SIMPLE(S[i]);
-
-    // MARQUE LES POINTS 2M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 1M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 0M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match0(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) // T := [S \ P] \cup M, où M représente les pts marqués
-      if ((S[i] && !IS_SIMPLE(S[i])) || IS_2M_CRUCIAL(S[i]) || IS_1M_CRUCIAL(S[i]) || IS_0M_CRUCIAL(S[i]))
-	T[i] = 1;
-#ifdef DEBUG
-writeimage(t,"_T");
-#endif
-
-    for (i = 0; i < N; i++)
-      if (S[i] && !T[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 255; // normalize values
-
-  freeimage(t);
-  termine_topo3d();
-  return(1);
-} /* lskelEK3() */
-
-/* ==================================== */
-int32_t lskelCK3(struct xvimage *image, 
-	     int32_t nsteps,
-	     struct xvimage *inhibit)
-/* ==================================== */
-/*
-Squelette symétrique curviligne
-Algo CK3 données: S
-Répéter jusqu'à stabilité
-  C := points de courbe de S
-  I := I \cup C
-  P := voxels simples pour S et pas dans I
-  C2 := voxels 2M-cruciaux (match2)
-  C1 := voxels 1M-cruciaux (match1)
-  C0 := voxels 0M-cruciaux (match0)
-  P := P  \  [C2 \cup C1 \cup C0]
-  S := S \ P
-*/
-#undef F_NAME
-#define F_NAME "lskelCK3"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t ds = depth(image);       /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  u_int8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  u_int8_t *T = UCHARDATA(t);
-  u_int8_t *I;
-  int32_t step, nonstab;
-  int32_t top, topb;
-  u_int8_t v[27];
-
-  if (inhibit == NULL) 
-  {
-    inhibit = copyimage(image); 
-    razimage(inhibit);
-  }
-  I = UCHARDATA(inhibit);
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-
-  init_topo3d();
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    // MARQUE LES POINTS SIMPLES NON DANS I
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]) && !I[i] && simple26(S, i, rs, ps, N))
-	SET_SIMPLE(S[i]);
-    // DEUXIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE (2)
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2s(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // TROISIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE (1)
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1s(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS DE COURBE (3)
-    for (i = 0; i < N; i++)
-    {
-      if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
-      {    
-	top26(S, i, rs, ps, N, &top, &topb);
-	if (top > 1) SET_CURVE(S[i]);
-      }
-    }
-    // DEMARQUE PTS DE COURBE ET LES MEMORISE DANS I
-    for (i = 0; i < N; i++)
-    { 
-      UNSET_2M_CRUCIAL(S[i]);
-      if (IS_CURVE(S[i])) { UNSET_SIMPLE(S[i]); I[i] = 1; }
-    }
-    // MARQUE LES POINTS 2M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 1M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 0M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match0(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) // T := [S \ P] \cup M, où M représente les pts marqués
-      if ((S[i] && !IS_SIMPLE(S[i])) || IS_2M_CRUCIAL(S[i]) || IS_1M_CRUCIAL(S[i]) || IS_0M_CRUCIAL(S[i]))
-	T[i] = 1;
-#ifdef DEBUG
-writeimage(t,"_T");
-#endif
-
-    for (i = 0; i < N; i++)
-      if (S[i] && !T[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 255; // normalize values
-
-  freeimage(t);
-  termine_topo3d();
-  return(1);
-} /* lskelCK3() */
-
-/* ==================================== */
-int32_t lskelCK3b(struct xvimage *image, 
-	     int32_t nsteps,
-	     struct xvimage *inhibit)
-/* ==================================== */
-/*
-Squelette symétrique curviligne
-Variante avec reconstruction des points extrémités
-Algo CK3b données: S
-Répéter jusqu'à stabilité
-  C := points de courbe de S
-  E := points extrémités de S
-  C := C union [E inter gamma(C)] 
-  I := I \cup C
-  P := voxels simples pour S et pas dans I
-  C2 := voxels 2M-cruciaux (match2)
-  C1 := voxels 1M-cruciaux (match1)
-  C0 := voxels 0M-cruciaux (match0)
-  P := P  \  [C2 \cup C1 \cup C0]
-  S := S \ P
-*/
-#undef F_NAME
-#define F_NAME "lskelCK3"
-{ 
-  int32_t i, j, k, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t ds = depth(image);       /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  u_int8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  u_int8_t *T = UCHARDATA(t);
-  struct xvimage *e = copyimage(image); 
-  u_int8_t *E = UCHARDATA(e);
-  u_int8_t *I;
-  int32_t step, nonstab;
-  int32_t top, topb;
-  u_int8_t v[27];
-
-  if (inhibit == NULL) 
-  {
-    inhibit = copyimage(image); 
-    razimage(inhibit);
-  }
-  I = UCHARDATA(inhibit);
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-
-  init_topo3d();
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    // AJOUTE LES EXTREMITES DANS E
-    memset(E, 0, N);
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match_end(v)) E[i] = 1;
-      }
-    // MARQUE LES POINTS SIMPLES NON DANS I
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]) && !I[i] && simple26(S, i, rs, ps, N))
-	SET_SIMPLE(S[i]);
-    // DEUXIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE (2)
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2s(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // TROISIEME SOUS-ITERATION : MARQUE LES POINTS DE COURBE (1)
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1s(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS DE COURBE (3)
-    for (i = 0; i < N; i++)
-    {
-      if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
-      {    
-	top26(S, i, rs, ps, N, &top, &topb);
-	if (top > 1) SET_CURVE(S[i]);
-      }
-    }
-
-    // DEMARQUE PTS DE COURBE ET LES MEMORISE DANS I
-    // AJOUTE AUX POINTS DE COURBE LEURS VOISINS QUI SONT DANS E
-    for (i = 0; i < N; i++)
-    { 
-      UNSET_2M_CRUCIAL(S[i]);
-      if (IS_CURVE(S[i])) 
-      {
-        for (k = 0; k < 26; k += 1)        /* parcourt les voisins en 26-connexite */
-        {
-          j = voisin26(i, k, rs, ps, N);
-          if ((j != -1) && E[j])
-	  {
-	    UNSET_SIMPLE(S[j]); 
-	    I[j] = 1; 
-	  }
-	}
-	UNSET_SIMPLE(S[i]); 
-	I[i] = 1; 
-      }
-    }
-    // MARQUE LES POINTS 2M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 1M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 0M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match0(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) // T := [S \ P] \cup M, où M représente les pts marqués
-      if ((S[i] && !IS_SIMPLE(S[i])) || IS_2M_CRUCIAL(S[i]) || IS_1M_CRUCIAL(S[i]) || IS_0M_CRUCIAL(S[i]))
-	T[i] = 1;
-#ifdef DEBUG
-writeimage(t,"_T");
-#endif
-
-    for (i = 0; i < N; i++)
-      if (S[i] && !T[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 255; // normalize values
-
-  freeimage(t);
-  freeimage(e);
-  termine_topo3d();
-  return(1);
-} /* lskelCK3b() */
-
-/* ==================================== */
-int32_t lskelCK3c(struct xvimage *image, 
-	     int32_t nsteps,
-	     struct xvimage *inhibit)
-/* ==================================== */
-/*
-Squelette symétrique curviligne, variante
-Les points "candidats" à devenir des points de courbes sont les
-points qui ne sont pas voisins d'un point isthme 2D ni d'un point interieur
-Algo CK3c données: S
-Répéter jusqu'à stabilité
-  C := points de courbe de S
-  P := voxels simples pour S et pas dans C
-  C2 := voxels 2M-cruciaux (match2)
-  C1 := voxels 1M-cruciaux (match1)
-  C0 := voxels 0M-cruciaux (match0)
-  P := P  \  [C2 \cup C1 \cup C0]
-  S := S \ P
-*/
-#undef F_NAME
-#define F_NAME "lskelCK3c"
-{ 
-  int32_t i, j, k, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t ds = depth(image);       /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  u_int8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  u_int8_t *T = UCHARDATA(t);
-  u_int8_t *I;
-  int32_t step, nonstab;
-  int32_t top, topb;
-  u_int8_t v[27];
-
-  if (inhibit == NULL) 
-  {
-    inhibit = copyimage(image); 
-    razimage(inhibit);
-  }
-  I = UCHARDATA(inhibit);
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-
-  init_topo3d();
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    // MARQUE LES POINTS SIMPLES NON DANS I
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]) && !I[i] && simple26(S, i, rs, ps, N))
-	SET_SIMPLE(S[i]);
-    // MARQUE LES POINTS DE SURFACE (2)
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2s(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS DE SURFACE (3) ET LES POINTS INTERIEURS
-    for (i = 0; i < N; i++)
-    {
-      if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
-      {    
-	top26(S, i, rs, ps, N, &top, &topb);
-	if (topb > 1) SET_SURF(S[i]);
-	if (topb == 0) SET_SELECTED(S[i]);
-      }
-    }
-
-    // DEMARQUE PTS ET REND "NON-SIMPLES" LES CANDIDATS
-    for (i = 0; i < N; i++)
-    { 
-      UNSET_2M_CRUCIAL(S[i]);
-      if (IS_OBJECT(S[i])) 
-      {
-        for (k = 0; k < 26; k += 1)        /* parcourt les voisins en 26-connexite */
-        {
-          j = voisin26(i, k, rs, ps, N);
-          if ((j != -1) && (IS_SURF(S[j]) || IS_SELECTED(S[j])))break;
-	}
-	if (k == 26) UNSET_SIMPLE(S[i]);
-#ifdef PASBON
-        for (k = 0; k < 12; k += 2)        /* parcourt les voisins en 6-connexite */
-        {
-          j = voisin6(i, k, rs, ps, N);
-          if ((j != -1) && IS_SURF(S[j])) break;
-	}
-	if (k == 12) UNSET_SIMPLE(S[i]);
-#endif
-      }
-    }
-    // MARQUE LES POINTS 2M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 1M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 0M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match0(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) // T := [S \ P] \cup M, où M représente les pts marqués
-      if ((S[i] && !IS_SIMPLE(S[i])) || IS_2M_CRUCIAL(S[i]) || IS_1M_CRUCIAL(S[i]) || IS_0M_CRUCIAL(S[i]))
-	T[i] = 1;
-#ifdef DEBUG
-writeimage(t,"_T");
-#endif
-
-    for (i = 0; i < N; i++)
-      if (S[i] && !T[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 255; // normalize values
-
-  freeimage(t);
-  termine_topo3d();
-  return(1);
-} /* lskelCK3c() */
-
-/* ==================================== */
-int32_t lskelAK3(struct xvimage *image, 
-	     int32_t nsteps,
-	     struct xvimage *inhibit,
-	     int32_t filter)
-/* ==================================== */
-/*
-Amincissement symétrique avec inclusion de l'axe médian
-
-A REVOIR : 
-- pb des "échancrures"
-- si on filtre l'axe médian alors l'homotopie n'est plus garantie ?
-(cf. prop. sur les 0-cliques cruciales)
-
-Algo AK3 données: S
-K := \emptyset ; T := S
-Répéter jusqu'à stabilité
-  E := T \ominus \Gamma_6
-  D := T \ [E \oplus \Gamma_6]
-  T := E
-  K := K \cup D
-  P := voxels de S \ K simples pour S
-  R := voxels de P qui s'apparient avec le masque C (bertrand_match3)
-  S := [S  \  P]  \cup  R
-*/
-#undef F_NAME
-#define F_NAME "lskelAK3"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t ds = depth(image);       /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  u_int8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  u_int8_t *T = UCHARDATA(t);
-  struct xvimage *r = copyimage(image); 
-  u_int8_t *R = UCHARDATA(r);
-  struct xvimage *e = copyimage(image); 
-  u_int8_t *E = UCHARDATA(e);
-  struct xvimage *d = copyimage(image); 
-  u_int8_t *D = UCHARDATA(d);
-  struct xvimage *k = copyimage(image); 
-  u_int8_t *K = UCHARDATA(k);
-  int32_t step, nonstab;
-  u_int8_t v[27];
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image not implemented\n", F_NAME);
-    return 0;
-  }
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 1; // normalize values
-
-  init_topo3d();
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  // K := \emptyset ; T := S
-  memset(K, 0, N);
-  memcpy(T, S, N);
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    //  E := T \ominus \Gamma_6 
-    memset(E, 0, N);
-    for (i = 0; i < N; i++) 
-      if (T[i] && (nbvoiso6(T, i, rs, ps, N) == 6)) E[i] = 1;
-
-    //  D := E \oplus \Gamma_6
-    memset(D, 0, N);
-    for (i = 0; i < N; i++)
-      if (E[i] || (nbvoiso6(E, i, rs, ps, N) >= 1)) D[i] = 1;
-
-    //  D := T \ D
-    for (i = 0; i < N; i++)
-      if (T[i] && !D[i]) D[i] = 1; else D[i] = 0;
-
-    //  T := E
-    memcpy(T, E, N);
-
-    //  K := K \cup D
-    for (i = 0; i < N; i++)
-      if (D[i]) K[i] = 1;
-
-    // PREMIERE SOUS-ITERATION : MARQUE LES POINTS SIMPLES qui ne sont pas dans K
-    if (step > filter)
-    {
-      for (i = 0; i < N; i++) 
-	if (S[i] && !K[i] && simple26(S, i, rs, ps, N))
-	  SET_SIMPLE(S[i]);
-    }
-    else
-    {
-      for (i = 0; i < N; i++) 
-	if (S[i] && simple26(S, i, rs, ps, N))
-	  SET_SIMPLE(S[i]);
-    }
-
-    // DEUXIEME SOUS-ITERATION : MARQUE LES CLIQUES CRUCIALES CORRESPONDANT AUX 2-FACES
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    // TROISIEME SOUS-ITERATION : MARQUE LES CLIQUES CRUCIALES CORRESPONDANT AUX 1-FACES
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1(v))
-	  //if (match1s(v))  // VARIANTE POUR EVITER LES "ECHANCRURES" (à voir)
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    // D := [S \ P] \cup  R, où R représente les pts marqués
-    memset(D, 0, N);
-    for (i = 0; i < N; i++) 
-      if ((S[i] && !IS_SIMPLE(S[i])) || IS_2M_CRUCIAL(S[i]) || IS_1M_CRUCIAL(S[i]))
-	D[i] = 1;
-
-    for (i = 0; i < N; i++) // pour  tester la stabilité
-      if (S[i] && !D[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = 1;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 255; // normalize values
-
-  freeimage(t);
-  freeimage(r);
-  freeimage(e);
-  freeimage(d);
-  freeimage(k);
-  termine_topo3d();
-  return(1);
-} /* lskelAK3() */
-
-/* ==================================== */
-int32_t lskelMK3c(struct xvimage *image, 
-	     int32_t nsteps,
-	     struct xvimage *inhibit)
-/* ==================================== */
-/*
-Squelette symétrique ultime avec ensemble de contrainte
-Version révisée d'après le papier IWCIA 2006
-Algo MK3c données: S
-Répéter jusqu'à stabilité
-  P := voxels simples pour S et non dans I
-  C2 := voxels 2M-cruciaux (match2)
-  C1 := voxels 1M-cruciaux (match1)
-  C0 := voxels 0M-cruciaux (match0)
-  P := P  \  [C2 \cup C1 \cup C0]
-  S := S \ P
-*/
-#undef F_NAME
-#define F_NAME "lskelMK3c"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t ds = depth(image);       /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  u_int8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  u_int8_t *T = UCHARDATA(t);
-  u_int8_t *I = NULL;
-  int32_t step, nonstab;
-  u_int8_t v[27];
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-
-  if (inhibit != NULL) I = UCHARDATA(inhibit);
-
-  init_topo3d();
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("MK3b step %d\n", step);
-#endif
-
-    // PREMIERE SOUS-ITERATION : MARQUE LES POINTS SIMPLES ET PAS DANS I
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]) && simple26(S, i, rs, ps, N) && (!I || !I[i]))
-	SET_SIMPLE(S[i]);
-#ifdef DEBUG
-writeimage(image,"_S");
-#endif
-    // DEUXIEME SOUS-ITERATION : MARQUE LES POINTS 2M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-#ifdef DEBUG
-memset(R, 0, N);
-for (i = 0; i < N; i++) if (IS_2M_CRUCIAL(S[i])) R[i] = 255;
-writeimage(r,"_C2");
-#endif
-
-    // TROISIEME SOUS-ITERATION : MARQUE LES POINTS 1M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-#ifdef DEBUG
-printf("%d %d %d\n", i % rs, (i % ps) / rs, i / ps);
-#endif
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-#ifdef DEBUG
-memset(R, 0, N);
-for (i = 0; i < N; i++) if (IS_1M_CRUCIAL(S[i])) R[i] = 255;
-writeimage(r,"_C1");
-#endif
-
-    // QUATRIEME SOUS-ITERATION : MARQUE LES POINTS 0M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-#ifdef DEBUG
-printf("%d %d %d\n", i % rs, (i % ps) / rs, i / ps);
-#endif
-	extract_vois(S, i, rs, ps, N, v);
-	if (match0(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-#ifdef DEBUG
-memset(R, 0, N);
-for (i = 0; i < N; i++) if (IS_0M_CRUCIAL(S[i])) R[i] = 255;
-writeimage(r,"_C0");
-#endif
-
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) // T := [S \ P] \cup  R, où R représente les pts marqués
-      if ((S[i] && !IS_SIMPLE(S[i])) || IS_2M_CRUCIAL(S[i]) || IS_1M_CRUCIAL(S[i]) || IS_0M_CRUCIAL(S[i]))
-	T[i] = 1;
-#ifdef DEBUG
-writeimage(t,"_T");
-#endif
-
-    for (i = 0; i < N; i++)
-      if (S[i] && !T[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 255; // normalize values
-
-  freeimage(t);
-  termine_topo3d();
-  return(1);
-} /* lskelMK3c() */
-
-/* ==================================== */
-int32_t ldistaxetopo3(struct xvimage *image, 
-		      struct xvimage *inhibit,
-		      struct xvimage *res)
-/* ==================================== */
-/*
-Idem squelette symétrique ultime (algo MK3).
-Marque les points (dans res) par le nombre d'itérations nécessaires à leur enlèvement.
-Les points non enlevés sont marqués MARK_INFTY.
-Retourne dans image l'axe topologique.
-*/
-#undef F_NAME
-#define F_NAME "ldistaxetopo3"
-     //#define MARK_INFTY 2000000000
-#define MARK_INFTY 255
-{ 
-  int32_t i, j, k, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t ds = depth(image);       /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  u_int8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  u_int8_t *T = UCHARDATA(t);
-  struct xvimage *r = copyimage(image); 
-  u_int8_t *R = UCHARDATA(r);
-  u_int32_t *O = ULONGDATA(res); 
-  int32_t step, nonstab, minvois;
-  u_int8_t v[27];
-  
-  if ((rowsize(res) != rs) || (colsize(res) != cs) || (depth(res) != ds))
-  {
-    fprintf(stderr, "%s: incompatible image sizes\n", F_NAME);
-    exit(0);
-  }
-  if (datatype(image) != VFF_TYP_1_BYTE)
-  {
-    fprintf(stderr, "%s: image type must be u_int8_t\n", F_NAME);
-    return(0);
-  }
-  if (datatype(res) != VFF_TYP_4_BYTE)
-  {
-    fprintf(stderr, "%s: result type must be u_int32_t\n", F_NAME);
-    return(0);
-  }
-
-  if (inhibit != NULL)
-  {
-    fprintf(stderr, "%s: inhibit image not yet implemented\n", F_NAME);
-    return 0;
-  }
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  for (i = 0; i < N; i++) if (S[i]) O[i] = MARK_INFTY; else O[i] = 0;
-
-  init_topo3d();
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab)
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    // PREMIERE SOUS-ITERATION : MARQUE LES POINTS SIMPLES
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]) && simple26(S, i, rs, ps, N))
-	SET_SIMPLE(S[i]);
-    // DEUXIEME SOUS-ITERATION : MARQUE LES CLIQUES CRUCIALES CORRESPONDANT AUX 2-FACES
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match2(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // TROISIEME SOUS-ITERATION : MARQUE LES CLIQUES CRUCIALES CORRESPONDANT AUX 1-FACES
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (match1(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) // T := [S \ P] \cup  R, où R représente les pts marqués
-      if ((S[i] && !IS_SIMPLE(S[i])) || IS_2M_CRUCIAL(S[i]) || IS_1M_CRUCIAL(S[i]))
-	T[i] = 1;
-    memset(R, 0, N);
-    for (i = 0; i < N; i++)
-      if (nbvoiso26(T, i, rs, ps, N) >= 1) R[i] = 1; // calcule R = Dilat(T)
-    for (i = 0; i < N; i++)
-      if (T[i] || (S[i] && !R[i])) T[i] = 1; else T[i] = 0; // T := T \cup [S \ R]
-
-    for (i = 0; i < N; i++)
-      if (S[i] && !T[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-	O[i] = step;
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  } // while (nonstab)
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  // CALCUL AXE TOPOLOGIQUE
-  memset(S, 0, N);
-  for (i = 0; i < N; i++) if (O[i] > 0)
-  {
-    if (O[i] == MARK_INFTY)
-      S[i] = 255;
-    else
-    {
-      minvois = MARK_INFTY;
-#define VOISIN26
-#ifdef VOISIN6
-      for (k = 0; k <= 10; k += 2)        /* parcourt les voisins en 6-connexite */
-      {
-	j = voisin6(i, k, rs, ps, N);
-	if ((j != -1) && (O[j] > 0) && (O[j] < minvois)) minvois = O[j];
-      }
-#endif
-#ifdef VOISIN26
-      for (k = 0; k < 26; k += 1)        /* parcourt les voisins en 26-connexite */
-      {
-	j = voisin26(i, k, rs, ps, N);
-	if ((j != -1) && (O[j] > 0) && (O[j] < minvois)) minvois = O[j];
-      }
-#endif
-      if ((O[i] - minvois) > 1)  S[i] = 255;
-    }
-  }
-
-  freeimage(t);
-  freeimage(r);
-  termine_topo3d();
-  return(1);
-} /* ldistaxetopo3() */
-
-#ifdef TEST
-int32_t main()
-{
-  u_int8_t V[27] = {
-    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
-    10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
-    20, 21, 22, 23, 24, 25, 26
-  };
-
-  print_vois(V);
-  isometrieYZ_vois(V);
-  print_vois(V);
-  isometrieYZ_vois(V);
-  print_vois(V);
-  isometrieXZ_vois(V);
-  print_vois(V);
-  isometrieXZ_vois(V);
-  print_vois(V);
-}
-#endif
-
-
-// ===================================================================
-// ===================================================================
-// VERSIONS ASYMETRIQUES
-// ===================================================================
-// ===================================================================
-
-/* ==================================== */
-int32_t asym_match_vois2(u_int8_t *v)
-/* ==================================== */
-/*
-               12      11      10       
-               13       8       9
-               14      15      16
-
-		3	2	1			
-		4      26	0
-		5	6	7
-Teste si les conditions suivantes sont réunies:
-1: v[8] et v[26] doivent être dans l'objet et simples
-2: for i = 0 to 7 do w[i] = v[i] || v[i+9] ; w[0...7] doit être non 2D-simple
-Si le test réussit, le point 8 est marqué 2M_CRUCIAL
-*/
-{
-  u_int8_t t;
-  if (!IS_SIMPLE(v[8]) || !IS_SIMPLE(v[26]) || IS_SELECTED(v[8]) || IS_SELECTED(v[26])) return 0;
-  if (v[0] || v[9]) t = 1; else t = 0;
-  if (v[1] || v[10]) t |= 2;
-  if (v[2] || v[11]) t |= 4;
-  if (v[3] || v[12]) t |= 8;
-  if (v[4] || v[13]) t |= 16;
-  if (v[5] || v[14]) t |= 32;
-  if (v[6] || v[15]) t |= 64;
-  if (v[7] || v[16]) t |= 128;
-  if ((t4b(t) == 1) && (t8(t) == 1)) return 0; // simple 2D
-  SET_SELECTED(v[8]);
-  return 1;
-} // asym_match_vois2()
-
-/* ==================================== */
-int32_t asym_match_vois1(u_int8_t *v)
-/* ==================================== */
-// A A  P1 P2  B B
-// A A  P3 P4  B B
-// avec pour localisations possibles :
-// 12 11   3  2   21 20 
-// 13  8   4 26   22 17
-// et :
-// 11 10    2 1   20 19
-//  8  9   26 0   17 18
-//
-// Teste si les trois conditions suivantes sont réunies:
-// 1: (P1 et P4) ou (P2 et P3)
-// 2: tous les points Pi non nuls doivent être simples et non marqués 2M_CRUCIAL
-// 3: A et B sont tous nuls ou [au moins un A non nul et au moins un B non nul]
-// Si le test réussit, un des points Pi non nuls est marqué 1M_CRUCIAL
-{
-  int32_t ret = 0;
-  if (!((v[2] && v[4]) || (v[3] && v[26]))) goto next1;
-  if ((IS_OBJECT(v[2])  && (!IS_SIMPLE(v[2])  || IS_SELECTED(v[2]))) ||
-      (IS_OBJECT(v[3])  && (!IS_SIMPLE(v[3])  || IS_SELECTED(v[3]))) ||
-      (IS_OBJECT(v[4])  && (!IS_SIMPLE(v[4])  || IS_SELECTED(v[4]))) ||
-      (IS_OBJECT(v[26]) && (!IS_SIMPLE(v[26]) || IS_SELECTED(v[26])))) goto next1;
-  if ((v[12] || v[11] || v[13] || v[8] || v[21] || v[20] || v[22] || v[17]) &&
-      ((!v[12] && !v[11] && !v[13] && !v[8]) || 
-       (!v[21] && !v[20] && !v[22] && !v[17]))) goto next1;
-  if (v[2])  SET_SELECTED(v[2]);
-  else if (v[3])  SET_SELECTED(v[3]);
-  else if (v[4])  SET_SELECTED(v[4]);
-  else if (v[26]) SET_SELECTED(v[26]);
-  ret = 1;
- next1:
-  if (!((v[2] && v[0]) || (v[1] && v[26]))) goto next2;
-  if ((IS_OBJECT(v[2])  && (!IS_SIMPLE(v[2])  || IS_SELECTED(v[2]))) ||
-      (IS_OBJECT(v[1])  && (!IS_SIMPLE(v[1])  || IS_SELECTED(v[1]))) ||
-      (IS_OBJECT(v[0])  && (!IS_SIMPLE(v[0])  || IS_SELECTED(v[0]))) ||
-      (IS_OBJECT(v[26]) && (!IS_SIMPLE(v[26]) || IS_SELECTED(v[26])))) goto next2;
-  if ((v[10] || v[11] || v[9] || v[8] || v[19] || v[20] || v[18] || v[17]) &&
-      ((!v[10] && !v[11] && !v[9] && !v[8]) || 
-       (!v[19] && !v[20] && !v[18] && !v[17]))) goto next2;
-  if (v[2])  SET_SELECTED(v[2]);
-  else if (v[1])  SET_SELECTED(v[1]);
-  else if (v[0])  SET_SELECTED(v[0]);
-  else if (v[26]) SET_SELECTED(v[26]);
-  ret = 1;
- next2:
-  return ret;
-} // asym_match_vois1()
-
-/* ==================================== */
-int32_t asym_match_vois0(u_int8_t *v)
-/* ==================================== */
-/*
-               12      11
-               13       8
-
-		3	2
-		4      26
-
-Teste si les conditions suivantes sont réunies:
-1: au moins un des ensembles {12,26}, {11,4}, {13,2}, {8,3} est inclus dans l'objet, et
-2: les points non nuls sont tous simples, non marqués 2M_CRUCIAL et non marqués 1M_CRUCIAL
-Si le test réussit, les points non nuls sont marqués 0M_CRUCIAL
-*/
-{
-  u_int8_t t;
-  if (!((v[12]&&v[26]) || (v[11]&&v[4]) || (v[13]&&v[2]) || (v[8]&&v[3]) )) return 0;
-
-  if (v[12] && (!IS_SIMPLE(v[12]) || IS_SELECTED(v[12]))) return 0;
-  if (v[26] && (!IS_SIMPLE(v[26]) || IS_SELECTED(v[26]))) return 0;
-  if (v[11] && (!IS_SIMPLE(v[11]) || IS_SELECTED(v[11]))) return 0;
-  if (v[ 4] && (!IS_SIMPLE(v[ 4]) || IS_SELECTED(v[ 4]))) return 0;
-  if (v[13] && (!IS_SIMPLE(v[13]) || IS_SELECTED(v[13]))) return 0;
-  if (v[ 2] && (!IS_SIMPLE(v[ 2]) || IS_SELECTED(v[ 2]))) return 0;
-  if (v[ 8] && (!IS_SIMPLE(v[ 8]) || IS_SELECTED(v[ 8]))) return 0;
-  if (v[ 3] && (!IS_SIMPLE(v[ 3]) || IS_SELECTED(v[ 3]))) return 0;
-
-  if (v[12]) SET_SELECTED(v[12]);
-  else if (v[26]) SET_SELECTED(v[26]);
-  else if (v[11]) SET_SELECTED(v[11]);
-  else if (v[ 4]) SET_SELECTED(v[ 4]);
-  else if (v[13]) SET_SELECTED(v[13]);
-  else if (v[ 2]) SET_SELECTED(v[ 2]);
-  else if (v[ 8]) SET_SELECTED(v[ 8]);
-  else if (v[ 3]) SET_SELECTED(v[ 3]);
-  return 1;
-} // asym_match_vois0()
-
-/* ==================================== */
-int32_t asym_match2(u_int8_t *v)
-/* ==================================== */
-{
-  int32_t i, ret = 0;
-  if (asym_match_vois2(v)) ret = 1;
-  isometrieXZ_vois(v);
-  if (asym_match_vois2(v)) ret = 1;
-  isometrieXZ_vois(v);
-  isometrieYZ_vois(v);
-  if (asym_match_vois2(v)) ret = 1;
-  isometrieYZ_vois(v);
-  return ret;
-} /* asym_match2() */
-
-/* ==================================== */
-int32_t asym_match1(u_int8_t *v)
-/* ==================================== */
-{
-  int32_t i, ret = 0;
-  if (asym_match_vois1(v)) ret = 1;
-  isometrieXZ_vois(v);
-  if (asym_match_vois1(v)) ret = 1;
-  isometrieXZ_vois(v);
-  isometrieYZ_vois(v);
-  if (asym_match_vois1(v)) ret = 1;
-  isometrieYZ_vois(v);
-  return ret;
-} /* asym_match1() */
-
-/* ==================================== */
-int32_t asym_match0(u_int8_t *v)
-/* ==================================== */
-{
-  int32_t i, ret = 0;
-  if (asym_match_vois0(v)) ret = 1;
-  return ret;
-} /* asym_match0() */
-
-/* ==================================== */
-int32_t lskelAMK3c(struct xvimage *image, 
-		   int32_t nsteps,
-		   struct xvimage *inhibit)
-/* ==================================== */
-/*
-Squelette asymétrique ultime avec ensemble de contrainte
-Algo AMK3c données: S
-Répéter jusqu'à stabilité
-  P := voxels simples pour S et non dans I
-  C2 := voxels 2M-cruciaux (asym_match2)
-  C1 := voxels 1M-cruciaux (asym_match1)
-  C0 := voxels 0M-cruciaux (asym_match0)
-  P := P  \  [C2 \cup C1 \cup C0]
-  S := S \ P
-*/
-#undef F_NAME
-#define F_NAME "lskelAMK3c"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t ds = depth(image);       /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  u_int8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  u_int8_t *T = UCHARDATA(t);
-  u_int8_t *I = NULL;
-  int32_t step, nonstab;
-  u_int8_t v[27];
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-
-  if (inhibit != NULL) I = UCHARDATA(inhibit);
-
-  init_topo3d();
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("AMK3b step %d\n", step);
-#endif
-
-    // PREMIERE SOUS-ITERATION : MARQUE LES POINTS SIMPLES ET PAS DANS I
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]) && simple26(S, i, rs, ps, N) && (!I || !I[i]))
-	SET_SIMPLE(S[i]);
-
-    // DEUXIEME SOUS-ITERATION : MARQUE LES POINTS 2M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (asym_match2(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    // TROISIEME SOUS-ITERATION : MARQUE LES POINTS 1M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (asym_match1(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    // QUATRIEME SOUS-ITERATION : MARQUE LES POINTS 0M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (asym_match0(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) // T := [S \ P] \cup  R, où R représente les pts marqués
-      if ((S[i] && !IS_SIMPLE(S[i])) || IS_SELECTED(S[i]))
-	T[i] = 1;
-
-    for (i = 0; i < N; i++)
-      if (S[i] && !T[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 255; // normalize values
-
-  freeimage(t);
-  termine_topo3d();
-  return(1);
-} /* lskelAMK3c() */
-
-
-/* ==================================== */
-int32_t lskelACK3(struct xvimage *image, 
-	     int32_t nsteps,
-	     struct xvimage *inhibit)
-/* ==================================== */
-/*
-Squelette asymétrique curviligne
-Algo ACK3 données: S
-Répéter jusqu'à stabilité
-  C := points de courbe de S
-  I := I \cup C
-  P := voxels simples pour S et pas dans I
-  C2 := voxels 2M-cruciaux (asym_match2)
-  C1 := voxels 1M-cruciaux (asym_match1)
-  C0 := voxels 0M-cruciaux (asym_match0)
-  P := P  \  [C2 \cup C1 \cup C0]
-  S := S \ P
-*/
-#undef F_NAME
-#define F_NAME "lskelACK3"
-{ 
-  int32_t i, j, x, y, z;
-  int32_t rs = rowsize(image);     /* taille ligne */
-  int32_t cs = colsize(image);     /* taille colonne */
-  int32_t ds = depth(image);       /* nb plans */
-  int32_t ps = rs * cs;            /* taille plan */
-  int32_t N = ps * ds;             /* taille image */
-  u_int8_t *S = UCHARDATA(image);      /* l'image de depart */
-  struct xvimage *t = copyimage(image); 
-  u_int8_t *T = UCHARDATA(t);
-  u_int8_t *I;
-  int32_t step, nonstab;
-  int32_t top, topb;
-  u_int8_t v[27];
-
-  if (inhibit == NULL) 
-  {
-    inhibit = copyimage(image); 
-    razimage(inhibit);
-  }
-  I = UCHARDATA(inhibit);
-
-  if (nsteps == -1) nsteps = 1000000000;
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-
-  init_topo3d();
-
-  /* ================================================ */
-  /*               DEBUT ALGO                         */
-  /* ================================================ */
-
-  step = 0;
-  nonstab = 1;
-  while (nonstab && (step < nsteps))
-  {
-    nonstab = 0;
-    step++;
-#ifdef VERBOSE
-    printf("step %d\n", step);
-#endif
-
-    // MARQUE LES POINTS SIMPLES NON DANS I
-    for (i = 0; i < N; i++) 
-      if (IS_OBJECT(S[i]) && !I[i] && simple26(S, i, rs, ps, N))
-	SET_SIMPLE(S[i]);
-    // MARQUE LES POINTS DE COURBE (3)
-    for (i = 0; i < N; i++)
-    {
-      if (IS_OBJECT(S[i]) && !IS_SIMPLE(S[i]))
-      {    
-	top26(S, i, rs, ps, N, &top, &topb);
-	if (top > 1) SET_CURVE(S[i]);
-      }
-    }
-    // DEMARQUE PTS DE COURBE ET LES MEMORISE DANS I
-    for (i = 0; i < N; i++)
-    { 
-      if (IS_CURVE(S[i])) { UNSET_SIMPLE(S[i]); I[i] = 1; }
-    }
-    // MARQUE LES POINTS 2M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (asym_match2(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 1M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (asym_match1(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-    // MARQUE LES POINTS 0M-CRUCIAUX
-    for (i = 0; i < N; i++) 
-      if (IS_SIMPLE(S[i]))
-      { 
-	extract_vois(S, i, rs, ps, N, v);
-	if (asym_match0(v))
-	  insert_vois(v, S, i, rs, ps, N);
-      }
-
-    memset(T, 0, N);
-    for (i = 0; i < N; i++) // T := [S \ P] \cup M, où M représente les pts marqués
-      if ((S[i] && !IS_SIMPLE(S[i])) || IS_SELECTED(S[i]))
-	T[i] = 1;
-
-    for (i = 0; i < N; i++)
-      if (S[i] && !T[i]) 
-      {
-	S[i] = 0; 
-	nonstab = 1; 
-      }
-    for (i = 0; i < N; i++) if (S[i]) S[i] = S_OBJECT;
-  }
-
-#ifdef VERBOSE1
-    printf("number of steps: %d\n", step);
-#endif
-
-  for (i = 0; i < N; i++) if (S[i]) S[i] = 255; // normalize values
-
-  freeimage(t);
-  termine_topo3d();
-  return(1);
-} /* lskelACK3() */
diff -r 8b1af7363833 src/lib/lsquel.c
--- a/src/lib/lsquel.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lsquel.c	Mon Jan 13 15:50:10 2014 +0100
@@ -168,7 +168,6 @@
 } /* testmini() */
 
 /* ==================================== */
-static 
 void empilevoisins(int32_t x, int32_t rs, int32_t N, Fifo *FIFOna, Fifo *FIFOea, Fifo *FIFOsa, Fifo *FIFOoa)
 /* ==================================== */
 {
diff -r 8b1af7363833 src/lib/lsquelval.c
--- a/src/lib/lsquelval.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lsquelval.c	Mon Jan 13 15:50:10 2014 +0100
@@ -244,7 +244,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
 #ifdef DEBUG
       printf("pop x = %d,%d, im = %d, dx = %ld\n", x%rs, x/rs, IM[x], DX[x]);
@@ -271,7 +271,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
 #ifdef DEBUG
       printf("pop x = %d,%d, im = %d, dx = %ld\n", x%rs, x/rs, IM[x], DX[x]);
@@ -324,7 +324,7 @@
     {
       while (!mcrbt_RbtVide(RBT))
       {
-        x = mcrbt_RbtPopMin(RBT);
+        x = RbtPopMin(RBT);
 #ifdef DEBUG
         printf("pop x = %d,%d, dt = %ld\n", x%rs, x/rs, DT[x]);
 #endif
@@ -343,7 +343,7 @@
       int32_t abaisse;
       while (!mcrbt_RbtVide(RBT))
       {
-        x = mcrbt_RbtPopMin(RBT);
+        x = RbtPopMin(RBT);
 #ifdef DEBUG
         printf("pop x = %d,%d, dt = %d\n", x%rs, x/rs, DT[x]);
 #endif
@@ -448,7 +448,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (mctopo3d_simple6(IM, x, rs, ps, N))
       {
@@ -472,7 +472,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
       if (mctopo3d_simple26(IM, x, rs, ps, N))
       {
@@ -514,7 +514,7 @@
     int32_t abaisse;
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       do
       {
         abaisse = 0;
@@ -539,7 +539,7 @@
     int32_t abaisse;
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       do
       {
         abaisse = 0;
@@ -697,7 +697,7 @@
   {
     while (!mcrbt_RbtVide(RBT))
     {
-      x = mcrbt_RbtPopMin(RBT);
+      x = RbtPopMin(RBT);
       UnSet(x, EN_RBT);
 #ifdef DEBUG
       printf("pop x = %d,%d, im = %d, dx = %ld\n", x%rs, x/rs, IM[x], DX[x]);
diff -r 8b1af7363833 src/lib/ltangents.cxx
--- a/src/lib/ltangents.cxx	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/ltangents.cxx	Mon Jan 13 15:50:10 2014 +0100
@@ -39,7 +39,6 @@
 Paulin Sanselme, 2011
 */
 
-#include <algorithm>
 #include <lbdigitalline.h>
 
 #include <stdio.h>
@@ -96,7 +95,7 @@
   {
     Xdir[i] = 0;
     Ydir[i] = 0;
-    for (j = std::max(0,mask-i); j < std::min(2*mask,npoints+mask-i-1); j++)
+    for (j = max(0,mask-i); j < min(2*mask,npoints+mask-i-1); j++)
       {
 	tmp = i+j-mask+1;
 	Xdir[i] += (int64_t)(tab_combi[j]*deltaX[tmp]);
@@ -143,7 +142,7 @@
     Xdir[i] = 0;
     Ydir[i] = 0;
     Zdir[i] = 0;
-    for (j = std::max(0,mask-i); j < std::min(2*mask,npoints+mask-i-1); j++)
+    for (j = max(0,mask-i); j < min(2*mask,npoints+mask-i-1); j++)
       {
 	tmp = i+j-mask+1;
 	assert(tmp>=0 && tmp<npoints);
@@ -536,7 +535,7 @@
     switch (elim)
     {
     case XY: 
-      indmax = std::min(yzindmax,xzindmax);
+      indmax = min(yzindmax,xzindmax);
 #ifdef DEBUG_ExtractDSSs3D
       printf("%s: case XY indmax=%d pos+indmax-1=%d lastend=%d\n", F_NAME, indmax, pos+indmax-1, lastend);
 #endif
@@ -570,7 +569,7 @@
       break;
 
     case YZ:
-      indmax = std::min(xyindmax,xzindmax);
+      indmax = min(xyindmax,xzindmax);
 #ifdef DEBUG_ExtractDSSs3D
       printf("%s: case YZ indmax=%d pos+indmax-1=%d lastend=%d\n", F_NAME, indmax, pos+indmax-1, lastend);
 #endif
@@ -609,7 +608,7 @@
       break;
 
     case XZ:
-      indmax = std::min(xyindmax,yzindmax);
+      indmax = min(xyindmax,yzindmax);
 #ifdef DEBUG_ExtractDSSs3D
       printf("%s: case XZ indmax=%d pos+indmax-1=%d lastend=%d\n", F_NAME, indmax, pos+indmax-1, lastend);
 #endif
@@ -817,7 +816,7 @@
     switch (elim)
     {
     case XY: 
-      indmax = std::min(yzindmax,xzindmax);
+      indmax = min(yzindmax,xzindmax);
 #ifdef DEBUG_CoverByDSSs3D
       printf("%s: case XY indmax=%d pos+indmax-1=%d\n", F_NAME, indmax, pos+indmax-1);
 #endif
@@ -830,7 +829,7 @@
       break;
 
     case YZ:
-      indmax = std::min(xyindmax,xzindmax);
+      indmax = min(xyindmax,xzindmax);
 #ifdef DEBUG_CoverByDSSs3D
       printf("%s: case YZ indmax=%d pos+indmax-1=%d\n", F_NAME, indmax, pos+indmax-1);
 #endif
@@ -843,7 +842,7 @@
       break;
 
     case XZ:
-      indmax = std::min(xyindmax,yzindmax);
+      indmax = min(xyindmax,yzindmax);
 #ifdef DEBUG_CoverByDSSs3D
       printf("%s: case XZ indmax=%d pos+indmax-1=%d\n", F_NAME, indmax, pos+indmax-1);
 #endif
@@ -1002,7 +1001,7 @@
   switch (elim)
     {
     case XY: 
-      indmax = std::min(yzindmax,xzindmax);
+      indmax = min(yzindmax,xzindmax);
 #ifdef DEBUG_FindDSSs3D
       printf("%s: case XY indmax=%d pos+indmax-1=%d lastend=%d\n", F_NAME, indmax, pos+indmax-1, lastend);
 #endif
@@ -1015,7 +1014,7 @@
       break;
 
     case YZ:
-      indmax = std::min(xyindmax,xzindmax);
+      indmax = min(xyindmax,xzindmax);
 #ifdef DEBUG_FindDSSs3D
       printf("%s: case YZ indmax=%d pos+indmax-1=%d lastend=%d\n", F_NAME, indmax, pos+indmax-1, lastend);
 #endif
@@ -1028,7 +1027,7 @@
       break;
 
     case XZ:
-      indmax = std::min(xyindmax,yzindmax);
+      indmax = min(xyindmax,yzindmax);
 #ifdef DEBUG_FindDSSs3D
       printf("%s: case XZ indmax=%d pos+indmax-1=%d lastend=%d\n", F_NAME, indmax, pos+indmax-1, lastend);
 #endif
diff -r 8b1af7363833 src/lib/lwshedtopo.c
--- a/src/lib/lwshedtopo.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/lwshedtopo.c	Mon Jan 13 15:50:10 2014 +0100
@@ -724,7 +724,7 @@
 } /* lwshedtopo_lreconsdilat() */
 
 /* ==================================== */
-int32_t lwshedtopo_lreconseros(
+int32_t lreconseros(
         struct xvimage *g,
         struct xvimage *f,
         int32_t connex) 
diff -r 8b1af7363833 src/lib/mcfahdouble.c
--- a/src/lib/mcfahdouble.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,285 +0,0 @@
-/* $Id: mcfahdouble.c,v 1.1.1.1 2008-11-25 08:01:41 mcouprie Exp $ */
-/* 
-   Librairie mcfahdouble :
-
-   fonctions pour la gestion d'une file d'attente hierarchique
-   politique "pure" priorite
-
-   Michel Couprie 1999
-*/
-
-/* d'apres F. Meyer: "Un Algorithme Optimal de Ligne de Partage des Eaux" */
-
-/* traitement des points "attardes" (ceux dont le niveau d'immersion a */
-/* ete depasse: on utilise la variante suggeree par F. Meyer consistant */
-/* a gerer une file speciale pour ces cas d'urgence, file plus prioritaire */
-/* que toutes */
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mcfahdouble.h>
-
-/* #define TESTFahd */
-/* #define VERBOSE */
-
-/* ==================================== */
-Fahd * CreeFahdVide(
-  int32_t taillemax)
-/* ==================================== */
-{
-  int32_t i;
-  Fahd * L = (Fahd *)calloc(1,4 * sizeof(int32_t) + 
-                          (NPRIO+4)*sizeof(FahdElt *) + 
-                          taillemax*sizeof(FahdElt));
-  if (L == NULL)
-  {
-    fprintf(stderr, "erreur allocation Fahd\n");
-    exit(1);
-  }
-  L->Max = taillemax;
-  L->Util = 0;
-  L->Maxutil = 0;
-  L->Niv = 0;
-  for (i = 0; i < taillemax - 1; i++)
-    L->Elts[i].Next = &(L->Elts[i+1]);
-  L->Elts[taillemax - 1].Next = NULL;
-  L->Libre = &(L->Elts[0]);
-  for (i = 0; i < NPRIO; i++)
-    L->Tete[i]= NULL;
-  L->Queue = NULL;
-  return L;
-} /* CreeFahdVide() */
-
-/* ==================================== */
-void FahdFlush(
-  Fahd * L)
-/* ==================================== */
-{
-  int32_t i;
-  L->Niv = 0;
-  L->Util = 0;
-  for (i = 0; i < L->Max - 1; i++)
-    L->Elts[i].Next = &(L->Elts[i+1]);
-  L->Elts[L->Max - 1].Next = NULL;
-  L->Libre = &(L->Elts[0]);
-  for (i = 0; i < NPRIO; i++)
-    L->Tete[i]= NULL;
-  L->Queue = NULL;
-} /* FahdFlush() */
-
-/* ==================================== */
-int32_t FahdVide(
-  Fahd * L)
-/* ==================================== */
-{
-  return (L->Queue == NULL);
-} /* FahdVide() */
-
-/* ==================================== */
-int32_t FahdVideNiveau(
-  Fahd * L,
-  int32_t niv)
-/* ==================================== */
-{
-  if (L->Queue == NULL) return 1;
-  if (L->Niv > niv) return 1;
-  return 0;
-} /* FahdVideNiveau() */
-
-/* ==================================== */
-int32_t FahdNiveau(
-  Fahd * L)
-/* ==================================== */
-{
-  if (L->Queue == NULL)
-  {
-    fprintf(stderr, "erreur Fahd vide\n");
-    exit(1);
-  }
-  return L->Niv;
-} /* FahdNiveau() */
-
-/* ==================================== */
-void FahdPop(
-  Fahd * L,
-  int32_t *P1,
-  int32_t *P2)
-/* ==================================== */
-{
-  FahdElt * FE;
-  if (L->Queue == NULL)
-  {
-    fprintf(stderr, "erreur Fahd vide\n");
-    exit(1);
-  }
-
-  L->Util--;
-
-  if (L->Queue == L->Tete[L->Niv]) /* on se prepare a effacer le dernier */
-  {                                /* element du niveau courant: il faut */
-    L->Tete[L->Niv] = NULL;        /* annuler le pointeur de tete */
-    do (L->Niv)++;                 /* et incrementer le niveau */
-    while ((L->Niv < NPRIO)          
-            && (L->Tete[L->Niv] == NULL));
-  }
-  *P1 = L->Queue->Point1;
-  *P2 = L->Queue->Point2;
-  FE = L->Queue->Next;
-  L->Queue->Next = L->Libre;
-  L->Libre = L->Queue;
-  L->Queue = FE;
-} /* FahdPop() */
-  
-/* ==================================== */
-void FahdFirst(
-  Fahd * L,
-  int32_t *P1,
-  int32_t *P2)
-/* ==================================== */
-{
-  FahdElt * FE;
-  if (L->Queue == NULL)
-  {
-    fprintf(stderr, "erreur Fahd vide\n");
-    exit(1);
-  }
-  *P1 = L->Queue->Point1;
-  *P2 = L->Queue->Point2;
-} /* FahdFirst() */
-  
-/* ==================================== */
-void FahdPush(
-  Fahd * L,
-  int32_t P1,
-  int32_t P2,
-  int32_t Ni)
-/* ==================================== */
-{
-  if (L->Libre == NULL)
-  {
-    fprintf(stderr, "erreur Fahd pleine\n");
-    exit(1);
-  }
-  if (Ni >= NPRIO)
-  {
-    fprintf(stderr, "erreur niveau = %d; max autorise = %d\n", Ni, NPRIO-1);
-    exit(1);
-  }
-
-  L->Util++;
-  if (L->Util > L->Maxutil) L->Maxutil = L->Util;
-  if (L->Queue == NULL)    /* insertion dans une Fahd vide */
-  {
-    L->Queue = L->Libre;
-    L->Libre = L->Libre->Next;
-    L->Queue->Point1 = P1;
-    L->Queue->Point2 = P2;
-    L->Niv = Ni;
-    L->Queue->Next = NULL;
-    L->Tete[Ni] = L->Queue;
-  } /* if Fahd Vide */
-  else if (L->Tete[Ni] != NULL)   /* insertion dans la liste de niveau Ni non vide */
-  {
-    FahdElt * FE = L->Tete[Ni]->Next;
-    L->Tete[Ni]->Next = L->Libre;
-    L->Libre = L->Libre->Next;
-    L->Tete[Ni] = L->Tete[Ni]->Next;
-    L->Tete[Ni]->Next = FE;
-    L->Tete[Ni]->Point1 = P1;      
-    L->Tete[Ni]->Point2 = P2;
-  }
-  else /* (L->Tete[Ni] == NULL) */
-  {
-    FahdElt * FE;
-    int32_t NiPrec = Ni;
-    while ((NiPrec >= 0) && (L->Tete[NiPrec] == NULL)) NiPrec--; 
-    if (NiPrec < 0)              /* creation d'un niveau inferieur au niveau courant */
-    {
-      FE = L->Queue;
-      L->Queue = L->Libre;
-      L->Libre = L->Libre->Next;
-      L->Queue->Point1 = P1;
-      L->Queue->Point2 = P2;
-      L->Niv = Ni;
-      L->Queue->Next = FE;
-      L->Tete[Ni] = L->Queue;
-    }
-    else
-    {
-      L->Tete[Ni] = L->Libre;
-      L->Libre = L->Libre->Next;
-      L->Tete[Ni]->Point1 = P1;
-      L->Tete[Ni]->Point2 = P2;
-      FE = L->Tete[NiPrec]->Next;
-      L->Tete[NiPrec]->Next = L->Tete[Ni];
-      L->Tete[Ni]->Next = FE;
-    }
-  }
-} /* FahdPush() */
-
-/* ==================================== */
-void FahdTermine(
-  Fahd * L)
-/* ==================================== */
-{
-#ifdef VERBOSE
-  printf("Fahd: taux d'utilisation: %g\n", (double)L->Maxutil / (double)L->Max);
-#endif
-  free(L);
-} /* FahdTermine() */
-
-/* ==================================== */
-void FahdPrint(
-  Fahd * L)
-/* ==================================== */
-{
-  int32_t i;
-  FahdElt * FE;
-  if (FahdVide(L)) {printf("[]\n"); return;}
-  FE = L->Queue;
-  for (i = L->Niv; i < NPRIO; i++)
-    if (L->Tete[i] != NULL) 
-    {
-      printf("%d [ ", i);
-      for (;FE != L->Tete[i]; FE = FE->Next)
-        printf("(%d,%d) ", FE->Point1, FE->Point2);
-      printf("(%d,%d) ]\n", FE->Point1, FE->Point2);
-      FE = FE->Next;
-    }
-} /* FahdPrint() */
-
-#ifdef TESTFahd
-void main()
-{
-  Fahd * L = CreeFahdVide(5);
-  char r[80];
-  int32_t p, n;
-
-  do
-  {
-    printf("commande (qUIT, PuSH, PoP, pRINT, TESTvIDE) > ");
-    scanf("%s", r);
-    switch (r[0])
-    {
-      case 'u':
-        printf("niveau > ");
-        scanf("%d", &n);
-        printf("valeur > ");
-        scanf("%d", &p);
-        FahdPush(L, p, n);
-        break;
-      case 'o': 
-        printf("pop: %d\n", FahdPop(L));
-        break;
-      case 'p': FahdPrint(L); break;
-      case 'v': 
-        printf("vide: %d\n", FahdVide(L));
-        break;
-      case 'q': break;
-    }
-  } while (r[0] != 'q');
-  FahdTermine(L);
-}
-#endif TESTFahd
diff -r 8b1af7363833 src/lib/mcmesh.c
--- a/src/lib/mcmesh.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/mcmesh.c	Mon Jan 13 15:50:10 2014 +0100
@@ -329,8 +329,7 @@
 } /* TermineMesh() */
 
 /* ==================================== */
-static
-int32_t NotIn(
+int32_t mcmesh_NotIn(
   int32_t e,
   int32_t *list,                   
   int32_t n)                       
@@ -343,7 +342,7 @@
   while (n > 0)
     if (list[--n] == e) return 0;
   return 1;
-} /* NotIn() */
+} /* mcmesh_NotIn() */
 
 /* ==================================== */
 int32_t MCM_AddVertex(MCM *M, double x, double y, double z, int32_t indface)
@@ -362,7 +361,7 @@
   {
     i = re->auxdata; /* index du vertex */
     /* il est la : on lui ajoute la face si elle n'y est pas deja */
-    if (NotIn(indface, M->Vertices->v[i].face, M->Vertices->v[i].nfaces)) 
+    if (mcmesh_NotIn(indface, M->Vertices->v[i].face, M->Vertices->v[i].nfaces)) 
     {
       if (M->Vertices->v[i].nfaces >= MCM_MAXADJFACES)
       {
@@ -429,7 +428,7 @@
 #undef F_NAME
 #define F_NAME "MCM_VertexAddFace"
 {
-  if (NotIn(indface, M->Vertices->v[indvert].face, M->Vertices->v[indvert].nfaces)) 
+  if (mcmesh_NotIn(indface, M->Vertices->v[indvert].face, M->Vertices->v[indvert].nfaces)) 
   { // si elle n'y est pas déjà
     if (M->Vertices->v[indvert].nfaces >= MCM_MAXADJFACES)
     {
@@ -470,7 +469,7 @@
 #undef F_NAME
 #define F_NAME "MCM_VertexAddEdge"
 {
-  if (NotIn(indedge, M->Vertices->v[indvert].edge, M->Vertices->v[indvert].nedges)) 
+  if (mcmesh_NotIn(indedge, M->Vertices->v[indvert].edge, M->Vertices->v[indvert].nedges)) 
   { // s'il n'y est pas déjà
     if (M->Vertices->v[indvert].nedges >= MCM_MAXADJEDGES)
     {
@@ -614,7 +613,7 @@
   {
     i = re->auxdata; /* index du vertex */
     /* il est la : on lui ajoute la face si elle n'y est pas deja */
-    if (NotIn(indface, Vertices->v[i].face, Vertices->v[i].nfaces)) 
+    if (mcmesh_NotIn(indface, Vertices->v[i].face, Vertices->v[i].nfaces)) 
     {
       if (Vertices->v[i].nfaces >= MCM_MAXADJFACES)
       {
@@ -779,9 +778,9 @@
     for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
     {                                         /* et calcule le link */
       F = M->Faces->f[V.face[j]];
-      k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
     } /* for j */
 
     for (k = 0; k < n; k++)   /* parcourt le link et cree les cotes */
@@ -950,9 +949,9 @@
     for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
     {                                         /* et calcule le link */
       F = Faces->f[V.face[j]];
-      k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
     } /* for j */
 
     for (k = 0; k < n; k++)   /* parcourt le link et cree les cotes */
@@ -1079,11 +1078,11 @@
     for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
     {                                         /* et calcule le link */
       F = M->Faces->f[V.face[j]];
-      k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
       assert(n <= MCM_MAXADJFACES);
-      k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
       assert(n <= MCM_MAXADJFACES);
-      k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
       assert(n <= MCM_MAXADJFACES);
     } /* for j */
 
@@ -1138,11 +1137,11 @@
     for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
     {                                         /* et calcule le link */
       F = M->Faces->f[V.face[j]];
-      k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
       assert(n <= MCM_MAXADJFACES);
-      k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
       assert(n <= MCM_MAXADJFACES);
-      k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
       assert(n <= MCM_MAXADJFACES);
     } /* for j */
 
@@ -1185,11 +1184,11 @@
     for (f = 0; f < V.nfaces; f++) /* parcourt les faces adjacentes */
     {                                         /* et calcule le link */
       F = &(M->Faces->f[V.face[f]]);
-      k = F->vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F->vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
       assert(n <= MCM_MAXADJFACES);
-      k = F->vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F->vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
       assert(n <= MCM_MAXADJFACES);
-      k = F->vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F->vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
       assert(n <= MCM_MAXADJFACES);
     } /* for f */
 
@@ -1324,9 +1323,9 @@
     for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
     {                                         /* et calcule le link */
       F = Faces->f[V.face[j]];
-      k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
     } /* for j */
     e += n;
   }
@@ -1344,9 +1343,9 @@
     for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
     {                                         /* et calcule le link */
       F = Faces->f[V.face[j]];
-      k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+      k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
     } /* for j */
     for (k = 0; k < n; k++)   /* stocke le link */
       Links->neigh[e++] = link[k];
@@ -1748,9 +1747,9 @@
         for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
           {                                      /* et calcule le link */
           F = Faces->f[V.face[j]];
-          k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
         } /* for j */
 #ifdef WARN_NON_CYCLE
         if (n != V.nfaces)
@@ -1825,9 +1824,9 @@
         for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
           {                                      /* et calcule le link */
           F = Faces->f[V.face[j]];
-          k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
         } /* for j */
         if (n == V.nfaces) // sommet non bord
         {
@@ -2711,9 +2710,9 @@
         for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
           {                                      /* et calcule le link */
           F = Faces->f[V.face[j]];
-          k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
         } /* for j */
 #ifdef WARN_NON_CYCLE
         if (n != V.nfaces)
@@ -2762,9 +2761,9 @@
         for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
           {                                      /* et calcule le link */
           F = Faces->f[V.face[j]];
-          k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
         } /* for j */
         if (n == 0) break; // point isole
                                 
@@ -2888,9 +2887,9 @@
         for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
           {                                      /* et calcule le link */
           F = Faces->f[V.face[j]];
-          k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
         } /* for j */
 #ifdef WARN_NON_CYCLE
         if (n != V.nfaces)
@@ -2939,9 +2938,9 @@
         for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
           {                                      /* et calcule le link */
           F = Faces->f[V.face[j]];
-          k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[0]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[1]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
+          k = F.vert[2]; if ((k != i) && mcmesh_NotIn(k, link, n)) link[n++] = k;
         } /* for j */
 #ifdef WARN_NON_CYCLE
         if (n != V.nfaces)
diff -r 8b1af7363833 src/lib/mcmesh.c.sav
--- a/src/lib/mcmesh.c.sav	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,2189 +0,0 @@
-/* $Id: mcmesh.c.sav,v 1.1.1.1 2008-11-25 08:01:39 mcouprie Exp $ */
-/* 
-  Gestion d'une triangulation
-  Michel Couprie  -  Mai 2001
-  Update Fevrier 2002 : Edges et lissage courbures
-  Update Fevrier 2004 : Addition de bruit gaussien
-  Update Fevrier 2004 : RegulMeshHamam
-  Update Février 2006 : mesures
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <math.h>
-#include <mcmesh.h>
-#include <mcrbt1.h>
-#include <mcgeo.h>
-#include <mcprobas.h>
-#include <mcutil.h>
-
-#ifndef EPSILON
-#define EPSILON 1E-20
-#endif
-
-#define OPTIMALSTEP
-//#define PLOTCOSTFUNCTION
-
-#define DEBUGHAM3
-/*
-#define DEBUG
-*/
-#define PARANO
-#define VERBOSE
-//#define MESURE
-
-#define NITERMAX 20000
-
-meshtabvertices *Vertices = NULL;
-meshtabfaces *Faces = NULL;
-meshtabedges *Edges = NULL;
-meshtablinks *Links = NULL;
-Rbt * RBT;
-
-double normevect(double x, double y, double z)
-{
-  return sqrt(x*x + y*y + z*z);
-}
-
-/* ==================================== */
-meshtabvertices * AllocVertices(int32_t taillemax)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "AllocVertices"
-{
-  meshtabvertices * T = (meshtabvertices *)calloc(1,sizeof(meshtabvertices) + taillemax*sizeof(meshvertex));
-  if (T == NULL) 
-  {
-    fprintf(stderr, "%s : malloc failed\n", F_NAME);
-    return NULL;
-  }
-  T->lab = (uint8_t *)calloc(taillemax, sizeof(char));
-  if (T->lab == NULL) 
-  {
-    fprintf(stderr, "%s : malloc failed\n", F_NAME);
-    return NULL;
-  }
-  T->tmp = (uint8_t *)calloc(taillemax, sizeof(char));
-  if (T->tmp == NULL) 
-  {
-    fprintf(stderr, "%s : malloc failed\n", F_NAME);
-    return NULL;
-  }
-  T->max = taillemax;
-  T->cur = 0;
-  return T;
-} /* AllocVertices() */
-
-/* ==================================== */
-void ReAllocVertices(meshtabvertices **A)
-/* ==================================== */
-{
-  int32_t i, taillemax;
-  meshtabvertices * T, *Tmp;
-
-  //printf("ReAllocVertices: ancienne taille %d nouvelle taille %d\n", (*A)->max, 2 * (*A)->max);
-
-  taillemax = 2 * (*A)->max;  /* alloue le double de l'ancienne taille */ 
-  T = AllocVertices(taillemax);
-  T->cur = (*A)->cur;
-  memcpy(T->v, (*A)->v, T->cur * sizeof(meshvertex));
-  memcpy(T->lab, (*A)->lab, T->cur * sizeof(char));
-  memcpy(T->tmp, (*A)->tmp, T->cur * sizeof(char));
-  Tmp = *A;
-  *A = T;
-  free(Tmp->lab);
-  free(Tmp->tmp);
-  free(Tmp);
-} /* ReAllocVertices() */
-
-/* ==================================== */
-meshtabfaces * AllocFaces(int32_t taillemax)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "AllocFaces"
-{
-  meshtabfaces * T = (meshtabfaces *)calloc(1,sizeof(meshtabfaces) + taillemax*sizeof(meshface));
-  if (T == NULL) 
-  {
-    fprintf(stderr, "%s : malloc failed\n", F_NAME);
-    return NULL;
-  }
-  T->max = taillemax;
-  T->cur = 0;
-  return T;
-} /* AllocFaces() */
-
-/* ==================================== */
-void ReAllocFaces(meshtabfaces **A)
-/* ==================================== */
-{
-  int32_t i, taillemax;
-  meshtabfaces * T, *Tmp;
-
-  //printf("ReAllocFaces: ancienne taille %d nouvelle taille %d\n", (*A)->max, 2 * (*A)->max);
-
-  taillemax = 2 * (*A)->max;  /* alloue le double de l'ancienne taille */ 
-  T = AllocFaces(taillemax);
-  T->cur = (*A)->cur;
-  memcpy(T->f, (*A)->f, T->cur * sizeof(meshface));
-  Tmp = *A;
-  *A = T;
-  free(Tmp);
-} /* ReAllocFaces() */
-
-/* ==================================== */
-meshtabedges * AllocEdges(int32_t taillemax)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "AllocEdges"
-{
-  meshtabedges * T = (meshtabedges *)calloc(1,sizeof(meshtabedges) + taillemax*sizeof(meshedge));
-  if (T == NULL) 
-  {
-    fprintf(stderr, "%s : malloc failed\n", F_NAME);
-    return NULL;
-  }
-  T->max = taillemax;
-  T->cur = 0;
-  return T;
-} /* AllocEdges() */
-
-/* ==================================== */
-void ReAllocEdges(meshtabedges **A)
-/* ==================================== */
-{
-  int32_t i, taillemax;
-  meshtabedges * T, *Tmp;
-
-  //printf("ReAllocEdges: ancienne taille %d nouvelle taille %d\n", (*A)->max, 2 * (*A)->max);
-
-  taillemax = 2 * (*A)->max;  /* alloue le double de l'ancienne taille */ 
-  T = AllocEdges(taillemax);
-  T->cur = (*A)->cur;
-  memcpy(T->e, (*A)->e, T->cur * sizeof(meshedge));
-  Tmp = *A;
-  *A = T;
-  free(Tmp);
-} /* ReAllocEdges() */
-
-/* ==================================== */
-meshtablinks * AllocLinks(int32_t nvert, int32_t nedge)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "AllocLinks"
-{
-  meshtablinks * T = (meshtablinks *)calloc(1,sizeof(meshtablinks));
-  if (T == NULL) 
-  {
-    fprintf(stderr, "%s : malloc failed\n", F_NAME);
-    return NULL;
-  }
-  T->nvert = nvert;
-  T->nedge = nedge;
-  T->lastneigh = (int32_t *)calloc(1,nvert * sizeof(int32_t));
-  T->neigh = (int32_t *)calloc(1,nedge * sizeof(int32_t));
-  if ((T->lastneigh == NULL) || (T->neigh == NULL))
-  {
-    fprintf(stderr, "%s : malloc failed\n", F_NAME);
-    return NULL;
-  }
-  return T;
-} /* AllocLinks() */
-
-/* ==================================== */
-void InitMesh(int32_t taillemax)
-/* ==================================== */
-{
-  Vertices = AllocVertices(taillemax);
-  Faces = AllocFaces(taillemax);
-  RBT = CreeRbtVide(taillemax);
-} /* InitMesh() */
-
-/* ==================================== */
-void TermineMesh()
-/* ==================================== */
-{
-  free(Vertices->lab);
-  free(Vertices->tmp);
-  free(Vertices);
-  free(Faces);
-  if (Edges) free(Edges);
-  if (Links) { free(Links->lastneigh); free(Links->neigh); free(Links); }
-  RbtTermine(RBT);
-} /* TermineMesh() */
-
-/* ==================================== */
-int32_t NotIn(
-  int32_t e,
-  int32_t *list,                   
-  int32_t n)                       
-/* ==================================== */
-{
-/* renvoie 1 si e n'est pas dans list, 0 sinon */
-/* e : l'element a rechercher */
-/* list : la liste (tableau d'entiers) */
-/* n : le nombre d'elements dans la liste */
-  while (n > 0)
-    if (list[--n] == e) return 0;
-  return 1;
-} /* NotIn() */
-
-/* ==================================== */
-int32_t AddVertex(double x, double y, double z, int32_t indface)
-/* ==================================== */
-/* modifie les var. globales Faces, Vertices */
-#undef F_NAME
-#define F_NAME "AddVertex"
-{
-  int32_t i;
-  TypRbtKey point;
-  RbtElt * re;
-
-  /* cherche si le sommet est deja la */
-  point.x = x;
-  point.y = y;
-  point.z = z;
-  re = RbtSearch(RBT, point); 
-  if (re != RBT->nil)
-  {
-    i = re->auxdata; /* index du vertex */
-    /* il est la : on lui ajoute la face si elle n'y est pas deja */
-    if (NotIn(indface, Vertices->v[i].face, Vertices->v[i].nfaces)) 
-    {
-      if (Vertices->v[i].nfaces >= MAXADJFACES)
-      {
-        fprintf(stderr, "%s : WARNING: more than %d faces\n", F_NAME, MAXADJFACES);
-        fprintf(stderr, "x=%g, y=%g, z=%g\n", x, y, z);
-        goto skipadd;
-      }
-      Vertices->v[i].face[ Vertices->v[i].nfaces++ ] = indface;
-    }
-skipadd:
-    return i;
-  } /* if (re != RBT->nil) */
-  if (Vertices->cur >= Vertices->max) ReAllocVertices(&Vertices);
-  i = Vertices->cur;
-  Vertices->cur += 1;
-  Vertices->v[i].x = x;
-  Vertices->v[i].y = y;
-  Vertices->v[i].z = z;
-  Vertices->v[i].face[ 0 ] = indface;
-  Vertices->v[i].nfaces = 1;
-  (void)RbtInsert(&RBT, point, i);
-  return i;
-} /* AddVertex() */
-
-
-/* ==================================== */
-int32_t AddVertexFixe(double x, double y, double z, int32_t indface)
-/* ==================================== */
-/* modifie les var. globales Faces, Vertices */
-{
-  int32_t i;
-  i = AddVertex(x, y, z, indface);
-  Vertices->lab[i] = 1;
-  return i;
-} /* AddVertexFixe() */
-
-/* ==================================== */
-void AddFace(double x1, double y1, double z1, 
-             double x2, double y2, double z2, 
-             double x3, double y3, double z3
-            )
-/* ==================================== */
-/* modifie les var. globales Faces, Vertices */
-{
-  int32_t iv1, iv2, iv3, i, indface;
-  if (Faces->cur >= Faces->max) ReAllocFaces(&Faces);
-  indface = Faces->cur;
-  Faces->cur += 1;
-  iv1 = AddVertex(x1, y1, z1, indface);
-  iv2 = AddVertex(x2, y2, z2, indface);
-  iv3 = AddVertex(x3, y3, z3, indface);
-  Faces->f[indface].vert[0] = iv1;
-  Faces->f[indface].vert[1] = iv2;
-  Faces->f[indface].vert[2] = iv3;
-  Faces->f[indface].xn = Faces->f[indface].yn = Faces->f[indface].zn = 0.0;
-} /* AddFace() */
-
-/* ==================================== */
-void AddFaceFixe(double x1, double y1, double z1, 
-                 double x2, double y2, double z2, 
-                 double x3, double y3, double z3,
-                 int32_t fix1, int32_t fix2, int32_t fix3
-                )
-/* ==================================== */
-/* modifie les var. globales Faces, Vertices */
-{
-  int32_t iv1, iv2, iv3, i, indface;
-  if (Faces->cur >= Faces->max) ReAllocFaces(&Faces);
-  indface = Faces->cur;
-  Faces->cur += 1;
-  if (fix1)
-    iv1 = AddVertexFixe(x1, y1, z1, indface);
-  else 
-    iv1 = AddVertex(x1, y1, z1, indface);
-  if (fix2)
-    iv2 = AddVertexFixe(x2, y2, z2, indface);
-  else 
-    iv2 = AddVertex(x2, y2, z2, indface);
-  if (fix3)
-    iv3 = AddVertexFixe(x3, y3, z3, indface);
-  else 
-    iv3 = AddVertex(x3, y3, z3, indface);
-  Faces->f[indface].vert[0] = iv1;
-  Faces->f[indface].vert[1] = iv2;
-  Faces->f[indface].vert[2] = iv3;
-  Faces->f[indface].xn = Faces->f[indface].yn = Faces->f[indface].zn = 0.0;
-} /* AddFaceFixe() */
-
-/* ==================================== */
-int32_t AddEdge(int32_t v1, int32_t v2, int32_t f1, int32_t f2)
-/* ==================================== */
-/* modifie la var. globales Edges */
-{
-  int32_t indedge;
-  if (Edges->cur >= Edges->max) ReAllocEdges(&Edges);
-  indedge = Edges->cur;
-  Edges->cur += 1;
-  Edges->e[indedge].v1 = v1;
-  Edges->e[indedge].v2 = v2;
-  Edges->e[indedge].f1 = f1;
-  Edges->e[indedge].f2 = f2;
-  return indedge;
-} /* AddEdge() */
-
-/* ==================================== */
-void SaveCoords()
-/* ==================================== */
-{
-  int32_t i;
-  for (i = 0; i < Vertices->cur; i++)
-  {
-    Vertices->v[i].xp = Vertices->v[i].x;
-    Vertices->v[i].yp = Vertices->v[i].y;
-    Vertices->v[i].zp = Vertices->v[i].z;
-  }
-} /* SaveCoords() */
-
-/* ==================================== */
-void SaveOriginalCoords()
-/* ==================================== */
-{
-  int32_t i;
-  for (i = 0; i < Vertices->cur; i++)
-  {
-    Vertices->v[i].xo = Vertices->v[i].x;
-    Vertices->v[i].yo = Vertices->v[i].y;
-    Vertices->v[i].zo = Vertices->v[i].z;
-  }
-} /* SaveOriginalCoords() */
-
-/* ==================================== */
-void RestoreCoords()
-/* ==================================== */
-{
-  int32_t i;
-  for (i = 0; i < Vertices->cur; i++)
-  {
-    Vertices->v[i].x = Vertices->v[i].xp;
-    Vertices->v[i].y = Vertices->v[i].yp;
-    Vertices->v[i].z = Vertices->v[i].zp;
-  }
-} /* RestoreCoords() */
-
-/* ==================================== */
-void ComputeEdges()
-/* ==================================== */
-/*
-  Contruit le tableau des cotes (edges),
-  et met a jour le champ 'edge' des sommets.
-*/
-#undef F_NAME
-#define F_NAME "ComputeEdges"
-{
-  int32_t i, j, k, n, e, nvertices;
-  meshvertex V;
-  meshface F;
-  int32_t link[MAXADJFACES];
-  int32_t f1, f2;
-
-  if (Edges == NULL) 
-  {
-    fprintf(stderr, "%s : Edges array must be allocated\n", F_NAME);
-    exit(0);
-  }  
-  nvertices = Vertices->cur;
-  for (i = 0; i < nvertices; i++) Vertices->v[i].nedges = 0;
-  for (i = 0; i < nvertices; i++)
-  {
-    V = Vertices->v[i];
-    n = 0;
-    for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
-    {                                         /* et calcule le link */
-      F = Faces->f[V.face[j]];
-      k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-    } /* for j */
-
-    for (k = 0; k < n; k++)   /* parcourt le link et cree les cotes */
-    {
-      if (link[k] > i) /* pour ne compter un cote qu'une seule fois */
-      {
-        f2 = f1 = -1;
-        for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
-        {                    /* et trouve les 2 qui contiennent link[k] */
-          F = Faces->f[V.face[j]];
-          if ((F.vert[0] == link[k]) || (F.vert[1] == link[k]) || (F.vert[2] == link[k]))
-	  {
-            if (f1 == -1) f1 = V.face[j]; else { f2 = V.face[j]; break; }
-	  }
-        } /* for j */
-        e = AddEdge(i, link[k], f1, f2);
-        Vertices->v[i].edge[Vertices->v[i].nedges++] = e;
-        Vertices->v[link[k]].edge[Vertices->v[link[k]].nedges++] = e;
-      } /* if */    
-    } /* for k */
-  } /* for i */
-} /* ComputeEdges() */
-
-/* ==================================== */
-void ComputeLinks()
-/* ==================================== */
-/*
-  Contruit le graphe des voisins (links),
-*/
-#undef F_NAME
-#define F_NAME "ComputeLinks"
-{
-  int32_t i, j, k, n, e, nvertices;
-  meshvertex V;
-  meshface F;
-  int32_t link[MAXADJFACES];
-  int32_t f1, f2;
-
-  if (Links != NULL) 
-  {
-    fprintf(stderr, "%s : Error : Links already exists\n", F_NAME);
-    exit(0);
-  }  
-  nvertices = Vertices->cur;
-  e = 0; // compte le nombre total de relations "successeur"
-  for (i = 0; i < nvertices; i++)
-  {
-    V = Vertices->v[i];
-    n = 0;
-    for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
-    {                                         /* et calcule le link */
-      F = Faces->f[V.face[j]];
-      k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-    } /* for j */
-    e += n;
-  }
-  Links = AllocLinks(nvertices, e);
-  if (Links == NULL) 
-  {
-    fprintf(stderr, "%s : AllocLinks failed\n", F_NAME);
-    exit(0);
-  }  
-  e = 0; // pour indicer le tableau "neigh"
-  for (i = 0; i < nvertices; i++)
-  {
-    V = Vertices->v[i];
-    n = 0;
-    for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
-    {                                         /* et calcule le link */
-      F = Faces->f[V.face[j]];
-      k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-      k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-    } /* for j */
-    for (k = 0; k < n; k++)   /* stocke le link */
-      Links->neigh[e++] = link[k];
-    Links->lastneigh[i] = e-1;
-  } /* for i */
-} /* ComputeLinks() */
-
-/* ==================================== */
-void NormaleFace(int32_t f, vec3 normale)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "NormalFace"
-{
-  int32_t s0, s1, s2;
-  meshface F = Faces->f[f];
-  double norm;
-  vec3 v1, v2;
-
-  s0 = F.vert[0]; s1 = F.vert[1]; s2 = F.vert[2];
-
-  /* calcule les vecteurs: v1 = s0 - s1, v2 = s0 - s2 */
-  v1[0] = Vertices->v[s0].x - Vertices->v[s1].x;
-  v1[1] = Vertices->v[s0].y - Vertices->v[s1].y;
-  v1[2] = Vertices->v[s0].z - Vertices->v[s1].z;
-  v2[0] = Vertices->v[s0].x - Vertices->v[s2].x;
-  v2[1] = Vertices->v[s0].y - Vertices->v[s2].y;
-  v2[2] = Vertices->v[s0].z - Vertices->v[s2].z;
-
-  /* normale face: produit vectoriel de v1 et de v2 */
-  normale[0] = v1[1] * v2[2] - v1[2] * v2[1];
-  normale[1] = v1[2] * v2[0] - v1[0] * v2[2];
-  normale[2] = v1[0] * v2[1] - v1[1] * v2[0];
-
-  /* normalise la normale */
-  norm = normale[0] * normale[0] + normale[1] * normale[1] + normale[2] * normale[2];
-  norm = sqrt(norm);
-
-  if (norm < EPSILON)
-  {
-    fprintf(stderr, "%s: warning: cannot compute normal\n", F_NAME);
-  }
-  else 
-  {
-    normale[0] = - normale[0] / norm; // signe - pour tourner la normale vers l'exterieur
-    normale[1] = - normale[1] / norm;
-    normale[2] = - normale[2] / norm;
-  }
-
-} // NormaleFace() 
-
-/* ==================================== */
-double AngleFaces(int32_t f1, int32_t f2)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "AngleFaces"
-{
-  vec3 n1, n2;
-  double s;
-  mat33 m, mr;
-  meshface F1 = Faces->f[f1];
-  meshface F2 = Faces->f[f2];
-  int32_t a, b, c; // indices des trois sommets formant la face f1, 
-               // b et c etant communs a f1 et f2
-
-  NormaleFace(f1, n1);
-  NormaleFace(f2, n2);
-  
-  s = n1[0] * n2[0] + n1[1] * n2[1] + n1[2] * n2[2];
-
-  // retrouve les sommets a, b, c
-  a = F1.vert[0]; 
-  if ((a != F2.vert[0]) && (a != F2.vert[1]) && (a != F2.vert[2]))
-  { b = F1.vert[1]; c = F1.vert[2]; }
-  else
-  {
-    b = a;
-    a = F1.vert[1];
-    if ((a != F2.vert[0]) && (a != F2.vert[1]) && (a != F2.vert[2]))
-      c = F1.vert[2];
-    else
-    {
-      c = a;
-      a = F1.vert[2];
-    }
-  }
-
-  // calcule les vecteurs: b - a, b - c
-  // et les range dans les 2 premieres colonnes de m
-  m[0][0] = Vertices->v[b].x - Vertices->v[a].x;
-  m[1][0] = Vertices->v[b].y - Vertices->v[a].y;
-  m[2][0] = Vertices->v[b].z - Vertices->v[a].z;
-  m[0][1] = Vertices->v[b].x - Vertices->v[c].x;
-  m[1][1] = Vertices->v[b].y - Vertices->v[c].y;
-  m[2][1] = Vertices->v[b].z - Vertices->v[c].z;
-  // troisieme colonne: la normale n1
-  m[0][2] = n1[0];
-  m[1][2] = n1[1];
-  m[2][2] = n1[2];
-  // matrice de changement de base inverse: mr
-  if (invmat3(m, mr) == 0)
-  {
-    fprintf(stderr, "%s: erreur matrice non inversible\n", F_NAME);
-    exit(0);    
-  }
-  // coordonnees de n2 dans la base de la face f1 (resultat dans n1)
-  multmat3vec3(mr, n2, n1);
-  // l'angle est positif si la 1ere coordonnee du resultat l'est
-  if (s > 1.0) s = 1.0;
-  if (n1[0] >= 0)
-    return acos(s);
-  else
-    return -acos(s);
-} // AngleFaces()
-
-/* ==================================== */
-double MaxAngleFaces()
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "MaxAngleFaces"
-{
-  int32_t i;
-  int32_t f1, f2;
-  double angle, maxangle = 0.0;
-  if (Edges == NULL) 
-  {
-    fprintf(stderr, "%s : Edges must be computed\n", F_NAME);
-    exit(0);
-  }  
-  for (i = 0; i < Edges->cur; i++)
-  {
-    f1 = (Edges->e[i]).f1;
-    f2 = (Edges->e[i]).f2;
-    angle = AngleFaces(f1,f2);
-    angle = mcabs(angle);
-    if (angle > maxangle) maxangle = angle;
-  }
-  return maxangle;
-} // MaxAngleFaces()
-
-/* ==================================== */
-void MeanAngleFaces(double *mean, double *standev)
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "MeanAngleFaces"
-{
-  int32_t i, N = Edges->cur;
-  int32_t f1, f2;
-  double angle, m1 = 0.0, m2 = 0.0;
-  if (Edges == NULL) 
-  {
-    fprintf(stderr, "%s : Edges must be computed\n", F_NAME);
-    exit(0);
-  }  
-  for (i = 0; i < N; i++)
-  {
-    f1 = (Edges->e[i]).f1;
-    f2 = (Edges->e[i]).f2;
-    angle = AngleFaces(f1,f2);
-    angle = mcabs(angle);
-    m1 += angle;
-    m2 += angle * angle;
-  }
-  *mean = m1 / N;
-  *standev = sqrt((m2 - (*mean * *mean) / N) / N);
-} // MeanAngleFaces()
-
-/* ==================================== */
-double MaxLengthEdges()
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "MaxLengthEdges"
-{
-  int32_t i;
-  int32_t v1, v2;
-  double length, maxlength = 0.0;
-  if (Edges == NULL) 
-  {
-    fprintf(stderr, "%s : Edges must be computed\n", F_NAME);
-    exit(0);
-  }  
-  for (i = 0; i < Edges->cur; i++)
-  {
-    v1 = (Edges->e[i]).v1;
-    v2 = (Edges->e[i]).v2;
-    length = dist3(Vertices->v[v1].x, Vertices->v[v1].y, Vertices->v[v1].z,
-		   Vertices->v[v2].x, Vertices->v[v2].y, Vertices->v[v2].z);
-    if (length > maxlength) maxlength = length;
-  }
-  return maxlength;
-} // MaxLengthEdges()
-
-/* ==================================== */
-void ComputeCurvatures()
-/* ==================================== */
-/*
-  Parcourt le tableau des cotes (edges) et calcule, le cas echeant,
-  l'angle entre les deux facettes adjacentes a chaque cote.
-*/
-{
-  int32_t i;
-  meshedge E;
-
-  for (i = 0; i < Edges->cur; i++)
-  {
-    E = Edges->e[i];
-    if (E.f2 != -1)
-      Edges->e[i].curv = AngleFaces(E.f1, E.f2);
-  }
-} // ComputeCurvatures()
-
-/* ==================================== */
-int32_t OppositeVertex(int32_t f, int32_t e)
-/* ==================================== */
-// retourne le vertex de la face f oppose au cote e
-{
-  int32_t a = Edges->e[e].v1;   
-  int32_t b = Edges->e[e].v2;   
-  meshface F = Faces->f[f];
-  if ((F.vert[0] != a) && (F.vert[0] != b)) return F.vert[0];
-  if ((F.vert[1] != a) && (F.vert[1] != b)) return F.vert[1];
-  return F.vert[2];
-} // OppositeVertex()
-
-/* ==================================== */
-double CurvVoisEdges(int32_t v)
-/* ==================================== */
-// retourne la moyenne des courbures des cotes "voisins" de v:
-// - sens 1 : cotes adjacents
-// - sens 2 : cotes opposes a v pour les faces adjacentes
-// implemente pour le moment le sens 1
-{
-  double curv;
-  int32_t i, ne, e;
-
-  //printf("vertex %d : ", v);
-  ne = Vertices->v[v].nedges;
-  for (i = 0; i < ne; i++)
-  {
-    e = Vertices->v[v].edge[i];
-    //printf("(%d %g) ", e, Edges->e[e].curv);
-    curv += Edges->e[e].curv;
-  }
-  curv /= ne;
-  //printf(" moy: %g\n", curv);
-  return curv;
-} // CurvVoisEdges()
-
-/* ==================================== */
-void MoveVertex(int32_t v, int32_t f, int32_t e, double dc)
-/* ==================================== */
-// calcule le deplacement du vertex v, egal a la normale a la face f, 
-// ponderee par un facteur beta = dc * r / 5
-// ou r est la distance de v au cote e et dc est la difference de courbure
-// le deplacement est cumule dans les champs xp, yp, zp du vertex,
-// et le nombre de deplacements est stocke dans le champ tmp associe au vertex.
-{
-  double nx = Faces->f[f].xn;
-  double ny = Faces->f[f].yn;
-  double nz = Faces->f[f].zn;
-  point3 e1, e2, p;
-  double r, beta;
-
-  e1.x = Vertices->v[Edges->e[e].v1].x;
-  e1.y = Vertices->v[Edges->e[e].v1].y;
-  e1.z = Vertices->v[Edges->e[e].v1].z;
-  e2.x = Vertices->v[Edges->e[e].v2].x;
-  e2.y = Vertices->v[Edges->e[e].v2].y;
-  e2.z = Vertices->v[Edges->e[e].v2].z;
-  p.x = Vertices->v[v].x;
-  p.y = Vertices->v[v].y;
-  p.z = Vertices->v[v].z;
-  r = distpointdroite3(p, e1, e2);  
-  beta = (dc * r) / 5.0;
-
-  //printf("sommet %d cote %d distance %g beta %g\n", v, e, r, beta);
-
-  Vertices->tmp[v] += 1;
-  Vertices->v[v].xp += beta * nx;
-  Vertices->v[v].yp += beta * ny;
-  Vertices->v[v].zp += beta * nz;
-} // MoveVertex()
-
-/* ==================================== */
-void AddNoiseMesh(double alpha)
-/* ==================================== */
-{
-  int32_t i;
-  for (i = 0; i < Vertices->cur; i++)
-  {
-
-    Vertices->v[i].x += Normal(0.0, alpha);
-    Vertices->v[i].y += Normal(0.0, alpha);
-    Vertices->v[i].z += Normal(0.0, alpha);
-  }
-} /* AddNoiseMesh() */
-
-/* ==================================== */
-void LissageMesh()
-/* ==================================== */
-/* 
-   ATTENTION : utilise et modifie les champs xp, yp, zp du vertex V.
-   Les sommets dont les labels sont non nuls resteront a leur position initiale .
-*/
-{
-#define MAXVOISEDGES 100
-  int32_t e, i, f1, f2, v1, v2;
-  double c, cv;
-
-  //printf("%d %d\n", Vertices->cur, Edges->cur);
-
-  for (i = 0; i < Vertices->cur; i++)
-  {
-    Vertices->tmp[i] = 0;
-    Vertices->v[i].xp = Vertices->v[i].yp = Vertices->v[i].zp = 0.0;
-  }
-
-  for (e = 0; e < Edges->cur; e++)
-  {
-    c = Edges->e[e].curv;
-    f2 = Edges->e[e].f2;
-    if (f2 == -1) goto next;
-    f1 = Edges->e[e].f1;
-    v1 = OppositeVertex(f1, e);
-    //printf("Vertices->lab[%d] = %d\n", v1, Vertices->lab[v1]);
-    if (Vertices->lab[v1] == 0)
-    {
-      cv = CurvVoisEdges(v1);
-      //printf("e = %d, c = %g, cv1 = %g\n", e, c, cv);
-      if ((c >= 0) && (c > cv)) MoveVertex(v1, f1, e, c - cv);
-      if ((c <= 0) && (c < cv)) MoveVertex(v1, f1, e, c - cv);
-    }
-
-    v2 = OppositeVertex(f2, e);
-    if (Vertices->lab[v2] == 0)
-    {
-      cv = CurvVoisEdges(v2);
-      //printf("e = %d, c = %g, cv2 = %g\n", e, c, cv);
-      if ((c >= 0) && (c > cv)) MoveVertex(v2, f2, e, c - cv);
-      if ((c <= 0) && (c < cv)) MoveVertex(v2, f2, e, c - cv);
-    }
-    next:;
-  }
-
-  for (i = 0; i < Vertices->cur; i++)
-  if (Vertices->tmp[i] > 0)
-  {
-    Vertices->v[i].x += (Vertices->v[i].xp / Vertices->tmp[i]);
-    Vertices->v[i].y += (Vertices->v[i].yp / Vertices->tmp[i]);
-    Vertices->v[i].z += (Vertices->v[i].zp / Vertices->tmp[i]);
-  }
-
-} /* LissageMesh() */
-
-/* ==================================== */
-void RegulMeshLaplacian(int32_t niters)
-/* ==================================== */
-/* 
-   ATTENTION : utilise et modifie les champs xp, yp, zp du vertex V.
-   Les sommets dont les labels sont non nuls resteront a leur position initiale .
-*/
-#undef F_NAME
-#define F_NAME "RegulMeshLaplacian"
-{
-  int32_t i, j, k, n, iter, a;
-  meshvertex V;
-  meshface F;
-  int32_t link[MAXADJFACES];
-  double x, y, z, sx, sy, sz, norme, alpha;
-
-  a = 0; // calcule a = nb max de voisins pour 1 vertex
-  for (i = 0; i < Vertices->cur; i++)
-    if (Vertices->v[i].nfaces > a) a = Vertices->v[i].nfaces; 
-  alpha = 1.0 / (4 * a);
-
-#ifdef MESURE
-  Edges = AllocEdges(1);
-  ComputeEdges();
-#endif
-
-  for (iter = 0; iter < niters; iter++)
-  {
-#ifdef VERBOSE
-    printf("%s: iter %d\n", F_NAME, iter);
-#endif
-#ifdef MESURE
-    {
-      double mean, stddev, meandc = MeanDistCenter();
-      MeanAngleFaces(&mean, &stddev);
-      printf("meanangle = %g ; std. deviation = %g ; mean dist center = %g\n", 
-	     mean, stddev, meandc);
-    }
-#endif
-    for (i = 0; i < Vertices->cur; i++)
-    {
-      if (Vertices->lab[i] == 0)
-      {                              /* pour chaque sommet de la grille dont le label est nul */
-        V = Vertices->v[i];
-        n = 0;
-        for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
-          {                                      /* et calcule le link */
-          F = Faces->f[V.face[j]];
-          k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-        } /* for j */
-#ifdef WARN_NON_CYCLE
-        if (n != V.nfaces)
-        {
-          fprintf(stderr, "%s: warning: link[%d] non cycle\n", F_NAME, i);
-        }
-#endif                              
-        sx = sy = sz = 0.0;
-        for (j = 0; j < n; j++)
-        {
-          sx += Vertices->v[link[j]].x;
-          sy += Vertices->v[link[j]].y;
-          sz += Vertices->v[link[j]].z;
-        } /* for j */
-        x = sx / n; y = sy / n; z = sz / n;
-#ifdef PAS_INDEPT_NB_VOIS
-        Vertices->v[i].xp = (x + Vertices->v[i].x) / 2;
-        Vertices->v[i].yp = (y + Vertices->v[i].y) / 2;
-        Vertices->v[i].zp = (z + Vertices->v[i].z) / 2;
-#endif
-        Vertices->v[i].xp = (1.0 - n * alpha) * Vertices->v[i].x + n * alpha * x;
-        Vertices->v[i].yp = (1.0 - n * alpha) * Vertices->v[i].y + n * alpha * y;
-        Vertices->v[i].zp = (1.0 - n * alpha) * Vertices->v[i].z + n * alpha * z;
-      } /* if ... */
-      else
-      {
-        Vertices->v[i].xp = Vertices->v[i].x;
-        Vertices->v[i].yp = Vertices->v[i].y;
-        Vertices->v[i].zp = Vertices->v[i].z;
-      } /* else */
-    } /* for i */
-    // stocke le resultat dans (x,y,z) 
-    for (i = 0; i < Vertices->cur; i++)
-    {
-      Vertices->v[i].x = Vertices->v[i].xp;
-      Vertices->v[i].y = Vertices->v[i].yp;
-      Vertices->v[i].z = Vertices->v[i].zp;
-    }
-  } // for (iter = 0; iter < niters; iter++)
-} /* RegulMeshLaplacian() */
-
-/* ==================================== */
-void RegulMeshHamam(double theta)
-/* ==================================== */
-/* 
-   ATTENTION : utilise et modifie les champs xp, yp, zp du vertex V.
-   Les sommets dont les labels sont non nuls resteront a leur position initiale .
-   Methode de Hamam & al [HC06]
-*/
-#undef F_NAME
-#define F_NAME "RegulMeshHamam"
-#define RMH_EPSILON 1E-3
-{
-  int32_t a, n, i, j, k, iter, nv;
-  meshvertex V;
-  meshface F;
-  int32_t link[MAXADJFACES];
-  double x, y, z, sx, sy, sz, alphax, alphay, alphaz;
-  double *tx, *ty, *tz;    // resultats intermediaires
-  int32_t nitermax = NITERMAX; // garde-fou
-  double normgradx, normgrady, normgradz, divisorx, divisory, divisorz;
-  int32_t stabilite;
-#ifdef OPTIMALSTEP
-  double *ux, *uy, *uz;    // resultats intermediaires
-#endif
-
-  tx = (double *)calloc(1,Vertices->cur * sizeof(double));
-  ty = (double *)calloc(1,Vertices->cur * sizeof(double));
-  tz = (double *)calloc(1,Vertices->cur * sizeof(double));
-  if ((tx == NULL) || (ty == NULL) || (tz == NULL))
-  {
-    fprintf(stderr, "%s: malloc failed\n", F_NAME);
-    exit(0);    
-  }
-
-#ifdef OPTIMALSTEP
-  ux = (double *)calloc(1,Vertices->cur * sizeof(double));
-  uy = (double *)calloc(1,Vertices->cur * sizeof(double));
-  uz = (double *)calloc(1,Vertices->cur * sizeof(double));
-  if ((ux == NULL) || (uy == NULL) || (uz == NULL))
-  {
-    fprintf(stderr, "%s: malloc failed\n", F_NAME);
-    exit(0);    
-  }
-#endif
-
-  for (i = 0; i < Vertices->cur; i++)  // sauve les coordonnees initiales
-  {
-    Vertices->v[i].xo = Vertices->v[i].x;
-    Vertices->v[i].yo = Vertices->v[i].y;
-    Vertices->v[i].zo = Vertices->v[i].z;
-  }
-
-  a = 0; // calcule a = nb max de voisins pour 1 vertex
-  for (i = 0; i < Vertices->cur; i++)
-    if (Vertices->v[i].nfaces > a) a = Vertices->v[i].nfaces; 
-  // calcule alpha pour une convergence monotone
-  alphax = alphay = alphaz = 1.0 / (1.0 + 4.0 * a * a * theta);
-  if (Links == NULL) ComputeLinks();
-  iter = 0;
-  stabilite = 0;
-  while ((stabilite == 0) && (iter < nitermax))
-  {
-    stabilite = 1;
-    iter++;
-#ifdef DEBUG
-    fprintf(stderr, "%s: iteration %d\n", F_NAME, iter);
-#endif
-    for (n = 0, i = 0; i < Vertices->cur; i++) // calcule A x --- resultat dans tx, ty, tz
-    {
-      nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-      sx = nv * Vertices->v[i].x;
-      sy = nv * Vertices->v[i].y;
-      sz = nv * Vertices->v[i].z;
-      for (; n <= Links->lastneigh[i]; n++)
-      {
-        j = Links->neigh[n];
-        sx -= Vertices->v[j].x;
-        sy -= Vertices->v[j].y;
-        sz -= Vertices->v[j].z;
-      }
-      tx[i] = sx; ty[i] = sy; tz[i] = sz; 
-    } // for (i = 0; i < Vertices->cur; i++)
-    for (n = 0, i = 0; i < Vertices->cur; i++) // calcule theta A^2 x --- resultat dans Vertices->v[].xp, yp, zp;
-    {
-      nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-      sx = nv * tx[i];
-      sy = nv * ty[i];
-      sz = nv * tz[i];
-      for (; n <= Links->lastneigh[i]; n++)
-      {
-        j = Links->neigh[n];
-        sx -= tx[j];
-        sy -= ty[j];
-        sz -= tz[j];
-      }
-      Vertices->v[i].xp = theta * sx; 
-      Vertices->v[i].yp = theta * sy; 
-      Vertices->v[i].zp = theta * sz; 
-    } // for (i = 0; i < Vertices->cur; i++)
-
-#ifdef PLOTCOSTFUNCTION
- {
-   double J = 0.0;
-   for (i = 0; i < Vertices->cur; i++)
-   {
-     tx[i] = (Vertices->v[i].x - Vertices->v[i].xo) * 
-             (Vertices->v[i].x - Vertices->v[i].xo) + 
-              Vertices->v[i].x * Vertices->v[i].xp;
-     ty[i] = (Vertices->v[i].y - Vertices->v[i].yo) * 
-             (Vertices->v[i].y - Vertices->v[i].yo) + 
-              Vertices->v[i].y * Vertices->v[i].yp;
-     tz[i] = (Vertices->v[i].z - Vertices->v[i].zo) * 
-             (Vertices->v[i].z - Vertices->v[i].zo) + 
-              Vertices->v[i].z * Vertices->v[i].zp;
-     J += tx[i]*tx[i] + ty[i]*ty[i] + tz[i]*tz[i]; 
-   } // for (i = 0; i < Vertices->cur; i++)
-   printf("%g\n", J);
- }
-#endif
-
-    normgradx = normgrady = normgradz = 0.0;
-    for (i = 0; i < Vertices->cur; i++) // calcule le gradient nabla J  --- resultat dans t?[];
-    {
-      tx[i] = Vertices->v[i].x - Vertices->v[i].xo + Vertices->v[i].xp;
-      ty[i] = Vertices->v[i].y - Vertices->v[i].yo + Vertices->v[i].yp;
-      tz[i] = Vertices->v[i].z - Vertices->v[i].zo + Vertices->v[i].zp;
-
-      normgradx += tx[i]*tx[i];
-      normgrady += ty[i]*ty[i];
-      normgradz += tz[i]*tz[i]; 
-    } // for (i = 0; i < Vertices->cur; i++)
-
-#ifdef OPTIMALSTEP
-    for (n = 0, i = 0; i < Vertices->cur; i++) // calcule A J --- resultat dans ux, uy, uz;
-    {
-      nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-      sx = nv * tx[i];
-      sy = nv * ty[i];
-      sz = nv * tz[i];
-      for (; n <= Links->lastneigh[i]; n++)
-      {
-        j = Links->neigh[n];
-        sx -= tx[j];
-        sy -= ty[j];
-        sz -= tz[j];
-      }
-      ux[i] = sx; 
-      uy[i] = sy; 
-      uz[i] = sz; 
-    } // for (i = 0; i < Vertices->cur; i++)
-
-    for (n = 0, i = 0; i < Vertices->cur; i++) // calcule (I + theta A^2) J --- resultat dans Vertices->v[].xp, yp, zp;
-    {
-      nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-      sx = nv * ux[i];
-      sy = nv * uy[i];
-      sz = nv * uz[i];
-      for (; n <= Links->lastneigh[i]; n++)
-      {
-        j = Links->neigh[n];
-        sx -= ux[j];
-        sy -= uy[j];
-        sz -= uz[j];
-      }
-      Vertices->v[i].xp = tx[i] + (theta * sx); 
-      Vertices->v[i].yp = ty[i] + (theta * sy); 
-      Vertices->v[i].zp = tz[i] + (theta * sz); 
-    } // for (i = 0; i < Vertices->cur; i++)
-
-    divisorx = divisory = divisorz = 0.0;
-    for (i = 0; i < Vertices->cur; i++) // calcule J^t (I + theta A^2) J
-    {
-      divisorx += Vertices->v[i].xp * tx[i];
-      divisory += Vertices->v[i].yp * ty[i];
-      divisorz += Vertices->v[i].zp * tz[i];
-    } // for (i = 0; i < Vertices->cur; i++)
-    alphax = normgradx / divisorx;
-    alphay = normgrady / divisory;
-    alphaz = normgradz / divisorz;
-#endif
-
-    for (i = 0; i < Vertices->cur; i++) // calcule x pour l'iteration suivante  --- resultat dans Vertices->v[].x, y, z;
-    {
-      Vertices->v[i].x = Vertices->v[i].x - (alphax * tx[i]);
-      Vertices->v[i].y = Vertices->v[i].y - (alphay * ty[i]);
-      Vertices->v[i].z = Vertices->v[i].z - (alphaz * tz[i]);
-    } // for (i = 0; i < Vertices->cur; i++)
-
-    if ((sqrt(normgradx) > RMH_EPSILON) || 
-	(sqrt(normgrady) > RMH_EPSILON) ||
-	(sqrt(normgradz) > RMH_EPSILON)) stabilite = 0;
-
-#ifdef DEBUG
-  fprintf(stderr, "%s: normgradx = %g ; normgrady = %g ; normgradz = %g ; niter = %d\n", 
-	  F_NAME, sqrt(normgradx), sqrt(normgrady), sqrt(normgradz), iter);
-#endif
-
-  } // while (!stabilite && (iter < nitermax))
-
-  if (iter == nitermax)
-    fprintf(stderr, "%s: WARNING: non-convergence\n", F_NAME);
-
-#ifdef VERBOSE
-#ifndef PLOTCOSTFUNCTION 
-  //  fprintf(stderr, "%s: alphax = %g ; niter = %d\n", F_NAME, alpha, iter);
-  printf("%g\t%d\t", alphax, iter);
-#endif
-#endif
-
-  free(tx); free(ty); free(tz); 
-#ifdef OPTIMALSTEP
-  free(ux); free(uy); free(uz); 
-#endif
-} /* RegulMeshHamam() */
-
-/* ==================================== */
-void RegulMeshHamam1(double theta)
-/* ==================================== */
-/* 
-   ATTENTION : utilise et modifie les champs xp, yp, zp du vertex V.
-   Les sommets dont les labels sont non nuls resteront a leur position initiale .
-   Methode de Hamam & al [HC06], variante avec A au lieu de AA
-*/
-#undef F_NAME
-#define F_NAME "RegulMeshHamam1"
-{
-  int32_t a, n, i, j, k, iter, nv;
-  meshvertex V;
-  meshface F;
-  int32_t link[MAXADJFACES];
-  double x, y, z, sx, sy, sz, alphax, alphay, alphaz;
-  double *tx, *ty, *tz;    // resultats intermediaires
-  int32_t nitermax = NITERMAX; // garde-fou
-  double normgradx, normgrady, normgradz, divisorx, divisory, divisorz;
-  int32_t stabilite;
-
-  tx = (double *)calloc(1,Vertices->cur * sizeof(double));
-  ty = (double *)calloc(1,Vertices->cur * sizeof(double));
-  tz = (double *)calloc(1,Vertices->cur * sizeof(double));
-  if ((tx == NULL) || (ty == NULL) || (tz == NULL))
-  {
-    fprintf(stderr, "%s: malloc failed\n", F_NAME);
-    exit(0);    
-  }
-
-  for (i = 0; i < Vertices->cur; i++)  // sauve les coordonnees initiales
-  {
-    Vertices->v[i].xo = Vertices->v[i].x;
-    Vertices->v[i].yo = Vertices->v[i].y;
-    Vertices->v[i].zo = Vertices->v[i].z;
-  }
-
-  a = 0; // calcule a = nb max de voisins pour 1 vertex
-  for (i = 0; i < Vertices->cur; i++)
-    if (Vertices->v[i].nfaces > a) a = Vertices->v[i].nfaces; 
-  // calcule alpha pour une convergence monotone
-  alphax = alphay = alphaz = 1.0 / (1.0 + 2.0 * a * theta);
-
-  if (Links == NULL) ComputeLinks();
-
-  iter = 0;
-  stabilite = 0;
-  while ((stabilite == 0) && (iter < nitermax))
-  {
-    stabilite = 1;
-    iter++;
-#ifdef DEBUG
-    fprintf(stderr, "%s: iteration %d\n", F_NAME, iter);
-#endif
-    for (n = 0, i = 0; i < Vertices->cur; i++) // calcule theta A x --- resultat dans Vertices->v[].xp, yp, zp;
-    {
-      nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-      sx = nv * Vertices->v[i].x;
-      sy = nv * Vertices->v[i].y;
-      sz = nv * Vertices->v[i].z;
-      for (; n <= Links->lastneigh[i]; n++)
-      {
-        j = Links->neigh[n];
-        sx -= Vertices->v[j].x;
-        sy -= Vertices->v[j].y;
-        sz -= Vertices->v[j].z;
-      }
-      Vertices->v[i].xp = theta * sx; 
-      Vertices->v[i].yp = theta * sy; 
-      Vertices->v[i].zp = theta * sz; 
-    } // for (i = 0; i < Vertices->cur; i++)
-
-#ifdef PLOTCOSTFUNCTION
- {
-   double J = 0.0;
-   for (i = 0; i < Vertices->cur; i++)
-   {
-     tx[i] = (Vertices->v[i].x - Vertices->v[i].xo) * 
-             (Vertices->v[i].x - Vertices->v[i].xo) + 
-              Vertices->v[i].x * Vertices->v[i].xp;
-     ty[i] = (Vertices->v[i].y - Vertices->v[i].yo) * 
-             (Vertices->v[i].y - Vertices->v[i].yo) + 
-              Vertices->v[i].y * Vertices->v[i].yp;
-     tz[i] = (Vertices->v[i].z - Vertices->v[i].zo) * 
-             (Vertices->v[i].z - Vertices->v[i].zo) + 
-              Vertices->v[i].z * Vertices->v[i].zp;
-     J += tx[i]*tx[i] + ty[i]*ty[i] + tz[i]*tz[i]; 
-   } // for (i = 0; i < Vertices->cur; i++)
-   printf("%g\n", J);
- }
-#endif
-
-    normgradx = normgrady = normgradz = 0.0;
-    for (i = 0; i < Vertices->cur; i++) // calcule le gradient nabla J  --- resultat dans t?[];
-    {
-      tx[i] = Vertices->v[i].x - Vertices->v[i].xo + Vertices->v[i].xp;
-      ty[i] = Vertices->v[i].y - Vertices->v[i].yo + Vertices->v[i].yp;
-      tz[i] = Vertices->v[i].z - Vertices->v[i].zo + Vertices->v[i].zp;
-
-      normgradx += tx[i]*tx[i];
-      normgrady += ty[i]*ty[i];
-      normgradz += tz[i]*tz[i]; 
-    } // for (i = 0; i < Vertices->cur; i++)
-
-#ifdef OPTIMALSTEP
-    for (n = 0, i = 0; i < Vertices->cur; i++) // calcule (I + theta A) Jx --- resultat dans Vertices->v[].xp, yp, zp;
-    {
-      nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-      sx = nv * tx[i];
-      sy = nv * ty[i];
-      sz = nv * tz[i];
-      for (; n <= Links->lastneigh[i]; n++)
-      {
-        j = Links->neigh[n];
-        sx -= tx[j];
-        sy -= ty[j];
-        sz -= tz[j];
-      }
-      Vertices->v[i].xp = tx[i] + (theta * sx); 
-      Vertices->v[i].yp = ty[i] + (theta * sy); 
-      Vertices->v[i].zp = tz[i] + (theta * sz); 
-    } // for (i = 0; i < Vertices->cur; i++)
-    divisorx = divisory = divisorz = 0.0;
-    for (i = 0; i < Vertices->cur; i++) // calcule Jx^t (I + theta A) Jx
-    {
-      divisorx += Vertices->v[i].xp * tx[i];
-      divisory += Vertices->v[i].yp * ty[i];
-      divisorz += Vertices->v[i].zp * tz[i];
-    } // for (i = 0; i < Vertices->cur; i++)
-    alphax = normgradx / divisorx;
-    alphay = normgrady / divisory;
-    alphaz = normgradz / divisorz;
-#endif
-
-    for (i = 0; i < Vertices->cur; i++) // calcule x pour l'iteration suivante  --- resultat dans Vertices->v[].x, y, z;
-    {
-      Vertices->v[i].x = Vertices->v[i].x - (alphax * tx[i]);
-      Vertices->v[i].y = Vertices->v[i].y - (alphay * ty[i]);
-      Vertices->v[i].z = Vertices->v[i].z - (alphaz * tz[i]);
-    } // for (i = 0; i < Vertices->cur; i++)
-
-    if ((sqrt(normgradx) > RMH_EPSILON) || 
-	(sqrt(normgrady) > RMH_EPSILON) ||
-	(sqrt(normgradz) > RMH_EPSILON)) stabilite = 0;
-
-#ifdef DEBUG
-  fprintf(stderr, "%s: normgradx = %g ; normgrady = %g ; normgradz = %g ; niter = %d\n", 
-	  F_NAME, sqrt(normgradx), sqrt(normgrady), sqrt(normgradz), iter);
-#endif
-
-  } // while (!stabilite && (iter < nitermax))
-
-#ifdef VERBOSE
-#ifndef PLOTCOSTFUNCTION 
-  //  fprintf(stderr, "%s: alpha = %g ; niter = %d\n", F_NAME, alpha, iter);
-  printf("%g\t%d\t", alphax, iter);
-#endif
-#endif
-
-  if (iter == nitermax)
-    fprintf(stderr, "%s: WARNING: non-convergence\n", F_NAME);
-
-  free(tx); free(ty); free(tz); 
-} /* RegulMeshHamam1() */
-
-/* ==================================== */
-void RegulMeshHamam2(int32_t nitermax)
-/* ==================================== */
-/* 
-   ATTENTION : utilise et modifie les champs xp, yp, zp du vertex V.
-   Les sommets dont les labels sont non nuls resteront a leur position initiale .
-   Methode de Hamam & al [HC06], test d'une variante (theta = infini)
-*/
-#undef F_NAME
-#define F_NAME "RegulMeshHamam2"
-{
-  int32_t a, n, i, j, k, iter, nv;
-  meshvertex V;
-  meshface F;
-  int32_t link[MAXADJFACES];
-  double x, y, z, sx, sy, sz, alpha, dx, dy, dz;
-  double *tx, *ty, *tz; // resultats intermediaires
-  double normgradx, normgrady, normgradz;
-  int32_t stabilite;
-
-  if (nitermax == -1) nitermax = NITERMAX;
-
-  tx = (double *)calloc(1,Vertices->cur * sizeof(double));
-  ty = (double *)calloc(1,Vertices->cur * sizeof(double));
-  tz = (double *)calloc(1,Vertices->cur * sizeof(double));
-  if ((tx == NULL) || (ty == NULL) || (tz == NULL))
-  {
-    fprintf(stderr, "%s: malloc failed\n", F_NAME);
-    exit(0);    
-  }
-
-  for (i = 0; i < Vertices->cur; i++)  // sauve les coordonnees initiales
-  {
-    Vertices->v[i].xo = Vertices->v[i].x;
-    Vertices->v[i].yo = Vertices->v[i].y;
-    Vertices->v[i].zo = Vertices->v[i].z;
-  }
-
-  a = 0; // calcule a = nb max de voisins pour 1 vertex
-  for (i = 0; i < Vertices->cur; i++)
-    if (Vertices->v[i].nfaces > a) a = Vertices->v[i].nfaces; 
-  // calcule alpha pour une convergence monotone
-  alpha = 1.0 / (1.0 + 4.0 * a * a);
-  if (Links == NULL) ComputeLinks();
-
-#ifdef MESURE
-  Edges = AllocEdges(1);
-  ComputeEdges();
-#endif
-
-  iter = 0;
-  stabilite = 0;
-  while ((stabilite == 0) && (iter < nitermax))
-  {
-    stabilite = 1;
-    normgradx = normgrady = normgradz = 0.0;
-    iter++;
-#ifdef DEBUG
-    fprintf(stderr, "%s: iteration %d\n", F_NAME, iter);
-#endif
-#ifdef MESURE
-    {
-      double mean, stddev, meandc = MeanDistCenter();
-      MeanAngleFaces(&mean, &stddev);
-      printf("meanangle = %g ; std. deviation = %g ; mean dist center = %g\n", 
-	     mean, stddev, meandc);
-    }
-#endif
-
-    for (n = 0, i = 0; i < Vertices->cur; i++) // calcule A x --- resultat dans tx, ty, tz
-    {
-      nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-      sx = nv * Vertices->v[i].x;
-      sy = nv * Vertices->v[i].y;
-      sz = nv * Vertices->v[i].z;
-      for (; n <= Links->lastneigh[i]; n++)
-      {
-        j = Links->neigh[n];
-        sx -= Vertices->v[j].x;
-        sy -= Vertices->v[j].y;
-        sz -= Vertices->v[j].z;
-      }
-      tx[i] = sx; ty[i] = sy; tz[i] = sz; 
-    } // for (i = 0; i < Vertices->cur; i++)
-    for (n = 0, i = 0; i < Vertices->cur; i++) // calcule A^2 x --- resultat dans Vertices->v[].xp, yp, zp;
-    {
-      nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-      sx = nv * tx[i];
-      sy = nv * ty[i];
-      sz = nv * tz[i];
-      for (; n <= Links->lastneigh[i]; n++)
-      {
-        j = Links->neigh[n];
-        sx -= tx[j];
-        sy -= ty[j];
-        sz -= tz[j];
-      }
-      Vertices->v[i].xp = sx; 
-      Vertices->v[i].yp = sy; 
-      Vertices->v[i].zp = sz; 
-    } // for (i = 0; i < Vertices->cur; i++)
-    for (i = 0; i < Vertices->cur; i++) // calcule x pour l'iteration suivante  --- resultat dans Vertices->v[].x, y, z;
-    {
-      dx = Vertices->v[i].xp;
-      dy = Vertices->v[i].yp;
-      dz = Vertices->v[i].zp;
-
-      normgradx += dx*dx;
-      normgrady += dy*dy;
-      normgradz += dz*dz; 
-
-      Vertices->v[i].x = Vertices->v[i].x - (alpha * dx);
-      Vertices->v[i].y = Vertices->v[i].y - (alpha * dy);
-      Vertices->v[i].z = Vertices->v[i].z - (alpha * dz);
-
-    } // for (i = 0; i < Vertices->cur; i++)
-
-    if ((sqrt(normgradx) > RMH_EPSILON) || 
-	(sqrt(normgrady) > RMH_EPSILON) ||
-	(sqrt(normgradz) > RMH_EPSILON)) stabilite = 0;
-
-#ifdef DEBUG
-  fprintf(stderr, "%s: normgradx = %g ; normgrady = %g ; normgradz = %g ; niter = %d\n", 
-	  F_NAME, sqrt(normgradx), sqrt(normgrady), sqrt(normgradz), iter);
-#endif
-
-  } // while (!stabilite && (iter < nitermax))
-
-#ifdef VERBOSE
-  if (iter < nitermax)
-    fprintf(stderr, "%s: convergence reached at iteration %d\n", F_NAME, iter);
-#endif
-
-  free(tx); free(ty); free(tz); 
-} /* RegulMeshHamam2() */
-
-/* ==================================== */
-void RegulMeshHamam3(double theta)
-/* ==================================== */
-/* 
-   ATTENTION : utilise et modifie les champs xp, yp, zp du vertex V.
-   Les sommets dont les labels sont non nuls resteront a leur position initiale.
-   Methode de Hamam & al [HC06], variante utilisant le gradient conjugué
-*/
-#undef F_NAME
-#define F_NAME "RegulMeshHamam3"
-{
-  int32_t a, n, i, j, k, iter, nv;
-  meshvertex V;
-  meshface F;
-  int32_t link[MAXADJFACES];
-  double x, y, z, sx, sy, sz;
-  double *dx, *dy, *dz;    // resultats intermediaires
-  double *ex, *ey, *ez;    // resultats intermediaires
-  double *fx, *fy, *fz;    // resultats intermediaires
-  double *tx, *ty, *tz;    // resultats intermediaires
-  double alphax, betax, deltax, gamma_1x, gamma_nx, gamma_n1x;
-  double alphay, betay, deltay, gamma_1y, gamma_ny, gamma_n1y;
-  double alphaz, betaz, deltaz, gamma_1z, gamma_nz, gamma_n1z;
-  // PLUS D'UTILITE POUR gamma_1
-
-  dx = (double *)calloc(1,Vertices->cur * sizeof(double));
-  dy = (double *)calloc(1,Vertices->cur * sizeof(double));
-  dz = (double *)calloc(1,Vertices->cur * sizeof(double));
-  if ((dx == NULL) || (dy == NULL) || (dz == NULL))
-  {
-    fprintf(stderr, "%s: malloc failed\n", F_NAME);
-    exit(0);    
-  }
-
-  ex = (double *)calloc(1,Vertices->cur * sizeof(double));
-  ey = (double *)calloc(1,Vertices->cur * sizeof(double));
-  ez = (double *)calloc(1,Vertices->cur * sizeof(double));
-  if ((ex == NULL) || (ey == NULL) || (ez == NULL))
-  {
-    fprintf(stderr, "%s: malloc failed\n", F_NAME);
-    exit(0);    
-  }
-
-  fx = (double *)calloc(1,Vertices->cur * sizeof(double));
-  fy = (double *)calloc(1,Vertices->cur * sizeof(double));
-  fz = (double *)calloc(1,Vertices->cur * sizeof(double));
-  if ((fx == NULL) || (fy == NULL) || (fz == NULL))
-  {
-    fprintf(stderr, "%s: malloc failed\n", F_NAME);
-    exit(0);    
-  }
-
-  tx = (double *)calloc(1,Vertices->cur * sizeof(double));
-  ty = (double *)calloc(1,Vertices->cur * sizeof(double));
-  tz = (double *)calloc(1,Vertices->cur * sizeof(double));
-  if ((tx == NULL) || (ty == NULL) || (tz == NULL))
-  {
-    fprintf(stderr, "%s: malloc failed\n", F_NAME);
-    exit(0);    
-  }
-
-  for (i = 0; i < Vertices->cur; i++)  // sauve les coordonnees initiales
-  {
-    Vertices->v[i].xo = Vertices->v[i].x;
-    Vertices->v[i].yo = Vertices->v[i].y;
-    Vertices->v[i].zo = Vertices->v[i].z;
-  }
-
-  if (Links == NULL) ComputeLinks();
-
-  for (n = 0, i = 0; i < Vertices->cur; i++) // calcule A x --- resultat dans tx, ty, tz
-  {
-    nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-    sx = nv * Vertices->v[i].x;
-    sy = nv * Vertices->v[i].y;
-    sz = nv * Vertices->v[i].z;
-    for (; n <= Links->lastneigh[i]; n++)
-    {
-      j = Links->neigh[n];
-      sx -= Vertices->v[j].x;
-      sy -= Vertices->v[j].y;
-      sz -= Vertices->v[j].z;
-    }
-    tx[i] = sx; ty[i] = sy; tz[i] = sz; 
-  } // for (i = 0; i < Vertices->cur; i++)
-
-  for (n = 0, i = 0; i < Vertices->cur; i++) // calcule -theta A^2 x --- resultat dans ex, ey, ez et dans dx, dy, dz;
-  {
-    nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-    sx = nv * tx[i];
-    sy = nv * ty[i];
-    sz = nv * tz[i];
-    for (; n <= Links->lastneigh[i]; n++)
-    {
-      j = Links->neigh[n];
-      sx -= tx[j];
-      sy -= ty[j];
-      sz -= tz[j];
-    }
-    dx[i] = ex[i] = -theta * sx; 
-    dy[i] = ey[i] = -theta * sy; 
-    dz[i] = ez[i] = -theta * sz; 
-  } // for (i = 0; i < Vertices->cur; i++)
-
-  gamma_1x = gamma_1y = gamma_1z = 0; // calcule gamma_1 = gamma_n = e^t e
-  for (i = 0; i < Vertices->cur; i++) 
-  { 
-    gamma_1x += ex[i] * ex[i];
-    gamma_1y += ey[i] * ey[i];
-    gamma_1z += ez[i] * ez[i];
-  }
-  gamma_nx = gamma_1x; gamma_ny = gamma_1y; gamma_nz = gamma_1z;
-
-  // =================================================
-  // BOUCLE PRINCIPALE
-  // =================================================
-  for (iter = 1; iter < Vertices->cur; iter++)
-  {
-#ifdef DEBUGHAM3
-    fprintf(stderr, "%s: iteration %d\n", F_NAME, iter);
-#endif
-
-    for (n = 0, i = 0; i < Vertices->cur; i++) // calcule A d --- resultat dans tx, ty, tz
-    {
-      nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-      sx = nv * dx[i];
-      sy = nv * dy[i];
-      sz = nv * dz[i];
-      for (; n <= Links->lastneigh[i]; n++)
-      {
-        j = Links->neigh[n];
-        sx -= dx[j];
-        sy -= dy[j];
-        sz -= dz[j];
-      }
-      tx[i] = sx; ty[i] = sy; tz[i] = sz; 
-    } // for (i = 0; i < Vertices->cur; i++)
-
-    for (n = 0, i = 0; i < Vertices->cur; i++) // calcule d + theta A^2 d --- resultat dans fx, fy, fz;
-    {
-      nv = Links->lastneigh[i] - n + 1; // nb de voisins de i
-      sx = nv * tx[i];
-      sy = nv * ty[i];
-      sz = nv * tz[i];
-      for (; n <= Links->lastneigh[i]; n++)
-      {
-        j = Links->neigh[n];
-        sx -= tx[j];
-        sy -= ty[j];
-        sz -= tz[j];
-      }
-      fx[i] = dx[i] + theta * sx; 
-      fy[i] = dy[i] + theta * sy; 
-      fz[i] = dz[i] + theta * sz; 
-    } // for (i = 0; i < Vertices->cur; i++)
-
-    alphax = alphay = alphaz = 0; // calcule d^t f, résultat dans alpha
-    for (i = 0; i < Vertices->cur; i++)
-    {
-      alphax += dx[i] * fx[i];
-      alphay += dy[i] * fy[i];
-      alphaz += dz[i] * fz[i];
-    }
-    alphax = gamma_nx / alphax; // calcule alpha
-    alphay = gamma_ny / alphay;
-    alphaz = gamma_nz / alphaz;
-
-    for (i = 0; i < Vertices->cur; i++) // x = x + alpha d
-    {
-      Vertices->v[i].x += alphax * dx[i];
-      Vertices->v[i].y += alphay * dy[i];
-      Vertices->v[i].z += alphaz * dz[i];
-    }
-
-    for (i = 0; i < Vertices->cur; i++) // e = e - alpha f
-    {
-      ex[i] -= alphax * fx[i];
-      ey[i] -= alphay * fy[i];
-      ez[i] -= alphaz * fz[i];
-    }
-
-    gamma_n1x = gamma_n1y = gamma_n1z = 0; // calcule gamma_n1 = e^t e
-    for (i = 0; i < Vertices->cur; i++)
-    {
-      gamma_n1x += ex[i] * ex[i];
-      gamma_n1y += ey[i] * ey[i];
-      gamma_n1z += ez[i] * ez[i];
-    }
-
-    betax = gamma_n1x / gamma_nx; // calcule beta = gamma_n1 / gamma_n
-    betay = gamma_n1y / gamma_ny;
-    betaz = gamma_n1z / gamma_nz;
-
-    gamma_nx = gamma_n1x; // gamma_n = gamma_n1
-    gamma_ny = gamma_n1y;
-    gamma_nz = gamma_n1z;
-
-    for (i = 0; i < Vertices->cur; i++) // d = e + beta d
-    {
-      dx[i] = ex[i] + betax * dx[i];
-      dy[i] = ey[i] + betay * dy[i];
-      dz[i] = ez[i] + betaz * dz[i];
-    }
-  } // for (iter = 1; iter < Vertices->cur; iter++)
-
-  free(tx); free(ty); free(tz); 
-  free(dx); free(dy); free(dz); 
-  free(ex); free(ey); free(ez); 
-  free(fx); free(fy); free(fz); 
-} /* RegulMeshHamam3() */
-
-/* ==================================== */
-void RegulMeshHC(double alpha, double beta)
-/* ==================================== */
-/* 
-   Methode de Vollmer, Mencl et Mueller
-   ATTENTION : utilise et modifie les champs xp, yp, zp du vertex V.
-   Les sommets dont les labels sont non nuls resteront a leur position initiale .
-*/
-#undef F_NAME
-#define F_NAME "RegulMeshHC"
-{
-  int32_t i, j, k, n, iter;
-  int32_t stabilite, nitermax = NITERMAX;
-  meshvertex V;
-  meshface F;
-  int32_t link[MAXADJFACES];
-  double x, y, z, sx, sy, sz, normgradx, normgrady, normgradz, dx, dy, dz;
-  double *tx, *ty, *tz; // pour calculer la norme du vecteur des modifications
-
-#ifdef VERBOSE
-  //printf("%s: alpha = %g ; beta = %g\n", F_NAME, alpha, beta);
-  printf("%g\t%g\t", alpha, beta);
-#endif
-
-  tx = (double *)calloc(1,Vertices->cur * sizeof(double));
-  ty = (double *)calloc(1,Vertices->cur * sizeof(double));
-  tz = (double *)calloc(1,Vertices->cur * sizeof(double));
-  if ((tx == NULL) || (ty == NULL) || (tz == NULL))
-  {
-    fprintf(stderr, "%s: malloc failed\n", F_NAME);
-    exit(0);    
-  }
-
-  for (i = 0; i < Vertices->cur; i++)  // sauve les coordonnees initiales
-  {
-    Vertices->v[i].xo = Vertices->v[i].x;
-    Vertices->v[i].yo = Vertices->v[i].y;
-    Vertices->v[i].zo = Vertices->v[i].z;
-  }
-
-
-  iter = 0;
-  stabilite = 0;
-  while ((stabilite == 0) && (iter < nitermax))
-  {
-    stabilite = 1;
-    normgradx = normgrady = normgradz = 0.0;
-    iter++;
-
-    for (i = 0; i < Vertices->cur; i++)  // sauve les coordonnees en debut d'iteration
-    {
-      tx[i] = Vertices->v[i].x;
-      ty[i] = Vertices->v[i].y;
-      tz[i] = Vertices->v[i].z;
-    }
-
-#ifdef DEBUG
-    fprintf(stderr, "%s: iter = %d\n", F_NAME, iter);
-#endif
-
-    for (i = 0; i < Vertices->cur; i++) // calcule p (terminologie VMM) et stocke dans (xp,yp,zp)
-    {
-      if (Vertices->lab[i] == 0)
-      {                              /* pour chaque sommet de la grille dont le label est nul */
-        V = Vertices->v[i];
-        n = 0;
-        for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
-          {                                      /* et calcule le link */
-          F = Faces->f[V.face[j]];
-          k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-        } /* for j */
-#ifdef WARN_NON_CYCLE
-        if (n != V.nfaces)
-        {
-          fprintf(stderr, "%s: warning: link[%d] non cycle\n", F_NAME, i);
-        }
-#endif
-        if (n == 0) break; // point isole
-                                
-        sx = sy = sz = 0.0;
-        for (j = 0; j < n; j++)
-        {
-          sx += Vertices->v[link[j]].x;
-          sy += Vertices->v[link[j]].y;
-          sz += Vertices->v[link[j]].z;
-        } /* for j */
-        x = sx / n; y = sy / n; z = sz / n;
-        Vertices->v[i].xp = x;
-        Vertices->v[i].yp = y;
-        Vertices->v[i].zp = z;
-      } /* if ... */
-      else
-      {
-        Vertices->v[i].xp = Vertices->v[i].x;
-        Vertices->v[i].yp = Vertices->v[i].y;
-        Vertices->v[i].zp = Vertices->v[i].z;
-      } /* else */
-    } /* for i */
-  
-    // calcule b = p - (alpha o + (1-alpha) q) et stocke dans (x,y,z) 
-    for (i = 0; i < Vertices->cur; i++)
-    {
-      Vertices->v[i].x = Vertices->v[i].xp - (alpha * Vertices->v[i].xo + (1.0 - alpha) * Vertices->v[i].x);
-      Vertices->v[i].y = Vertices->v[i].yp - (alpha * Vertices->v[i].yo + (1.0 - alpha) * Vertices->v[i].y);
-      Vertices->v[i].z = Vertices->v[i].zp - (alpha * Vertices->v[i].zo + (1.0 - alpha) * Vertices->v[i].z);
-    }
-  
-    // p est dans (xp,yp,zp) et b est dans (x,y,z)
-    // calcule p - (beta b + (1 - beta) * mean(b, link)) et stocke dans (xp,yp,zp)
-    for (i = 0; i < Vertices->cur; i++) 
-    {
-      if (Vertices->lab[i] == 0)
-      {                              /* pour chaque sommet de la grille dont le label est nul */
-        V = Vertices->v[i];
-        n = 0;
-        for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes */
-          {                                      /* et calcule le link */
-          F = Faces->f[V.face[j]];
-          k = F.vert[0]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[1]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-          k = F.vert[2]; if ((k != i) && NotIn(k, link, n)) link[n++] = k;
-        } /* for j */
-        if (n == 0) break; // point isole
-                                
-        sx = sy = sz = 0.0;
-        for (j = 0; j < n; j++)
-        {
-          sx += Vertices->v[link[j]].x;
-          sy += Vertices->v[link[j]].y;
-          sz += Vertices->v[link[j]].z;
-        } /* for j */
-        x = sx / n; y = sy / n; z = sz / n;
-        Vertices->v[i].xp -= (beta * Vertices->v[i].x + (1.0-beta) * x);
-        Vertices->v[i].yp -= (beta * Vertices->v[i].y + (1.0-beta) * y);
-        Vertices->v[i].zp -= (beta * Vertices->v[i].z + (1.0-beta) * z);
-      } /* if ... */
-    } /* for i */
-  
-    // stocke le resultat dans (x,y,z) 
-    for (i = 0; i < Vertices->cur; i++)
-    {
-      Vertices->v[i].x = Vertices->v[i].xp;
-      Vertices->v[i].y = Vertices->v[i].yp;
-      Vertices->v[i].z = Vertices->v[i].zp;
-    }
-
-    // calcule la norme du vecteur d'evolution
-    for (i = 0; i < Vertices->cur; i++)
-    {
-      dx = tx[i] - Vertices->v[i].x;
-      dy = ty[i] - Vertices->v[i].y;
-      dz = tz[i] - Vertices->v[i].z;
-      normgradx += dx*dx;
-      normgrady += dy*dy;
-      normgradz += dz*dz; 
-    }
-
-
-    if ((sqrt(normgradx) > RMH_EPSILON) || 
-	(sqrt(normgrady) > RMH_EPSILON) ||
-	(sqrt(normgradz) > RMH_EPSILON)) stabilite = 0;
-
-  } // while ((stabilite == 0) && (iter < nitermax))
-
-#ifdef VERBOSE
-  if (iter < nitermax)
-    printf("%d\t", iter);
-  //printf("%s: convergence reached at iteration %d\n", F_NAME, iter);
-#endif
-
-  free(tx); free(ty); free(tz); 
-
-} /* RegulMeshHC() */
-
-/* ==================================== */
-void BoundingBoxMesh(meshbox *B)
-/* ==================================== */
-{
-  int32_t i;
-  meshvertex V;
-  B->bxmin = B->bxmax = Vertices->v[0].x; 
-  B->bymin = B->bymax = Vertices->v[0].y; 
-  B->bzmin = B->bzmax = Vertices->v[0].z; 
-  for (i = 1; i < Vertices->cur; i++)
-  {                              /* pour chaque sommet de la grille */
-    V = Vertices->v[i];
-    if (V.x < B->bxmin) B->bxmin = V.x; else if (V.x > B->bxmax) B->bxmax = V.x;
-    if (V.y < B->bymin) B->bymin = V.y; else if (V.y > B->bymax) B->bymax = V.y;
-    if (V.z < B->bzmin) B->bzmin = V.z; else if (V.z > B->bzmax) B->bzmax = V.z;
-  } /* for i */
-} /* BoundingBoxMesh() */
-
-/* ==================================== */
-void IsobarMesh(double *X, double *Y, double *Z)
-/* ==================================== */
-{
-  int32_t i;
-  meshvertex V;
-  double sx, sy, sz;
-
-  sx = sy = sz = 0;
-  for (i = 0; i < Vertices->cur; i++)
-  {                              /* pour chaque sommet de la grille */
-    V = Vertices->v[i];
-    sx += V.x;
-    sy += V.y;
-    sz += V.z;
-  } /* for i */
-  *X = sx / Vertices->cur;
-  *Y = sy / Vertices->cur;
-  *Z = sz / Vertices->cur;
-} /* IsobarMesh() */
-
-/* ==================================== */
-double MeanDistCenter()
-/* ==================================== */
-// mean distance from vertices to the geometric center of the mesh
-{
-  int32_t i;
-  meshvertex V;
-  double sx, sy, sz, md;
-
-  sx = sy = sz = 0.0;
-  for (i = 0; i < Vertices->cur; i++)
-  {
-    V = Vertices->v[i];
-    sx += V.x; sy += V.y; sz += V.z;
-  } /* for i */
-  sx = sx / Vertices->cur;
-  sy = sy / Vertices->cur;
-  sz = sz / Vertices->cur;
-  md = 0.0;
-  for (i = 0; i < Vertices->cur; i++)
-  {
-    V = Vertices->v[i];
-    md += dist3(sx, sy, sz, V.x, V.y, V.z);
-  } /* for i */
-  return md / Vertices->cur;
-} /* IsobarMesh() */
-
-/* ==================================== */
-void TranslateMesh(double x, double y, double z)
-/* ==================================== */
-{
-  int32_t i;
-  for (i = 0; i < Vertices->cur; i++)
-  {                              /* pour chaque sommet de la grille */
-    Vertices->v[i].x += x;
-    Vertices->v[i].y += y;
-    Vertices->v[i].z += z;
-  } /* for i */
-} /* TranslateMesh() */
-
-/* ==================================== */
-void ZoomMesh(double k)
-/* ==================================== */
-{
-  int32_t i;
-  for (i = 0; i < Vertices->cur; i++)
-  {                              /* pour chaque sommet de la grille */
-    Vertices->v[i].x *= k;
-    Vertices->v[i].y *= k;
-    Vertices->v[i].z *= k;
-  } /* for i */
-} /* ZoomMesh() */
-
-/* ==================================== */
-void ZoomMeshX(double k)
-/* ==================================== */
-{
-  int32_t i;
-  for (i = 0; i < Vertices->cur; i++)
-    Vertices->v[i].x *= k;
-} /* ZoomMeshX() */
-
-/* ==================================== */
-void ZoomMeshY(double k)
-/* ==================================== */
-{
-  int32_t i;
-  for (i = 0; i < Vertices->cur; i++)
-    Vertices->v[i].y *= k;
-} /* ZoomMeshY() */
-
-/* ==================================== */
-void ZoomMeshZ(double k)
-/* ==================================== */
-{
-  int32_t i;
-  for (i = 0; i < Vertices->cur; i++)
-    Vertices->v[i].z *= k;
-} /* ZoomMeshZ() */
-
-/* ==================================== */
-double VolMesh()
-/* ==================================== */
-/*
-  Calcule le volume contenu dans le maillage. 
-  Suppose que le maillage constitue une surface combinatoire orientable.
-*/
-{
-  int32_t i, j, k0, k1, k2, n;
-  meshvertex V;
-  meshface F;
-  double x0, y0, z0, x1, y1, z1, x2, y2, z2, vol=0.0;
-
-  for (i = 0; i < Faces->cur; i++)
-  {                              /* pour chaque face */
-    F = Faces->f[i];
-    k0 = F.vert[0]; k1 = F.vert[1]; k2 = F.vert[2];
-    V = Vertices->v[k0];
-    x0 = V.x; y0 = V.y; z0 = V.z;
-    V = Vertices->v[k1];
-    x1 = V.x; y1 = V.y; z1 = V.z;
-    V = Vertices->v[k2];
-    x2 = V.x; y2 = V.y; z2 = V.z;
-    vol += x0*y1*z2 + y0*z1*x2 + z0*x1*y2 - z0*y1*x2 - y0*x1*z2 - x0*z1*y2;
-  } /* for i */
-
-  return -vol/6; /* - a cause de l'orientation des faces */
-} /* VolMesh() */
-
-/* ==================================== */
-void CalculNormales()
-/* ==================================== */
-/* Stocke les normales dans les champs xp, yp, zp du vertex V */
-#undef F_NAME
-#define F_NAME "CalculNormales"
-{
-  int32_t i, j, s1, s2;
-  meshvertex V;
-  meshface F;
-  double x, y, z, norm;
-  vec3 v1, v2, normaleface, normale;
-
-  for (i = 0; i < Vertices->cur; i++)
-  {                              /* pour chaque sommet de la grille */
-    V = Vertices->v[i];
-    normale[0] = normale[1] = normale[2] = 0;
-    for (j = 0; j < V.nfaces; j++) /* parcourt les faces adjacentes au sommet i */
-    {
-      F = Faces->f[V.face[j]];
-      s1 = -1;
-      /* range dans s1 et s2 les indices des 2 autres sommets de la face */
-      /* attention a respecter l'ordre */
-      if (F.vert[0] == i) { s1 = F.vert[1]; s2 = F.vert[2]; }
-      else if (F.vert[1] == i) { s1 = F.vert[2]; s2 = F.vert[0]; }
-      else if (F.vert[2] == i) { s1 = F.vert[0]; s2 = F.vert[1]; }
-#ifdef PARANO
-      else
-      {
-        fprintf(stderr, "%s: unexpected error in mesh structure\n", F_NAME);
-        exit(0);
-      }
-#endif
-      /* calcule les vecteurs: v1 = i - s1, v2 = i - s2 */
-      v1[0] = V.x - Vertices->v[s1].x;
-      v1[1] = V.y - Vertices->v[s1].y;
-      v1[2] = V.z - Vertices->v[s1].z;
-      v2[0] = V.x - Vertices->v[s2].x;
-      v2[1] = V.y - Vertices->v[s2].y;
-      v2[2] = V.z - Vertices->v[s2].z;
-      /* normale face: produit vectoriel de v1 et de v2 */
-      normaleface[0] = v1[1] * v2[2] - v1[2] * v2[1];
-      normaleface[1] = v1[2] * v2[0] - v1[0] * v2[2];
-      normaleface[2] = v1[0] * v2[1] - v1[1] * v2[0];
-      /* cumule pour le calcul de la normale moyenne */
-      normale[0] += normaleface[0];
-      normale[1] += normaleface[1];
-      normale[2] += normaleface[2];
-    } /* for j */
-    /* normalise la normale */
-    norm = normale[0] * normale[0] + normale[1] * normale[1] + normale[2] * normale[2];
-    norm = sqrt(norm);
-    if (norm < EPSILON)
-    {
-      fprintf(stderr, "%s: warning: cannot compute normal for vertex %d\n", F_NAME, i);
-    }
-    else 
-    {
-      Vertices->v[i].xp = -normale[0] / norm;
-      Vertices->v[i].yp = -normale[1] / norm;
-      Vertices->v[i].zp = -normale[2] / norm;
-    }
-  } /* for i */
-} /* CalculNormales() */
-
-/* ==================================== */
-void CalculNormalesFaces()
-/* ==================================== */
-{
-  int32_t i, j, s0, s1, s2;
-  meshvertex V;
-  meshface F;
-  double x, y, z, norm;
-  vec3 v1, v2, normale;
-
-  for (i = 0; i < Faces->cur; i++)
-  {                              /* pour chaque sommet de la grille */
-    F = Faces->f[i];
-    s0 = F.vert[0]; s1 = F.vert[1]; s2 = F.vert[2];
-    /* calcule les vecteurs: v1 = s0 - s1, v2 = s0 - s2 */
-    v1[0] = Vertices->v[s0].x - Vertices->v[s1].x;
-    v1[1] = Vertices->v[s0].y - Vertices->v[s1].y;
-    v1[2] = Vertices->v[s0].z - Vertices->v[s1].z;
-    v2[0] = Vertices->v[s0].x - Vertices->v[s2].x;
-    v2[1] = Vertices->v[s0].y - Vertices->v[s2].y;
-    v2[2] = Vertices->v[s0].z - Vertices->v[s2].z;
-    /* normale face: produit vectoriel de v1 et de v2 */
-    normale[0] = v1[1] * v2[2] - v1[2] * v2[1];
-    normale[1] = v1[2] * v2[0] - v1[0] * v2[2];
-    normale[2] = v1[0] * v2[1] - v1[1] * v2[0];
-
-    /* normalise la normale */
-    norm = normale[0] * normale[0] + normale[1] * normale[1] + normale[2] * normale[2];
-    norm = sqrt(norm);
-    if (norm < EPSILON)
-    {
-      fprintf(stderr, "%s: warning: cannot compute normal for vertex %d\n", F_NAME, i);
-    }
-    else 
-    {
-      Faces->f[i].xn = -normale[0] / norm;
-      Faces->f[i].yn = -normale[1] / norm;
-      Faces->f[i].zn = -normale[2] / norm;
-    }
-  } /* for i */
-} /* CalculNormalesFaces() */
-
-/* ==================================== */
-void PrintMesh()
-/* ==================================== */
-{
-  int32_t i, j;
-  printf(" ========== VERTICES ===========\n");
-  for (i = 0; i < Vertices->cur; i++)
-  {
-    printf("v[%d]: x=%g, y=%g, z=%g;  ", i, 
-           Vertices->v[i].x, Vertices->v[i].y, Vertices->v[i].z);
-    printf("v[%d]: xp=%g, yp=%g, zp=%g;  faces ", i, 
-       Vertices->v[i].xp, Vertices->v[i].yp, Vertices->v[i].zp);
-    for (j = 0; j < Vertices->v[i].nfaces; j++)
-      printf("%d  ", Vertices->v[i].face[j]);
-    printf("\n");
-  }
-  printf(" ============ FACES ===========\n");
-  for (i = 0; i < Faces->cur; i++)
-  {
-    printf("f[%d]: v1=%d, v2=%d, v3=%d ; normale = %g %g %g\n", i, 
-           Faces->f[i].vert[0], Faces->f[i].vert[1], Faces->f[i].vert[2],
-           Faces->f[i].xn, Faces->f[i].yn, Faces->f[i].zn);
-  }
-  if (Edges)
-  {
-    printf(" ============ EDGES ===========\n");
-    for (i = 0; i < Edges->cur; i++)
-    {
-      printf("e[%d]: v1=%d, v2=%d, f1=%d, f2=%d, curv=%g\n", i, 
-             Edges->e[i].v1, Edges->e[i].v2, Edges->e[i].f1, Edges->e[i].f2,
-             Edges->e[i].curv);
-    }
-  }
-  if (Links)
-  {
-    printf(" ============ LINKS ===========\n");
-    j = 0;
-    for (i = 0; i < Vertices->cur; i++)
-    {
-      printf("neigh[%d]: ", i);
-      for (; j <= Links->lastneigh[i]; j++)
-        printf("%d ", Links->neigh[j]);
-      printf("\n");
-    }
-  }
-} /* PrintMesh() */
-
-#ifdef DEBUG
-int32_t main()
-{
-  char r[80];
-  double x1, y1, z1, x2, y2, z2, x3, y3, z3 ;
-
-  InitMesh(1);
-  (void)AddFace(0,0,0, 1,0,0, 0,1,0);
-  (void)AddFace(0,0,0, 1,0,0, 0,0,1);
-  (void)AddFace(0,0,0, 0,0,1, 0,1,0);
-  Edges = AllocEdges(1);
-  ComputeEdges();
-  ComputeLinks();
-  ComputeCurvatures();
-  do
-  {
-    printf("commande (qUIT, PuSH, rEGUL, pRINT)\n");
-    scanf("%s", r);
-    switch (r[0])
-    {
-      case 'u':
-        printf("sommets (9) > ");
-        scanf("%lf %lf %lf", &x1, &y1, &z1);
-        scanf("%lf %lf %lf", &x2, &y2, &z2);
-        scanf("%lf %lf %lf", &x3, &y3, &z3);
-        (void)AddFace(x1, y1, z1, x2, y2, z2, x3, y3, z3);
-        break;
-      case 'r': RegulMeshHamam(1.0); break;
-      case 'p': PrintMesh(); break;
-      case 'q': break;
-    }
-  } while (r[0] != 'q');
-  TermineMesh();
-}
-#endif
diff -r 8b1af7363833 src/lib/mcpolygons.c
--- a/src/lib/mcpolygons.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/mcpolygons.c	Mon Jan 13 15:50:10 2014 +0100
@@ -312,7 +312,7 @@
     {
       a = F.vert[j]; 
       b = F.vert[(j+1)%F.n];
-      if (mcrbt_RbtSearch(P->RBT, (TypRbtKey)(a*N+b)) == P->RBT->nil)
+      if (RbtSearch(P->RBT, (TypRbtKey)(a*N+b)) == P->RBT->nil)
       {
 	e = MCP_AddEdge(P, a, b);
 	(void)mcrbt_RbtInsert(&P->RBT, (TypRbtKey)(a*N+b), (TypRbtAuxData)e);
@@ -384,7 +384,7 @@
     {
       a = F.vert[j]; 
       b = F.vert[(j+1)%F.n];
-      re = mcrbt_RbtSearch(P->RBT, (TypRbtKey)(a*P->Vertices->nsp+b));
+      re = RbtSearch(P->RBT, (TypRbtKey)(a*P->Vertices->nsp+b));
       if (re != P->RBT->nil)
       {
 	E = P->Edges->e[re->auxdata];
@@ -460,7 +460,7 @@
 	fprintf(fileout, "%d ", a);
 #endif
 	b = F.vert[(j+1)%F.n];
-	re = mcrbt_RbtSearch(P->RBT, (TypRbtKey)(a*nsp+b));
+	re = RbtSearch(P->RBT, (TypRbtKey)(a*nsp+b));
 	if (re != P->RBT->nil)
 	{
 	  E = P->Edges->e[re->auxdata];
@@ -523,7 +523,7 @@
     pz[i] = P->Vertices->v[a].z; 
     i++;
     b = F.vert[(j+1)%F.n];
-    re = mcrbt_RbtSearch(P->RBT, (TypRbtKey)(a*nsp+b));
+    re = RbtSearch(P->RBT, (TypRbtKey)(a*nsp+b));
     if (re != P->RBT->nil)
     {
       E = P->Edges->e[re->auxdata];
diff -r 8b1af7363833 src/lib/mcrbt.c
--- a/src/lib/mcrbt.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/mcrbt.c	Mon Jan 13 15:50:10 2014 +0100
@@ -171,7 +171,6 @@
 } /* mcrbt_CreeRbtVide() */
 
 /* ==================================== */
-static
 void RbtTransRec(
   Rbt **T, Rbt * A, RbtElt * x)
 /* ==================================== */
@@ -183,7 +182,6 @@
 } /* RbtTransRec() */
 
 /* ==================================== */
-static
 void RbtReAlloc(Rbt **A)
 /* ==================================== */
 {
@@ -206,7 +204,6 @@
 } /* RbtReAlloc() */
 
 /* ==================================== */
-static
 void RbtFlush(
   Rbt * T)
 /* ==================================== */
@@ -238,7 +235,6 @@
 } /* mcrbt_RbtTermine() */
 
 /* ==================================== */
-static
 void RbtPrintRec(
   Rbt * T, RbtElt * x, index_t niv)
 /* ==================================== */
@@ -258,7 +254,6 @@
 } /* RbtPrintRec() */
 
 /* ==================================== */
-static
 void RbtPrint(
   Rbt * T)
 /* ==================================== */
@@ -267,7 +262,7 @@
 } /* RbtPrint() */
 
 /* ==================================== */
-RbtElt * mcrbt_RbtSearch(
+RbtElt * RbtSearch(
   Rbt * T, TypRbtKey k)
 /* ==================================== */
 {
@@ -287,7 +282,6 @@
 } /* mcrbt_RbtMinimum() */
 
 /* ==================================== */
-static
 RbtElt * RbtMaximum(
   Rbt * T, RbtElt * x)
 /* ==================================== */
@@ -647,7 +641,7 @@
 } /* mcrbt_RbtDelete() */
 
 /* ==================================== */
-TypRbtAuxData mcrbt_RbtPopMin(
+TypRbtAuxData RbtPopMin(
   Rbt * T)
 /* ==================================== */
 /* 
@@ -665,7 +659,6 @@
 } /* RbtPopMin() */
 
 /* ==================================== */
-static
 TypRbtAuxData RbtPopMax(
   Rbt * T)
 /* ==================================== */
@@ -684,7 +677,7 @@
 } /* RbtPopMax() */
 
 /* ==================================== */
-TypRbtKey mcrbt_RbtMinLevel(
+TypRbtKey RbtMinLevel(
   Rbt * T)
 /* ==================================== */
 {
@@ -726,14 +719,14 @@
       case 'd':
         printf("valeur > ");
         scanf("%lf", &p);
-        x = mcrbt_RbtSearch(T, p);
+        x = RbtSearch(T, p);
         if (x != T->nil) mcrbt_RbtDelete(T, x);
         else printf("pas trouve !\n");
         break;
       case 's':
         printf("valeur > ");
         scanf("%lf", &p);
-        x = mcrbt_RbtSearch(T, p);
+        x = RbtSearch(T, p);
         printf("trouve: %d\n", x != T->nil);
         break;
       case 'i':
@@ -747,7 +740,7 @@
       case 'c':
         printf("valeur > ");
         scanf("%lf", &p);
-        x = mcrbt_RbtSearch(T, p);
+        x = RbtSearch(T, p);
         printf("trouve: %d\n", x != T->nil);
         if (x != T->nil)
 	{
@@ -759,7 +752,7 @@
         if (mcrbt_RbtVide(T)) 
           printf("vide\n");
         else
-          (void)mcrbt_RbtPopMin(T); 
+          (void)RbtPopMin(T); 
         break;
       case 'p': RbtPrint(T); break;
       case 'v': printf("vide: %d\n", mcrbt_RbtVide(T)); break;
@@ -791,7 +784,7 @@
         printf("vide\n");
       else
       {
-        d = mcrbt_RbtPopMin(T); 
+        d = RbtPopMin(T); 
         n--;
         printf("je retire %ld; n = %d\n", d, n);
       }
diff -r 8b1af7363833 src/lib/mcrbt1.c
--- a/src/lib/mcrbt1.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,578 +0,0 @@
-/* $Id: mcrbt1.c,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-/* 
-   Librairie mcrbt :
-
-   Fonctions pour la gestion d'un arbre rouge et noir
-
-   D'apres "Introduction a l'algorithmique", 
-     T. Cormen, C. Leiserson, R. Rivest, pp. 258, Dunod Ed. 
-
-   Michel Couprie - aout 2000
-
-   Modif avril 2001: reallocation si depassement de capacite
-*/
-
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mcrbt1.h>
-
-/* #define TESTRBT */
-/* #define VERBOSE */
-
-/* ==================================== */
-Rbt * CreeRbtVide(
-  int32_t taillemax)
-/* ==================================== */
-{
-  int32_t i;
-  Rbt * T = (Rbt *)calloc(1,sizeof(Rbt) + taillemax*sizeof(RbtElt));
-  /* le tableau Elts du Rbt peut stocker taillemax+1 elements, dont 1 pour nil */
-  /* l'element 0 du tableau est reserve pour representer nil */
-  if (T == NULL)
-  {   fprintf(stderr, "CreeRbtVide() : malloc failed\n");
-      return NULL;
-  }
-  T->max = taillemax;
-  T->util = 0;
-  T->maxutil = 0;
-  T->nil = &(T->elts[0]);
-  T->nil->left = T->nil->right = T->nil->parent = NULL;
-  T->root = T->nil;
-
-  /* chaine les elements libres a l'aide du pointeur right */
-  for (i = 1; i < taillemax; i++) T->elts[i].right = &(T->elts[i+1]);
-  T->elts[taillemax].right = NULL;
-  T->libre = &(T->elts[1]);
-
-  return T;
-} /* CreeRbtVide() */
-
-/* ==================================== */
-static
-void RbtTransRec(
-  Rbt **T, Rbt * A, RbtElt * x)
-/* ==================================== */
-{
-  int32_t i;
-  if (x == A->nil) return;
-  RbtInsert(T, x->key, x->auxdata);
-  RbtTransRec(T, A, x->left);
-  RbtTransRec(T, A, x->right);
-} /* RbtTransRec() */
-
-/* ==================================== */
-static
-void RbtReAlloc(Rbt **A)
-/* ==================================== */
-{
-  int32_t i, taillemax;
-  Rbt * T, *Tmp;
-
-#ifdef VERBOSE
-  printf("RbtReAlloc: ancienne taille %d nouvelle taille %d\n", (*A)->max, 2 * (*A)->max);
-#endif
-
-  taillemax = 2 * (*A)->max;  /* alloue le double de l'ancienne taille */ 
-  T = CreeRbtVide(taillemax);
-  RbtTransRec(&T, *A, (*A)->root);
-  Tmp = *A;
-  *A = T;
-  free(Tmp);
-} /* RbtReAlloc() */
-
-/* ==================================== */
-static
-void RbtFlush(
-  Rbt * T)
-/* ==================================== */
-{
-  int32_t i;
-  T->util = 0;
-  for (i = 0; i < T->max - 1; i++) T->elts[i].right = &(T->elts[i+1]);
-  T->elts[T->max - 1].right = NULL;
-  T->root = T->nil;
-} /* RbtFlush() */
-
-/* ==================================== */
-int32_t RbtVide(
-  Rbt * T)
-/* ==================================== */
-{
-  return (T->util == 0);
-} /* RbtVide() */
-
-/* ==================================== */
-void RbtTermine(
-  Rbt * T)
-/* ==================================== */
-{
-#ifdef VERBOSE
-  printf("Rbt: taux d'utilisation: %g\n", (double)T->maxutil / (double)T->max);
-#endif
-  free(T);
-} /* RbtTermine() */
-
-/* ==================================== */
-static
-void RbtPrintRec(
-  Rbt * T, RbtElt * x, int32_t niv)
-/* ==================================== */
-{
-  int32_t i;
-  if (x == T->nil) return;
-  RbtPrintRec(T, x->left, niv+1);
-  for (i = 0; i < niv; i++) printf("    ");
-  PRINTKEY(x->key); printf("(");
-  if (x->color == RBT_Red) printf("r"); else  printf("b");
-  printf(")\n");
-  RbtPrintRec(T, x->right, niv+1);
-} /* RbtPrintRec() */
-
-/* ==================================== */
-static
-void RbtPrint(
-  Rbt * T)
-/* ==================================== */
-{
-  RbtPrintRec(T, T->root, 0);
-} /* RbtPrint() */
-
-/* ==================================== */
-RbtElt * mcrbt1_RbtSearch(
-  Rbt * T, TypRbtKey k)
-/* ==================================== */
-{
-  RbtElt * x = T->root;
-  while ((x != T->nil) && !EQUALKEY(k,x->key))
-    if (LESSKEY(k,x->key)) x = x->left; else x = x->right;
-  return x;
-} /* RbtSearch() */
-
-/* ==================================== */
-RbtElt * RbtMinimum(
-  Rbt * T, RbtElt * x)
-/* ==================================== */
-{
-  while (x->left != T->nil) x = x->left;
-  return x;
-} /* RbtMinimum() */
-
-/* ==================================== */
-static
-RbtElt * RbtMaximum(
-  Rbt * T, RbtElt * x)
-/* ==================================== */
-{
-  while (x->right != T->nil) x = x->right;
-  return x;
-} /* RbtMaximum() */
-
-/* ==================================== */
-RbtElt * RbtSuccessor(
-  Rbt * T, RbtElt * x)
-/* ==================================== */
-{
-  RbtElt * y;
-  if (x->right != T->nil) return RbtMinimum(T, x->right);
-  y = x->parent;
-  while ((y != T->nil) && (x == y->right))
-  {
-    x = y;
-    y = y->parent;
-  }
-  return y;
-} /* RbtSuccessor() */
-
-/* ==================================== */
-void RbtInsertSimple(
-  Rbt * T, RbtElt * z)
-/* ==================================== */
-{
-  RbtElt * x;
-  RbtElt * y;
-
-  y = T->nil;
-  x = T->root;
-  while (x != T->nil)
-  {
-    y = x;
-    if (LESSKEY(z->key,x->key)) x = x->left; else x = x->right;
-  }
-  z->parent = y;
-  if (y == T->nil)
-    T->root = z;
-  else
-    if (LESSKEY(z->key,y->key)) y->left = z; else y->right = z;
-} /* RbtInsertSimple() */
-
-/* ==================================== */
-RbtElt * RbtInsertAux(  /* allocation et insertion simple */
-  Rbt ** T, TypRbtKey k, TypRbtAuxData d)
-/* ==================================== */
-{
-  RbtElt * z;
-
-  if ((*T)->libre == NULL) RbtReAlloc(T);
-  (*T)->util++;
-  if ((*T)->util > (*T)->maxutil) (*T)->maxutil = (*T)->util;
-  z = (*T)->libre;
-  (*T)->libre = (*T)->libre->right;
-  COPYKEY(z->key,k);
-  z->auxdata = d;
-  z->left = (*T)->nil;
-  z->right = (*T)->nil;
-  RbtInsertSimple((*T), z);
-  return z;
-} /* RbtInsertAux() */
-
-/* ==================================== */
-static
-void LeftRotate(
-  Rbt * T, RbtElt * x)
-/* ==================================== */
-{
-  RbtElt * y;
-
-  y = x->right;                    /* assume right(x) != NIL */
-  x->right = y->left;              /* move y's child over */
-  if (y->left != T->nil)
-    y->left->parent = x;
-  y->parent = x->parent;           /* move y up to x's position */
-  if (x->parent == T->nil)
-    T->root = y;
-  else 
-  {
-    if (x == x->parent->left)
-      x->parent->left = y;
-    else x->parent->right = y;
-  }
-  y->left = x;                     /* move x down */
-  x->parent = y;
-} /* LeftRotate() */
-
-/* ==================================== */
-static
-void RightRotate(
-  Rbt * T, RbtElt * x)
-/* ==================================== */
-{
-  RbtElt * y;
-
-  y = x->left;              /* assume left(x) != NIL */
-  x->left = y->right;
-  if (y->right != T->nil)
-    y->right->parent = x;
-  y->parent = x->parent;
-  if (x->parent == T->nil)
-    T->root = y;
-  else 
-  {
-    if (x == x->parent->right)
-       x->parent->right = y;
-    else x->parent->left = y;
-  }
-  y->right = x;
-  x->parent = y;
-} /* RightRotate() */
-
-/* ==================================== */
-RbtElt * RbtInsert(
-  Rbt ** T, TypRbtKey k, TypRbtAuxData d)
-/* ==================================== */
-{
-  RbtElt * x;
-  RbtElt * xc;            /* pour retourner le pointeur sur l'element alloue */
-  RbtElt * uncle;
-
-  xc = x = RbtInsertAux(T, k, d);          /* allocation et insertion simple */
-  x->color = RBT_Red;
-
-  /* re-equilibrage de l'arbre */
-  while ((x != (*T)->root) && (x->parent->color == RBT_Red))
-  {
-    if (x->parent == x->parent->parent->left)
-    {
-      uncle = x->parent->parent->right;
-      if (uncle->color == RBT_Red)
-      {
-        x->parent->color = RBT_Black;                    /* Case I */
-        uncle->color = RBT_Black;
-        x->parent->parent->color = RBT_Red;
-        x = x->parent->parent;
-      }
-      else 
-      {
-        if (x == x->parent->right)
-        {
-          x = x->parent;                             /* Case II */
-          LeftRotate((*T),x);
-        }
-        x->parent->color = RBT_Black;                    /* Case III */
-        x->parent->parent->color = RBT_Red;
-        RightRotate((*T), x->parent->parent);
-      }
-    }
-    else /* same as "then" with "right" and "left" swapped */
-    {
-      uncle = x->parent->parent->left;
-      if (uncle->color == RBT_Red)
-      {
-        x->parent->color = RBT_Black;                     /* Case I */
-        uncle->color = RBT_Black;
-        x->parent->parent->color = RBT_Red;
-        x = x->parent->parent;
-      }
-      else 
-      {
-        if (x == x->parent->left)
-        {
-          x = x->parent;                             /* Case II */
-          RightRotate((*T),x);
-        }
-        x->parent->color = RBT_Black;                    /* Case III */
-        x->parent->parent->color = RBT_Red;
-        LeftRotate((*T), x->parent->parent);
-      }
-    }
-  } /* while */
-  (*T)->root->color = RBT_Black;
-  return xc;                      /* modif mc: retourne xc plutot que x */
-} /* RbtInsert() */
-
-/* ==================================== */
-void RbtDeleteFixup(
-  Rbt * T, RbtElt * x)
-/* ==================================== */
-{
-  RbtElt * s;
-
-  while ((x != T->root) && (x->color == RBT_Black))
-  {
-    if (x == x->parent->left)
-    {
-      s = x->parent->right;               /* Get x's sibling */
-      if (s->color == RBT_Red)
-      {
-        s->color = RBT_Black;              /* Case I */
-        x->parent->color = RBT_Red;
-        LeftRotate(T, x->parent);
-        s = x->parent->right;
-      }
-      if ((s->left->color == RBT_Black) && (s->right->color == RBT_Black))
-      {
-        s->color = RBT_Red;                /* Case II */
-        x = x->parent;
-      }              
-      else 
-      {
-        if (s->right->color == RBT_Black)
-	{
-          s->left->color = RBT_Black;      /* Case III */
-          s->color = RBT_Red;                        
-          RightRotate(T,s);
-          s = x->parent->right;
-        }
-        s->color = x->parent->color;   /* Case IV */
-        x->parent->color = RBT_Black;
-        s->right->color = RBT_Black;
-        LeftRotate(T, x->parent);                   
-        x = T->root;
-      }
-    }
-    else
-    {            /* Same as "then" with right and left swapped */
-      s = x->parent->left;               /* Get x's sibling */
-      if (s->color == RBT_Red)
-      {
-        s->color = RBT_Black;              /* Case I */
-        x->parent->color = RBT_Red;
-        RightRotate(T, x->parent);
-        s = x->parent->left;
-      }
-      if ((s->right->color == RBT_Black) && (s->left->color == RBT_Black))
-      {
-        s->color = RBT_Red;                /* Case II */
-        x = x->parent;
-      }              
-      else 
-      {
-        if (s->left->color == RBT_Black)
-	{
-          s->right->color = RBT_Black;     /* Case III */
-          s->color = RBT_Red;                        
-          LeftRotate(T,s);
-          s = x->parent->left;
-        }
-        s->color = x->parent->color;   /* Case IV */
-        x->parent->color = RBT_Black;
-        s->left->color = RBT_Black;
-        RightRotate(T, x->parent);                   
-        x = T->root;
-      }
-    }
-  } /* while */
-  x->color = RBT_Black;
-} /* RbtDeleteFixup() */
-
-/* ==================================== */
-RbtElt * RbtDeleteAux(         /* return deleted node */
-  Rbt * T, RbtElt * z)
-/* ==================================== */
-{
-  RbtElt * c;
-  RbtElt * d;
-
-  if ((z->left == T->nil) || (z->right == T->nil))
-    d = z;
-  else 
-    d = RbtSuccessor(T, z);
-  if (d->left != T->nil)
-    c = d->left;
-  else 
-    c = d->right;
-  c->parent = d->parent;      /* no test for NIL with sentinel */
-  if (d->parent == T->nil)
-    T->root = c;
-  else 
-  {
-    if (d == d->parent->left)
-      d->parent->left = c;
-    else 
-      d->parent->right = c;
-  }
-  if (d != z)
-  {
-    COPYKEY(z->key,d->key);
-    z->auxdata = d->auxdata;
-  }
-  if (d->color == RBT_Black)
-    RbtDeleteFixup(T, c);     /* c is now "Double-Black" */
-  return d;
-} /* RbtDeleteAux() */
-
-/* ==================================== */
-void RbtDelete(
-  Rbt * T, RbtElt * z)
-/* ==================================== */
-{
-  z = RbtDeleteAux(T, z);
-  z->right = T->libre;
-  T->libre = z;
-  T->util -= 1;
-} /* RbtDelete() */
-
-/* ==================================== */
-TypRbtAuxData mcrbt1_RbtPopMin(
-  Rbt * T)
-/* ==================================== */
-/* 
-  Retire de l'arbre l'element de cle min.
-  ATTENTION: pas de test arbre vide.
-*/
-{
-  RbtElt * z = T->root;
-  while (z->left != T->nil) z = z->left; /* recherche le min */
-  z = RbtDeleteAux(T, z);                /* efface de l'arbre */
-  z->right = T->libre;
-  T->libre = z;
-  T->util -= 1;
-  return z->auxdata;
-} /* RbtPopMin() */
-
-/* ==================================== */
-static
-TypRbtAuxData RbtPopMax(
-  Rbt * T)
-/* ==================================== */
-/* 
-  Retire de l'arbre l'element de cle max.
-  ATTENTION: pas de test arbre vide.
-*/
-{
-  RbtElt * z = T->root;
-  while (z->left != T->nil) z = z->right; /* recherche le max */
-  z = RbtDeleteAux(T, z);                 /* efface de l'arbre */
-  z->right = T->libre;
-  T->libre = z;
-  T->util -= 1;
-  return z->auxdata;
-} /* RbtPopMax() */
-
-/* ==================================== */
-TypRbtKey mcrbt1_RbtMinLevel(
-  Rbt * T)
-/* ==================================== */
-{
-  RbtElt * x = T->root;
-  while (x->left != T->nil) x = x->left;
-  return x->key;
-} /* RbtMinLevel() */
-
-#ifdef TESTRBT
-int32_t main()
-{
-  Rbt * T = CreeRbtVide(1);
-  char r[80];
-  double p;
-  RbtElt * x;
-
-  do
-  {
-    printf("commande (qUIT, PuSH, PoP, pRINT, TESTvIDE\n");
-    printf("          sEARCH MiNIMUM MaXIMUM SUcCESSOR dELETE) > \n");
-    scanf("%s", r);
-    switch (r[0])
-    {
-      case 'u':
-        printf("valeur > ");
-        scanf("%lf", &p);
-        (void)RbtInsert(&T, p, 0);
-        break;
-      case 'd':
-        printf("valeur > ");
-        scanf("%lf", &p);
-        x = mcrbt1_RbtSearch(T, p);
-        if (x != T->nil) RbtDelete(T, x);
-        else printf("pas trouve !\n");
-        break;
-      case 's':
-        printf("valeur > ");
-        scanf("%lf", &p);
-        x = mcrbt1_RbtSearch(T, p);
-        printf("trouve: %d\n", x != T->nil);
-        break;
-      case 'i':
-        x = RbtMinimum(T, T->root);
-        printf("minimum: %g\n", x->key);
-        break;
-      case 'a':
-        x = RbtMaximum(T, T->root);
-        printf("maximum: %g\n", x->key);
-        break;
-      case 'c':
-        printf("valeur > ");
-        scanf("%lf", &p);
-        x = mcrbt1_RbtSearch(T, p);
-        printf("trouve: %d\n", x != T->nil);
-        if (x != T->nil)
-	{
-          x = RbtSuccessor(T, x);
-          if (x != T->nil) printf("succ: %g\n", x->key);
-	}
-        break;
-      case 'o': 
-        if (RbtVide(T)) 
-          printf("vide\n");
-        else
-          (void)RbtPopMin(T); 
-        break;
-      case 'p': RbtPrint(T); break;
-      case 'v': printf("vide: %d\n", RbtVide(T)); break;
-      case 'q': break;
-    }
-  } while (r[0] != 'q');
-  RbtTermine(T);
-}
-#endif
diff -r 8b1af7363833 src/lib/mcscene.c
--- a/src/lib/mcscene.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,51 +0,0 @@
-#include <stddef.h>
-#include <stdio.h>
-
-#include "mcscn.h"
-// Functions for the management of 3D scenes
-// Michel Couprie - Juillet 2004
-
-/* =============================================================== */
-void write3Dscene(scene3d *S)
-/* =============================================================== */
-#undef F_NAME
-#define F_NAME "write3Dscene"
-{
-} // write3Dscene()
-
-/* =============================================================== */
-scene3d *init3Dscene(int32_t nobj)
-/* =============================================================== */
-#undef F_NAME
-#define F_NAME "init3Dscene"
-{
-  scene3d *S = (scene3d *)calloc(1,sizeof(scene3d));
-  if (S == NULL)
-  {   
-    fprintf(stderr, "%s: malloc failed\n", F_NAME);
-    return NULL;
-  }
-  S->nobj = nobj;
-  S->objs = (scene_obj *)calloc(1,nobj * sizeof(scene_obj));
-  if (S->objs == NULL)
-  {   
-    fprintf(stderr, "%s: malloc failed\n", F_NAME);
-    return NULL;
-  }
-  return S;
-} // init3Dscene()
-
-/* =============================================================== */
-scene3d *read3Dscene(char *filename)
-/* =============================================================== */
-#undef F_NAME
-#define F_NAME "read3Dscene"
-{
-  scene3d *S;
-
-  return S;
-} // read3Dscene()
-#include <stdio.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
diff -r 8b1af7363833 src/lib/mcskel2d3d.c
--- a/src/lib/mcskel2d3d.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/mcskel2d3d.c	Mon Jan 13 15:50:10 2014 +0100
@@ -60,7 +60,6 @@
 #define IS_OBJ(f)    (f&FLAG_OBJ)
 
 /* ==================================== */
-static
 int32_t NotIn(
   index_t e,
   index_t *list,                   
diff -r 8b1af7363833 src/lib/mcskel3d.c
--- a/src/lib/mcskel3d.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/lib/mcskel3d.c	Mon Jan 13 15:50:10 2014 +0100
@@ -1743,14 +1743,14 @@
   while (!mcrbt_RbtVide(RBT) && (n < nsteps))
   {
     n++;
-    p = mcrbt_RbtMinLevel(RBT); 
+    p = RbtMinLevel(RBT); 
 #ifdef VERBOSE
     printf("step %d, prio %g ", n, p);
 #endif
     mcskel3d_K3_MarkObj(k);
-    while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
     {
-      i = mcrbt_RbtPopMin(RBT);
+      i = RbtPopMin(RBT);
       if (IS_OBJ(K[i]) && M[i]) 
       { // pas déjà retiré (K[i]) et pas encore traité (M[i])
 	if (I[i] == 0)
@@ -2373,15 +2373,15 @@
   while (!mcrbt_RbtVide(RBT) && (n < nsteps))
   {
     n++;
-    p = mcrbt_RbtMinLevel(RBT); 
+    p = RbtMinLevel(RBT); 
 #ifdef VERBOSE
     printf("step %d, prio %g ", n, p);
 #endif
 
     // CONSTRUIT LA LISTE DES POINTS A TRAITER ET MAJ. MARQUEUR COURANT (MARK2)
-    while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
     {
-      i = mcrbt_RbtPopMin(RBT);
+      i = RbtPopMin(RBT);
       if (IS_OBJ(K[i]) && IS_MARKED2(I[i])) 
       { // pas déjà retiré et pas encore traité
 	if (!IS_MARKED1(I[i]))
@@ -2391,7 +2391,7 @@
 	                      // points du squelette apparus dans l'itération
 	}
       } // if (IS_OBJ(K[i]) && IS_MARKED2(I[i])) 
-    } // while (!mcrbt_RbtVide(RBT) && (mcrbt_RbtMinLevel(RBT) == p))
+    } // while (!mcrbt_RbtVide(RBT) && (RbtMinLevel(RBT) == p))
 #ifdef DEBUG
     writeimage(k, "_k");
 #endif
diff -r 8b1af7363833 src/lib/mctopo3d_notable.c
--- a/src/lib/mctopo3d_notable.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,2133 +0,0 @@
-/* $Id: mctopo3d_notable.c,v 1.1.1.1 2008-11-25 08:01:41 mcouprie Exp $ */
-/* 
-Librairie mctopo3D : 
-
-Calcul des nombres topologiques en 3D
-
-Version calculant les nombres de connexité T et Tb directement
-d'après la definition de G. Bertrand [Ber94].
-
-[Ber94] G. Bertrand, "Simple points, topological numbers and geodesic
-neighborhoods in cubic grids", Pattern Recognition Letters, 
-Vol. 15, pp. 1003-1011, 1994.
-
-Michel Couprie 1998-2007
-
-Update nov. 2006 : modif geodesic_neighborhood pour compatibilité 64 bits
-Update nov. 2007 : modif nbcomp pour compatibilité 64 bits
-*/
-
-#include <stdint.h>
-#include <string.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <mclifo.h>
-#include <mcutil.h>
-#include <mccodimage.h>
-#include <mctopo3d.h>
-
-/* globales privees */
-static Lifo * LIFO_topo3d1 = NULL;
-static Lifo * LIFO_topo3d2 = NULL;
-static voxel cube_topo3d[27];
-static voxel cubec_topo3d[27];
-  
-/* ========================================== */
-void init_topo3d()
-/* ========================================== */
-#undef F_NAME
-#define F_NAME "init_topo3d"
-{
-  LIFO_topo3d1 = CreeLifoVide(27);
-  LIFO_topo3d2 = CreeLifoVide(27);
-  if ((LIFO_topo3d1 == NULL) || (LIFO_topo3d2 == NULL))
-  {   
-    fprintf(stderr, "mccube() : CreeLifoVide failed\n");
-    exit(0);
-  }
-  construitcube(cube_topo3d);
-  construitcube(cubec_topo3d);
-} /* init_topo3d() */
-
-/* ========================================== */
-void termine_topo3d()
-/* ========================================== */
-{
-  LifoTermine(LIFO_topo3d1);
-  LifoTermine(LIFO_topo3d2);
-} /* termine_topo3d() */
-
-/* ========================================== */
-void construitcube(voxel * cube)
-/* ========================================== */
-{
-  uint8_t x,y,z,u,v,w;
-  pvoxel p;
-  for (z = 0; z < 3; z++)
-    for (y = 0; y < 3; y++)
-      for (x = 0; x < 3; x++)
-      {
-      	p = &(cube[encode(x,y,z)]);
-        p->x = x;
-        p->y = y;
-        p->z = z;
-        p->n = encode(x,y,z);
-      	p->val = 0;
-      	p->lab = 0;
-      	p->lab2 = 0;
-      	p->n6v = 0;
-      	p->n12v = 0;
-      	p->n8v = 0;
-      	p->n18v = 0;
-      	p->n26v = 0;
-
-        if ((x == 1) && (y == 1) && (z == 1))  p->type = centre;
-        else
-          if (abs(1-x)+abs(1-y)+abs(1-z) == 1) p->type = face;
-          else
-            if (abs(1-x)+abs(1-y)+abs(1-z) <= 2) p->type = arete;
-            else
-              p->type = coin;
-
-      	for (w = 0; w < 3; w++)
-       	  for (v = 0; v < 3; v++)
-      	    for (u = 0; u < 3; u++)
-      	    {
-              if (abs(u-x)+abs(v-y)+abs(w-z) == 1)
-	      {
-                p->v6[p->n6v++] = &(cube[encode(u,v,w)]);
-                p->v18[p->n18v++] = &(cube[encode(u,v,w)]);
-                p->v26[p->n26v++] = &(cube[encode(u,v,w)]);
-	      }
-              else
-              if (mcmax(abs(u-x), mcmax(abs(v-y), abs(w-z))) == 1)
-              {
-                if (abs(u-x)+abs(v-y)+abs(w-z) <= 2)
-		{
-                  p->v12[p->n12v++] = &(cube[encode(u,v,w)]);
-                  p->v18[p->n18v++] = &(cube[encode(u,v,w)]);
-                  p->v26[p->n26v++] = &(cube[encode(u,v,w)]);
-		}
-                else 
-		{
-                  p->v8[p->n8v++] = &(cube[encode(u,v,w)]);
-                  p->v26[p->n26v++] = &(cube[encode(u,v,w)]);
-		}
-              }
-      	    }  /* for w v u */
-      } /* for z y x */
-} /* construitcube() */
-
-/* ========================================== */
-uint32_t encodecube()
-/* ========================================== */
-{
-  uint8_t n;
-  pvoxel p;
-  uint32_t i = 0;
-
-  for (n = 0; n < 27; n++)
-  {
-    p = &(cube_topo3d[n]);
-    if (p->val) i = i | (1<<n);        
-  } /* for n */
-  return i;
-} /* encodecube() */
-
-/* ========================================== */
-void geodesic_neighborhood(voxel * cube, uint8_t connex, uint8_t s)
-/* ========================================== */
-#undef F_NAME
-#define F_NAME ""
-/* 
-  met a 1 le champ lab des points appartenant au voisinage geodesique d'ordre s du point central,
-  met a 0 les autres
-*/
-{
-  uint8_t n;
-  pvoxel p, pp, pc;
-  Lifo * LIFOtmp;
-  
-  if ((LIFO_topo3d1 == NULL) || (LIFO_topo3d2 == NULL))
-  { 
-    fprintf(stderr, "geodesic_neighborhood: LIFO_topo3d1 and LIFO_topo3d2 must be allocated\n"); 
-    exit(0); 
-  }
-
-  if (s < 1) 
-  { 
-    fprintf(stderr, "geodesic_neighborhood: order %d not allowed (must be > 0)\n", s); 
-    exit(0); 
-  }
-  
-  /* met a 0 le champ lab des points du cube */
-  for (n = 0; n < 27; n++) cube[n].lab = 0;
-
-  /* met a 1 le champ lab des voisins de valeur 1 du point central pc */
-  pc = &(cube[13]);
-  for (n = 0; n < pc->n6v; n++)
-  {
-    p = pc->v6[n];
-    if (p->val == 1)
-    { p->lab = 1; LifoPush(LIFO_topo3d1, (int32_t)(p-pc)); }
-  }
-  if (connex > 6)
-    for (n = 0; n < pc->n12v; n++)
-    {
-      p = pc->v12[n];
-      if (p->val == 1)
-      { p->lab = 1; LifoPush(LIFO_topo3d1, (int32_t)(p-pc)); }
-    }
-  if (connex > 18)
-    for (n = 0; n < pc->n8v; n++)
-    {
-      p = pc->v8[n];
-      if (p->val == 1)
-      { p->lab = 1; LifoPush(LIFO_topo3d1, (int32_t)(p-pc)); }
-    }
-  s--;
-
-  while (s > 0)
-  {
-    while (!LifoVide(LIFO_topo3d1))
-    {
-      p = pc + LifoPop(LIFO_topo3d1);
-      /* met a 1 le champ lab des voisins de valeur 1 du point p (sauf pc) */
-      for (n = 0; n < p->n6v; n++)
-      {
-        pp = p->v6[n];
-        if ((pp != pc) && (pp->val == 1) && (pp->lab == 0))
-        { pp->lab = 1; LifoPush(LIFO_topo3d2, (int32_t)(pp-pc)); }
-      }
-      if (connex > 6)
-        for (n = 0; n < p->n12v; n++)
-        {
-          pp = p->v12[n];
-          if ((pp != pc) && (pp->val == 1) && (pp->lab == 0))
-          { pp->lab = 1; LifoPush(LIFO_topo3d2, (int32_t)(pp-pc)); }
-        }
-      if (connex > 18)
-        for (n = 0; n < p->n8v; n++)
-        {
-          pp = p->v8[n];
-          if ((pp != pc) && (pp->val == 1) && (pp->lab == 0))
-          { pp->lab = 1; LifoPush(LIFO_topo3d2, (int32_t)(pp-pc)); }
-        }
-    } /* while (!LifoVide(LIFO_topo3d1)) */
-    s--;
-    LIFOtmp = LIFO_topo3d1;
-    LIFO_topo3d1 = LIFO_topo3d2;
-    LIFO_topo3d2 = LIFOtmp;
-  } /* while (s > 0) */
-
-  LifoFlush(LIFO_topo3d1);
-  
-} /* geodesic_neighborhood() */
-
-/* ========================================== */
-void G6(voxel * cube)
-/* ========================================== */
-{
-  geodesic_neighborhood(cube, 6, 2);	
-} /* G6() */
-
-/* ========================================== */
-void G6p(voxel * cube)
-/* ========================================== */
-{
-  geodesic_neighborhood(cube, 6, 3);	
-} /* G6p() */
-
-/* ========================================== */
-void G18(voxel * cube)
-/* ========================================== */
-{
-  geodesic_neighborhood(cube, 18, 2);	
-} /* G18() */
-
-/* ========================================== */
-void G26(voxel * cube)
-/* ========================================== */
-{
-  geodesic_neighborhood(cube, 26, 1);	
-} /* G26() */
-
-/* ========================================== */
-uint8_t nbcomp(voxel * cube, uint8_t connex)
-/* ========================================== */
-/*
-  retourne le nombre de composantes connexes de l'objet marque par un lab=1 
-*/
-{
-  uint8_t ncc;
-  uint32_t n, v, m;
-  pvoxel p,pp;
-
-  ncc = 0;
-  for (n = 0; n < 27; n++) cube[n].lab2 = 0;
-  for (n = 0; n < 27; n++)
-  {
-    p = &(cube[n]);
-    if ((p->lab == 1) && (p->lab2 == 0))
-    {
-      ncc++;
-      p->lab2 = ncc;
-      LifoPush(LIFO_topo3d1, n);
-      while (!LifoVide(LIFO_topo3d1))
-      {
-	m = LifoPop(LIFO_topo3d1);
-	p = &(cube[m]);
-        for (v = 0; v < p->n6v; v++)
-        {
-          pp = p->v6[v];
-          if ((pp->lab == 1) && (pp->lab2 == 0))
-	  {
-            pp->lab2 = ncc;
-            LifoPush(LIFO_topo3d1, pp->n);
-	  }
-        } /* for v */
-        if (connex > 6)
-          for (v = 0; v < p->n12v; v++)
-          {
-            pp = p->v12[v];
-            if ((pp->lab == 1) && (pp->lab2 == 0)) 
-	    {
-              pp->lab2 = ncc;
-              LifoPush(LIFO_topo3d1, pp->n);
-	    }
-          } /* for v */
-        if (connex > 18)
-          for (v = 0; v < p->n8v; v++)
-          {
-            pp = p->v8[v];
-            if ((pp->lab == 1) && (pp->lab2 == 0))
-	    {
-              pp->lab2 = ncc;
-              LifoPush(LIFO_topo3d1, pp->n);
-	    }
-          } /* for v */
-      } /* while (!LifoVide(LIFO_topo3d1)) */
-    } /* if */
-  } /* for n */
-
-  return ncc;
-} /* nbcomp() */
-
-/* ========================================== */
-uint8_t nbvois6(voxel * cube)
-/* ========================================== */
-/*
-  retourne le nombre de 6-voisins du point central appartenant a l'objet
-*/
-{
-  uint8_t v, nbvois;
-  pvoxel p,pp;
-
-  nbvois = 0;
-  p = &(cube[13]);
-  for (v = 0; v < p->n6v; v++)
-  {
-    pp = p->v6[v];
-    if (pp->val) nbvois++;
-  }
-
-  return nbvois;
-} /* nbvois6() */
-
-/* ========================================== */
-uint8_t nbvois26(voxel * cube)
-/* ========================================== */
-/*
-  retourne le nombre de 26-voisins du point central appartenant a l'objet
-*/
-{
-  uint8_t v, nbvois;
-  pvoxel p,pp;
-
-  nbvois = 0;
-  p = &(cube[13]);
-  for (v = 0; v < p->n26v; v++)
-  {
-    pp = p->v26[v];
-    if (pp->val) nbvois++;
-  }
-
-  return nbvois;
-} /* nbvois26() */
-
-/* ========================================== */
-int32_t nbvoisc6(
-  uint8_t *B,            /* pointeur base image */
-  int32_t i,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ========================================== */
-/*
-  retourne le nombre de 6-voisins du point central de niveau nul
-*/
-{
-  int32_t nbvois = 0;
-  if ((i%rs!=rs-1) && !B[i+1])    nbvois++;
-  if (((i%ps)>=rs) && !B[i-rs])   nbvois++;
-  if ((i%rs!=0) && !B[i-1])       nbvois++;
-  if (((i%ps)<ps-rs) && !B[i+rs]) nbvois++;
-  if ((i>=ps) && !B[i-ps])        nbvois++;
-  if ((i<N-ps) && !B[i+ps])      nbvois++;
-  return nbvois;
-} /* nbvoisc6() */
-
-/* ========================================== */
-int32_t nbvoisc18(
-  uint8_t *B,            /* pointeur base image */
-  int32_t i,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ========================================== */
-/*
-  retourne le nombre de 18-voisins du point central de niveau nul
-*/
-{
-  int32_t nbvois = 0;
-  if (((i<N-ps)&&(i%rs!=rs-1)) && !B[ps+i+1]) nbvois++;
-  if (((i<N-ps)&&(i%ps>=rs)) && !B[ps+i-rs]) nbvois++;
-  if (((i<N-ps)&&(i%rs!=0)) && !B[ps+i-1]) nbvois++;
-  if (((i<N-ps)&&(i%ps<ps-rs)) && !B[ps+i+rs]) nbvois++;
-  if (((i<N-ps)) && !B[ps+i]) nbvois++;
-  if (((i%rs!=rs-1)) && !B[i+1]) nbvois++;
-  if (((i%rs!=rs-1)&&(i%ps>=rs)) && !B[i+1-rs]) nbvois++;
-  if (((i%ps>=rs)) && !B[i-rs]) nbvois++;
-  if (((i%ps>=rs)&&(i%rs!=0)) && !B[i-rs-1]) nbvois++;
-  if (((i%rs!=0)) && !B[i-1]) nbvois++;
-  if (((i%rs!=0)&&(i%ps<ps-rs)) && !B[i-1+rs]) nbvois++;
-  if (((i%ps<ps-rs)) && !B[i+rs]) nbvois++;
-  if (((i%ps<ps-rs)&&(i%rs!=rs-1)) && !B[i+rs+1]) nbvois++;
-  if (((i>=ps)&&(i%rs!=rs-1)) && !B[-ps+i+1]) nbvois++;
-  if (((i>=ps)&&(i%ps>=rs)) && !B[-ps+i-rs]) nbvois++;
-  if (((i>=ps)&&(i%rs!=0)) && !B[-ps+i-1]) nbvois++;
-  if (((i>=ps)&&(i%ps<ps-rs)) && !B[-ps+i+rs]) nbvois++;
-  if (((i>=ps)) && !B[-ps+i]) nbvois++;
-  return nbvois;
-} /* nbvoisc18() */
-
-/* ========================================== */
-int32_t nbvoisc26(
-  uint8_t *B,            /* pointeur base image */
-  int32_t i,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ========================================== */
-/*
-  retourne le nombre de 26-voisins du point central de niveau nul
-*/
-{
-  int32_t nbvois = 0;
-  if (((i<N-ps)&&(i%rs!=rs-1)) && !B[ps+i+1]) nbvois++;
-  if (((i<N-ps)&&(i%rs!=rs-1)&&(i%ps>=rs)) && !B[ps+i+1-rs]) nbvois++;
-  if (((i<N-ps)&&(i%ps>=rs)) && !B[ps+i-rs]) nbvois++;
-  if (((i<N-ps)&&(i%ps>=rs)&&(i%rs!=0)) && !B[ps+i-rs-1]) nbvois++;
-  if (((i<N-ps)&&(i%rs!=0)) && !B[ps+i-1]) nbvois++;
-  if (((i<N-ps)&&(i%rs!=0)&&(i%ps<ps-rs)) && !B[ps+i-1+rs]) nbvois++;
-  if (((i<N-ps)&&(i%ps<ps-rs)) && !B[ps+i+rs]) nbvois++;
-  if (((i<N-ps)&&(i%ps<ps-rs)&&(i%rs!=rs-1)) && !B[ps+i+rs+1]) nbvois++;
-  if (((i<N-ps)) && !B[ps+i]) nbvois++;
-  if (((i%rs!=rs-1)) && !B[i+1]) nbvois++;
-  if (((i%rs!=rs-1)&&(i%ps>=rs)) && !B[i+1-rs]) nbvois++;
-  if (((i%ps>=rs)) && !B[i-rs]) nbvois++;
-  if (((i%ps>=rs)&&(i%rs!=0)) && !B[i-rs-1]) nbvois++;
-  if (((i%rs!=0)) && !B[i-1]) nbvois++;
-  if (((i%rs!=0)&&(i%ps<ps-rs)) && !B[i-1+rs]) nbvois++;
-  if (((i%ps<ps-rs)) && !B[i+rs]) nbvois++;
-  if (((i%ps<ps-rs)&&(i%rs!=rs-1)) && !B[i+rs+1]) nbvois++;
-  if (((i>=ps)&&(i%rs!=rs-1)) && !B[-ps+i+1]) nbvois++;
-  if (((i>=ps)&&(i%rs!=rs-1)&&(i%ps>=rs)) && !B[-ps+i+1-rs]) nbvois++;
-  if (((i>=ps)&&(i%ps>=rs)) && !B[-ps+i-rs]) nbvois++;
-  if (((i>=ps)&&(i%ps>=rs)&&(i%rs!=0)) && !B[-ps+i-rs-1]) nbvois++;
-  if (((i>=ps)&&(i%rs!=0)) && !B[-ps+i-1]) nbvois++;
-  if (((i>=ps)&&(i%rs!=0)&&(i%ps<ps-rs)) && !B[-ps+i-1+rs]) nbvois++;
-  if (((i>=ps)&&(i%ps<ps-rs)) && !B[-ps+i+rs]) nbvois++;
-  if (((i>=ps)&&(i%ps<ps-rs)&&(i%rs!=rs-1)) && !B[-ps+i+rs+1]) nbvois++;
-  if (((i>=ps)) && !B[-ps+i]) nbvois++;
-  return nbvois;
-} /* nbvoisc26() */
-
-/* ========================================== */
-int32_t nbvoiso6(
-  uint8_t *B,            /* pointeur base image */
-  int32_t i,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ========================================== */
-/*
-  retourne le nombre de 6-voisins du point central de niveau NON nul
-*/
-{
-  int32_t nbvois = 0;
-  if ((i%rs!=rs-1) && B[i+1])    nbvois++;
-  if (((i%ps)>=rs) && B[i-rs])   nbvois++;
-  if ((i%rs!=0) && B[i-1])       nbvois++;
-  if (((i%ps)<ps-rs) && B[i+rs]) nbvois++;
-  if ((i>=ps) && B[i-ps])        nbvois++;
-  if ((i<N-ps) && B[i+ps])      nbvois++;
-  return nbvois;
-} /* nbvoiso6() */
-
-/* ========================================== */
-int32_t nbvoiso18(
-  uint8_t *B,            /* pointeur base image */
-  int32_t i,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ========================================== */
-/*
-  retourne le nombre de 18-voisins du point central de niveau NON nul
-*/
-{
-  int32_t nbvois = 0;
-  if (((i<N-ps)&&(i%rs!=rs-1)) && B[ps+i+1]) nbvois++;
-  if (((i<N-ps)&&(i%ps>=rs)) && B[ps+i-rs]) nbvois++;
-  if (((i<N-ps)&&(i%rs!=0)) && B[ps+i-1]) nbvois++;
-  if (((i<N-ps)&&(i%ps<ps-rs)) && B[ps+i+rs]) nbvois++;
-  if (((i<N-ps)) && B[ps+i]) nbvois++;
-  if (((i%rs!=rs-1)) && B[i+1]) nbvois++;
-  if (((i%rs!=rs-1)&&(i%ps>=rs)) && B[i+1-rs]) nbvois++;
-  if (((i%ps>=rs)) && B[i-rs]) nbvois++;
-  if (((i%ps>=rs)&&(i%rs!=0)) && B[i-rs-1]) nbvois++;
-  if (((i%rs!=0)) && B[i-1]) nbvois++;
-  if (((i%rs!=0)&&(i%ps<ps-rs)) && B[i-1+rs]) nbvois++;
-  if (((i%ps<ps-rs)) && B[i+rs]) nbvois++;
-  if (((i%ps<ps-rs)&&(i%rs!=rs-1)) && B[i+rs+1]) nbvois++;
-  if (((i>=ps)&&(i%rs!=rs-1)) && B[-ps+i+1]) nbvois++;
-  if (((i>=ps)&&(i%ps>=rs)) && B[-ps+i-rs]) nbvois++;
-  if (((i>=ps)&&(i%rs!=0)) && B[-ps+i-1]) nbvois++;
-  if (((i>=ps)&&(i%ps<ps-rs)) && B[-ps+i+rs]) nbvois++;
-  if (((i>=ps)) && B[-ps+i]) nbvois++;
-  return nbvois;
-} /* nbvoiso18() */
-
-/* ========================================== */
-int32_t nbvoiso26(
-  uint8_t *B,            /* pointeur base image */
-  int32_t i,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ========================================== */
-/*
-  retourne le nombre de 26-voisins du point central de niveau NON nul
-*/
-{
-  int32_t nbvois = 0;
-  if (((i<N-ps)&&(i%rs!=rs-1)) && B[ps+i+1]) nbvois++;
-  if (((i<N-ps)&&(i%rs!=rs-1)&&(i%ps>=rs)) && B[ps+i+1-rs]) nbvois++;
-  if (((i<N-ps)&&(i%ps>=rs)) && B[ps+i-rs]) nbvois++;
-  if (((i<N-ps)&&(i%ps>=rs)&&(i%rs!=0)) && B[ps+i-rs-1]) nbvois++;
-  if (((i<N-ps)&&(i%rs!=0)) && B[ps+i-1]) nbvois++;
-  if (((i<N-ps)&&(i%rs!=0)&&(i%ps<ps-rs)) && B[ps+i-1+rs]) nbvois++;
-  if (((i<N-ps)&&(i%ps<ps-rs)) && B[ps+i+rs]) nbvois++;
-  if (((i<N-ps)&&(i%ps<ps-rs)&&(i%rs!=rs-1)) && B[ps+i+rs+1]) nbvois++;
-  if (((i<N-ps)) && B[ps+i]) nbvois++;
-  if (((i%rs!=rs-1)) && B[i+1]) nbvois++;
-  if (((i%rs!=rs-1)&&(i%ps>=rs)) && B[i+1-rs]) nbvois++;
-  if (((i%ps>=rs)) && B[i-rs]) nbvois++;
-  if (((i%ps>=rs)&&(i%rs!=0)) && B[i-rs-1]) nbvois++;
-  if (((i%rs!=0)) && B[i-1]) nbvois++;
-  if (((i%rs!=0)&&(i%ps<ps-rs)) && B[i-1+rs]) nbvois++;
-  if (((i%ps<ps-rs)) && B[i+rs]) nbvois++;
-  if (((i%ps<ps-rs)&&(i%rs!=rs-1)) && B[i+rs+1]) nbvois++;
-  if (((i>=ps)&&(i%rs!=rs-1)) && B[-ps+i+1]) nbvois++;
-  if (((i>=ps)&&(i%rs!=rs-1)&&(i%ps>=rs)) && B[-ps+i+1-rs]) nbvois++;
-  if (((i>=ps)&&(i%ps>=rs)) && B[-ps+i-rs]) nbvois++;
-  if (((i>=ps)&&(i%ps>=rs)&&(i%rs!=0)) && B[-ps+i-rs-1]) nbvois++;
-  if (((i>=ps)&&(i%rs!=0)) && B[-ps+i-1]) nbvois++;
-  if (((i>=ps)&&(i%rs!=0)&&(i%ps<ps-rs)) && B[-ps+i-1+rs]) nbvois++;
-  if (((i>=ps)&&(i%ps<ps-rs)) && B[-ps+i+rs]) nbvois++;
-  if (((i>=ps)&&(i%ps<ps-rs)&&(i%rs!=rs-1)) && B[-ps+i+rs+1]) nbvois++;
-  if (((i>=ps)) && B[-ps+i]) nbvois++;
-  return nbvois;
-} /* nbvoiso26() */
-
-/* ========================================== */
-uint8_t T6(voxel * cube)
-/* ========================================== */
-{
-  G6(cube);
-  return nbcomp(cube, 6);
-} /* T6() */
-
-/* ========================================== */
-uint8_t T6p(voxel * cube)
-/* ========================================== */
-{
-  G6p(cube);
-  return nbcomp(cube, 6);
-} /* T6p() */
-
-/* ========================================== */
-uint8_t T18(voxel * cube)
-/* ========================================== */
-{
-  G18(cube);
-  return nbcomp(cube, 18);
-} /* T18() */
-
-/* ========================================== */
-uint8_t T26(voxel * cube)
-/* ========================================== */
-{
-  G26(cube);
-  return nbcomp(cube, 26);
-} /* T26() */
-
-/* ========================================== */
-static uint8_t simple(voxel * cube, voxel * cubec, uint8_t connex)
-/* ========================================== */
-#undef F_NAME
-#define F_NAME ""
-{
-  switch (connex)
-  {
-    case 6: return (uint8_t)((T6(cube) == 1) && (T26(cubec) == 1));
-    case 18: return (uint8_t)((T18(cube) == 1) && (T6p(cubec) == 1));
-    case 26: return (uint8_t)((T26(cube) == 1) && (T6(cubec) == 1));
-    default: 
-      fprintf(stderr, "simple: mauvaise connexite : %d\n", connex); 
-      exit(0); 
-  } /* switch (connex) */
-} /* simple() */
-
-/* ==================================== */
-int32_t preparecubes(
-  uint8_t *B,            /* pointeur base image */
-  int32_t i,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-/*
-  Transfere le voisinage de i pour l'image 3d img dans les 
-  structures cube_topo3d (vois. original) et cubec_topo3d (complementaire).
-  ATTENTION: i ne doit pas etre un point de bord (test a faire avant).
- */
-{
-
-  /* plan "HAUT" (+ps) */
-  if (B[ps+i+1])    cube_topo3d[23].val = 1; else cube_topo3d[23].val = 0;
-  if (B[ps+i+1-rs]) cube_topo3d[20].val = 1; else cube_topo3d[20].val = 0;
-  if (B[ps+i-rs])   cube_topo3d[19].val = 1; else cube_topo3d[19].val = 0;
-  if (B[ps+i-rs-1]) cube_topo3d[18].val = 1; else cube_topo3d[18].val = 0;
-  if (B[ps+i-1])    cube_topo3d[21].val = 1; else cube_topo3d[21].val = 0;
-  if (B[ps+i-1+rs]) cube_topo3d[24].val = 1; else cube_topo3d[24].val = 0;
-  if (B[ps+i+rs])   cube_topo3d[25].val = 1; else cube_topo3d[25].val = 0;
-  if (B[ps+i+rs+1]) cube_topo3d[26].val = 1; else cube_topo3d[26].val = 0;
-  if (B[ps+i])      cube_topo3d[22].val = 1; else cube_topo3d[22].val = 0;
-  /* plan "COURANT" () */
-  if (B[i+1])       cube_topo3d[14].val = 1; else cube_topo3d[14].val = 0;
-  if (B[i+1-rs])    cube_topo3d[11].val = 1; else cube_topo3d[11].val = 0;
-  if (B[i-rs])      cube_topo3d[10].val = 1; else cube_topo3d[10].val = 0;
-  if (B[i-rs-1])    cube_topo3d[9].val = 1; else cube_topo3d[9].val = 0;
-  if (B[i-1])       cube_topo3d[12].val = 1; else cube_topo3d[12].val = 0;
-  if (B[i-1+rs])    cube_topo3d[15].val = 1; else cube_topo3d[15].val = 0;
-  if (B[i+rs])      cube_topo3d[16].val = 1; else cube_topo3d[16].val = 0;
-  if (B[i+rs+1])    cube_topo3d[17].val = 1; else cube_topo3d[17].val = 0;
-  if (B[i])         cube_topo3d[13].val = 1; else cube_topo3d[13].val = 0;
-  /* plan "BAS" (-ps) */
-  if (B[-ps+i+1])    cube_topo3d[5].val = 1; else cube_topo3d[5].val = 0;
-  if (B[-ps+i+1-rs]) cube_topo3d[2].val = 1; else cube_topo3d[2].val = 0;
-  if (B[-ps+i-rs])   cube_topo3d[1].val = 1; else cube_topo3d[1].val = 0;
-  if (B[-ps+i-rs-1]) cube_topo3d[0].val = 1; else cube_topo3d[0].val = 0;
-  if (B[-ps+i-1])    cube_topo3d[3].val = 1; else cube_topo3d[3].val = 0;
-  if (B[-ps+i-1+rs]) cube_topo3d[6].val = 1; else cube_topo3d[6].val = 0;
-  if (B[-ps+i+rs])   cube_topo3d[7].val = 1; else cube_topo3d[7].val = 0;
-  if (B[-ps+i+rs+1]) cube_topo3d[8].val = 1; else cube_topo3d[8].val = 0;
-  if (B[-ps+i])      cube_topo3d[4].val = 1; else cube_topo3d[4].val = 0;
-  
-  for (i = 0; i < 27; i++) 
-    if (cube_topo3d[i].val == 1) cubec_topo3d[i].val = 0; else cubec_topo3d[i].val = 1;
-} /* preparecubes() */
-
-/* ==================================== */
-int32_t preparecubesh(
-  uint8_t *img,          /* pointeur base image */
-  int32_t i,                       /* index du point */
-  int32_t h,                       /* seuil */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-/*
-  Transfere le voisinage de i pour l'image 3d img seuillee au niveau h dans les 
-  structures cube_topo3d (vois. original) et cubec_topo3d (complementaire).
-  ATTENTION: i ne doit pas etre un point de bord (test a faire avant).
- */
-{
-  /* plan "ARRIERE" (+ps) */
-  if (img[ps+i+1]>=h)    cube_topo3d[17].val = 1; else cube_topo3d[17].val = 0;
-  if (img[ps+i+1-rs]>=h) cube_topo3d[26].val = 1; else cube_topo3d[26].val = 0;
-  if (img[ps+i-rs]>=h)   cube_topo3d[25].val = 1; else cube_topo3d[25].val = 0;
-  if (img[ps+i-rs-1]>=h) cube_topo3d[24].val = 1; else cube_topo3d[24].val = 0;
-  if (img[ps+i-1]>=h)    cube_topo3d[15].val = 1; else cube_topo3d[15].val = 0;
-  if (img[ps+i-1+rs]>=h) cube_topo3d[6].val = 1; else cube_topo3d[6].val = 0;
-  if (img[ps+i+rs]>=h)   cube_topo3d[7].val = 1; else cube_topo3d[7].val = 0;
-  if (img[ps+i+rs+1]>=h) cube_topo3d[8].val = 1; else cube_topo3d[8].val = 0;
-  if (img[ps+i]>=h)      cube_topo3d[16].val = 1; else cube_topo3d[16].val = 0;
-  /* plan "COURANT" () */
-  if (img[i+1]>=h)       cube_topo3d[14].val = 1; else cube_topo3d[14].val = 0;
-  if (img[i+1-rs]>=h)    cube_topo3d[23].val = 1; else cube_topo3d[23].val = 0;
-  if (img[i-rs]>=h)      cube_topo3d[22].val = 1; else cube_topo3d[22].val = 0;
-  if (img[i-rs-1]>=h)    cube_topo3d[21].val = 1; else cube_topo3d[21].val = 0;
-  if (img[i-1]>=h)       cube_topo3d[12].val = 1; else cube_topo3d[12].val = 0;
-  if (img[i-1+rs]>=h)    cube_topo3d[3].val = 1; else cube_topo3d[3].val = 0;
-  if (img[i+rs]>=h)      cube_topo3d[4].val = 1; else cube_topo3d[4].val = 0;
-  if (img[i+rs+1]>=h)    cube_topo3d[5].val = 1; else cube_topo3d[5].val = 0;
-  if (img[i]>=h)         cube_topo3d[13].val = 1; else cube_topo3d[13].val = 0;
-  /* plan "AVANT" (-ps) */
-  if (img[-ps+i+1]>=h)    cube_topo3d[11].val = 1; else cube_topo3d[11].val = 0;
-  if (img[-ps+i+1-rs]>=h) cube_topo3d[20].val = 1; else cube_topo3d[20].val = 0;
-  if (img[-ps+i-rs]>=h)   cube_topo3d[19].val = 1; else cube_topo3d[19].val = 0;
-  if (img[-ps+i-rs-1]>=h) cube_topo3d[18].val = 1; else cube_topo3d[18].val = 0;
-  if (img[-ps+i-1]>=h)    cube_topo3d[9].val = 1; else cube_topo3d[9].val = 0;
-  if (img[-ps+i-1+rs]>=h) cube_topo3d[0].val = 1; else cube_topo3d[0].val = 0;
-  if (img[-ps+i+rs]>=h)   cube_topo3d[1].val = 1; else cube_topo3d[1].val = 0;
-  if (img[-ps+i+rs+1]>=h) cube_topo3d[2].val = 1; else cube_topo3d[2].val = 0;
-  if (img[-ps+i]>=h)      cube_topo3d[10].val = 1; else cube_topo3d[10].val = 0;
-  
-  for (i = 0; i < 27; i++) 
-    if (cube_topo3d[i].val == 1) cubec_topo3d[i].val = 0; else cubec_topo3d[i].val = 1;
-} /* preparecubesh() */
-
-/* ==================================== */
-int32_t preparecubesh_l(
-  uint32_t *img,          /* pointeur base image */
-  int32_t i,                       /* index du point */
-  int32_t h,                      /* seuil */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-/*
-  Transfere le voisinage de i pour l'image 3d img seuillee au niveau h dans les 
-  structures cube_topo3d (vois. original) et cubec_topo3d (complementaire).
-  ATTENTION: i ne doit pas etre un point de bord (test a faire avant).
- */
-{
-  /* plan "ARRIERE" (+ps) */
-  if (img[ps+i+1]>=h)    cube_topo3d[17].val = 1; else cube_topo3d[17].val = 0;
-  if (img[ps+i+1-rs]>=h) cube_topo3d[26].val = 1; else cube_topo3d[26].val = 0;
-  if (img[ps+i-rs]>=h)   cube_topo3d[25].val = 1; else cube_topo3d[25].val = 0;
-  if (img[ps+i-rs-1]>=h) cube_topo3d[24].val = 1; else cube_topo3d[24].val = 0;
-  if (img[ps+i-1]>=h)    cube_topo3d[15].val = 1; else cube_topo3d[15].val = 0;
-  if (img[ps+i-1+rs]>=h) cube_topo3d[6].val = 1; else cube_topo3d[6].val = 0;
-  if (img[ps+i+rs]>=h)   cube_topo3d[7].val = 1; else cube_topo3d[7].val = 0;
-  if (img[ps+i+rs+1]>=h) cube_topo3d[8].val = 1; else cube_topo3d[8].val = 0;
-  if (img[ps+i]>=h)      cube_topo3d[16].val = 1; else cube_topo3d[16].val = 0;
-  /* plan "COURANT" () */
-  if (img[i+1]>=h)       cube_topo3d[14].val = 1; else cube_topo3d[14].val = 0;
-  if (img[i+1-rs]>=h)    cube_topo3d[23].val = 1; else cube_topo3d[23].val = 0;
-  if (img[i-rs]>=h)      cube_topo3d[22].val = 1; else cube_topo3d[22].val = 0;
-  if (img[i-rs-1]>=h)    cube_topo3d[21].val = 1; else cube_topo3d[21].val = 0;
-  if (img[i-1]>=h)       cube_topo3d[12].val = 1; else cube_topo3d[12].val = 0;
-  if (img[i-1+rs]>=h)    cube_topo3d[3].val = 1; else cube_topo3d[3].val = 0;
-  if (img[i+rs]>=h)      cube_topo3d[4].val = 1; else cube_topo3d[4].val = 0;
-  if (img[i+rs+1]>=h)    cube_topo3d[5].val = 1; else cube_topo3d[5].val = 0;
-  if (img[i]>=h)         cube_topo3d[13].val = 1; else cube_topo3d[13].val = 0;
-  /* plan "AVANT" (-ps) */
-  if (img[-ps+i+1]>=h)    cube_topo3d[11].val = 1; else cube_topo3d[11].val = 0;
-  if (img[-ps+i+1-rs]>=h) cube_topo3d[20].val = 1; else cube_topo3d[20].val = 0;
-  if (img[-ps+i-rs]>=h)   cube_topo3d[19].val = 1; else cube_topo3d[19].val = 0;
-  if (img[-ps+i-rs-1]>=h) cube_topo3d[18].val = 1; else cube_topo3d[18].val = 0;
-  if (img[-ps+i-1]>=h)    cube_topo3d[9].val = 1; else cube_topo3d[9].val = 0;
-  if (img[-ps+i-1+rs]>=h) cube_topo3d[0].val = 1; else cube_topo3d[0].val = 0;
-  if (img[-ps+i+rs]>=h)   cube_topo3d[1].val = 1; else cube_topo3d[1].val = 0;
-  if (img[-ps+i+rs+1]>=h) cube_topo3d[2].val = 1; else cube_topo3d[2].val = 0;
-  if (img[-ps+i]>=h)      cube_topo3d[10].val = 1; else cube_topo3d[10].val = 0;
-  
-  for (i = 0; i < 27; i++) 
-    if (cube_topo3d[i].val == 1) cubec_topo3d[i].val = 0; else cubec_topo3d[i].val = 1;
-} /* preparecubesh_l() */
-
-/* ******************************************************************************* */
-/* ******************************************************************************* */
-/*                               PRIMITIVES 3D BINAIRES                            */
-/* ******************************************************************************* */
-/* ******************************************************************************* */
-
-/* ==================================== */
-int32_t top6(                   /* pour un objet en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N,                       /* taille image */
-  int32_t *t,
-  int32_t *tb)                     /* resultats */
-/* ==================================== */
-/*
-  ATTENTION: p ne doit pas etre un point de bord (test a faire avant).
-*/
-{
-  preparecubes(img, p, rs, ps, N);
-  *t = T6(cube_topo3d);
-  *tb = T26(cubec_topo3d);
-} /* top6() */
-
-/* ==================================== */
-int32_t top18(                   /* pour un objet en 18-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N,                       /* taille image */
-  int32_t *t,
-  int32_t *tb)                     /* resultats */
-/* ==================================== */
-/*
-  ATTENTION: p ne doit pas etre un point de bord (test a faire avant).
-*/
-{
-  preparecubes(img, p, rs, ps, N);
-  *t = T18(cube_topo3d);
-  *tb = T6p(cubec_topo3d);
-} /* top18() */
-
-/* ==================================== */
-int32_t top26(                   /* pour un objet en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N,                       /* taille image */
-  int32_t *t,
-  int32_t *tb)                     /* resultats */
-/* ==================================== */
-/*
-  ATTENTION: p ne doit pas etre un point de bord (test a faire avant).
-*/
-{
-  preparecubes(img, p, rs, ps, N);
-  *t = T26(cube_topo3d);
-  *tb = T6(cubec_topo3d);
-} /* top26() */
-
-/* ==================================== */
-int32_t simple6(                   /* pour un objet en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "simple6"
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubes(img, p, rs, ps, N);
-  return ((T6(cube_topo3d) == 1) && (T26(cubec_topo3d) == 1));
-} /* simple6() */
-
-/* ==================================== */
-int32_t simple18(                  /* pour un objet en 18-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "simple18"
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubes(img, p, rs, ps, N);
-  return ((T18(cube_topo3d) == 1) && (T6p(cubec_topo3d) == 1));
-} /* simple18() */
-
-/* ==================================== */
-int32_t simple26(                  /* pour un objet en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "simple26"
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubes(img, p, rs, ps, N);
-  return ((T26(cube_topo3d) == 1) && (T6(cubec_topo3d) == 1));
-} /* simple26() */
-
-/* ==================================== */
-int32_t simple6h(                   /* pour un objet en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t h,                       /* seuil */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "simple6h"
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, h, rs, ps, N);
-  return ((T6(cube_topo3d) == 1) && (T26(cubec_topo3d) == 1));
-} /* simple6h() */
-
-/* ==================================== */
-int32_t simple18h(                  /* pour un objet en 18-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t h,                       /* seuil */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "simple18h"
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, h, rs, ps, N);
-  return ((T18(cube_topo3d) == 1) && (T6p(cubec_topo3d) == 1));
-} /* simple18h() */
-
-/* ==================================== */
-int32_t simple26h(                  /* pour un objet en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t h,                       /* seuil */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-#undef F_NAME
-#define F_NAME "simple26h"
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, h, rs, ps, N);
-  return ((T26(cube_topo3d) == 1) && (T6(cubec_topo3d) == 1));
-} /* simple26h() */
-
-/* ==================================== */
-int32_t tbar6h(               /* pour un objet en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t h,                       /* seuil */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return -1;
-  preparecubesh(img, p, h, rs, ps, N);
-  return T26(cubec_topo3d);
-} /* tbar6h() */
-
-/* ==================================== */
-int32_t tbar26h(              /* pour un objet en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t h,                       /* seuil */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return -1;
-  preparecubesh(img, p, h, rs, ps, N);
-  return T6(cubec_topo3d);
-} /* tbar26h() */
-
-/* ========================================== */
-uint8_t P_simple(voxel * cube, voxel * cubep, voxel * cubec, uint8_t connex)
-/* ========================================== */
-#undef F_NAME
-#define F_NAME "P_simple"
-/*
-  cube contient X
-  cubep contient P
-  cubec (auxiliaire) n'a pas besoin d'etre initialise
-  d'apres: "Some topological properties of surfaces in Z3", G. Bertrand & R. Malgouyres
-           Theoreme 6
-*/
-{
-  uint8_t n;
-  uint8_t v;
-  pvoxel x;  /* point central de cube */
-  pvoxel y;  /* point de cube */
-  pvoxel xc; /* point central de cubec */
-  pvoxel yc; /* point de cubec */
-  pvoxel xp; /* point central de cubep */
-  pvoxel yp; /* point de cubep */
-
-  for (n = 0; n < 27; n++) if (cube[n].val == 1) cubec[n].val = 0; else cubec[n].val = 1;
-
-  switch (connex) /* teste la condition 2 (theoreme 6) */
-  {
-    case 6:  
-      if (T26(cubec) != 1) return 0; 
-      break;
-    case 18: 
-      if (T6p(cubec) != 1) return 0; 
-      break;
-    case 26: 
-      if (T6(cubec) != 1) return 0; 
-      break;
-    default: 
-      fprintf(stderr, "P_simple: mauvaise connexite : %d\n", connex); 
-      exit(0); 
-  } /* switch (connex) */
-  
-  x = &(cube[13]);
-  xc = &(cubec[13]);
-  xp = &(cubep[13]);
-  switch (connex) /* teste la condition 4 (theoreme 6) */
-  {
-    case 6: 
-      for (n = 0; n < x->n26v; n++)
-      {
-        yp = xp->v26[n];
-        if (yp->val)
-        {
-          yc = xc->v26[n];
-          v = yc->val;
-          yc->val = 1;
-          if (T26(cubec) != 1) return 0;
-          yc->val = v;
-        } /* if (yp->val) */
-      } /* for (n = 0; n < x->n26v; n++) */
-      break;
-    case 18: 
-      for (n = 0; n < x->n6v; n++)
-      {
-        yp = xp->v6[n];
-        if (yp->val)
-        {
-          yc = xc->v6[n];
-          v = yc->val;
-          yc->val = 1;
-          if (T6p(cubec) != 1) return 0;
-          yc->val = v;
-        } /* if (yp->val) */
-      } /* for (n = 0; n < x->n6v; n++) */
-      break;
-    case 26: 
-      for (n = 0; n < x->n6v; n++)
-      {
-        yp = xp->v6[n];
-        if (yp->val)
-        {
-          yc = xc->v6[n];
-          v = yc->val;
-          yc->val = 1;
-          if (T6(cubec) != 1) return 0;
-          yc->val = v;
-        } /* if (yp->val) */
-      } /* for (n = 0; n < x->n6v; n++) */
-      break;
-    default: 
-      fprintf(stderr, "P_simple: mauvaise connexite : %d\n", connex); 
-      exit(0); 
-  } /* switch (connex) */
-  
-  for (n = 0; n < 27; n++) /* calcule et range dans cubec l'ensemble R = X - P  */
-  {
-    y = &(cube[n]);
-    yp = &(cubep[n]);
-    yc = &(cubec[n]);
-    if (y->val && !yp->val) yc->val = 1; else yc->val = 0;
-  } /* for (n = 0; n < 27; n++) */
-
-  switch (connex) /* teste la condition 1 (theoreme 6) */
-  {
-    case 6:  
-      if (T6(cubec) != 1) return 0;
-      break;
-    case 18: 
-      if (T18(cubec) != 1) return 0;
-      break;
-    case 26: 
-      if (T26(cubec) != 1) return 0;
-      break;
-    default: 
-      fprintf(stderr, "P_simple: mauvaise connexite : %d\n", connex); 
-      exit(0); 
-  } /* switch (connex) */
-  
-  switch (connex) /* teste la condition 3 (theoreme 6) */
-  {
-    case 6: 
-      for (n = 0; n < x->n6v; n++)
-      {
-        yp = xp->v6[n];
-        if (yp->val)
-        {
-          yc = xc->v6[n];
-          v = yc->val;
-          yc->val = 1;
-          if (T6(cubec) != 1) return 0;
-          yc->val = v;
-        } /* if (yp->val) */
-      } /* for (n = 0; n < x->n6v; n++) */
-      break;
-    case 18: 
-      for (n = 0; n < x->n18v; n++)
-      {
-        yp = xp->v18[n];
-        if (yp->val)
-        {
-          yc = xc->v18[n];
-          v = yc->val;
-          yc->val = 1;
-          if (T18(cubec) != 1) return 0;
-          yc->val = v;
-        } /* if (yp->val) */
-      } /* for (n = 0; n < x->n18v; n++) */
-      break;
-    case 26: 
-      for (n = 0; n < x->n26v; n++)
-      {
-        yp = xp->v26[n];
-        if (yp->val)
-        {
-          yc = xc->v26[n];
-          v = yc->val;
-          yc->val = 1;
-          if (T26(cubec) != 1) return 0;
-          yc->val = v;
-        } /* if (yp->val) */
-      } /* for (n = 0; n < x->n26v; n++) */
-      break;
-    default: 
-      fprintf(stderr, "P_simple: mauvaise connexite : %d\n", connex); 
-      exit(0); 
-  } /* switch (connex) */
-  return 1;
-} /* P_simple() */
-
-
-
-
-
-/* ******************************************************************************* */
-/* ******************************************************************************* */
-/*                                  PRIMITIVES 3D NDG                              */
-/* ******************************************************************************* */
-/* ******************************************************************************* */
-
-/* ==================================== */
-int32_t pdestr6(                   /* pour des minima en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return ((T26(cube_topo3d) == 1) && (T6(cubec_topo3d) == 1));
-} /* pdestr6() */
-
-/* ==================================== */
-int32_t pdestr18(                  /* pour des minima en 18-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return ((T6p(cube_topo3d) == 1) && (T18(cubec_topo3d) == 1));
-} /* pdestr18() */
-
-/* ==================================== */
-int32_t pdestr26(                  /* pour des minima en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return ((T6(cube_topo3d) == 1) && (T26(cubec_topo3d) == 1));
-} /* pdestr26() */
-
-/* ==================================== */
-int32_t plevdestr6(                   /* pour des minima en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return (T6(cubec_topo3d) == 1);
-} /* plevdestr6() */
-
-/* ==================================== */
-int32_t plevdestr18(                  /* pour des minima en 18-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return (T18(cubec_topo3d) == 1);
-} /* plevdestr18() */
-
-/* ==================================== */
-int32_t plevdestr26(                  /* pour des minima en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return (T26(cubec_topo3d) == 1);
-} /* plevdestr26() */
-
-/* ==================================== */
-int32_t pconstr6(                   /* pour des minima en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return ((T26(cube_topo3d) == 1) && (T6(cubec_topo3d) == 1));
-} /* pconstr6() */
-
-/* ==================================== */
-int32_t pconstr18(                  /* pour des minima en 18-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return ((T6p(cube_topo3d) == 1) && (T18(cubec_topo3d) == 1));
-} /* pconstr18() */
-
-/* ==================================== */
-int32_t pconstr26(                  /* pour des minima en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return ((T6(cube_topo3d) == 1) && (T26(cubec_topo3d) == 1));
-} /* pconstr26() */
-
-/* ==================================== */
-int32_t plevconstr6(                   /* pour des minima en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return (T26(cube_topo3d) == 1);
-} /* plevconstr6() */
-
-/* ==================================== */
-int32_t plevconstr18(                  /* pour des minima en 18-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return (T6p(cube_topo3d) == 1);
-} /* plevconstr18() */
-
-/* ==================================== */
-int32_t plevconstr26(                  /* pour des minima en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return (T6(cube_topo3d) == 1);
-} /* plevconstr26() */
-
-/* ==================================== */
-int32_t peak6(                   /* pour des minima en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return (T26(cube_topo3d) == 0);
-} /* peak6() */
-
-/* ==================================== */
-int32_t peak26(                    /* pour des minima en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return (T6(cube_topo3d) == 0);
-} /* peak26() */
-
-/* ==================================== */
-int32_t well6(                   /* pour des minima en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return (T6(cubec_topo3d) == 0);
-} /* well6() */
-
-/* ==================================== */
-int32_t well26(                    /* pour des minima en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return (T26(cubec_topo3d) == 0);
-} /* well26() */
-
-/* ==================================== */
-uint8_t alpha26m(
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* retourne le sup des valeurs < img[x] dans le 26-voisinage de x, */
-/* ou img[x] si pas de telles valeurs */
-/* ==================================== */
-{
-	register uint8_t val = *(img+p);
-	register int32_t q;
-	register uint8_t v;
-	register int32_t alpha = NDG_MIN - 1;
-        register int32_t k;
-
-        for (k = 0; k < 26; k += 1)
-        {
-          q = voisin26(p, k, rs, ps, N);
-          if ((q != -1) && ((v=img[q]) < val) && ((int32_t)v > alpha)) alpha = (int32_t)v;
-	}
-        if (alpha == NDG_MIN - 1) 
-          return val;
-        else
-          return (uint8_t)alpha;
-} /* alpha26m() */
-
-/* ==================================== */
-uint32_t alpha26m_l(
-  uint32_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* retourne le sup des valeurs < img[x] dans le 26-voisinage de x, */
-/* ou img[x] si pas de telles valeurs */
-/* ==================================== */
-{
-	register uint32_t val = *(img+p);
-	register int32_t q;
-	register uint32_t v;
-	register int32_t alpha = NDG_MIN - 1;
-        register int32_t k;
-
-        for (k = 0; k < 26; k += 1)
-        {
-          q = voisin26(p, k, rs, ps, N);
-          if ((q != -1) && ((v=img[q]) < val) && ((int32_t)v > alpha)) alpha = (int32_t)v;
-	}
-        if (alpha == NDG_MIN - 1) 
-          return val;
-        else
-          return (uint32_t)alpha;
-} /* alpha26m_l() */
-
-/* ==================================== */
-uint8_t alpha6m(
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* retourne le sup des valeurs < img[x] dans le 6-voisinage de x, */
-/* ou img[x] si pas de telles valeurs */
-/* ==================================== */
-{
-	register uint8_t val = *(img+p);
-	register int32_t q;
-	register uint8_t v;
-	register int32_t alpha = NDG_MIN - 1;
-        register int32_t k;
-
-        for (k = 0; k <= 10; k += 2)
-        {
-          q = voisin6(p, k, rs, ps, N);
-          if ((q != -1) && ((v=img[q]) < val) && ((int32_t)v > alpha)) alpha = (int32_t)v;
-	}
-        if (alpha == NDG_MIN - 1) 
-          return val;
-        else
-          return (uint8_t)alpha;
-} /* alpha6m() */
-
-/* ==================================== */
-uint8_t alpha26p(
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* retourne le inf des valeurs > img[x] dans le 26-voisinage de x, */
-/* ou img[x] si pas de telles valeurs */
-/* ==================================== */
-{
-	register uint8_t val = *(img+p);
-	register int32_t q;
-	register uint8_t v;
-	register int32_t alpha = NDG_MAX + 1;
-        register int32_t k;
-
-        for (k = 0; k < 26; k += 1)
-        {
-          q = voisin26(p, k, rs, ps, N);
-          if ((q != -1) && ((v=img[q]) > val) && ((int32_t)v < alpha)) alpha = (int32_t)v;
-	}
-        if (alpha == NDG_MAX + 1) 
-          return val;
-        else
-          return (uint8_t)alpha;
-} /* alpha26p() */
-
-/* ==================================== */
-uint8_t alpha6p(
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* retourne le inf des valeurs > img[x] dans le 6-voisinage de x, */
-/* ou img[x] si pas de telles valeurs */
-/* ==================================== */
-{
-	register uint8_t val = *(img+p);
-	register int32_t q;
-	register uint8_t v;
-	register int32_t alpha = NDG_MAX + 1;
-        register int32_t k;
-
-        for (k = 0; k <= 10; k += 2)
-        {
-          q = voisin6(p, k, rs, ps, N);
-          if ((q != -1) && ((v=img[q]) > val) && ((int32_t)v < alpha)) alpha = (int32_t)v;
-	}
-        if (alpha == NDG_MAX + 1) 
-          return val;
-        else
-          return (uint8_t)alpha;
-} /* alpha6p() */
-
-/* ==================================== */
-uint8_t delta6m( 
-/* retourne la valeur max. a laquelle p est destructible - minima 6-connexes */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{	
-  uint8_t ret, sav = img[p];
-  while (pdestr6(img, p, rs, ps, N)) img[p] = alpha26m(img, p, rs, ps, N);
-  ret = img[p];
-  img[p] = sav;
-  return ret;
-} /* delta6m() */
-
-/* ==================================== */
-uint8_t delta26m( 
-/* retourne la valeur max. a laquelle p est destructible - minima 26-connexes */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{	
-  uint8_t ret, sav = img[p];
-  while (pdestr26(img, p, rs, ps, N)) img[p] = alpha26m(img, p, rs, ps, N);
-  ret = img[p];
-  img[p] = sav;
-  return ret;
-} /* delta26m() */
-
-/* ==================================== */
-uint8_t delta6p( 
-/* retourne la valeur min. a laquelle p est constructible - minima 6-connexes */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{	
-  uint8_t ret, sav = img[p];
-  while (pconstr6(img, p, rs, ps, N)) img[p] = alpha26p(img, p, rs, ps, N);
-  ret = img[p];
-  img[p] = sav;
-  return ret;
-} /* delta6p() */
-
-/* ==================================== */
-uint8_t delta26p( 
-/* retourne la valeur min. a laquelle p est constructible - minima 26-connexes */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{	
-  uint8_t ret, sav = img[p];
-  while (pconstr26(img, p, rs, ps, N)) img[p] = alpha26p(img, p, rs, ps, N);
-  ret = img[p];
-  img[p] = sav;
-  return ret;
-} /* delta26p() */
-
-/* ==================================== */
-int32_t separant6(  /* teste si un point est separant - minima 6-connexes
-	         ie- s'il est separant pour une coupe <= img[p] */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  int32_t k, q;
-
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-
-  preparecubesh(img, p, img[p], rs, ps, N);
-  if (T6(cubec_topo3d) >= 2) return 1;
-
-  for (k = 0; k < 26; k += 1)
-  {
-    q = voisin26(p, k, rs, ps, N);
-    if ((q != -1) && (img[q] <= img[p]))
-    {
-      preparecubesh(img, p, img[q], rs, ps, N);
-      if (T6(cubec_topo3d) >= 2) return 1;
-    }
-  }	
-  return 0;
-} /* separant6() */
-
-/* ==================================== */
-int32_t hseparant6(  /* teste si un point est hseparant - minima 6-connexes
-	         ie- s'il est separant pour la coupe h */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t h,                       /* parametre */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  int32_t k, q;
-
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-
-  preparecubesh(img, p, h, rs, ps, N);
-  if (T6(cubec_topo3d) >= 2) return 1;
-  return 0;
-} /* hseparant6() */
-
-/* ==================================== */
-int32_t hfseparant6(  /* teste si un point est hfseparant - minima 6-connexes
-	         ie- s'il est separant pour une coupe c telle que h < c <= img[p] */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t h,                       /* parametre */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  int32_t k, q;
-
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-
-  preparecubesh(img, p, img[p], rs, ps, N);
-  if (T6(cubec_topo3d) >= 2) return 1;
-
-  for (k = 0; k < 26; k += 1)
-  {
-    q = voisin26(p, k, rs, ps, N);
-    if ((q != -1) && (img[q] > h) && (img[q] <= img[p]))
-    {
-      preparecubesh(img, p, img[q], rs, ps, N);
-      if (T6(cubec_topo3d) >= 2) return 1;
-    }
-  }	
-  return 0;
-} /* hfseparant6() */
-
-/* ==================================== */
-int32_t filsombre6(                /* pour des minima en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-/*
-   pour la coupe K (>img[p]), le point doit etre
-   - soit un point isole (T == 1; Tb == 0)
-   - soit une extremite de courbe (T == 1; Tb == 1 et card(K) = 1)
-   - soit un point de courbe (T == 1; Tb == 2 et card(K) = 2)
-   - soit un point de croisement de courbe (T == 1; Tb == n et card(K) = n)
-
-*/
-{
-  int32_t T, Tb, Nb;
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  T = T26(cube_topo3d);
-  if (T != 1) return 0;
-  Tb = T6(cubec_topo3d);
-  if (Tb == 0) return 1;
-  Nb = nbvois6(cubec_topo3d);
-  if (Tb > 0) return (Nb == Tb);
-  return 0;
-} /* filsombre6() */
-
-/* ==================================== */
-int32_t filsombre26(               /* pour des minima en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-/*
-   pour la coupe K (>img[p]), le point doit etre
-   - soit un point isole (T == 1; Tb == 0)
-   - soit une extremite de courbe (T == 1; Tb == 1 et card(K) = 1)
-   - soit un point de courbe (T == 1; Tb == 2 et card(K) = 2)
-   - soit un point de croisement de courbe (T == 1; Tb == n et card(K) = n)
-
-*/
-{
-  int32_t T, Tb, Nb;
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  T = T6(cube_topo3d);
-  if (T != 1) return 0;
-  Tb = T26(cubec_topo3d);
-  if (Tb == 0) return 1;
-  Nb = nbvois26(cubec_topo3d);
-  if (Tb > 0) return (Nb == Tb);
-  return 0;
-} /* filsombre26() */
-
-/* ==================================== */
-int32_t filclair6(                /* pour des minima en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-/*
-   pour la coupe K (>=img[p]), le point doit etre
-   - soit un point isole (Tb == 1; T == 0)
-   - soit une extremite de courbe (Tb == 1; T == 1 et card(K) = 1)
-   - soit un point de courbe (Tb == 1; T == 2 et card(K) = 2)
-   - soit un point de croisement de courbe (Tb == 1; T == n et card(K) = n)
-*/
-{
-  int32_t T, Tb, Nb;
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  Tb = T6(cubec_topo3d);
-  if (Tb != 1) return 0;
-  T = T26(cube_topo3d);
-  if (T == 0) return 1;
-  Nb = nbvois26(cube_topo3d);
-  if (T > 0) return (Nb == T);
-  return 0;
-} /* filclair6() */
-
-/* ==================================== */
-int32_t filclair26(                /* pour des minima en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-/*
-   pour la coupe K (>=img[p]), le point doit etre
-   - soit un point isole (Tb == 1; T == 0)
-   - soit une extremite de courbe (Tb == 1; T == 1 et card(K) = 1)
-   - soit un point de courbe (Tb == 1; T == 2 et card(K) = 2)
-   - soit un point de croisement de courbe (Tb == 1; T == n et card(K) = n)
-*/
-{
-  int32_t T, Tb, Nb;
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  Tb = T26(cubec_topo3d);
-  if (Tb != 1) return 0;
-  T = T6(cube_topo3d);
-  if (T == 0) return 1;
-  Nb = nbvois6(cube_topo3d);
-  if (T > 0) return (Nb == T);
-  return 0;
-} /* filclair26() */
-
-/* ==================================== */
-int32_t t6mm(                   /* pour des minima en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return T6(cubec_topo3d);
-} /* t6mm() */
-
-/* ==================================== */
-int32_t t6m(                   /* pour des minima en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return T6(cubec_topo3d);
-} /* t6m() */
-
-/* ==================================== */
-int32_t t26mm(                   /* pour des minima en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return T26(cubec_topo3d);
-} /* t26mm() */
-
-/* ==================================== */
-int32_t t26m(                   /* pour des minima en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return T26(cubec_topo3d);
-} /* t26m() */
-
-/* ==================================== */
-int32_t t6pp(
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return T6(cube_topo3d);
-} /* t6pp() */
-
-/* ==================================== */
-int32_t t6p(
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return T6(cube_topo3d);
-} /* t6p() */
-
-/* ==================================== */
-int32_t t26pp(
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p]+1, rs, ps, N);
-  return T26(cube_topo3d);
-} /* t26pp() */
-
-/* ==================================== */
-int32_t t26p(
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh(img, p, img[p], rs, ps, N);
-  return T26(cube_topo3d);
-} /* t26p() */
-
-/* ==================================== */
-int32_t t26pp_l(
-  uint32_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh_l(img, p, img[p]+1, rs, ps, N);
-  return T26(cube_topo3d);
-} /* t26pp_l() */
-
-/* ==================================== */
-int32_t t6pp_l(
-  uint32_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    return 0;
-  preparecubesh_l(img, p, img[p]+1, rs, ps, N);
-  return T6(cube_topo3d);
-} /* t6pp_l() */
-
-/* ==================================== */
-void nbtopoh3d26_l( /* pour les minima en 26-connexite */ 
-  uint32_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  uint32_t h,
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N,                       /* taille image */
-  int32_t *t6p,
-  int32_t *t26mm)
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    {
-      printf("ERREUR: nbtopoh3d26_l: point de bord\n");
-      exit(0);
-    }
-  preparecubesh_l(img, p, h, rs, ps, N);
-  *t6p = T6(cube_topo3d);
-  *t26mm = T26(cubec_topo3d);
-} /* nbtopoh3d26_l() */
-
-/* ==================================== */
-void nbtopoh3d6_l( /* pour les minima en 6-connexite */ 
-  uint32_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  uint32_t h,
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N,                       /* taille image */
-  int32_t *t26p,
-  int32_t *t6mm)
-/* ==================================== */
-{
-  if ((p < ps) || (p >= N-ps) ||         /* premier ou dernier plan */
-      (p%ps < rs) || (p%ps >= ps-rs) ||  /* premiere ou derniere colonne */
-      (p%rs == 0) || (p%rs == rs-1))     /* premiere ou derniere ligne */
-    {
-      printf("ERREUR: nbtopoh3d6_l: point de bord\n");
-      exit(0);
-    }
-  preparecubesh_l(img, p, h, rs, ps, N);
-  *t26p = T26(cube_topo3d);
-  *t6mm = T6(cubec_topo3d);
-} /* nbtopoh3d6_l() */
-
-/* ==================================== */
-int32_t bordext6(uint8_t *F, int32_t x, int32_t rs, int32_t ps, int32_t N)
-/* ==================================== */
-/* teste si x a un 6-voisin a 0 */
-{
-  int32_t k, y;
-  for (k = 0; k <= 10; k += 2) /* parcourt les voisins en 6-connexite */
-  {
-    y = voisin6(x, k, rs, ps, N);
-    if ((y != -1) && (F[y] == 0)) return 1;
-  } /* for k */      
-  return 0;
-} /* bordext6() */
-
-/* ==================================== */
-int32_t bordext26(uint8_t *F, int32_t x, int32_t rs, int32_t ps, int32_t N)
-/* ==================================== */
-/* teste si x a un 26-voisin a 0 */
-{
-  int32_t k, y;
-  for (k = 0; k < 26; k += 1) /* parcourt les voisins en 26-connexite */
-  {
-    y = voisin26(x, k, rs, ps, N);
-    if ((y != -1) && (F[y] == 0)) return 1;
-  } /* for k */      
-  return 0;
-} /* bordext26() */
-
-/* ==================================== */
-int32_t curve6( /* point de courbe en 6-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-/*  ATTENTION: i ne doit pas etre un point de bord (test a faire avant). */
-{
-  if (img[p] == 0) return 0;
-  preparecubes(img, p, rs, ps, N);
-  if ((T6(cube_topo3d) == 2) && (nbvoiso6(img, p, rs, ps, N) == 2)) return 1;
-  return 0;
-} /* curve6() */
-
-/* ==================================== */
-int32_t curve18( /* point de courbe en 18-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-/*  ATTENTION: i ne doit pas etre un point de bord (test a faire avant). */
-{
-  if (img[p] == 0) return 0;
-  preparecubes(img, p, rs, ps, N);
-  if ((T18(cube_topo3d) == 2) && (nbvoiso18(img, p, rs, ps, N) == 2)) return 1;
-  return 0;
-} /* curve18() */
-
-/* ==================================== */
-int32_t curve26( /* point de courbe en 26-connexite */
-  uint8_t *img,          /* pointeur base image */
-  int32_t p,                       /* index du point */
-  int32_t rs,                      /* taille rangee */
-  int32_t ps,                      /* taille plan */
-  int32_t N)                       /* taille image */
-/* ==================================== */
-/*  ATTENTION: i ne doit pas etre un point de bord (test a faire avant). */
-{
-  if (img[p] == 0) return 0;
-  preparecubes(img, p, rs, ps, N);
-  if ((T26(cube_topo3d) == 2) && (nbvoiso26(img, p, rs, ps, N) == 2)) return 1;
-  return 0;
-} /* curve26() */
diff -r 8b1af7363833 src/lib/mcxbib.c
--- a/src/lib/mcxbib.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,591 +0,0 @@
-/* $Id: mcxbib.c,v 1.1.1.1 2008-11-25 08:01:43 mcouprie Exp $ */
-/* ==================================================================== */
-/* a simple drawing library */
-/* from "X Window Application Programming" */
-
-#include <mcxbib.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <stdlib.h>
-#include <stdio.h>
-
-/* ====================================================== */
-/* globals */
-/* ====================================================== */
-
-#define NBCOLORS 128
-
-Display       *theDisplay;
-Window        theWindow;
-GC            theGC;
-XFontStruct   *theFont;
-Colormap      theColormap;
-int32_t           theScreen;
-int32_t           theDepth;
-uint32_t thePlane[1];
-uint32_t thePixel[NBCOLORS];
-XColor        theColors[NBCOLORS];
-uint32_t theBlackPixel;
-uint32_t theWhitePixel;
-
-/* ==================================================================== */
-/* init code to talk to the X server */
-/* ==================================================================== */
-
-/* =========================================== */
-void initX()
-/* =========================================== */
-/* sets up the connection to the X server      */
-{
-  theDisplay = XOpenDisplay(NULL);
-  if (theDisplay == NULL) {
-    fprintf(stderr, "Error: cannot establish a connection to the X server\n");
-    exit(1);
-  } /* if */
-  
-  theScreen = DefaultScreen( theDisplay );
-  theDepth  = DefaultDepth( theDisplay, theScreen );
-  theBlackPixel  = BlackPixel( theDisplay, theScreen );
-  theWhitePixel  = WhitePixel( theDisplay, theScreen );
-  theFont = XLoadQueryFont(theDisplay, FONTE18);
-
-} /* initX() */
-
-/* =========================================== */
-void getXInfo()
-/* =========================================== */
-{
-  
-} /* getXInfo() */
-
-/* ==================================================================== */
-/* routine to close down X - 
-   from "X Window Application Programming" */
-/* ==================================================================== */
-
-/* =========================================== */
-void quitX()
-/* =========================================== */
-/* closes the connection to the X server       */
-{
-  XCloseDisplay( theDisplay );
-  
-} /* quitX() */
-
-
-/* ==================================================================== */
-/* window opening routine - from "X Window Application Programming" */
-/* ==================================================================== */
-
-/* ==================================== */
-int32_t createGC(Window theNewWindow, GC     *theNewGC) 
-/* creates a Graphic Context for the given window     */
-/* (necessary to draw into the window)                */
-/* returns 0 if error, 1 if OK                        */
-/* ==================================== */
-{
-  XGCValues theGCValues;
-
-  *theNewGC = XCreateGC( theDisplay, theNewWindow, 
-                         (uint32_t)0, &theGCValues );
-  if (*theNewGC == 0) return(0);
-  else {
-    XSetForeground( theDisplay, *theNewGC, theBlackPixel );
-    XSetBackground( theDisplay, *theNewGC, theWhitePixel );
-    return(1);
-  } /* else */
-} /* createGC() */
-
-#define LINESOLID 0
-#define LINEONOFFDASH 1
-#define LINEDOUBLEDASH 2
-
-/* ==================================== */
-void changeLineStyle(GC theGC, int32_t linewidth,  int32_t dash) 
-/* ==================================== */
-{
-  XGCValues theGCValues;
-
-  theGCValues.line_width = linewidth;
-  switch (dash % 3) {
-    case LINESOLID: theGCValues.line_style = LineSolid; break;
-    case LINEONOFFDASH: theGCValues.line_style = LineOnOffDash; break;
-    case LINEDOUBLEDASH: theGCValues.line_style = LineDoubleDash; break;
-  } /* switch */
-  
-  XChangeGC( theDisplay, theGC, (GCLineWidth | GCLineStyle), &theGCValues);
-} /* changeLineStyle() */
-
-/* ==================================== */
-Window openWindow(int32_t x, int32_t y, int32_t width, int32_t height, int32_t flag, GC *theNewGC) 
-/* opens a new window - returns the window id         */
-/* ==================================== */
-{
-  Window               theNewWindow;
-
-  /* open a window on the display */
-  theNewWindow = XCreateSimpleWindow(
-                    theDisplay,
-                    RootWindow(theDisplay, theScreen),
-                    x, y, width, height,
-                    BORDER_WIDTH,
-                    0,
-                    theWhitePixel);
-
-  /* create a Graphic Context for the window */
-  if ( createGC(theNewWindow, theNewGC) == 0 ) {
-    XDestroyWindow(theDisplay, theNewWindow);
-    return( (Window)0 );
-  } /* if */
-
-  XSetFont(theDisplay, *theNewGC, theFont->fid);
-
-  /* ask X to place the window visibility on the screen */
-  XMapWindow( theDisplay, theNewWindow );
-
-  /* flush X requests to the X server */
-  XFlush( theDisplay );
-
-  /* return the window id */
-  return( theNewWindow );
-
-} /* openWindow() */
-
-  
-/* ==================================== */
-void allocNamedColor(Display *theDisplay, Colormap *default_cmap, uint32_t *thePixel, 
-                     char * color_name, uint32_t color_code)
-/* ==================================== */
-{
-  XColor exact_def;
-
-  if (!XParseColor(theDisplay, *default_cmap, color_name, &exact_def))
-  {
-    fprintf(stderr, "openWindow : XParseColor failed\n");
-    exit(0);
-  }
-#ifdef DEBUG_COLOR
-printf("requested color %d %d %d\n", exact_def.red, exact_def.green, exact_def.blue);
-#endif
-  if (!XAllocColor(theDisplay, *default_cmap, &exact_def))
-  {
-    fprintf(stderr, "openWindow : XAllocColor failed\n");
-    exit(0);
-  }
-#ifdef DEBUG_COLOR
-printf("actually got color %d %d %d", exact_def.red, exact_def.green, exact_def.blue);
-printf("   pixel value %d\n", exact_def.pixel);    
-#endif
-  thePixel[color_code] = exact_def.pixel;
-}
-
-/* ==================================== */
-Window openColorWindow(int32_t x, int32_t y, int32_t width, int32_t height, int32_t flag, GC *theNewGC) 
-/* opens a new window - returns the window id         */
-/* ==================================== */
-{
-  Window theNewWindow;
-  int32_t flags;
-  Status status;
-  int32_t i;
-  int32_t default_depth;
-  Visual *default_visual;
-  Colormap default_cmap;
-  int32_t screen_num = 0;
-  XVisualInfo visual_info;
-  static char *visual_class[] = {"StaticGray", "Grayscale", "StaticColor", "PseudoColor", 
-    "TrueColor", "DirectColor"};
-  XColor exact_def;
-
-  default_depth = DefaultDepth (theDisplay, screen_num);
-  default_visual = DefaultVisual (theDisplay, screen_num);
-  default_cmap = DefaultColormap (theDisplay, screen_num);
-
-#ifdef DEBUG_COLOR
-printf("default depth = %d\n", default_depth);
-#endif
-  i = 5;
-  while (!XMatchVisualInfo(theDisplay, screen_num, default_depth, i, &visual_info)) i--;
-
-#ifdef DEBUG_COLOR
-printf("found a %s class visual at depth %d\n", visual_class[i], default_depth);
-#endif
-
-  for (i = 0; i < 64; i++)           /* 64 premieres couleurs : echelle de gris */
-  {
-    exact_def.red = exact_def.green = exact_def.blue = 1024 * i;
-#ifdef DEBUG_COLOR
-printf("requested color %d %d %d\n", exact_def.red, exact_def.green, exact_def.blue);
-#endif
-    if (!XAllocColor(theDisplay, default_cmap, &exact_def))
-    {
-      fprintf(stderr, "openWindow : XAllocColor failed\n");
-      exit(0);
-    }
-#ifdef DEBUG_COLOR
-printf("actually got color %d %d %d", exact_def.red, exact_def.green, exact_def.blue);
-printf("   pixel value %d\n", exact_def.pixel);    
-#endif
-    thePixel[i] = exact_def.pixel;
-  }
-  
-  allocNamedColor(theDisplay, &default_cmap, thePixel, "red",     MC_RED);
-  allocNamedColor(theDisplay, &default_cmap, thePixel, "green",   MC_GREEN);
-  allocNamedColor(theDisplay, &default_cmap, thePixel, "blue",    MC_BLUE);
-  allocNamedColor(theDisplay, &default_cmap, thePixel, "yellow",  MC_YELLOW);
-  allocNamedColor(theDisplay, &default_cmap, thePixel, "cyan",    MC_CYAN);
-  allocNamedColor(theDisplay, &default_cmap, thePixel, "magenta", MC_MAGENTA);
-  allocNamedColor(theDisplay, &default_cmap, thePixel, "orange",  MC_ORANGE);
-  allocNamedColor(theDisplay, &default_cmap, thePixel, "purple",  MC_PURPLE);
-  allocNamedColor(theDisplay, &default_cmap, thePixel, "brown",   MC_BROWN);
-  allocNamedColor(theDisplay, &default_cmap, thePixel, "pink",    MC_PINK);
-  allocNamedColor(theDisplay, &default_cmap, thePixel, "LightGrey", MC_LIGHTGREY);
-
-  /* open a window on the display */
-  theNewWindow = XCreateSimpleWindow(
-                    theDisplay,
-                    RootWindow(theDisplay, theScreen),
-                    x, y, width, height,
-                    BORDER_WIDTH,
-                    0,
-                    theBlackPixel);
-
-  /* create a Graphic Context for the window */
-  if ( createGC(theNewWindow, theNewGC) == 0 ) {
-    XDestroyWindow(theDisplay, theNewWindow);
-    return( (Window)0 );
-  } /* if */
-
-  XSetFont(theDisplay, *theNewGC, theFont->fid);
-
-  /* ask X to place the window visibility on the screen */
-  XMapWindow( theDisplay, theNewWindow );
-
-  /* flush X requests to the X server */
-  XFlush( theDisplay );
-
-  /* return the window id */
-  return( theNewWindow );
-
-} /* openColorWindow() */
-
-/* ==================================================================== */
-/* routines to deal with mouse button events - 
-   from "X Window Application Programming" */
-/* ==================================================================== */
-
-#define EV_MASK (ButtonPressMask|ButtonReleaseMask|KeyPressMask|EnterWindowMask)
-
-/* ==================================== */
-void WaitMouseEvent(int32_t *x, int32_t *y) 
-/* blocks awaiting an event      */
-/* ==================================== */
-{
-  XEvent theEvent;
-  XComposeStatus theComposeStatus;
-  XNextEvent( theDisplay, &theEvent );
-  if (theEvent.type != ButtonPress) WaitMouseEvent(x,y);
-  else
-  {
-    *x = theEvent.xbutton.x;
-    *y = theEvent.xbutton.y;
-  }
-} /* WaitMouseEvent() */
-
-/* ============================= */
-int32_t WaitKbdEvent() 
-/* ============================= */
-/* blocks awaiting an event      */
-{
-  XEvent theEvent;
-  XComposeStatus theComposeStatus;
-  XNextEvent( theDisplay, &theEvent );
-  if (theEvent.type == KeyPress)
-    return theEvent.xkey.keycode;
-  else
-    return -1;
-} /* WaitKbdEvent() */
-
-/* ==================================== */
-int32_t WaitEvent(int32_t *x, int32_t *y) 
-/* blocks awaiting an event      */
-/* ==================================== */
-{
-  XEvent theEvent;
-  XComposeStatus theComposeStatus;
-  XNextEvent( theDisplay, &theEvent );
-  if (theEvent.type == KeyPress)
-    *x = theEvent.xkey.keycode;
-  else
-  {
-    *x = theEvent.xbutton.x;
-    *y = theEvent.xbutton.y;
-  }
-  return theEvent.type;
-} /* WaitEvent() */
-
-/* ==================================== */
-int32_t WaitAnyEvent(int32_t *x, int32_t *y, int32_t *c) 
-/* blocks awaiting any event      */
-/* ==================================== */
-{
-  XEvent theEvent;
-  XComposeStatus theComposeStatus;
-  XNextEvent( theDisplay, &theEvent );
-  if (theEvent.type == KeyPress)
-    *x = theEvent.xkey.keycode;
-  else
-  {
-    *x = theEvent.xbutton.x;
-    *y = theEvent.xbutton.y;
-    *c = theEvent.xbutton.button;
-  }
-  return theEvent.type;
-} /* WaitAnyEvent() */
-
-/* ==================================== */
-void initEvents(Window theWindow) 
-/* ==================================== */
-{
-  (void)XSelectInput( theDisplay, theWindow, EV_MASK );
-} /* initEvents() */
-
-/* ==================================================================== */
-/* window drawing routines - from "X Window Application Programming" */
-/* ==================================================================== */
-
-/* ==================================== */
-void setColToWhite(GC gc)  
-/* ==================================== */
-{
-  (void)XSetForeground(theDisplay, gc, theWhitePixel);
-}
-
-/* ==================================== */
-void setColToBlack(GC gc)  
-/* ==================================== */
-{
-  (void)XSetForeground(theDisplay, gc, theBlackPixel);
-}
-
-/* ==================================== */
-void drawLine(Window theWindow, GC theGC, int32_t x1, int32_t y1,  int32_t x2, int32_t y2) 
-/* ==================================== */
-{
-  (void)XDrawLine(theDisplay, theWindow, theGC, x1, y1, x2, y2);
-} /* drawLine() */
-
-/* ==================================== */
-void drawPoint(Window theWindow, GC theGC, int32_t x, int32_t y) 
-/* ==================================== */
-{
-  (void)XDrawPoint(theDisplay, theWindow, theGC, x, y);
-} /* drawPoint() */
-
-/* ==================================== */
-void fillRectangle(Window theWindow, GC theGC, int32_t x, int32_t y, int32_t w, int32_t h) 
-/* ==================================== */
-{
-  (void)XFillRectangle(theDisplay, theWindow, theGC, x, y, w, h);
-} /* fillRectangle() */
-
-/* ==================================================================== */
-/* routines to deal with text - 
-   from "X Window Application Programming" */
-/* ==================================================================== */
-
-/* ==================================== */
-XFontStruct * initFont (GC theGC, char fontName[]) 
-/* ==================================== */
-{
-  XFontStruct *fontStruct;
-
-  fontStruct = XLoadQueryFont( theDisplay, fontName );
-  if (fontStruct != 0) XSetFont(theDisplay, theGC, fontStruct->fid);
-  return(fontStruct);
-} /* initFont() */
-
-/* ==================================== */
-void drawString(Window theWindow, GC theGC, int32_t x, int32_t y, char *str) 
-/* ==================================== */
-{
-  XDrawString( theDisplay, theWindow, theGC, x, y, str, strlen(str) );
-} /* drawString() */
-
-
-/* ==================================================================== */
-/* ==================================================================== */
-/* Higher level functions, allowing a simpler interface */
-/* ==================================================================== */
-/* ==================================================================== */
-
-/* ==================================================================== */
-/* drawing routines */
-/* ==================================================================== */
-
-/* ==================================== */
-void ColToWhite() 
-/* ==================================== */
-{ 
-  XSetForeground(theDisplay, theGC, theWhitePixel); 
-}
-
-/* ==================================== */
-void ColToBlack() 
-/* ==================================== */
-{ 
-  XSetForeground(theDisplay, theGC, theBlackPixel); 
-}
-
-/* ==================================== */
-void Col( uint32_t c )                  /* for windows created by openWindow() */
-/* ==================================== */
-{ 
-  XSetForeground(theDisplay, theGC, c); 
-}
-
-/* ==================================== */
-void Color( uint32_t c )                  /* for windows created by openColorWindow() */
-/* ==================================== */
-{ 
-  XSetForeground(theDisplay, theGC, thePixel[c]); 
-}
-
-/* ==================================== */
-void Line(int32_t x1, int32_t y1, int32_t x2, int32_t y2)  
-/* ==================================== */
-{
-  XDrawLine(theDisplay, theWindow, theGC, x1, y1, x2, y2);
-}
-
-/* ==================================== */
-void Point(int32_t x, int32_t y) 
-/* ==================================== */
-{ 
-  XDrawPoint(theDisplay, theWindow, theGC, x, y);
-}
-
-/* ==================================== */
-void FRectangle(int32_t x, int32_t y, int32_t w, int32_t h) 
-/* ==================================== */
-{
-  XFillRectangle(theDisplay, theWindow, theGC, x, y, w, h);
-}
-
-/* ==================================== */
-void Rectangle(int32_t x, int32_t y, int32_t w, int32_t h) 
-/* ==================================== */
-{
-  Line(x, y, x+w, y);  
-  Line(x, y, x, y+h);  
-  Line(x, y+h, x+w, y+h);  
-  Line(x+w, y, x+w, y+h);  
-}
-
-/* ==================================================================== */
-/* routines to deal with text - 
-   from "X Window Application Programming" */
-/* ==================================================================== */
-
-/* ==================================== */
-void SetFont (char *fontName) 
-/* ==================================== */
-{
-  XFontStruct *fontStruct;
-
-  fontStruct = XLoadQueryFont( theDisplay, fontName );
-  if (fontStruct != 0) XSetFont(theDisplay, theGC, fontStruct->fid);
-}
-
-/* ==================================== */
-void String(int32_t x, int32_t y, char *str) 
-/* ==================================== */
-{
-  XDrawString( theDisplay, theWindow, theGC, x, y, str, strlen(str) );
-}
-
-/* ==================================================================== */
-/* routines to initiate, refresh and terminate */
-/* ==================================================================== */
-
-/* ==================================== */
-void InitGraphics(int32_t x, int32_t y, int32_t w, int32_t h) 
-/* ==================================== */
-{
-  initX();
-
-  theWindow = openWindow( x, y, w, h, 
-                          0,        /* 0: not a pop-up */
-                          &theGC );
-
-  initEvents( theWindow );
-}
-
-/* ==================================== */
-void InitColorGraphics(int32_t x, int32_t y, int32_t w, int32_t h) 
-/* ==================================== */
-{
-  initX();
-
-  theWindow = openColorWindow( x, y, w, h, 
-                          0,        /* 0: not a pop-up */
-                          &theGC );
-
-  initEvents( theWindow );
-}
-
-/* ==================================== */
-void FlushGraphics()
-/* ==================================== */
-{
-  /* send output to the screen */
-  XFlush( theDisplay );
-}
- 
-/* ==================================== */
-void TerminateGraphics()
-/* ==================================== */
-{
-  XDestroyWindow( theDisplay, theWindow );
-
-  quitX();
-}
-
-#ifdef TESTX
-void main () 
-{
-  int32_t x, y;
-  int32_t col;
-  
-  InitGraphics( 100, 100, /* x, y */
-                300, 300  /* w, h */
-              );
-
-  /* draw into the window */
-  Line( 10, 10, 100, 100 );
-     /* x1  y1   x2   y2 */
-  /* send output to the screen */
-  FlushGraphics();
-
-  printf("press mouse button to continue\n");
-  WaitMouseEvent(&x, &y);
-  printf("mouse event - x = %d ; y = %d\n", x, y);
-
-  ColToWhite();
-  FRectangle(0, 0, 300, 300);
-  ColToBlack();
-
-  String(20, 20, "coucou !");
-  FlushGraphics();
-
-  printf("press a key\n");
-  do
-  {
-    x = WaitKbdEvent();
-    printf("kbd event - x = %d\n", x);
-  } while (x != 1);
-
-  TerminateGraphics();
- 
-} /* main() */
-#endif
diff -r 8b1af7363833 src/lib/tableRemyThiel.c
--- a/src/lib/tableRemyThiel.c	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,9620 +0,0 @@
-
-#include <stdint.h>
-
-#include "lmedialaxis.h"
-
-#define NBVECTNGLUT 7
-#define NBCOLLUT 1370 
-int32_t nbvectnglut = NBVECTNGLUT;
-int32_t nbcollut = NBCOLLUT;
-
-Weighting MgL1[NBVECTNGLUT] = 
-{
-  {1,  0,   1},
-  {1,  1,   2},
-  {2,  1, 101},
-  {3,  1, 146},
-  {3,  2, 424},
-  {4,  1, 848},
-  {5,  1, 1370}
-};
-
-int32_t LutColumn1[NBVECTNGLUT * NBCOLLUT] = {
-// column
-0,
-2,
-5,
-0,
-6,
-10,
-0,
-0,
-11,
-14,
-17,
-0,
-0,
-18,
-0,
-0,
-21,
-26,
-27,
-0,
-27,
-0,
-0,
-0,
-0,
-30,
-37,
-0,
-0,
-38,
-0,
-0,
-41,
-0,
-42,
-0,
-46,
-50,
-0,
-0,
-51,
-54,
-0,
-0,
-0,
-54,
-0,
-0,
-0,
-59,
-65,
-0,
-66,
-66,
-0,
-0,
-0,
-0,
-69,
-0,
-0,
-74,
-0,
-0,
-75,
-82,
-0,
-0,
-83,
-0,
-0,
-0,
-86,
-86,
-91,
-0,
-0,
-0,
-0,
-0,
-91,
-98,
-101,
-0,
-0,
-102,
-0,
-0,
-0,
-105,
-107,
-0,
-0,
-0,
-0,
-0,
-0,
-110,
-117,
-0,
-117,
-122,
-0,
-0,
-123,
-0,
-126,
-0,
-0,
-126,
-0,
-0,
-0,
-131,
-0,
-0,
-131,
-138,
-0,
-0,
-0,
-138,
-145,
-0,
-0,
-146,
-0,
-0,
-149,
-0,
-149,
-0,
-0,
-0,
-0,
-0,
-154,
-158,
-0,
-0,
-0,
-0,
-0,
-0,
-161,
-170,
-171,
-0,
-171,
-174,
-0,
-0,
-0,
-174,
-0,
-0,
-0,
-179,
-0,
-0,
-181,
-0,
-186,
-0,
-186,
-0,
-0,
-0,
-0,
-186,
-197,
-0,
-0,
-198,
-0,
-0,
-0,
-0,
-201,
-0,
-206,
-206,
-0,
-0,
-0,
-206,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-213,
-219,
-0,
-222,
-226,
-0,
-0,
-227,
-0,
-230,
-0,
-0,
-230,
-0,
-0,
-235,
-0,
-0,
-0,
-235,
-0,
-0,
-0,
-0,
-0,
-242,
-0,
-0,
-246,
-0,
-0,
-0,
-251,
-257,
-0,
-0,
-258,
-0,
-0,
-261,
-262,
-262,
-0,
-0,
-0,
-0,
-0,
-0,
-266,
-273,
-0,
-273,
-273,
-0,
-0,
-0,
-0,
-275,
-0,
-0,
-0,
-0,
-0,
-282,
-290,
-0,
-0,
-291,
-294,
-0,
-0,
-0,
-294,
-0,
-0,
-0,
-299,
-0,
-0,
-299,
-0,
-306,
-0,
-0,
-306,
-0,
-0,
-0,
-307,
-0,
-0,
-0,
-0,
-0,
-0,
-315,
-315,
-325,
-0,
-326,
-326,
-0,
-0,
-329,
-0,
-329,
-0,
-0,
-0,
-0,
-0,
-0,
-334,
-341,
-0,
-0,
-0,
-0,
-0,
-0,
-341,
-341,
-0,
-0,
-350,
-0,
-0,
-350,
-0,
-0,
-0,
-354,
-362,
-0,
-0,
-363,
-0,
-0,
-0,
-0,
-366,
-0,
-0,
-0,
-371,
-371,
-0,
-374,
-0,
-0,
-0,
-0,
-0,
-378,
-0,
-0,
-378,
-0,
-0,
-0,
-387,
-0,
-0,
-389,
-0,
-0,
-0,
-390,
-398,
-401,
-0,
-0,
-402,
-0,
-0,
-0,
-405,
-405,
-0,
-0,
-410,
-0,
-0,
-0,
-411,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-417,
-0,
-426,
-426,
-0,
-0,
-426,
-0,
-426,
-0,
-0,
-426,
-0,
-0,
-437,
-442,
-0,
-0,
-443,
-446,
-0,
-0,
-0,
-446,
-451,
-0,
-0,
-0,
-0,
-0,
-451,
-0,
-0,
-0,
-0,
-458,
-0,
-0,
-458,
-462,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-467,
-0,
-0,
-469,
-0,
-0,
-0,
-0,
-478,
-485,
-0,
-0,
-486,
-0,
-0,
-0,
-489,
-491,
-0,
-494,
-0,
-0,
-0,
-0,
-494,
-501,
-0,
-0,
-501,
-0,
-0,
-501,
-0,
-506,
-0,
-510,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-510,
-0,
-0,
-0,
-521,
-523,
-0,
-523,
-530,
-0,
-0,
-531,
-0,
-534,
-0,
-0,
-534,
-0,
-0,
-0,
-0,
-0,
-0,
-539,
-0,
-0,
-0,
-0,
-546,
-0,
-0,
-0,
-549,
-0,
-0,
-555,
-0,
-555,
-0,
-0,
-0,
-0,
-0,
-555,
-566,
-566,
-0,
-0,
-0,
-0,
-0,
-0,
-566,
-577,
-0,
-0,
-578,
-0,
-0,
-0,
-0,
-581,
-0,
-0,
-586,
-0,
-0,
-586,
-586,
-0,
-0,
-593,
-594,
-0,
-0,
-0,
-0,
-594,
-0,
-0,
-602,
-0,
-0,
-0,
-0,
-602,
-0,
-0,
-606,
-0,
-0,
-0,
-613,
-0,
-0,
-0,
-0,
-0,
-0,
-613,
-626,
-627,
-0,
-627,
-0,
-0,
-0,
-630,
-630,
-635,
-0,
-0,
-0,
-0,
-0,
-635,
-642,
-0,
-0,
-642,
-0,
-0,
-0,
-0,
-642,
-0,
-0,
-0,
-651,
-0,
-0,
-0,
-0,
-651,
-0,
-658,
-662,
-0,
-0,
-0,
-662,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-662,
-677,
-0,
-678,
-678,
-0,
-0,
-0,
-0,
-681,
-0,
-0,
-686,
-0,
-0,
-686,
-690,
-0,
-0,
-0,
-0,
-0,
-0,
-693,
-0,
-693,
-0,
-0,
-702,
-0,
-0,
-702,
-702,
-0,
-0,
-0,
-707,
-0,
-0,
-0,
-0,
-713,
-0,
-0,
-0,
-0,
-0,
-0,
-713,
-721,
-0,
-726,
-730,
-0,
-0,
-731,
-0,
-0,
-0,
-0,
-734,
-0,
-0,
-0,
-739,
-0,
-0,
-741,
-0,
-0,
-0,
-0,
-746,
-747,
-0,
-0,
-747,
-0,
-0,
-0,
-0,
-755,
-0,
-0,
-758,
-0,
-0,
-758,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-766,
-0,
-770,
-0,
-770,
-770,
-0,
-0,
-0,
-779,
-785,
-0,
-0,
-786,
-0,
-0,
-0,
-0,
-789,
-0,
-794,
-0,
-0,
-0,
-0,
-794,
-801,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-801,
-0,
-0,
-810,
-0,
-0,
-0,
-811,
-0,
-0,
-0,
-811,
-0,
-0,
-0,
-821,
-0,
-0,
-821,
-822,
-0,
-0,
-822,
-0,
-830,
-0,
-0,
-0,
-0,
-0,
-834,
-842,
-0,
-0,
-843,
-0,
-0,
-0,
-0,
-846,
-851,
-0,
-0,
-851,
-0,
-0,
-851,
-858,
-858,
-0,
-0,
-0,
-0,
-0,
-858,
-858,
-867,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-867,
-0,
-867,
-878,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-878,
-0,
-0,
-885,
-885,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-891,
-901,
-0,
-0,
-902,
-0,
-0,
-905,
-0,
-906,
-0,
-0,
-910,
-0,
-0,
-0,
-910,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-917,
-923,
-0,
-0,
-0,
-0,
-0,
-926,
-926,
-0,
-0,
-0,
-929,
-0,
-0,
-0,
-937,
-937,
-0,
-937,
-0,
-0,
-0,
-0,
-0,
-942,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-950,
-0,
-954,
-962,
-0,
-0,
-963,
-966,
-0,
-0,
-0,
-966,
-0,
-0,
-0,
-0,
-971,
-0,
-971,
-0,
-0,
-0,
-0,
-0,
-978,
-0,
-0,
-982,
-0,
-0,
-987,
-987,
-0,
-0,
-987,
-0,
-0,
-0,
-987,
-998,
-0,
-0,
-0,
-998,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1001,
-0,
-0,
-0,
-1011,
-1011,
-0,
-0,
-0,
-0,
-0,
-0,
-1011,
-1025,
-0,
-1026,
-1026,
-0,
-0,
-1029,
-0,
-1029,
-0,
-0,
-0,
-0,
-0,
-1034,
-1034,
-0,
-0,
-1041,
-1041,
-0,
-0,
-0,
-1043,
-1045,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1050,
-0,
-0,
-1061,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1062,
-1067,
-0,
-0,
-1074,
-0,
-0,
-0,
-1074,
-1074,
-0,
-0,
-1074,
-0,
-0,
-1083,
-1090,
-0,
-0,
-1091,
-0,
-0,
-0,
-0,
-1094,
-0,
-0,
-0,
-1099,
-0,
-0,
-1099,
-0,
-1106,
-0,
-1106,
-0,
-0,
-0,
-0,
-1106,
-0,
-0,
-0,
-1115,
-0,
-0,
-0,
-0,
-1115,
-0,
-1115,
-1126,
-0,
-0,
-0,
-0,
-1126,
-0,
-0,
-1126,
-0,
-0,
-0,
-1131,
-0,
-0,
-1139,
-0,
-0,
-0,
-0,
-0,
-1139,
-0,
-0,
-0,
-0,
-0,
-1146,
-1154,
-1157,
-0,
-0,
-1158,
-0,
-0,
-1161,
-1161,
-1161,
-0,
-0,
-0,
-0,
-0,
-0,
-1166,
-0,
-0,
-1173,
-1173,
-0,
-0,
-0,
-0,
-1173,
-0,
-0,
-1182,
-0,
-0,
-0,
-0,
-0,
-0,
-1182,
-1190,
-0,
-0,
-0,
-1193,
-1193,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1194,
-0,
-0,
-0,
-0,
-0,
-0,
-1206,
-0,
-0,
-0,
-0,
-0,
-0,
-1211,
-1211,
-1221,
-0,
-1221,
-1226,
-0,
-0,
-1227,
-0,
-0,
-0,
-0,
-1230,
-0,
-0,
-1235,
-0,
-1235,
-0,
-1238,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1242,
-0,
-0,
-1251,
-0,
-1251,
-0,
-0,
-1251,
-0,
-0,
-1257,
-1262,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1262,
-1262,
-0,
-0,
-1262,
-0,
-0,
-0,
-0,
-1275,
-0,
-0,
-1278,
-0,
-0,
-0,
-1278,
-0,
-0,
-1281,
-0,
-0,
-0,
-1290,
-1290,
-1297,
-0,
-0,
-1298,
-0,
-0,
-0,
-1301,
-1301,
-0,
-0,
-1306,
-0,
-0,
-0,
-1307,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1313,
-1315,
-0,
-1322,
-0,
-0,
-0,
-1322,
-0,
-1326,
-0,
-0,
-1326,
-0,
-0,
-0,
-0,
-0,
-0,
-1333,
-0,
-0,
-0,
-0,
-0,
-1333,
-0,
-0,
-1346,
-0,
-0,
-1347,
-0,
-1347,
-0,
-0,
-1347,
-0,
-0,
-0,
-1353,
-0,
-0,
-0,
-0,
-0,
-0,
-1361,
-1370,
-0,
-0,
-1371,
-1374,
-0,
-0,
-0,
-1374,
-1379,
-0,
-0,
-0,
-0,
-0,
-1379,
-1386,
-1386,
-0,
-0,
-0,
-0,
-0,
-0,
-1386,
-1395,
-0,
-0,
-1395,
-0,
-0,
-0,
-0,
-0,
-0,
-1397,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1406,
-0,
-0,
-0,
-1406,
-1419,
-0,
-1419,
-0,
-0,
-0,
-1419,
-0,
-1422,
-0,
-0,
-0,
-0,
-0,
-1422,
-1434,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1434,
-// column
-0,
-3,
-6,
-0,
-9,
-11,
-0,
-0,
-14,
-19,
-19,
-0,
-0,
-21,
-0,
-0,
-26,
-27,
-30,
-0,
-33,
-0,
-0,
-0,
-0,
-35,
-42,
-0,
-0,
-42,
-0,
-0,
-46,
-0,
-51,
-0,
-53,
-53,
-0,
-0,
-54,
-59,
-0,
-0,
-0,
-62,
-0,
-0,
-0,
-66,
-66,
-0,
-73,
-75,
-0,
-0,
-0,
-0,
-75,
-0,
-0,
-81,
-0,
-0,
-86,
-86,
-0,
-0,
-90,
-0,
-0,
-0,
-91,
-99,
-99,
-0,
-0,
-0,
-0,
-0,
-101,
-107,
-107,
-0,
-0,
-107,
-0,
-0,
-0,
-114,
-118,
-0,
-0,
-0,
-0,
-0,
-0,
-118,
-126,
-0,
-129,
-131,
-0,
-0,
-131,
-0,
-131,
-0,
-0,
-137,
-0,
-0,
-0,
-138,
-0,
-0,
-146,
-147,
-0,
-0,
-0,
-150,
-150,
-0,
-0,
-150,
-0,
-0,
-158,
-0,
-163,
-0,
-0,
-0,
-0,
-0,
-165,
-171,
-0,
-0,
-0,
-0,
-0,
-0,
-171,
-171,
-182,
-0,
-182,
-182,
-0,
-0,
-0,
-186,
-0,
-0,
-0,
-186,
-0,
-0,
-194,
-0,
-195,
-0,
-201,
-0,
-0,
-0,
-0,
-203,
-206,
-0,
-0,
-209,
-0,
-0,
-0,
-0,
-209,
-0,
-213,
-219,
-0,
-0,
-0,
-222,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-226,
-234,
-0,
-234,
-234,
-0,
-0,
-234,
-0,
-243,
-0,
-0,
-245,
-0,
-0,
-246,
-0,
-0,
-0,
-251,
-0,
-0,
-0,
-0,
-0,
-251,
-0,
-0,
-261,
-0,
-0,
-0,
-266,
-270,
-0,
-0,
-270,
-0,
-0,
-270,
-275,
-278,
-0,
-0,
-0,
-0,
-0,
-0,
-278,
-282,
-0,
-289,
-291,
-0,
-0,
-0,
-0,
-291,
-0,
-0,
-0,
-0,
-0,
-297,
-297,
-0,
-0,
-297,
-307,
-0,
-0,
-0,
-307,
-0,
-0,
-0,
-314,
-0,
-0,
-318,
-0,
-318,
-0,
-0,
-321,
-0,
-0,
-0,
-326,
-0,
-0,
-0,
-0,
-0,
-0,
-326,
-339,
-339,
-0,
-341,
-341,
-0,
-0,
-341,
-0,
-347,
-0,
-0,
-0,
-0,
-0,
-0,
-347,
-354,
-0,
-0,
-0,
-0,
-0,
-0,
-357,
-366,
-0,
-0,
-366,
-0,
-0,
-370,
-0,
-0,
-0,
-371,
-371,
-0,
-0,
-378,
-0,
-0,
-0,
-0,
-378,
-0,
-0,
-0,
-378,
-390,
-0,
-393,
-0,
-0,
-0,
-0,
-0,
-395,
-0,
-0,
-401,
-0,
-0,
-0,
-401,
-0,
-0,
-406,
-0,
-0,
-0,
-411,
-411,
-411,
-0,
-0,
-411,
-0,
-0,
-0,
-422,
-426,
-0,
-0,
-426,
-0,
-0,
-0,
-426,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-434,
-0,
-437,
-443,
-0,
-0,
-446,
-0,
-451,
-0,
-0,
-453,
-0,
-0,
-453,
-459,
-0,
-0,
-459,
-459,
-0,
-0,
-0,
-462,
-462,
-0,
-0,
-0,
-0,
-0,
-469,
-0,
-0,
-0,
-0,
-469,
-0,
-0,
-482,
-483,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-486,
-0,
-0,
-494,
-0,
-0,
-0,
-0,
-494,
-494,
-0,
-0,
-501,
-0,
-0,
-0,
-506,
-506,
-0,
-513,
-0,
-0,
-0,
-0,
-515,
-515,
-0,
-0,
-521,
-0,
-0,
-522,
-0,
-523,
-0,
-523,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-531,
-0,
-0,
-0,
-534,
-546,
-0,
-546,
-546,
-0,
-0,
-550,
-0,
-550,
-0,
-0,
-550,
-0,
-0,
-0,
-0,
-0,
-0,
-558,
-0,
-0,
-0,
-0,
-563,
-0,
-0,
-0,
-570,
-0,
-0,
-570,
-0,
-579,
-0,
-0,
-0,
-0,
-0,
-581,
-587,
-587,
-0,
-0,
-0,
-0,
-0,
-0,
-587,
-587,
-0,
-0,
-597,
-0,
-0,
-0,
-0,
-597,
-0,
-0,
-597,
-0,
-0,
-606,
-611,
-0,
-0,
-614,
-614,
-0,
-0,
-0,
-0,
-618,
-0,
-0,
-618,
-0,
-0,
-0,
-0,
-626,
-0,
-0,
-629,
-0,
-0,
-0,
-630,
-0,
-0,
-0,
-0,
-0,
-0,
-638,
-638,
-638,
-0,
-649,
-0,
-0,
-0,
-651,
-651,
-654,
-0,
-0,
-0,
-0,
-0,
-657,
-657,
-0,
-0,
-658,
-0,
-0,
-0,
-0,
-667,
-0,
-0,
-0,
-667,
-0,
-0,
-0,
-0,
-674,
-0,
-681,
-681,
-0,
-0,
-0,
-686,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-690,
-698,
-0,
-698,
-699,
-0,
-0,
-0,
-0,
-699,
-0,
-0,
-699,
-0,
-0,
-710,
-710,
-0,
-0,
-0,
-0,
-0,
-0,
-710,
-0,
-723,
-0,
-0,
-725,
-0,
-0,
-726,
-731,
-0,
-0,
-0,
-731,
-0,
-0,
-0,
-0,
-731,
-0,
-0,
-0,
-0,
-0,
-0,
-741,
-746,
-0,
-746,
-747,
-0,
-0,
-747,
-0,
-0,
-0,
-0,
-755,
-0,
-0,
-0,
-762,
-0,
-0,
-766,
-0,
-0,
-0,
-0,
-766,
-774,
-0,
-0,
-774,
-0,
-0,
-0,
-0,
-774,
-0,
-0,
-777,
-0,
-0,
-786,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-786,
-0,
-795,
-0,
-801,
-803,
-0,
-0,
-0,
-803,
-803,
-0,
-0,
-809,
-0,
-0,
-0,
-0,
-809,
-0,
-809,
-0,
-0,
-0,
-0,
-819,
-822,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-822,
-0,
-0,
-833,
-0,
-0,
-0,
-833,
-0,
-0,
-0,
-842,
-0,
-0,
-0,
-846,
-0,
-0,
-846,
-851,
-0,
-0,
-854,
-0,
-854,
-0,
-0,
-0,
-0,
-0,
-854,
-854,
-0,
-0,
-866,
-0,
-0,
-0,
-0,
-866,
-866,
-0,
-0,
-873,
-0,
-0,
-874,
-883,
-883,
-0,
-0,
-0,
-0,
-0,
-885,
-891,
-891,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-891,
-0,
-901,
-901,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-902,
-0,
-0,
-906,
-915,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-915,
-926,
-0,
-0,
-926,
-0,
-0,
-930,
-0,
-930,
-0,
-0,
-933,
-0,
-0,
-0,
-938,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-938,
-950,
-0,
-0,
-0,
-0,
-0,
-950,
-955,
-0,
-0,
-0,
-955,
-0,
-0,
-0,
-955,
-966,
-0,
-969,
-0,
-0,
-0,
-0,
-0,
-971,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-977,
-0,
-981,
-987,
-0,
-0,
-987,
-987,
-0,
-0,
-0,
-987,
-0,
-0,
-0,
-0,
-987,
-0,
-1001,
-0,
-0,
-0,
-0,
-0,
-1001,
-0,
-0,
-1001,
-0,
-0,
-1014,
-1014,
-0,
-0,
-1018,
-0,
-0,
-0,
-1019,
-1019,
-0,
-0,
-0,
-1026,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1026,
-0,
-0,
-0,
-1038,
-1038,
-0,
-0,
-0,
-0,
-0,
-0,
-1041,
-1041,
-0,
-1045,
-1045,
-0,
-0,
-1054,
-0,
-1059,
-0,
-0,
-0,
-0,
-0,
-1061,
-1067,
-0,
-0,
-1067,
-1067,
-0,
-0,
-0,
-1067,
-1074,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1077,
-0,
-0,
-1077,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1091,
-1098,
-0,
-0,
-1098,
-0,
-0,
-0,
-1106,
-1110,
-0,
-0,
-1110,
-0,
-0,
-1110,
-1110,
-0,
-0,
-1118,
-0,
-0,
-0,
-0,
-1118,
-0,
-0,
-0,
-1118,
-0,
-0,
-1130,
-0,
-1131,
-0,
-1131,
-0,
-0,
-0,
-0,
-1131,
-0,
-0,
-0,
-1131,
-0,
-0,
-0,
-0,
-1146,
-0,
-1153,
-1155,
-0,
-0,
-0,
-0,
-1155,
-0,
-0,
-1161,
-0,
-0,
-0,
-1161,
-0,
-0,
-1166,
-0,
-0,
-0,
-0,
-0,
-1171,
-0,
-0,
-0,
-0,
-0,
-1171,
-1171,
-1171,
-0,
-0,
-1185,
-0,
-0,
-1185,
-1187,
-1190,
-0,
-0,
-0,
-0,
-0,
-0,
-1190,
-0,
-0,
-1202,
-1203,
-0,
-0,
-0,
-0,
-1206,
-0,
-0,
-1206,
-0,
-0,
-0,
-0,
-0,
-0,
-1214,
-1214,
-0,
-0,
-0,
-1218,
-1226,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1226,
-0,
-0,
-0,
-0,
-0,
-0,
-1226,
-0,
-0,
-0,
-0,
-0,
-0,
-1242,
-1251,
-1251,
-0,
-1253,
-1253,
-0,
-0,
-1253,
-0,
-0,
-0,
-0,
-1259,
-0,
-0,
-1262,
-0,
-1262,
-0,
-1269,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1269,
-0,
-0,
-1269,
-0,
-1283,
-0,
-0,
-1283,
-0,
-0,
-1286,
-1286,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1286,
-1302,
-0,
-0,
-1302,
-0,
-0,
-0,
-0,
-1306,
-0,
-0,
-1306,
-0,
-0,
-0,
-1314,
-0,
-0,
-1314,
-0,
-0,
-0,
-1315,
-1323,
-1326,
-0,
-0,
-1326,
-0,
-0,
-0,
-1326,
-1326,
-0,
-0,
-1326,
-0,
-0,
-0,
-1326,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1342,
-1346,
-0,
-1353,
-0,
-0,
-0,
-1355,
-0,
-1355,
-0,
-0,
-1361,
-0,
-0,
-0,
-0,
-0,
-0,
-1362,
-0,
-0,
-0,
-0,
-0,
-1371,
-0,
-0,
-1371,
-0,
-0,
-1371,
-0,
-1379,
-0,
-0,
-1385,
-0,
-0,
-0,
-1386,
-0,
-0,
-0,
-0,
-0,
-0,
-1386,
-1386,
-0,
-0,
-1386,
-1403,
-0,
-0,
-0,
-1406,
-1410,
-0,
-0,
-0,
-0,
-0,
-1410,
-1410,
-1418,
-0,
-0,
-0,
-0,
-0,
-0,
-1418,
-1418,
-0,
-0,
-1425,
-0,
-0,
-0,
-0,
-0,
-0,
-1430,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1430,
-0,
-0,
-0,
-1446,
-1446,
-0,
-1446,
-0,
-0,
-0,
-1451,
-0,
-1459,
-0,
-0,
-0,
-0,
-0,
-1461,
-1467,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1467,
-// column
-0,
-6,
-11,
-0,
-14,
-18,
-0,
-0,
-21,
-26,
-27,
-0,
-0,
-30,
-0,
-0,
-35,
-38,
-41,
-0,
-42,
-0,
-0,
-0,
-0,
-46,
-53,
-0,
-0,
-54,
-0,
-0,
-59,
-0,
-62,
-0,
-66,
-66,
-0,
-0,
-69,
-74,
-0,
-0,
-0,
-75,
-0,
-0,
-0,
-81,
-83,
-0,
-86,
-90,
-0,
-0,
-0,
-0,
-91,
-0,
-0,
-98,
-0,
-0,
-101,
-102,
-0,
-0,
-107,
-0,
-0,
-0,
-110,
-114,
-117,
-0,
-0,
-0,
-0,
-0,
-118,
-126,
-126,
-0,
-0,
-126,
-0,
-0,
-0,
-131,
-137,
-0,
-0,
-0,
-0,
-0,
-0,
-138,
-147,
-0,
-147,
-150,
-0,
-0,
-150,
-0,
-154,
-0,
-0,
-158,
-0,
-0,
-0,
-161,
-0,
-0,
-165,
-170,
-0,
-0,
-0,
-171,
-171,
-0,
-0,
-174,
-0,
-0,
-181,
-0,
-182,
-0,
-0,
-0,
-0,
-0,
-186,
-194,
-0,
-0,
-0,
-0,
-0,
-0,
-195,
-198,
-203,
-0,
-206,
-206,
-0,
-0,
-0,
-209,
-0,
-0,
-0,
-213,
-0,
-0,
-219,
-0,
-222,
-0,
-222,
-0,
-0,
-0,
-0,
-226,
-233,
-0,
-0,
-234,
-0,
-0,
-0,
-0,
-235,
-0,
-242,
-246,
-0,
-0,
-0,
-246,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-251,
-261,
-0,
-262,
-262,
-0,
-0,
-262,
-0,
-266,
-0,
-0,
-270,
-0,
-0,
-275,
-0,
-0,
-0,
-278,
-0,
-0,
-0,
-0,
-0,
-282,
-0,
-0,
-290,
-0,
-0,
-0,
-293,
-297,
-0,
-0,
-297,
-0,
-0,
-299,
-306,
-307,
-0,
-0,
-0,
-0,
-0,
-0,
-307,
-315,
-0,
-315,
-318,
-0,
-0,
-0,
-0,
-321,
-0,
-0,
-0,
-0,
-0,
-326,
-326,
-0,
-0,
-329,
-338,
-0,
-0,
-0,
-339,
-0,
-0,
-0,
-341,
-0,
-0,
-347,
-0,
-350,
-0,
-0,
-354,
-0,
-0,
-0,
-357,
-0,
-0,
-0,
-0,
-0,
-0,
-361,
-366,
-371,
-0,
-371,
-374,
-0,
-0,
-374,
-0,
-378,
-0,
-0,
-0,
-0,
-0,
-0,
-378,
-389,
-0,
-0,
-0,
-0,
-0,
-0,
-390,
-395,
-0,
-0,
-398,
-0,
-0,
-401,
-0,
-0,
-0,
-406,
-406,
-0,
-0,
-411,
-0,
-0,
-0,
-0,
-411,
-0,
-0,
-0,
-417,
-425,
-0,
-426,
-0,
-0,
-0,
-0,
-0,
-426,
-0,
-0,
-434,
-0,
-0,
-0,
-437,
-0,
-0,
-443,
-0,
-0,
-0,
-446,
-450,
-450,
-0,
-0,
-450,
-0,
-0,
-0,
-453,
-459,
-0,
-0,
-462,
-0,
-0,
-0,
-465,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-469,
-0,
-478,
-482,
-0,
-0,
-483,
-0,
-483,
-0,
-0,
-486,
-0,
-0,
-491,
-494,
-0,
-0,
-494,
-494,
-0,
-0,
-0,
-501,
-501,
-0,
-0,
-0,
-0,
-0,
-506,
-0,
-0,
-0,
-0,
-510,
-0,
-0,
-515,
-522,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-523,
-0,
-0,
-531,
-0,
-0,
-0,
-0,
-534,
-534,
-0,
-0,
-542,
-0,
-0,
-0,
-545,
-549,
-0,
-549,
-0,
-0,
-0,
-0,
-550,
-555,
-0,
-0,
-558,
-0,
-0,
-563,
-0,
-566,
-0,
-566,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-570,
-0,
-0,
-0,
-579,
-585,
-0,
-586,
-586,
-0,
-0,
-587,
-0,
-587,
-0,
-0,
-594,
-0,
-0,
-0,
-0,
-0,
-0,
-597,
-0,
-0,
-0,
-0,
-606,
-0,
-0,
-0,
-611,
-0,
-0,
-613,
-0,
-614,
-0,
-0,
-0,
-0,
-0,
-618,
-626,
-629,
-0,
-0,
-0,
-0,
-0,
-0,
-630,
-630,
-0,
-0,
-638,
-0,
-0,
-0,
-0,
-641,
-0,
-0,
-642,
-0,
-0,
-651,
-654,
-0,
-0,
-654,
-658,
-0,
-0,
-0,
-0,
-658,
-0,
-0,
-662,
-0,
-0,
-0,
-0,
-667,
-0,
-0,
-674,
-0,
-0,
-0,
-677,
-0,
-0,
-0,
-0,
-0,
-0,
-681,
-681,
-681,
-0,
-690,
-0,
-0,
-0,
-690,
-698,
-699,
-0,
-0,
-0,
-0,
-0,
-699,
-702,
-0,
-0,
-707,
-0,
-0,
-0,
-0,
-710,
-0,
-0,
-0,
-713,
-0,
-0,
-0,
-0,
-721,
-0,
-726,
-726,
-0,
-0,
-0,
-726,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-731,
-741,
-0,
-741,
-746,
-0,
-0,
-0,
-0,
-747,
-0,
-0,
-747,
-0,
-0,
-755,
-758,
-0,
-0,
-0,
-0,
-0,
-0,
-758,
-0,
-762,
-0,
-0,
-770,
-0,
-0,
-773,
-774,
-0,
-0,
-0,
-777,
-0,
-0,
-0,
-0,
-779,
-0,
-0,
-0,
-0,
-0,
-0,
-786,
-795,
-0,
-795,
-798,
-0,
-0,
-798,
-0,
-0,
-0,
-0,
-802,
-0,
-0,
-0,
-803,
-0,
-0,
-811,
-0,
-0,
-0,
-0,
-811,
-821,
-0,
-0,
-822,
-0,
-0,
-0,
-0,
-822,
-0,
-0,
-830,
-0,
-0,
-833,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-834,
-0,
-846,
-0,
-846,
-846,
-0,
-0,
-0,
-851,
-851,
-0,
-0,
-854,
-0,
-0,
-0,
-0,
-854,
-0,
-858,
-0,
-0,
-0,
-0,
-866,
-873,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-874,
-0,
-0,
-882,
-0,
-0,
-0,
-885,
-0,
-0,
-0,
-885,
-0,
-0,
-0,
-891,
-0,
-0,
-899,
-902,
-0,
-0,
-902,
-0,
-906,
-0,
-0,
-0,
-0,
-0,
-906,
-906,
-0,
-0,
-915,
-0,
-0,
-0,
-0,
-915,
-923,
-0,
-0,
-926,
-0,
-0,
-929,
-929,
-933,
-0,
-0,
-0,
-0,
-0,
-933,
-938,
-938,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-942,
-0,
-950,
-954,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-955,
-0,
-0,
-963,
-966,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-966,
-971,
-0,
-0,
-971,
-0,
-0,
-981,
-0,
-982,
-0,
-0,
-986,
-0,
-0,
-0,
-987,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-987,
-1001,
-0,
-0,
-0,
-0,
-0,
-1001,
-1010,
-0,
-0,
-0,
-1011,
-0,
-0,
-0,
-1011,
-1019,
-0,
-1019,
-0,
-0,
-0,
-0,
-0,
-1022,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1026,
-0,
-1038,
-1038,
-0,
-0,
-1041,
-1041,
-0,
-0,
-0,
-1045,
-0,
-0,
-0,
-0,
-1045,
-0,
-1054,
-0,
-0,
-0,
-0,
-0,
-1054,
-0,
-0,
-1062,
-0,
-0,
-1067,
-1070,
-0,
-0,
-1070,
-0,
-0,
-0,
-1074,
-1074,
-0,
-0,
-0,
-1077,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1083,
-0,
-0,
-0,
-1091,
-1097,
-0,
-0,
-0,
-0,
-0,
-0,
-1098,
-1098,
-0,
-1106,
-1106,
-0,
-0,
-1109,
-0,
-1109,
-0,
-0,
-0,
-0,
-0,
-1110,
-1118,
-0,
-0,
-1118,
-1126,
-0,
-0,
-0,
-1126,
-1131,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1131,
-0,
-0,
-1139,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1146,
-1157,
-0,
-0,
-1158,
-0,
-0,
-0,
-1158,
-1161,
-0,
-0,
-1166,
-0,
-0,
-1169,
-1169,
-0,
-0,
-1171,
-0,
-0,
-0,
-0,
-1171,
-0,
-0,
-0,
-1173,
-0,
-0,
-1187,
-0,
-1190,
-0,
-1190,
-0,
-0,
-0,
-0,
-1194,
-0,
-0,
-0,
-1194,
-0,
-0,
-0,
-0,
-1203,
-0,
-1203,
-1206,
-0,
-0,
-0,
-0,
-1211,
-0,
-0,
-1218,
-0,
-0,
-0,
-1221,
-0,
-0,
-1225,
-0,
-0,
-0,
-0,
-0,
-1226,
-0,
-0,
-0,
-0,
-0,
-1234,
-1238,
-1238,
-0,
-0,
-1242,
-0,
-0,
-1242,
-1250,
-1251,
-0,
-0,
-0,
-0,
-0,
-0,
-1251,
-0,
-0,
-1259,
-1262,
-0,
-0,
-0,
-0,
-1262,
-0,
-0,
-1262,
-0,
-0,
-0,
-0,
-0,
-0,
-1269,
-1278,
-0,
-0,
-0,
-1281,
-1283,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1286,
-0,
-0,
-0,
-0,
-0,
-0,
-1290,
-0,
-0,
-0,
-0,
-0,
-0,
-1301,
-1302,
-1307,
-0,
-1307,
-1314,
-0,
-0,
-1315,
-0,
-0,
-0,
-0,
-1315,
-0,
-0,
-1323,
-0,
-1326,
-0,
-1326,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1326,
-0,
-0,
-1333,
-0,
-1342,
-0,
-0,
-1346,
-0,
-0,
-1349,
-1349,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1353,
-1355,
-0,
-0,
-1362,
-0,
-0,
-0,
-0,
-1362,
-0,
-0,
-1370,
-0,
-0,
-0,
-1371,
-0,
-0,
-1379,
-0,
-0,
-0,
-1382,
-1386,
-1386,
-0,
-0,
-1386,
-0,
-0,
-0,
-1386,
-1395,
-0,
-0,
-1395,
-0,
-0,
-0,
-1397,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1403,
-1413,
-0,
-1414,
-0,
-0,
-0,
-1414,
-0,
-1418,
-0,
-0,
-1422,
-0,
-0,
-0,
-0,
-0,
-0,
-1425,
-0,
-0,
-0,
-0,
-0,
-1430,
-0,
-0,
-1434,
-0,
-0,
-1441,
-0,
-1446,
-0,
-0,
-1446,
-0,
-0,
-0,
-1451,
-0,
-0,
-0,
-0,
-0,
-0,
-1451,
-1451,
-0,
-0,
-1451,
-1466,
-0,
-0,
-0,
-1466,
-1467,
-0,
-0,
-0,
-0,
-0,
-1470,
-1470,
-1481,
-0,
-0,
-0,
-0,
-0,
-0,
-1482,
-1482,
-0,
-0,
-1490,
-0,
-0,
-0,
-0,
-0,
-0,
-1493,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1494,
-0,
-0,
-0,
-1509,
-1515,
-0,
-1515,
-0,
-0,
-0,
-1518,
-0,
-1522,
-0,
-0,
-0,
-0,
-0,
-1522,
-1526,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1531,
-// column
-0,
-11,
-18,
-0,
-21,
-27,
-0,
-0,
-30,
-35,
-38,
-0,
-0,
-41,
-0,
-0,
-46,
-51,
-54,
-0,
-54,
-0,
-0,
-0,
-0,
-59,
-66,
-0,
-0,
-69,
-0,
-0,
-74,
-0,
-75,
-0,
-81,
-83,
-0,
-0,
-86,
-91,
-0,
-0,
-0,
-91,
-0,
-0,
-0,
-98,
-102,
-0,
-105,
-107,
-0,
-0,
-0,
-0,
-110,
-0,
-0,
-117,
-0,
-0,
-118,
-123,
-0,
-0,
-126,
-0,
-0,
-0,
-131,
-131,
-138,
-0,
-0,
-0,
-0,
-0,
-138,
-147,
-147,
-0,
-0,
-149,
-0,
-0,
-0,
-154,
-158,
-0,
-0,
-0,
-0,
-0,
-0,
-161,
-170,
-0,
-170,
-171,
-0,
-0,
-174,
-0,
-179,
-0,
-0,
-181,
-0,
-0,
-0,
-186,
-0,
-0,
-186,
-195,
-0,
-0,
-0,
-195,
-198,
-0,
-0,
-201,
-0,
-0,
-206,
-0,
-206,
-0,
-0,
-0,
-0,
-0,
-213,
-219,
-0,
-0,
-0,
-0,
-0,
-0,
-222,
-227,
-230,
-0,
-233,
-235,
-0,
-0,
-0,
-235,
-0,
-0,
-0,
-242,
-0,
-0,
-246,
-0,
-251,
-0,
-251,
-0,
-0,
-0,
-0,
-251,
-262,
-0,
-0,
-262,
-0,
-0,
-0,
-0,
-266,
-0,
-273,
-275,
-0,
-0,
-0,
-275,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-282,
-290,
-0,
-293,
-293,
-0,
-0,
-294,
-0,
-299,
-0,
-0,
-299,
-0,
-0,
-306,
-0,
-0,
-0,
-307,
-0,
-0,
-0,
-0,
-0,
-315,
-0,
-0,
-321,
-0,
-0,
-0,
-326,
-326,
-0,
-0,
-329,
-0,
-0,
-334,
-339,
-339,
-0,
-0,
-0,
-0,
-0,
-0,
-341,
-350,
-0,
-350,
-350,
-0,
-0,
-0,
-0,
-354,
-0,
-0,
-0,
-0,
-0,
-361,
-363,
-0,
-0,
-366,
-371,
-0,
-0,
-0,
-374,
-0,
-0,
-0,
-378,
-0,
-0,
-378,
-0,
-387,
-0,
-0,
-389,
-0,
-0,
-0,
-390,
-0,
-0,
-0,
-0,
-0,
-0,
-398,
-398,
-406,
-0,
-406,
-411,
-0,
-0,
-411,
-0,
-411,
-0,
-0,
-0,
-0,
-0,
-0,
-417,
-426,
-0,
-0,
-0,
-0,
-0,
-0,
-426,
-426,
-0,
-0,
-437,
-0,
-0,
-437,
-0,
-0,
-0,
-443,
-443,
-0,
-0,
-450,
-0,
-0,
-0,
-0,
-451,
-0,
-0,
-0,
-458,
-462,
-0,
-465,
-0,
-0,
-0,
-0,
-0,
-467,
-0,
-0,
-469,
-0,
-0,
-0,
-478,
-0,
-0,
-482,
-0,
-0,
-0,
-483,
-491,
-491,
-0,
-0,
-491,
-0,
-0,
-0,
-494,
-494,
-0,
-0,
-501,
-0,
-0,
-0,
-506,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-510,
-0,
-521,
-523,
-0,
-0,
-523,
-0,
-523,
-0,
-0,
-523,
-0,
-0,
-534,
-534,
-0,
-0,
-534,
-539,
-0,
-0,
-0,
-542,
-546,
-0,
-0,
-0,
-0,
-0,
-549,
-0,
-0,
-0,
-0,
-555,
-0,
-0,
-555,
-563,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-566,
-0,
-0,
-570,
-0,
-0,
-0,
-0,
-579,
-579,
-0,
-0,
-585,
-0,
-0,
-0,
-586,
-594,
-0,
-594,
-0,
-0,
-0,
-0,
-594,
-602,
-0,
-0,
-602,
-0,
-0,
-606,
-0,
-611,
-0,
-613,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-613,
-0,
-0,
-0,
-626,
-630,
-0,
-630,
-630,
-0,
-0,
-630,
-0,
-635,
-0,
-0,
-641,
-0,
-0,
-0,
-0,
-0,
-0,
-642,
-0,
-0,
-0,
-0,
-651,
-0,
-0,
-0,
-658,
-0,
-0,
-662,
-0,
-662,
-0,
-0,
-0,
-0,
-0,
-662,
-675,
-675,
-0,
-0,
-0,
-0,
-0,
-0,
-677,
-678,
-0,
-0,
-681,
-0,
-0,
-0,
-0,
-690,
-0,
-0,
-693,
-0,
-0,
-698,
-699,
-0,
-0,
-702,
-707,
-0,
-0,
-0,
-0,
-707,
-0,
-0,
-713,
-0,
-0,
-0,
-0,
-713,
-0,
-0,
-721,
-0,
-0,
-0,
-726,
-0,
-0,
-0,
-0,
-0,
-0,
-726,
-731,
-734,
-0,
-741,
-0,
-0,
-0,
-741,
-747,
-747,
-0,
-0,
-0,
-0,
-0,
-747,
-755,
-0,
-0,
-758,
-0,
-0,
-0,
-0,
-758,
-0,
-0,
-0,
-766,
-0,
-0,
-0,
-0,
-770,
-0,
-777,
-779,
-0,
-0,
-0,
-779,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-779,
-794,
-0,
-794,
-795,
-0,
-0,
-0,
-0,
-798,
-0,
-0,
-801,
-0,
-0,
-802,
-811,
-0,
-0,
-0,
-0,
-0,
-0,
-811,
-0,
-811,
-0,
-0,
-821,
-0,
-0,
-822,
-822,
-0,
-0,
-0,
-830,
-0,
-0,
-0,
-0,
-834,
-0,
-0,
-0,
-0,
-0,
-0,
-834,
-846,
-0,
-849,
-851,
-0,
-0,
-851,
-0,
-0,
-0,
-0,
-851,
-0,
-0,
-0,
-858,
-0,
-0,
-866,
-0,
-0,
-0,
-0,
-867,
-874,
-0,
-0,
-874,
-0,
-0,
-0,
-0,
-878,
-0,
-0,
-885,
-0,
-0,
-885,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-891,
-0,
-899,
-0,
-899,
-899,
-0,
-0,
-0,
-906,
-906,
-0,
-0,
-906,
-0,
-0,
-0,
-0,
-910,
-0,
-917,
-0,
-0,
-0,
-0,
-923,
-926,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-929,
-0,
-0,
-937,
-0,
-0,
-0,
-942,
-0,
-0,
-0,
-942,
-0,
-0,
-0,
-950,
-0,
-0,
-954,
-955,
-0,
-0,
-955,
-0,
-963,
-0,
-0,
-0,
-0,
-0,
-965,
-965,
-0,
-0,
-966,
-0,
-0,
-0,
-0,
-971,
-982,
-0,
-0,
-982,
-0,
-0,
-986,
-987,
-987,
-0,
-0,
-0,
-0,
-0,
-987,
-987,
-998,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1001,
-0,
-1001,
-1011,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1011,
-0,
-0,
-1022,
-1022,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1026,
-1026,
-0,
-0,
-1029,
-0,
-0,
-1038,
-0,
-1043,
-0,
-0,
-1045,
-0,
-0,
-0,
-1045,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1050,
-1062,
-0,
-0,
-0,
-0,
-0,
-1062,
-1067,
-0,
-0,
-0,
-1070,
-0,
-0,
-0,
-1074,
-1074,
-0,
-1074,
-0,
-0,
-0,
-0,
-0,
-1083,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1089,
-0,
-1097,
-1097,
-0,
-0,
-1098,
-1099,
-0,
-0,
-0,
-1106,
-0,
-0,
-0,
-0,
-1106,
-0,
-1109,
-0,
-0,
-0,
-0,
-0,
-1115,
-0,
-0,
-1125,
-0,
-0,
-1126,
-1131,
-0,
-0,
-1131,
-0,
-0,
-0,
-1131,
-1139,
-0,
-0,
-0,
-1139,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1146,
-0,
-0,
-0,
-1154,
-1158,
-0,
-0,
-0,
-0,
-0,
-0,
-1158,
-1158,
-0,
-1169,
-1171,
-0,
-0,
-1171,
-0,
-1171,
-0,
-0,
-0,
-0,
-0,
-1173,
-1173,
-0,
-0,
-1182,
-1187,
-0,
-0,
-0,
-1190,
-1194,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1194,
-0,
-0,
-1206,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1211,
-1218,
-0,
-0,
-1221,
-0,
-0,
-0,
-1221,
-1221,
-0,
-0,
-1225,
-0,
-0,
-1234,
-1234,
-0,
-0,
-1238,
-0,
-0,
-0,
-0,
-1238,
-0,
-0,
-0,
-1242,
-0,
-0,
-1250,
-0,
-1251,
-0,
-1257,
-0,
-0,
-0,
-0,
-1259,
-0,
-0,
-0,
-1262,
-0,
-0,
-0,
-0,
-1262,
-0,
-1262,
-1275,
-0,
-0,
-0,
-0,
-1278,
-0,
-0,
-1281,
-0,
-0,
-0,
-1286,
-0,
-0,
-1290,
-0,
-0,
-0,
-0,
-0,
-1290,
-0,
-0,
-0,
-0,
-0,
-1301,
-1307,
-1307,
-0,
-0,
-1307,
-0,
-0,
-1307,
-1315,
-1315,
-0,
-0,
-0,
-0,
-0,
-0,
-1315,
-0,
-0,
-1326,
-1326,
-0,
-0,
-0,
-0,
-1326,
-0,
-0,
-1333,
-0,
-0,
-0,
-0,
-0,
-0,
-1333,
-1347,
-0,
-0,
-0,
-1347,
-1347,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1353,
-0,
-0,
-0,
-0,
-0,
-0,
-1361,
-0,
-0,
-0,
-0,
-0,
-0,
-1370,
-1370,
-1378,
-0,
-1378,
-1379,
-0,
-0,
-1382,
-0,
-0,
-0,
-0,
-1382,
-0,
-0,
-1386,
-0,
-1395,
-0,
-1397,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1397,
-0,
-0,
-1406,
-0,
-1406,
-0,
-0,
-1413,
-0,
-0,
-1418,
-1419,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1422,
-1422,
-0,
-0,
-1425,
-0,
-0,
-0,
-0,
-1434,
-0,
-0,
-1441,
-0,
-0,
-0,
-1441,
-0,
-0,
-1446,
-0,
-0,
-0,
-1451,
-1451,
-1451,
-0,
-0,
-1451,
-0,
-0,
-0,
-1454,
-1466,
-0,
-0,
-1466,
-0,
-0,
-0,
-1470,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1470,
-1482,
-0,
-1482,
-0,
-0,
-0,
-1482,
-0,
-1491,
-0,
-0,
-1493,
-0,
-0,
-0,
-0,
-0,
-0,
-1494,
-0,
-0,
-0,
-0,
-0,
-1494,
-0,
-0,
-1509,
-0,
-0,
-1514,
-0,
-1515,
-0,
-0,
-1515,
-0,
-0,
-0,
-1522,
-0,
-0,
-0,
-0,
-0,
-0,
-1526,
-1526,
-0,
-0,
-1526,
-1539,
-0,
-0,
-0,
-1539,
-1539,
-0,
-0,
-0,
-0,
-0,
-1545,
-1547,
-1550,
-0,
-0,
-0,
-0,
-0,
-0,
-1553,
-1558,
-0,
-0,
-1558,
-0,
-0,
-0,
-0,
-0,
-0,
-1566,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1571,
-0,
-0,
-0,
-1574,
-1586,
-0,
-1589,
-0,
-0,
-0,
-1589,
-0,
-1595,
-0,
-0,
-0,
-0,
-0,
-1595,
-1603,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1603,
-// column
-0,
-14,
-21,
-0,
-26,
-30,
-0,
-0,
-35,
-42,
-42,
-0,
-0,
-46,
-0,
-0,
-53,
-54,
-59,
-0,
-62,
-0,
-0,
-0,
-0,
-66,
-75,
-0,
-0,
-75,
-0,
-0,
-81,
-0,
-86,
-0,
-90,
-90,
-0,
-0,
-91,
-98,
-0,
-0,
-0,
-101,
-0,
-0,
-0,
-107,
-107,
-0,
-114,
-118,
-0,
-0,
-0,
-0,
-118,
-0,
-0,
-126,
-0,
-0,
-131,
-131,
-0,
-0,
-137,
-0,
-0,
-0,
-138,
-146,
-147,
-0,
-0,
-0,
-0,
-0,
-150,
-158,
-158,
-0,
-0,
-158,
-0,
-0,
-0,
-165,
-171,
-0,
-0,
-0,
-0,
-0,
-0,
-171,
-181,
-0,
-182,
-186,
-0,
-0,
-186,
-0,
-186,
-0,
-0,
-194,
-0,
-0,
-0,
-195,
-0,
-0,
-203,
-206,
-0,
-0,
-0,
-209,
-209,
-0,
-0,
-209,
-0,
-0,
-219,
-0,
-222,
-0,
-0,
-0,
-0,
-0,
-226,
-234,
-0,
-0,
-0,
-0,
-0,
-0,
-234,
-234,
-245,
-0,
-246,
-246,
-0,
-0,
-0,
-251,
-0,
-0,
-0,
-251,
-0,
-0,
-261,
-0,
-262,
-0,
-266,
-0,
-0,
-0,
-0,
-270,
-275,
-0,
-0,
-278,
-0,
-0,
-0,
-0,
-278,
-0,
-282,
-290,
-0,
-0,
-0,
-291,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-297,
-307,
-0,
-307,
-307,
-0,
-0,
-307,
-0,
-314,
-0,
-0,
-318,
-0,
-0,
-321,
-0,
-0,
-0,
-326,
-0,
-0,
-0,
-0,
-0,
-326,
-0,
-0,
-338,
-0,
-0,
-0,
-341,
-347,
-0,
-0,
-347,
-0,
-0,
-347,
-354,
-357,
-0,
-0,
-0,
-0,
-0,
-0,
-357,
-361,
-0,
-366,
-370,
-0,
-0,
-0,
-0,
-371,
-0,
-0,
-0,
-0,
-0,
-378,
-378,
-0,
-0,
-378,
-390,
-0,
-0,
-0,
-390,
-0,
-0,
-0,
-395,
-0,
-0,
-401,
-0,
-401,
-0,
-0,
-406,
-0,
-0,
-0,
-411,
-0,
-0,
-0,
-0,
-0,
-0,
-411,
-422,
-425,
-0,
-426,
-426,
-0,
-0,
-426,
-0,
-434,
-0,
-0,
-0,
-0,
-0,
-0,
-434,
-443,
-0,
-0,
-0,
-0,
-0,
-0,
-446,
-453,
-0,
-0,
-453,
-0,
-0,
-459,
-0,
-0,
-0,
-462,
-462,
-0,
-0,
-469,
-0,
-0,
-0,
-0,
-469,
-0,
-0,
-0,
-469,
-483,
-0,
-483,
-0,
-0,
-0,
-0,
-0,
-486,
-0,
-0,
-494,
-0,
-0,
-0,
-494,
-0,
-0,
-501,
-0,
-0,
-0,
-506,
-506,
-506,
-0,
-0,
-506,
-0,
-0,
-0,
-515,
-521,
-0,
-0,
-522,
-0,
-0,
-0,
-523,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-531,
-0,
-534,
-542,
-0,
-0,
-545,
-0,
-546,
-0,
-0,
-550,
-0,
-0,
-550,
-558,
-0,
-0,
-558,
-558,
-0,
-0,
-0,
-563,
-563,
-0,
-0,
-0,
-0,
-0,
-570,
-0,
-0,
-0,
-0,
-570,
-0,
-0,
-581,
-586,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-587,
-0,
-0,
-597,
-0,
-0,
-0,
-0,
-597,
-597,
-0,
-0,
-606,
-0,
-0,
-0,
-611,
-611,
-0,
-614,
-0,
-0,
-0,
-0,
-618,
-618,
-0,
-0,
-626,
-0,
-0,
-629,
-0,
-630,
-0,
-630,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-638,
-0,
-0,
-0,
-641,
-651,
-0,
-654,
-654,
-0,
-0,
-657,
-0,
-657,
-0,
-0,
-658,
-0,
-0,
-0,
-0,
-0,
-0,
-667,
-0,
-0,
-0,
-0,
-674,
-0,
-0,
-0,
-681,
-0,
-0,
-681,
-0,
-686,
-0,
-0,
-0,
-0,
-0,
-690,
-698,
-699,
-0,
-0,
-0,
-0,
-0,
-0,
-699,
-699,
-0,
-0,
-710,
-0,
-0,
-0,
-0,
-710,
-0,
-0,
-710,
-0,
-0,
-721,
-726,
-0,
-0,
-726,
-726,
-0,
-0,
-0,
-0,
-731,
-0,
-0,
-731,
-0,
-0,
-0,
-0,
-741,
-0,
-0,
-746,
-0,
-0,
-0,
-747,
-0,
-0,
-0,
-0,
-0,
-0,
-755,
-755,
-755,
-0,
-762,
-0,
-0,
-0,
-766,
-770,
-773,
-0,
-0,
-0,
-0,
-0,
-774,
-774,
-0,
-0,
-777,
-0,
-0,
-0,
-0,
-786,
-0,
-0,
-0,
-786,
-0,
-0,
-0,
-0,
-795,
-0,
-802,
-802,
-0,
-0,
-0,
-803,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-809,
-819,
-0,
-819,
-822,
-0,
-0,
-0,
-0,
-822,
-0,
-0,
-822,
-0,
-0,
-833,
-833,
-0,
-0,
-0,
-0,
-0,
-0,
-833,
-0,
-842,
-0,
-0,
-846,
-0,
-0,
-851,
-854,
-0,
-0,
-0,
-854,
-0,
-0,
-0,
-0,
-854,
-0,
-0,
-0,
-0,
-0,
-0,
-866,
-873,
-0,
-873,
-874,
-0,
-0,
-874,
-0,
-0,
-0,
-0,
-882,
-0,
-0,
-0,
-885,
-0,
-0,
-891,
-0,
-0,
-0,
-0,
-891,
-901,
-0,
-0,
-902,
-0,
-0,
-0,
-0,
-902,
-0,
-0,
-906,
-0,
-0,
-915,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-915,
-0,
-926,
-0,
-926,
-930,
-0,
-0,
-0,
-933,
-933,
-0,
-0,
-938,
-0,
-0,
-0,
-0,
-938,
-0,
-938,
-0,
-0,
-0,
-0,
-950,
-955,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-955,
-0,
-0,
-966,
-0,
-0,
-0,
-966,
-0,
-0,
-0,
-971,
-0,
-0,
-0,
-977,
-0,
-0,
-981,
-986,
-0,
-0,
-987,
-0,
-987,
-0,
-0,
-0,
-0,
-0,
-987,
-987,
-0,
-0,
-1001,
-0,
-0,
-0,
-0,
-1001,
-1001,
-0,
-0,
-1010,
-0,
-0,
-1011,
-1014,
-1019,
-0,
-0,
-0,
-0,
-0,
-1019,
-1026,
-1026,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1026,
-0,
-1038,
-1038,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1041,
-0,
-0,
-1045,
-1054,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1054,
-1061,
-0,
-0,
-1061,
-0,
-0,
-1067,
-0,
-1067,
-0,
-0,
-1074,
-0,
-0,
-0,
-1077,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1077,
-1091,
-0,
-0,
-0,
-0,
-0,
-1091,
-1098,
-0,
-0,
-0,
-1098,
-0,
-0,
-0,
-1098,
-1109,
-0,
-1109,
-0,
-0,
-0,
-0,
-0,
-1110,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1118,
-0,
-1126,
-1130,
-0,
-0,
-1131,
-1131,
-0,
-0,
-0,
-1131,
-0,
-0,
-0,
-0,
-1131,
-0,
-1146,
-0,
-0,
-0,
-0,
-0,
-1146,
-0,
-0,
-1146,
-0,
-0,
-1157,
-1158,
-0,
-0,
-1161,
-0,
-0,
-0,
-1166,
-1166,
-0,
-0,
-0,
-1171,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1171,
-0,
-0,
-0,
-1185,
-1187,
-0,
-0,
-0,
-0,
-0,
-0,
-1190,
-1190,
-0,
-1194,
-1194,
-0,
-0,
-1203,
-0,
-1203,
-0,
-0,
-0,
-0,
-0,
-1206,
-1214,
-0,
-0,
-1214,
-1218,
-0,
-0,
-0,
-1218,
-1225,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1226,
-0,
-0,
-1226,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1242,
-1251,
-0,
-0,
-1251,
-0,
-0,
-0,
-1253,
-1259,
-0,
-0,
-1262,
-0,
-0,
-1262,
-1262,
-0,
-0,
-1269,
-0,
-0,
-0,
-0,
-1269,
-0,
-0,
-0,
-1269,
-0,
-0,
-1283,
-0,
-1286,
-0,
-1286,
-0,
-0,
-0,
-0,
-1286,
-0,
-0,
-0,
-1286,
-0,
-0,
-0,
-0,
-1301,
-0,
-1302,
-1306,
-0,
-0,
-0,
-0,
-1306,
-0,
-0,
-1314,
-0,
-0,
-0,
-1315,
-0,
-0,
-1323,
-0,
-0,
-0,
-0,
-0,
-1326,
-0,
-0,
-0,
-0,
-0,
-1326,
-1326,
-1326,
-0,
-0,
-1342,
-0,
-0,
-1342,
-1346,
-1349,
-0,
-0,
-0,
-0,
-0,
-0,
-1349,
-0,
-0,
-1355,
-1362,
-0,
-0,
-0,
-0,
-1362,
-0,
-0,
-1362,
-0,
-0,
-0,
-0,
-0,
-0,
-1371,
-1371,
-0,
-0,
-0,
-1379,
-1385,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1386,
-0,
-0,
-0,
-0,
-0,
-0,
-1386,
-0,
-0,
-0,
-0,
-0,
-0,
-1403,
-1406,
-1406,
-0,
-1410,
-1414,
-0,
-0,
-1414,
-0,
-0,
-0,
-0,
-1418,
-0,
-0,
-1425,
-0,
-1425,
-0,
-1430,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1430,
-0,
-0,
-1430,
-0,
-1446,
-0,
-0,
-1446,
-0,
-0,
-1451,
-1451,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1451,
-1461,
-0,
-0,
-1466,
-0,
-0,
-0,
-0,
-1467,
-0,
-0,
-1467,
-0,
-0,
-0,
-1477,
-0,
-0,
-1481,
-0,
-0,
-0,
-1482,
-1490,
-1491,
-0,
-0,
-1491,
-0,
-0,
-0,
-1491,
-1493,
-0,
-0,
-1493,
-0,
-0,
-0,
-1493,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1509,
-1515,
-0,
-1518,
-0,
-0,
-0,
-1518,
-0,
-1518,
-0,
-0,
-1526,
-0,
-0,
-0,
-0,
-0,
-0,
-1531,
-0,
-0,
-0,
-0,
-0,
-1538,
-0,
-0,
-1538,
-0,
-0,
-1539,
-0,
-1550,
-0,
-0,
-1554,
-0,
-0,
-0,
-1557,
-0,
-0,
-0,
-0,
-0,
-0,
-1557,
-1557,
-0,
-0,
-1557,
-1574,
-0,
-0,
-0,
-1574,
-1577,
-0,
-0,
-0,
-0,
-0,
-1577,
-1577,
-1587,
-0,
-0,
-0,
-0,
-0,
-0,
-1587,
-1587,
-0,
-0,
-1598,
-0,
-0,
-0,
-0,
-0,
-0,
-1601,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1601,
-0,
-0,
-0,
-1619,
-1621,
-0,
-1621,
-0,
-0,
-0,
-1626,
-0,
-1626,
-0,
-0,
-0,
-0,
-0,
-1630,
-1638,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1641,
-// column
-0,
-18,
-27,
-0,
-30,
-38,
-0,
-0,
-41,
-46,
-51,
-0,
-0,
-54,
-0,
-0,
-59,
-66,
-69,
-0,
-69,
-0,
-0,
-0,
-0,
-74,
-83,
-0,
-0,
-86,
-0,
-0,
-91,
-0,
-91,
-0,
-98,
-102,
-0,
-0,
-105,
-110,
-0,
-0,
-0,
-110,
-0,
-0,
-0,
-117,
-123,
-0,
-126,
-126,
-0,
-0,
-0,
-0,
-131,
-0,
-0,
-138,
-0,
-0,
-138,
-146,
-0,
-0,
-149,
-0,
-0,
-0,
-154,
-154,
-161,
-0,
-0,
-0,
-0,
-0,
-161,
-170,
-171,
-0,
-0,
-174,
-0,
-0,
-0,
-179,
-181,
-0,
-0,
-0,
-0,
-0,
-0,
-186,
-195,
-0,
-195,
-198,
-0,
-0,
-201,
-0,
-206,
-0,
-0,
-206,
-0,
-0,
-0,
-213,
-0,
-0,
-213,
-222,
-0,
-0,
-0,
-222,
-227,
-0,
-0,
-230,
-0,
-0,
-235,
-0,
-235,
-0,
-0,
-0,
-0,
-0,
-242,
-246,
-0,
-0,
-0,
-0,
-0,
-0,
-251,
-258,
-261,
-0,
-262,
-266,
-0,
-0,
-0,
-266,
-0,
-0,
-0,
-273,
-0,
-0,
-275,
-0,
-282,
-0,
-282,
-0,
-0,
-0,
-0,
-282,
-293,
-0,
-0,
-294,
-0,
-0,
-0,
-0,
-299,
-0,
-306,
-306,
-0,
-0,
-0,
-306,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-315,
-321,
-0,
-326,
-326,
-0,
-0,
-329,
-0,
-334,
-0,
-0,
-334,
-0,
-0,
-341,
-0,
-0,
-0,
-341,
-0,
-0,
-0,
-0,
-0,
-350,
-0,
-0,
-354,
-0,
-0,
-0,
-361,
-363,
-0,
-0,
-366,
-0,
-0,
-371,
-374,
-374,
-0,
-0,
-0,
-0,
-0,
-0,
-378,
-387,
-0,
-387,
-387,
-0,
-0,
-0,
-0,
-389,
-0,
-0,
-0,
-0,
-0,
-398,
-402,
-0,
-0,
-405,
-410,
-0,
-0,
-0,
-411,
-0,
-0,
-0,
-417,
-0,
-0,
-417,
-0,
-426,
-0,
-0,
-426,
-0,
-0,
-0,
-426,
-0,
-0,
-0,
-0,
-0,
-0,
-437,
-437,
-443,
-0,
-446,
-450,
-0,
-0,
-451,
-0,
-451,
-0,
-0,
-0,
-0,
-0,
-0,
-458,
-467,
-0,
-0,
-0,
-0,
-0,
-0,
-467,
-467,
-0,
-0,
-478,
-0,
-0,
-478,
-0,
-0,
-0,
-482,
-486,
-0,
-0,
-491,
-0,
-0,
-0,
-0,
-494,
-0,
-0,
-0,
-501,
-501,
-0,
-506,
-0,
-0,
-0,
-0,
-0,
-510,
-0,
-0,
-510,
-0,
-0,
-0,
-521,
-0,
-0,
-523,
-0,
-0,
-0,
-523,
-534,
-534,
-0,
-0,
-534,
-0,
-0,
-0,
-539,
-539,
-0,
-0,
-546,
-0,
-0,
-0,
-549,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-555,
-0,
-566,
-566,
-0,
-0,
-566,
-0,
-566,
-0,
-0,
-566,
-0,
-0,
-579,
-579,
-0,
-0,
-581,
-586,
-0,
-0,
-0,
-586,
-593,
-0,
-0,
-0,
-0,
-0,
-594,
-0,
-0,
-0,
-0,
-602,
-0,
-0,
-602,
-606,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-613,
-0,
-0,
-613,
-0,
-0,
-0,
-0,
-626,
-627,
-0,
-0,
-630,
-0,
-0,
-0,
-635,
-641,
-0,
-642,
-0,
-0,
-0,
-0,
-642,
-651,
-0,
-0,
-651,
-0,
-0,
-651,
-0,
-658,
-0,
-662,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-662,
-0,
-0,
-0,
-675,
-677,
-0,
-677,
-678,
-0,
-0,
-681,
-0,
-686,
-0,
-0,
-690,
-0,
-0,
-0,
-0,
-0,
-0,
-693,
-0,
-0,
-0,
-0,
-702,
-0,
-0,
-0,
-707,
-0,
-0,
-713,
-0,
-713,
-0,
-0,
-0,
-0,
-0,
-713,
-726,
-726,
-0,
-0,
-0,
-0,
-0,
-0,
-726,
-731,
-0,
-0,
-734,
-0,
-0,
-0,
-0,
-741,
-0,
-0,
-746,
-0,
-0,
-747,
-747,
-0,
-0,
-755,
-758,
-0,
-0,
-0,
-0,
-758,
-0,
-0,
-766,
-0,
-0,
-0,
-0,
-766,
-0,
-0,
-770,
-0,
-0,
-0,
-779,
-0,
-0,
-0,
-0,
-0,
-0,
-779,
-786,
-789,
-0,
-794,
-0,
-0,
-0,
-794,
-798,
-801,
-0,
-0,
-0,
-0,
-0,
-801,
-810,
-0,
-0,
-811,
-0,
-0,
-0,
-0,
-811,
-0,
-0,
-0,
-821,
-0,
-0,
-0,
-0,
-821,
-0,
-830,
-834,
-0,
-0,
-0,
-834,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-834,
-849,
-0,
-849,
-849,
-0,
-0,
-0,
-0,
-851,
-0,
-0,
-858,
-0,
-0,
-858,
-866,
-0,
-0,
-0,
-0,
-0,
-0,
-867,
-0,
-867,
-0,
-0,
-878,
-0,
-0,
-878,
-878,
-0,
-0,
-0,
-885,
-0,
-0,
-0,
-0,
-891,
-0,
-0,
-0,
-0,
-0,
-0,
-891,
-899,
-0,
-906,
-906,
-0,
-0,
-906,
-0,
-0,
-0,
-0,
-910,
-0,
-0,
-0,
-917,
-0,
-0,
-923,
-0,
-0,
-0,
-0,
-926,
-929,
-0,
-0,
-929,
-0,
-0,
-0,
-0,
-937,
-0,
-0,
-942,
-0,
-0,
-942,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-950,
-0,
-954,
-0,
-954,
-954,
-0,
-0,
-0,
-965,
-965,
-0,
-0,
-966,
-0,
-0,
-0,
-0,
-971,
-0,
-978,
-0,
-0,
-0,
-0,
-982,
-987,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-987,
-0,
-0,
-998,
-0,
-0,
-0,
-1001,
-0,
-0,
-0,
-1001,
-0,
-0,
-0,
-1011,
-0,
-0,
-1011,
-1011,
-0,
-0,
-1011,
-0,
-1022,
-0,
-0,
-0,
-0,
-0,
-1026,
-1026,
-0,
-0,
-1029,
-0,
-0,
-0,
-0,
-1034,
-1043,
-0,
-0,
-1043,
-0,
-0,
-1045,
-1050,
-1050,
-0,
-0,
-0,
-0,
-0,
-1050,
-1050,
-1061,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1062,
-0,
-1062,
-1074,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1074,
-0,
-0,
-1083,
-1083,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1089,
-1091,
-0,
-0,
-1094,
-0,
-0,
-1099,
-0,
-1106,
-0,
-0,
-1106,
-0,
-0,
-0,
-1106,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1115,
-1125,
-0,
-0,
-0,
-0,
-0,
-1126,
-1126,
-0,
-0,
-0,
-1131,
-0,
-0,
-0,
-1139,
-1139,
-0,
-1139,
-0,
-0,
-0,
-0,
-0,
-1146,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1154,
-0,
-1158,
-1158,
-0,
-0,
-1161,
-1166,
-0,
-0,
-0,
-1171,
-0,
-0,
-0,
-0,
-1173,
-0,
-1173,
-0,
-0,
-0,
-0,
-0,
-1182,
-0,
-0,
-1190,
-0,
-0,
-1193,
-1194,
-0,
-0,
-1194,
-0,
-0,
-0,
-1194,
-1206,
-0,
-0,
-0,
-1206,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1211,
-0,
-0,
-0,
-1221,
-1221,
-0,
-0,
-0,
-0,
-0,
-0,
-1221,
-1227,
-0,
-1234,
-1238,
-0,
-0,
-1238,
-0,
-1238,
-0,
-0,
-0,
-0,
-0,
-1242,
-1242,
-0,
-0,
-1251,
-1251,
-0,
-0,
-0,
-1257,
-1259,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1262,
-0,
-0,
-1275,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1278,
-1281,
-0,
-0,
-1290,
-0,
-0,
-0,
-1290,
-1290,
-0,
-0,
-1290,
-0,
-0,
-1301,
-1301,
-0,
-0,
-1307,
-0,
-0,
-0,
-0,
-1307,
-0,
-0,
-0,
-1313,
-0,
-0,
-1315,
-0,
-1322,
-0,
-1326,
-0,
-0,
-0,
-0,
-1326,
-0,
-0,
-0,
-1333,
-0,
-0,
-0,
-0,
-1333,
-0,
-1333,
-1346,
-0,
-0,
-0,
-0,
-1347,
-0,
-0,
-1347,
-0,
-0,
-0,
-1353,
-0,
-0,
-1361,
-0,
-0,
-0,
-0,
-0,
-1361,
-0,
-0,
-0,
-0,
-0,
-1370,
-1378,
-1378,
-0,
-0,
-1378,
-0,
-0,
-1379,
-1382,
-1382,
-0,
-0,
-0,
-0,
-0,
-0,
-1386,
-0,
-0,
-1397,
-1397,
-0,
-0,
-0,
-0,
-1397,
-0,
-0,
-1406,
-0,
-0,
-0,
-0,
-0,
-0,
-1406,
-1418,
-0,
-0,
-0,
-1419,
-1419,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1422,
-0,
-0,
-0,
-0,
-0,
-0,
-1434,
-0,
-0,
-0,
-0,
-0,
-0,
-1441,
-1441,
-1451,
-0,
-1451,
-1451,
-0,
-0,
-1451,
-0,
-0,
-0,
-0,
-1454,
-0,
-0,
-1461,
-0,
-1466,
-0,
-1470,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1470,
-0,
-0,
-1481,
-0,
-1481,
-0,
-0,
-1482,
-0,
-0,
-1491,
-1494,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1494,
-1494,
-0,
-0,
-1494,
-0,
-0,
-0,
-0,
-1509,
-0,
-0,
-1514,
-0,
-0,
-0,
-1514,
-0,
-0,
-1515,
-0,
-0,
-0,
-1526,
-1526,
-1526,
-0,
-0,
-1526,
-0,
-0,
-0,
-1531,
-1539,
-0,
-0,
-1539,
-0,
-0,
-0,
-1545,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1547,
-1553,
-0,
-1558,
-0,
-0,
-0,
-1558,
-0,
-1566,
-0,
-0,
-1566,
-0,
-0,
-0,
-0,
-0,
-0,
-1571,
-0,
-0,
-0,
-0,
-0,
-1571,
-0,
-0,
-1586,
-0,
-0,
-1589,
-0,
-1589,
-0,
-0,
-1589,
-0,
-0,
-0,
-1595,
-0,
-0,
-0,
-0,
-0,
-0,
-1603,
-1603,
-0,
-0,
-1605,
-1614,
-0,
-0,
-0,
-1614,
-1617,
-0,
-0,
-0,
-0,
-0,
-1622,
-1626,
-1626,
-0,
-0,
-0,
-0,
-0,
-0,
-1626,
-1637,
-0,
-0,
-1637,
-0,
-0,
-0,
-0,
-0,
-0,
-1643,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1650,
-0,
-0,
-0,
-1650,
-1665,
-0,
-1666,
-0,
-0,
-0,
-1666,
-0,
-1670,
-0,
-0,
-0,
-0,
-0,
-1670,
-1682,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1682,
-// column
-0,
-27,
-38,
-0,
-41,
-51,
-0,
-0,
-54,
-59,
-66,
-0,
-0,
-69,
-0,
-0,
-74,
-83,
-86,
-0,
-86,
-0,
-0,
-0,
-0,
-91,
-102,
-0,
-0,
-105,
-0,
-0,
-110,
-0,
-110,
-0,
-117,
-123,
-0,
-0,
-126,
-131,
-0,
-0,
-0,
-131,
-0,
-0,
-0,
-138,
-146,
-0,
-149,
-149,
-0,
-0,
-0,
-0,
-154,
-0,
-0,
-161,
-0,
-0,
-161,
-171,
-0,
-0,
-174,
-0,
-0,
-0,
-179,
-179,
-186,
-0,
-0,
-0,
-0,
-0,
-186,
-195,
-198,
-0,
-0,
-201,
-0,
-0,
-0,
-206,
-206,
-0,
-0,
-0,
-0,
-0,
-0,
-213,
-222,
-0,
-222,
-227,
-0,
-0,
-230,
-0,
-235,
-0,
-0,
-235,
-0,
-0,
-0,
-242,
-0,
-0,
-242,
-251,
-0,
-0,
-0,
-251,
-258,
-0,
-0,
-261,
-0,
-0,
-266,
-0,
-266,
-0,
-0,
-0,
-0,
-0,
-273,
-275,
-0,
-0,
-0,
-0,
-0,
-0,
-282,
-291,
-294,
-0,
-294,
-299,
-0,
-0,
-0,
-299,
-0,
-0,
-0,
-306,
-0,
-0,
-306,
-0,
-315,
-0,
-315,
-0,
-0,
-0,
-0,
-315,
-326,
-0,
-0,
-329,
-0,
-0,
-0,
-0,
-334,
-0,
-341,
-341,
-0,
-0,
-0,
-341,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-350,
-354,
-0,
-361,
-363,
-0,
-0,
-366,
-0,
-371,
-0,
-0,
-371,
-0,
-0,
-378,
-0,
-0,
-0,
-378,
-0,
-0,
-0,
-0,
-0,
-387,
-0,
-0,
-389,
-0,
-0,
-0,
-398,
-402,
-0,
-0,
-405,
-0,
-0,
-410,
-411,
-411,
-0,
-0,
-0,
-0,
-0,
-0,
-417,
-426,
-0,
-426,
-426,
-0,
-0,
-0,
-0,
-426,
-0,
-0,
-0,
-0,
-0,
-437,
-443,
-0,
-0,
-446,
-451,
-0,
-0,
-0,
-451,
-0,
-0,
-0,
-458,
-0,
-0,
-458,
-0,
-467,
-0,
-0,
-467,
-0,
-0,
-0,
-467,
-0,
-0,
-0,
-0,
-0,
-0,
-478,
-478,
-486,
-0,
-489,
-491,
-0,
-0,
-494,
-0,
-494,
-0,
-0,
-0,
-0,
-0,
-0,
-501,
-510,
-0,
-0,
-0,
-0,
-0,
-0,
-510,
-510,
-0,
-0,
-521,
-0,
-0,
-521,
-0,
-0,
-0,
-523,
-531,
-0,
-0,
-534,
-0,
-0,
-0,
-0,
-539,
-0,
-0,
-0,
-546,
-546,
-0,
-549,
-0,
-0,
-0,
-0,
-0,
-555,
-0,
-0,
-555,
-0,
-0,
-0,
-566,
-0,
-0,
-566,
-0,
-0,
-0,
-566,
-579,
-579,
-0,
-0,
-581,
-0,
-0,
-0,
-586,
-586,
-0,
-0,
-593,
-0,
-0,
-0,
-594,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-602,
-0,
-613,
-613,
-0,
-0,
-613,
-0,
-613,
-0,
-0,
-613,
-0,
-0,
-626,
-627,
-0,
-0,
-630,
-635,
-0,
-0,
-0,
-635,
-642,
-0,
-0,
-0,
-0,
-0,
-642,
-0,
-0,
-0,
-0,
-651,
-0,
-0,
-651,
-651,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-662,
-0,
-0,
-662,
-0,
-0,
-0,
-0,
-675,
-678,
-0,
-0,
-681,
-0,
-0,
-0,
-686,
-690,
-0,
-693,
-0,
-0,
-0,
-0,
-693,
-702,
-0,
-0,
-702,
-0,
-0,
-702,
-0,
-707,
-0,
-713,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-713,
-0,
-0,
-0,
-726,
-726,
-0,
-726,
-731,
-0,
-0,
-734,
-0,
-739,
-0,
-0,
-741,
-0,
-0,
-0,
-0,
-0,
-0,
-746,
-0,
-0,
-0,
-0,
-755,
-0,
-0,
-0,
-758,
-0,
-0,
-766,
-0,
-766,
-0,
-0,
-0,
-0,
-0,
-766,
-779,
-779,
-0,
-0,
-0,
-0,
-0,
-0,
-779,
-786,
-0,
-0,
-789,
-0,
-0,
-0,
-0,
-794,
-0,
-0,
-801,
-0,
-0,
-801,
-801,
-0,
-0,
-810,
-811,
-0,
-0,
-0,
-0,
-811,
-0,
-0,
-821,
-0,
-0,
-0,
-0,
-821,
-0,
-0,
-821,
-0,
-0,
-0,
-834,
-0,
-0,
-0,
-0,
-0,
-0,
-834,
-843,
-846,
-0,
-849,
-0,
-0,
-0,
-851,
-851,
-858,
-0,
-0,
-0,
-0,
-0,
-858,
-867,
-0,
-0,
-867,
-0,
-0,
-0,
-0,
-867,
-0,
-0,
-0,
-878,
-0,
-0,
-0,
-0,
-878,
-0,
-885,
-891,
-0,
-0,
-0,
-891,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-891,
-906,
-0,
-906,
-906,
-0,
-0,
-0,
-0,
-910,
-0,
-0,
-917,
-0,
-0,
-917,
-923,
-0,
-0,
-0,
-0,
-0,
-0,
-926,
-0,
-926,
-0,
-0,
-937,
-0,
-0,
-937,
-937,
-0,
-0,
-0,
-942,
-0,
-0,
-0,
-0,
-950,
-0,
-0,
-0,
-0,
-0,
-0,
-950,
-954,
-0,
-965,
-965,
-0,
-0,
-966,
-0,
-0,
-0,
-0,
-971,
-0,
-0,
-0,
-978,
-0,
-0,
-982,
-0,
-0,
-0,
-0,
-987,
-987,
-0,
-0,
-987,
-0,
-0,
-0,
-0,
-998,
-0,
-0,
-1001,
-0,
-0,
-1001,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1011,
-0,
-1011,
-0,
-1011,
-1011,
-0,
-0,
-0,
-1026,
-1026,
-0,
-0,
-1029,
-0,
-0,
-0,
-0,
-1034,
-0,
-1041,
-0,
-0,
-0,
-0,
-1043,
-1050,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1050,
-0,
-0,
-1061,
-0,
-0,
-0,
-1062,
-0,
-0,
-0,
-1062,
-0,
-0,
-0,
-1074,
-0,
-0,
-1074,
-1074,
-0,
-0,
-1074,
-0,
-1083,
-0,
-0,
-0,
-0,
-0,
-1089,
-1091,
-0,
-0,
-1094,
-0,
-0,
-0,
-0,
-1099,
-1106,
-0,
-0,
-1106,
-0,
-0,
-1106,
-1115,
-1115,
-0,
-0,
-0,
-0,
-0,
-1115,
-1115,
-1126,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1126,
-0,
-1126,
-1139,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1139,
-0,
-0,
-1146,
-1146,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1154,
-1158,
-0,
-0,
-1161,
-0,
-0,
-1166,
-0,
-1171,
-0,
-0,
-1173,
-0,
-0,
-0,
-1173,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1182,
-1190,
-0,
-0,
-0,
-0,
-0,
-1193,
-1193,
-0,
-0,
-0,
-1194,
-0,
-0,
-0,
-1206,
-1206,
-0,
-1206,
-0,
-0,
-0,
-0,
-0,
-1211,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1221,
-0,
-1221,
-1227,
-0,
-0,
-1230,
-1235,
-0,
-0,
-0,
-1238,
-0,
-0,
-0,
-0,
-1242,
-0,
-1242,
-0,
-0,
-0,
-0,
-0,
-1251,
-0,
-0,
-1257,
-0,
-0,
-1262,
-1262,
-0,
-0,
-1262,
-0,
-0,
-0,
-1262,
-1275,
-0,
-0,
-0,
-1275,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1278,
-0,
-0,
-0,
-1290,
-1290,
-0,
-0,
-0,
-0,
-0,
-0,
-1290,
-1298,
-0,
-1301,
-1307,
-0,
-0,
-1307,
-0,
-1307,
-0,
-0,
-0,
-0,
-0,
-1313,
-1313,
-0,
-0,
-1322,
-1322,
-0,
-0,
-0,
-1326,
-1326,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1333,
-0,
-0,
-1346,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1347,
-1347,
-0,
-0,
-1361,
-0,
-0,
-0,
-1361,
-1361,
-0,
-0,
-1361,
-0,
-0,
-1370,
-1371,
-0,
-0,
-1378,
-0,
-0,
-0,
-0,
-1379,
-0,
-0,
-0,
-1386,
-0,
-0,
-1386,
-0,
-1395,
-0,
-1397,
-0,
-0,
-0,
-0,
-1397,
-0,
-0,
-0,
-1406,
-0,
-0,
-0,
-0,
-1406,
-0,
-1406,
-1419,
-0,
-0,
-0,
-0,
-1419,
-0,
-0,
-1419,
-0,
-0,
-0,
-1422,
-0,
-0,
-1434,
-0,
-0,
-0,
-0,
-0,
-1434,
-0,
-0,
-0,
-0,
-0,
-1441,
-1451,
-1451,
-0,
-0,
-1451,
-0,
-0,
-1454,
-1454,
-1454,
-0,
-0,
-0,
-0,
-0,
-0,
-1461,
-0,
-0,
-1470,
-1470,
-0,
-0,
-0,
-0,
-1470,
-0,
-0,
-1481,
-0,
-0,
-0,
-0,
-0,
-0,
-1481,
-1491,
-0,
-0,
-0,
-1494,
-1494,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1494,
-0,
-0,
-0,
-0,
-0,
-0,
-1509,
-0,
-0,
-0,
-0,
-0,
-0,
-1514,
-1514,
-1526,
-0,
-1526,
-1526,
-0,
-0,
-1526,
-0,
-0,
-0,
-0,
-1531,
-0,
-0,
-1538,
-0,
-1539,
-0,
-1545,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1547,
-0,
-0,
-1558,
-0,
-1558,
-0,
-0,
-1558,
-0,
-0,
-1566,
-1571,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1571,
-1571,
-0,
-0,
-1571,
-0,
-0,
-0,
-0,
-1586,
-0,
-0,
-1589,
-0,
-0,
-0,
-1589,
-0,
-0,
-1589,
-0,
-0,
-0,
-1603,
-1603,
-1603,
-0,
-0,
-1605,
-0,
-0,
-0,
-1610,
-1614,
-0,
-0,
-1617,
-0,
-0,
-0,
-1622,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1626,
-1626,
-0,
-1637,
-0,
-0,
-0,
-1637,
-0,
-1643,
-0,
-0,
-1643,
-0,
-0,
-0,
-0,
-0,
-0,
-1650,
-0,
-0,
-0,
-0,
-0,
-1650,
-0,
-0,
-1665,
-0,
-0,
-1666,
-0,
-1666,
-0,
-0,
-1666,
-0,
-0,
-0,
-1670,
-0,
-0,
-0,
-0,
-0,
-0,
-1682,
-1683,
-0,
-0,
-1686,
-1691,
-0,
-0,
-0,
-1691,
-1698,
-0,
-0,
-0,
-0,
-0,
-1701,
-1707,
-1707,
-0,
-0,
-0,
-0,
-0,
-0,
-1707,
-1718,
-0,
-0,
-1718,
-0,
-0,
-0,
-0,
-0,
-0,
-1722,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1731,
-0,
-0,
-0,
-1731,
-1746,
-0,
-1746,
-0,
-0,
-0,
-1746,
-0,
-1747,
-0,
-0,
-0,
-0,
-0,
-1747,
-1763,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-1763
-};
diff -r 8b1af7363833 src/python/pygraph.cpp~
--- a/src/python/pygraph.cpp~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,65 +0,0 @@
-/*
-  This software is licensed under 
-  CeCILL FREE SOFTWARE LICENSE AGREEMENT
-
-  This software comes in hope that it will be useful but 
-  without any warranty to the extent permitted by applicable law.
-  
-  (C) UjoImro, 2012 <ujoimro@gmail.com>
-  ProCarPlan s.r.o.
-*/
-
-// this file contains the wrapper for Pink's skeleton class
-
-
-#ifndef PINK_DEVELOPMENT
-#  include "pink_python.h"
-#else /* PINK_DEVELOPMENT */
-#  include "pink_development.h"
-#endif /* PINK_DEVELOPMENT */
-
-#include "ujimage.hpp"
-#include "ui_graph.hpp"
-#include "python_doc.h"
-#include "ui_skeleton.hpp"
-
-
-void pygraph()
-{
-            
-    boost::python::class_< pink::graph_t<index_t> > (
-        "graph_t",
-        "This is the class for manipulating graphs.",
-        boost::python::init<>(
-            boost::python::args("self"), "Creates an empty graph object." )
-        )   
-
-        .def( boost::python::init< std::string > (
-                  boost::python::args("self","filename"), "Reads a skeleton from a file." )
-            )
-        
-        .def( "writegraph", &pink::graph_t<index_t>::writegraph,
-              ( boost::python::arg("filename") ),
-              "WRITE ME!!!"
-            )
-
-        // .def( "__repr__", &pink::skel_t<index_t>::repr,
-        //       boost::python::args("self"),
-        //       "Prints the graph."
-        //     )
-
-
-        ; // pink::skel_t (skeleton)
-    
-    boost::python::def( "skel2graph", pink::skel2graph<index_t>,
-                        ( boost::python::arg("skeleton"), boost::python::arg("mode") ),
-                        doc__skel2graph__c__
-        );
-
-
-
-} // pyskeleton
-        
-
-
-//LuM end of file
diff -r 8b1af7363833 src/python/pymorpho.cpp
--- a/src/python/pymorpho.cpp	Sat May 25 21:53:33 2013 +0200
+++ b/src/python/pymorpho.cpp	Mon Jan 13 15:50:10 2014 +0100
@@ -455,7 +455,7 @@
 
   UI_WRAP_FUNCTION(
     "dilatbin",
-    ldilatbin3d_ldilatbin3d,
+    ldilatbin3d,
     (arg("image"), arg("elem"), arg("x"), arg("y"), arg("z")),
     doc__dilatbin__c__
     );
@@ -497,7 +497,7 @@
 // NOTE: lderiche the question of l parameter
   UI_WRAP_FUNCTION(
     "deriche",
-    lderiche_lderiche,
+    lderiche,
     (arg("image"), arg("alpha"), arg("function"), arg("l") ),
     doc__deriche__c__
     );
diff -r 8b1af7363833 src/python/pynumpy.cpp~
--- a/src/python/pynumpy.cpp~	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,164 +0,0 @@
-/*
-  This software is licensed under 
-  CeCILL FREE SOFTWARE LICENSE AGREEMENT
-
-  This software comes in hope that it will be useful but 
-  without any warranty to the extent permitted by applicable law.
-  
-  (C) UjoImro, 2012 <ujoimro@gmail.com>
-  ProCarPlan s.r.o.
-*/
-
-// Pink NumPy Conversion routine
-
-#include <Python.h>
-#include <boost/python.hpp>
-#include <numpy/arrayobject.h>
-#include <boost/smart_ptr.hpp>
-
-#include "pink_python.h"
-
-namespace pink {
-    namespace python {
-
-        // this code has been borrowed from
-        // Copyright (c) 2008, Michael Droettboom
-
-        namespace detail {
-
-            template<class T>
-            class numpy_type_map {
-            public:
-                static const int typenum;
-            };
-
-            template<>
-            const int numpy_type_map<float>::typenum = NPY_FLOAT;
-
-            template<>
-            const int numpy_type_map<std::complex<float> >::typenum = NPY_CFLOAT;
-
-            template<>
-            const int numpy_type_map<double>::typenum = NPY_DOUBLE;
-
-            template<>
-            const int numpy_type_map<std::complex<double> >::typenum = NPY_CDOUBLE;
-
-            template<>
-            const int numpy_type_map<long double>::typenum = NPY_LONGDOUBLE;
-
-            template<>
-            const int numpy_type_map<std::complex<long double> >::typenum = NPY_CLONGDOUBLE;
-
-            template<>
-            const int numpy_type_map<boost::int8_t>::typenum = NPY_INT8;
-
-            template<>
-            const int numpy_type_map<boost::uint8_t>::typenum = NPY_UINT8;
-
-            template<>
-            const int numpy_type_map<boost::int16_t>::typenum = NPY_INT16;
-
-            template<>
-            const int numpy_type_map<boost::uint16_t>::typenum = NPY_UINT16;
-
-            template<>
-            const int numpy_type_map<boost::int32_t>::typenum = NPY_INT32;
-
-            template<>
-            const int numpy_type_map<boost::uint32_t>::typenum = NPY_UINT32;
-
-            template<>
-            const int numpy_type_map<boost::int64_t>::typenum = NPY_INT64;
-
-            template<>
-            const int numpy_type_map<boost::uint64_t>::typenum = NPY_UINT64;
-        }   
-
-
-        struct sentinel_t {
-            ~sentinel_t () {
-                std::cout << "the result has been returned" << std::endl;                
-            }           
-        };        
-            
-
-        template <class image_type>
-        PyObject * 
-        wrap2numpy( image_type & image )
-        {
-            sentinel_t sentinel;
-            
-            // the dimension of the image
-            int32_t nd = image.get_size().size();
-            _DEBUG(nd);            
-            // the sizes of the image
-            boost::shared_array<npy_intp> dims( new npy_intp[nd] );            
-            for ( index_t q=0; q<nd; ++q ) {
-                dims[q] = image.get_size()[q];
-                _DEBUG(dims[q]);
-            }
-            
-            PyArrayObject* numpy_array;
-            numpy_array = (PyArrayObject*)PyArray_SimpleNewFromData (
-                nd,
-                dims.get(),
-                detail::numpy_type_map<typename image_type::pixel_type>::typenum,
-                reinterpret_cast<void*>(image.get_pixels().get())
-                );
-             
-            if (numpy_array == NULL)
-                pink_error("Couldn't allocate the NumPy array.");
-
-            return (PyObject*)numpy_array;
-        }
-
-        
-        template <class image_type>
-        boost::python::object
-        numpy2pink( boost::python::object & array )
-        {
-
-            // PyArrayObject* PyArray_GETCONTIGUOUS(PyObject* op)
-            // PyObject* arrayPyArray_NewCopy( array.get(), NPY_CORDER );
-            
-            // if (!PyArray_ISCONTIGUOUS(array.get())) // the array is not continuous
-                // pink_error("This function can only wrap continuous arrays");
-                
-        }
-        
-        
-    } /* namespace python */
-} /* namespace pink */
-
-
-const std::string wrap2numpy_doc =
-                             "Converts a pink::ujimage object to a numpy array. The data is NOT copied"
-                             ", only the pointer is carried, which means that if you change the numpy "
-                             "array the image values change too. In exchange the conversion does no copy and "
-                             "is therefore in constant time.";
-
-const std::string wrap2pink_doc =
-                             "Converts a numpy array into a pink::ujimage object. The method fails "
-                             "if the data is not continuous. If the function succeeds, the data is NOT copied"
-                             ", only the pointer is carried, which means that if you change the numpy "
-                             "array the image values change too. In exchange the conversion does no copy and "
-                             "is therefore in constant time.";
-
-                             
-void numpy_export()
-{
-    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::char_image>,     ( boost::python::arg("image") ), wrap2numpy_doc );
-    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::short_image>,    ( boost::python::arg("image") ), wrap2numpy_doc );
-    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::int_image>,      ( boost::python::arg("image") ), wrap2numpy_doc );
-    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::float_image>,    ( boost::python::arg("image") ), wrap2numpy_doc );
-    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::double_image>,   ( boost::python::arg("image") ), wrap2numpy_doc );
-    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::fcomplex_image>, ( boost::python::arg("image") ), wrap2numpy_doc );
-    // boost::python::def( "wrap2numpy", &pink::python::wrap2numpy<pink::dcomplex_image>, ( boost::python::arg("image") ), wrap2numpy_doc );
-
-    boost::python::def( "wrap2pink", &pink::python::wrap2pink, ( boost::python::arg("array") ), wrap2numpy_doc );
-
-    import_array();  // numpy initialization
-}
-
-// LuM end of file
diff -r 8b1af7363833 src/python/pywshed.cpp
--- a/src/python/pywshed.cpp	Sat May 25 21:53:33 2013 +0200
+++ b/src/python/pywshed.cpp	Mon Jan 13 15:50:10 2014 +0100
@@ -39,7 +39,7 @@
 // by HT for Claire
   UI_WRAP_FUNCTION(
     "watershedMeyer2",
-    llpemeyer_llpemeyer2,
+    llpemeyer2,
     ( arg("image"), arg("markers"), arg("mask"), arg("connexity") ),
     doc__watershedMeyer2__c__
     );
diff -r 8b1af7363833 src/tables/LookUpTable.c
--- a/src/tables/LookUpTable.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/tables/LookUpTable.c	Mon Jan 13 15:50:10 2014 +0100
@@ -33,6 +33,9 @@
 
 //#define DEBUG
 
+/* utility */
+static int min(int x, int y) { if (x<y) return x; else return y; }
+
 /* Function prototypes */
 void ComputeCTg (int L, long int * CTg);
 int AddWeighting (MaskG *M, int x, int y, int w, int RR);
diff -r 8b1af7363833 src/tables/LookUpTable3d.c
--- a/src/tables/LookUpTable3d.c	Sat May 25 21:53:33 2013 +0200
+++ b/src/tables/LookUpTable3d.c	Mon Jan 13 15:50:10 2014 +0100
@@ -25,6 +25,9 @@
 
 //#define DEBUG
 
+/* utility */
+static int min(int x, int y) { if (x<y) return x; else return y; }
+
 /* Function prototypes */
 void ComputeCTg (int L, long int * CTg);
 int AddWeighting (MaskG *M, int x, int y, int z, int w, int RR);
diff -r 8b1af7363833 tcl/view.tcl
--- a/tcl/view.tcl	Sat May 25 21:53:33 2013 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,160 +0,0 @@
-#sh
-# The next line is executed by /bin/sh, but not Tcl \
-exec wish $0
-
-# Hide the default . widget
-wm withdraw .
-
-set VIEW(name) "view"
-
-set PINK "$env(PINK)"
-source [file join "$PINK" "tcl" "my_exec.tcl"]
-source [file join "$PINK" "tcl" "my_read.tcl"]
-source "$PINK/tcl/my_feedback.tcl"
-
-proc tmpfile {tmpname} {
-  global VIEW
-  return [file join "/tmp" "$VIEW(name)_$tmpname"]
-}
-
-set VIEW(filelist) [glob "*.jpg"]
-set VIEW(zoom) 2
-set VIEW(delay) 3000
-set count 0
-
-toplevel .waitmess -borderwidth 10
-entry .waitmess.entry
-pack .waitmess.entry -side top
-update
-foreach f $VIEW(filelist) {
-  my_feedback "processing $f..."
-  my_exec convert $f "_$f.ppm"
-  set h [my_readpgmheader "_$f.ppm"]
-  set rs [lindex $h 1]
-  set cs [lindex $h 2]
-  set w [expr $rs / 2]
-  set h [expr $cs / 2]
-  set filecount [format "%03d" $count]
-  incr count
-  my_exec cropppm "_$f.ppm" 0 0 $w $h "_$filecount"
-  my_exec zoomppm "_$filecount" $VIEW(zoom) "_$filecount"
-  set filecount [format "%03d" $count]
-  incr count
-  my_exec cropppm "_$f.ppm" $w 0 $w $h "_$filecount"
-  my_exec zoomppm "_$filecount" $VIEW(zoom) "_$filecount"
-  set filecount [format "%03d" $count]
-  incr count
-  my_exec cropppm "_$f.ppm" 0 $h $w $h "_$filecount"
-  my_exec zoomppm "_$filecount" $VIEW(zoom) "_$filecount"
-  set filecount [format "%03d" $count]
-  incr count
-  my_exec cropppm "_$f.ppm" $w $h $w $h "_$filecount"
-  my_exec zoomppm "_$filecount" $VIEW(zoom) "_$filecount"
-  file delete "_$f.ppm"
-}
-destroy .waitmess
-
-set VIEW(filelist) [glob "_???"]
-set VIEW(count) [llength $VIEW(filelist)]
-set VIEW(index) 0
-set VIEW(nima) 0
-set VIEW(nsub) 0
-toplevel .view
-
-# create a frame for buttons
-frame .view.top -borderwidth 10
-pack .view.top -side top -fill x
-
-# create the quit button
-button .view.top.quit -text Quit -command view_quit
-pack .view.top.quit -side right
-
-# create the prev, next and auto button
-button .view.top.prev -text prev -command view_prev
-button .view.top.next -text next -command view_next
-button .view.top.auto -text auto -command view_auto
-pack .view.top.prev .view.top.next .view.top.auto -side left
-
-# create the label for pixel value
-label .view.top.nimage -textvariable VIEW(nima) -width 3
-label .view.top.nsubim -textvariable VIEW(nsub) -width 3
-pack .view.top.nimage -side left
-pack .view.top.nsubim -side left
-
-# create an image and load contents from file 
-set ww [expr $w * $VIEW(zoom)]
-set hh [expr $h * $VIEW(zoom)]
-my_exec genimage $ww $hh 1 0 "_" 
-set VIEW(im) [image create photo imname -file "_"]
-
-# get image size
-set VIEW(im_cs) [image height $VIEW(im)]
-set VIEW(im_rs) [image width $VIEW(im)]
-
-# create a frame for the image
-frame .view.imframe -borderwidth 10 -width $VIEW(im_rs) -height $VIEW(im_cs)
-pack .view.imframe -side top
-
-# create canvas with the right sizes
-set c [canvas .view.imframe.c -width [expr $VIEW(im_rs) - 2] -height [expr $VIEW(im_cs) - 2]]
-pack .view.imframe.c -fill both -expand true
-
-# put the image into the canvas
-$c create image 1 1 -anchor nw  -image $VIEW(im)
-
-# action associated to next widget
-proc view_next {} {
-  global VIEW
-  if {$VIEW(index) < [expr $VIEW(count)-1]} {
-    incr VIEW(index)
-    set VIEW(nima) [expr ($VIEW(index) / 4) + 1]
-    set VIEW(nsub) [expr ($VIEW(index) % 4) + 1]
-    set filecount [format "%03d" $VIEW(index)]
-    $VIEW(im) read "_$filecount" 
-  }
-}
-
-# action associated to prev widget
-proc view_prev {} {
-  global VIEW
-  if {$VIEW(index) > 0} {
-    incr VIEW(index) -1
-    set VIEW(nima) [expr ($VIEW(index) / 4) + 1]
-    set VIEW(nsub) [expr ($VIEW(index) % 4) + 1]
-    set filecount [format "%03d" $VIEW(index)]
-    $VIEW(im) read "_$filecount" 
-  }
-}
-
-# action associated to auto widget
-proc view_auto {} {
-  global VIEW
-  .view config -cursor watch
-  while {$VIEW(index) < $VIEW(count)} {
-    set VIEW(nima) [expr ($VIEW(index) / 4) + 1]
-    set VIEW(nsub) [expr ($VIEW(index) % 4) + 1]
-    set filecount [format "%03d" $VIEW(index)]
-    $VIEW(im) read "_$filecount" 
-    update
-    after $VIEW(delay)
-    incr VIEW(index)
-  }
-  set VIEW(index) 0
-  set filecount [format "%03d" $VIEW(index)]
-  $VIEW(im) read "_$filecount" 
-  update
-  .view config -cursor left_ptr
-}
-
-# action associated to quit widget
-proc view_quit {} {
-  global VIEW
-  foreach file [glob -nocomplain "_*"] {
-    catch {exec rm $file} result
-  }
-  exit
-}
-
-wm protocol .view WM_DELETE_WINDOW view_quit
-bind .view "q" view_quit
-
diff -r 8b1af7363833 tools/filefilter
Binary file tools/filefilter has changed
diff -r 8b1af7363833 tutorial/python/2011.06.23_presentation.tar.bz2
Binary file tutorial/python/2011.06.23_presentation.tar.bz2 has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile00.pgm
Binary file tutorial/python/MC-TP7/solution/tile00.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile01.pgm
Binary file tutorial/python/MC-TP7/solution/tile01.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile02.pgm
Binary file tutorial/python/MC-TP7/solution/tile02.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile03.pgm
Binary file tutorial/python/MC-TP7/solution/tile03.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile04.pgm
Binary file tutorial/python/MC-TP7/solution/tile04.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile05.pgm
Binary file tutorial/python/MC-TP7/solution/tile05.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile06.pgm
Binary file tutorial/python/MC-TP7/solution/tile06.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile07.pgm
Binary file tutorial/python/MC-TP7/solution/tile07.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile08.pgm
Binary file tutorial/python/MC-TP7/solution/tile08.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile09.pgm
Binary file tutorial/python/MC-TP7/solution/tile09.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile10.pgm
Binary file tutorial/python/MC-TP7/solution/tile10.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile11.pgm
Binary file tutorial/python/MC-TP7/solution/tile11.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile12.pgm
Binary file tutorial/python/MC-TP7/solution/tile12.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile13.pgm
Binary file tutorial/python/MC-TP7/solution/tile13.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile14.pgm
Binary file tutorial/python/MC-TP7/solution/tile14.pgm has changed
diff -r 8b1af7363833 tutorial/python/MC-TP7/solution/tile15.pgm
Binary file tutorial/python/MC-TP7/solution/tile15.pgm has changed
diff -r 8b1af7363833 tutorial/python/presentation/airport.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tutorial/python/presentation/airport.py	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,59 @@
+# UjoImro, 2010
+
+from pink import *
+pink = cpp
+
+debug = False
+
+airport = pink.readimage("images/airport.pgm")
+
+imview(airport)
+
+def th(q):
+    return pink.seuil(airport, q)
+
+manipulate(th, 0, 255)
+
+# sol_airport
+# runway extraction
+def extract_runways( image, brightness_threshold=23, beed_filter_radius=3 ):
+    seuil = pink.seuil( image, brightness_threshold )
+    inv = pink.inverse(seuil)
+    asf = pink.asfbin(inv, beed_filter_radius)
+    #imview(asf)
+    skeleton = pink.skeleton(asf, 0, 8)
+    ptcurve = pink.ptcurve(skeleton, 8)
+    dilated = pink.geodilat(ptcurve, asf, 8)
+    skelcurv = pink.skelcurv(dilated, 0, 8)
+    return skelcurv
+    
+
+def ext(q):
+    return extract_runways(airport, 23, q)
+
+manipulate(ext, 0, 100, airport)
+    
+runways = extract_runways(airport)
+
+if debug: 
+    runways.writeimage("runways.pgm")
+    pink.surimp(airport, runways, "surimp.ppm")
+
+if debug:
+    imview([airport, runways])
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# LuM end of file
diff -r 8b1af7363833 tutorial/python/presentation/circuit.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tutorial/python/presentation/circuit.py	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,64 @@
+# UjoImro, 2010
+# presentation
+
+# fill in the holes
+def fill_the_holes(image):
+    frame = pink.frame(pink.char_image(image.size), 255)
+    inv = pink.inverse(image)
+    dilated = pink.geodilat(frame, inv, 8)
+    result = pink.inverse(dilated)
+    return result
+
+
+# extraction of the wires from a circuit
+def find_the_wires(image, seuil):
+    # binarize 
+    binary = pink.seuil(image, seuil, 0, 255)
+    inv = pink.inverse(binary)
+
+    # eliminate the little objects
+    #filtered = filter(inv, 2, 8)
+    eros = pink.erosball(inv, 2)
+    filtered = pink.geodilat(eros, inv, 8)
+
+    # fill the holes
+    filled = fill_the_holes(filtered)
+
+    # detect the joints
+    eros = pink.erosball(filled, 6)
+    dilat = pink.dilatball(eros, 6)
+    joints = pink.geodilat(dilat, filled, 8, 1)
+
+    # extract the wires
+    result = filled - joints
+
+    return result
+
+
+def try_seuil(s):
+    return pink.seuil(circuit, s, 0, 255)
+
+circuit = pink.readimage("images/circuit.pgm")
+seuil = manipulate(try_seuil, 0, 255, circuit)
+
+def fw(seuil):
+    return find_the_wires(circuit, seuil)
+
+manipulate(fw, 0, 100, circuit)
+
+if debug: imview([circuit, wires])
+#wires.writeimage("wires.pgm")
+
+
+
+
+
+
+
+
+
+
+
+
+
+# LuM end of file
diff -r 8b1af7363833 tutorial/python/presentation/fish.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tutorial/python/presentation/fish.py	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,45 @@
+# Michel Couprie, 2011
+# CeCILL free-software license
+
+# illustration of filtered Euclidean skeletons
+
+from pink import imview
+from pink import manipulate as manipulate
+from pink import cpp as pink
+
+global IMAGE
+IMAGE = pink.readimage("images/fish1.pgm")
+
+global LANG
+LANG = "en"
+
+def message(mes_en, mes_fr):
+    if LANG=="fr":
+        print mes_fr
+    else:
+        print mes_en
+
+message("\n\nDemonstration of skeletonization operators", "\n\nDemonstration des operateurs de squelettisation")
+message("Check the 'Superimpose' button in the window", "Activer l'option 'Superimpose' dans l'interface")
+message("Click 'Exit' to close the window and continue", "Cliquer sur 'Exit' pour passer au suivant")
+print("              ----------------")
+
+message("Discrete lambda-medial axis (DLMA)", "Lambda axe median discret (DLMA)")
+def try_DLMA(la): 
+    dlma = pink.lambdamedialaxis(IMAGE)
+    res = pink.seuil(dlma, la, 0, 255)
+    return pink.float2byte(res)
+
+manipulate(try_DLMA, 1, 100, IMAGE)
+
+message("Homotopic skeleton constrained by DLMA", "Squelette homotopique contraint par le DLMA")
+def try_DLMA_topo(la): 
+    dlma = pink.lambdamedialaxis(IMAGE)
+    constr = pink.seuil(dlma, la, 0, 255)
+    constr = pink.float2byte(constr)
+    res = pink.skeleton(IMAGE, dlma, 8, constr)
+    return res
+
+manipulate(try_DLMA_topo, 1, 100, IMAGE)
+
+# LuM end of file
diff -r 8b1af7363833 tutorial/python/presentation/images/airport.pgm
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tutorial/python/presentation/images/airport.pgm	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,1616 @@
+P5
+# This is a Synthetic Aperture Radar (SAR) image of the 
+# Willow Run Airport in Michigan. It comes courtesy of the 
+# Environmental Research Institute of Michigan, aka ERIM, in Ann
+# Arbor.
+# 
+# 
+392 435
+255
+&âS.L4.4&b) 3xJ)4;W<)))4D3&;.S3;J& ÊD 3
+  3ÁX¸&W¤i 
+ ) WfJ4 JD &;3&33.&.&.); &).fDxr)<S . )@&JbW3 3@ 3L3&33;|3&]LJÄ&3&@4. &&r¤Ä&&@WW<&;;Jâ&4;);. 4.3.))4.4<3L.L;W3r@3&&@b &J)])D&33<J&4X;J;) 4S34.&@ 
+
+i &@mJLJD&.4D) 3). 3WL&<&).  ;)&3)<3m &&L4)44<D..;..;3@&J4&.4.)4W< @3;;&@)&;34J4.;]D3i<]4);<@& ¤<  ;@33@)34) 43.S&) 44LS4S.fD4.  ;L@4&  )©tL.D@3W;)
+.&WJ;3&@D)3<&)   )4.3&&&3L )SL<..&@<i33@44.LLb.) )SS)& ¤<<&&.4 & )Dx43XriöþS3JLtbS&&&))<3)4. )@3D.)D;;.4L;L<).&&<.D.3;  <..;4& 3D.;X<3S@.J)..<
+
+4b.;.L&X<@)4W@.))3S3))3;L.44 .;.4 )4.4& 3)<4...;&4;;J)443&4.<)334.3.;)<S&3 3..&<3&DJ3iL< D@L@3&.i©mþm&SD). ;S<@3S.) @D4&4;<D)@<&)4x|D& L;.4@xt.
+));; @SD<&. &4    &).  W@&3&4<b]&&.44Ý&< 3L3WxL;.X.&f4|@bDL  .;r&<SxDD)SJ3 L;<.4.& &) 3..3<<<W4 WW3D)L
+.&&<))) &SX<..  4))D;<; 3;J&&).)X
+
+rL. )J@ 3@;;J3<D4)L;@DJ)&;@333.&3);S3)D3 4.  L &)&&.D .4<33.4<.)3; @3&4;& . ).X) <fW & D)L)DXD4;<.X43Sìþ|t&DD&344@.D)<&L34@3J;J;3) 3Xxb)
+  & &)JD<X;.;
+.43W<.JDJ )&4&3<& . );&4 ©.& &)4&;.44< )JD &4 3&D;fD.
+;)@&4&&)@.&.  .]4;;;<43L|33@;)L. 3444)44& D)44)@4.;3DJL4L34) W<4)3 &Ji@ . &&..4;) S).<4S& 
+4;.<);b4 3.43DS@J;L3X; . <&<3..3)&&)) &3&&.&&).3.;@43;&.3)) DJ&&3X33D .&&3 3; 3;44D<&4X43]3&<3 .4<D34 3¸Ì;&;4S. ..;.)<WS<3.S;.<)44.&3)&fi. ) ).&.JL@&;.
+&
+33&3 b<&<L  &.J  &
+)X  @34D.;D@&&)3@&<&;m4 m@S.)|r D<JJ3&)&43X 3&DfS.JD@ WS)&;J.<)J34);&3 L4..;
+&43@&S3.434;)&@)DJ
+&  &J]|@i;;)))<)).D3;3&4.
+
+
+
+
+ <)D;DWJ..<4J3JJ ;]434 .;. 4J 34;<@&; &4.43.&))@3.4X@3;)43)3@<4. @@L<@4&JJ) D<)) 4 @D3i4& ;3&3.L.4)3S<L;)@þÄ;L.J)<@))34D&.4L.&3&
+X JDÌr  .&Sf<<@b&S44&
+.&D3W]W&.)&  & &.3<.)& <3]<;@ 3]X].L.<)& <4 34ÝW<|4W&.S..  mðf<;D)&& &L34Si<DL;..&.;D.<&&.)<W; &))<43&)4J&))<;St3 )&  4.t)4Sþþ ;4&)4<<.&)
+
+
+
+<X))43.. ;3;&& )44&3S@ ;<&3  ).)4) .&@.3.44..4@ . DJ3;J4 .))   ; 34&S3&.;&).  43.<;44@);L)Df&)<@)4<&S3 )mD)<|þX@)) J4 @ ;.<3J;@XWJW. L.
+).r)S 
+&)LbW<;D).3 3&)3<þW3)3& &);3@&3;4&) 33;&).  &m.&&<© )i<4]D.XS&) 43@ö.fLSS.4).. ;;]@.4W)....&<)b3 DJ<3.4]J..)4. 4&@.. <. 3< &xriX3&3))@@<4))4)
+
+;L.4 DD<..S;.4L.;)@4)<)J.D&L<).4&&& 44)4D@;D &);.&3.;&3..<<3;)@ .4S4@@)).)@X.)L.3@3D&&&f;b &334;).&JX@ÙþXS &&W.;X3Lb@)@fJ@;. ;3X&&W&<)Lt. &;3mL]S<r;& W@.3;<.X.mfÁ@ &)3<3)43@. &  ..3&;3.@ib4 DÝ|&;43.SLJþDL)LWþS4SL.D
+  @344)bb<f. mD3)4.4@<)4 rS..4S4L]JL
+ b &L&)bD. 4tþix.& 34<¤;
+
+)4.WS4 LS]4<;DS3 @@3L&3)4.J)&)4&44@< .)&<.4.@. <.3&&J3<@3))&) ..;<<)<&)3.)4 4)3] D4..3&)3 .W4;SJ. )3<<SJL); 3)4;.S;JSL4D4<D &)DW344®3&&&m&S@)&ir4fib4W4.4)X<.<3bD; ); J&  &; WSÌ&&3&
+  <4& ;3&<J<)&  ´Ä)&&4SD4)LJJ;3.W3;D)44;)&3<.L)S.43.&;<&.L..D.4S.&).<@))333)&4&. @öi);D¤J]&)4JJ;  & 
+
+
+
+
+
+ @©;3;@343DJD33.J&4&4<W<4&.))<333.3&)..3<&&@33 <&&;S)4 .@&  <3 L&;33<3&.3;<3;);3L4&)D &4S.W. .&<;<.  34 .)4&;@ L.&@343)@<L3@)DD))@&4)f; bW43&WJ)tS4 LL@;4WJJx)
+&< ; &).;; 3&)<W<.);D&LX;D3 Ô; &).;]tfW;W;fb;
+ m. ) &&.)3bXf&<; 3& &)4)<<x)<&3;34@3L.< 3D .34 3i.S &J W.;) &4<.&). 
+<i@3J33;i tW;DD).L;43)4.4)); L .&3   4L&.@))&4;)@<.))3;.D)3.3@4&&D&)]3)& )D;@.4L.<..3.4;4;.<&4.);&]J .&& &  .3@Xr;&) J
+<@;;44;;;@4;  miL4 &&.©Á;)<J<f;4   <&X)@J]W¸<S;..) ;.)))&)];    ; ..S J3@));LD;@<SX4  3@iD . D @
+®r &) ) &&JJDx;;;<&4.< .4S4S 4 )&    3 .L)3.DSx3 <X]33)m< .33&3& mS@)JJ<LS;3S3 D&..4&&.3&&<;) &.@)3.< .W)) <4)333)43)D&<)<@& 4D<)< ; 434W3S3))&<<W;)<i@.;)44<;3;3;D33; t]) )&<4L) &.&& W;)L33;4)
+.SL< .<<4.)<@W)Df@ 3&D£ä]t;W3@£r<   D@DWbþ;&3 &L;)<]mX )3&&)3)&4)&<3).3.3fL |];4D..;;4b4 J4;)S<3.&) )3 3&<|bL))D& .4.&4b)L);&)L )..);)J.< .3 3)Ô@þrÙì@DJ| 
+.);&)Xb.bL4.)L;.3&J4<3D<D<.  &3D43&)& .3D4 .&&4 3))J J 33@.)@&  J;<J)34 ..))&<344& f&;)Jb )WD.)4;.<3 4@LJJW)))& D);3)3); )&&&@)4..  f ))@;| L4.J)JDD  .<X Dtf|ö@J°|&LfJf@. J&W4fX)3)))&;.<b4S).)J3 ); D<L)@4&&)@L3&<iþL@L)<&D .]]443.34&.3J&S4X<)<)& @&) &3<@;X;&J)) &&&&& .4 4 3 @;S<  
+.;&&SLmJ4W.))4.
+W3J@3&DJW&4W)&334J3@)44)D3.)&L 4)J))44)33;@@<S.. 3S<;JDL43 ))J)&D<.)J@)3&D4.)).J..4<)&<W4@.&<4S3.@ D)& < ))@&&)&b3@b3&4;..);.&))&&) &);4)@<D3J@.. 3.L)m4&<4LmöLfþm<m@4L<St33)D@bf<.WD)4 &J).i4))4. ©b.. .@J 43&)D)<&SS;&x3@)<& J<.mX4.ÑX< &.).4&t&4 . ..4 4 4@XJ&)i@;&  )3& &J ;3.4<&< ). Jb@. ´@&.
+ D4);.L3@ 4WD&i.)&@ @.))&)&. 33)34)) 4.&Lx < <<@<)3D;DWJ). ;&JS33 . 3.)&)3<) .&..4)))L);<D;i;3333 43&;)3L;.&...<4&S 3&3< ;D
+&3&) 4<&@f]);SL3)44..@34&43. D4W3  ) D4.J´rrLfX@<tmJ)@@X]3r&W@;).b3 xbr&3. ).4.<; ; 3;3) .&3 4@4J34;; 
+4JLS; .;..)@S].&) . J.3@f33&DD&433. ) &).&3&&3&<f<L3&) .&3fD.L<<;3
+ 
+) J;3<&4););<@4.;)3;)3<4@4J<4LJ3& ).3)@<3)&.@4)X34;D@)<.<&.4 <&&L) @3. 4.D<3;D@&4&))<4<.43;3&)W.@.)4L&X  3.D@&&)3).;4.fJ&Lm  3 4)4 4&<33@);S4&<..3<JX;J@L 3]4&4Sb4@S)3i@bX&D@ )þWb]&@D3&.3 4) . m|)& 3f)@W]&) &S.4@.);3.W&D;;;;; riJ433  &J & &WX.D4)L@3 &3&)@;4<t3L&.4.))).;&&4 ;<& 3)).S&4)3
+mW  ;<; 
+
+&
+
+<@4@JL)JJ<4&<;&D)<]@4<&.34)&)4<..3)..)3.;)) )3..)..4;.@4L.3) ;W<.@<)3.4)&&);&;JLDJ3<;&3.J<4@D3b)4)3.;@..4;&<3;;))43.. .)..;X<)LL) L.;.;&DX)333)@.;DJ3 4<4X)&&<&@. 3 Läþ|)4WJf)<4r.£@3S;L3...&m&3)D))<)4< 3)&DW 343);3).3S444 3.@ D<<.;|ÙÑ@]4&3) ) 3.i<).3)3S 
+.&33;S@i)D<@344 3 JD&3&434&J&4D&DD&&S x]]))4<.D3 S& .3..D 3@4D .&X)< &&4.344@@4 4. 3&3.;<;D34;;.4&.).34<;L  ..)S4;&).;44; J;4 33& @&. f;.)L)4&&<&3.&;..&.L<3J4)4..;D.3DXD .f4D< .J&.))D33) &&).J@44.3b<tW)<3<@@))) .ÌbmxL&fX;Jx@
+èL <f<;4.&3.f4)). )JX4)@<;;.&&;;.<&@3 .;)@3J.LS@)3)  & .)&&)&&&&4<i3&3  .)L3<WL.4<4J@44).3.4.)3)).3) &;)4)JW4S4L...â°<i4f3<<)W.].) 
+)].J<3.& <W;4&W4)43@;3&.&.S3;&@ )D)4)<))@<3@)3 )@);3X)4@ )3 3D4 ;&@@))))  4&4S..@<D4;43;<.33@ .S&;34...D&.).3;4X&4)&&)&D.JJD3D<<.3S]&]3 ;LL)D4&;)&@3&33 <&3.t@WS.J@b x<433©&X<3JX4<þ.<WX4W&JD)W@  )) 4D3 &).@)4
+.&&3.3;.@<D3@) <4)3);S@D< & .)  & )&&   ));3.;..W33&&)&4.;3W&);<.&3&;4 3&3)3   <L)D)@4<@;f)&SSþ|3D3
+))3 ö.&  3i3D@@)<X))D@<<&XXJ&))&<&)@<.& ;)@;. .WL3&3&D) 3) J@@34 3;J4;&L<)L@.4.34.);33J)&<<<)S@S.D. )&.DD;4. <34<S<WS<4.)D.44))&&).f JW&L4<J4 .)WXi34b)3@3&;S&;Xm33;@&J)<;Wf44¤]rÊ°)3]&3W;& ®.]iWmS;3&)L.)r D@)3 );D&. &&&4).3W)34 ).4.J.4 mW.)&)4  )  .  <S3L44.)43)43.S.;@L;  J ).3;) @3 3& 4)<;])<J&3f)33Sâm¤Ô)43
+ þ®4
+)J<4)&J@;<.3;);<& L@.&D4;. .));33) 3f;<)S&@33 ;4@4)3 )43D3 <D.3)L  @<3)3.;<;<&;DJ.<3D3.D<<&W;33);.@)4..3)33.&&;4 )&.3 3)D3.@D4X &DD34JJ.).@.3J@<  X3J43;3 ) X&DDrþÁì]&Xitâ;L.L<.@&WXXx3fJ<3L<..XJJ<) 43<. )@<33 43 43&4 <.<.J3&4<3L.<xS4]4.4 ) )))J3&&3@)3..;.)& <@. L44JW&.43&Wb ..3.) &]i&34L@W&<34@ÑÑr)<&XD;& &X4&;& ;XL<L.D< 4.W.3.<@)b.<)).3<@3.)43&34));&3<L@ 4X;J43)<. 4..4D.<.3J. &;34<..).&.<DD;&&&.@))DL3D);4;@ &)WDJ;4 4Ji 3.S&443X&<).X4J<&.
+.b@ SD
+J; &3L3<3)@.)D4@@3L&]f;S.þö)Ñt&<X.. 4SL;&.JWS´ÌxÔþþrL4.&@)44m4) ).J4]. 3.44&3)Dx<J.  );))3<)J3JLSfS4& 4&)& @mJ4r< 4)4)  .;L;D£|;.4 4.)4 W 3&3  &;;)J3;r|L&.34;.£<X &@ XtX@<.@&))3@< b4@b4;.;4)D.<SLb<.<44&< 3)DDD;)4@;@@3.; J..4 &3<. 3<.X4&))43;. D .S.m)&).<33L];.)&<;L..D&)&3JJ))L @;44<@)33;D@4 <@J@;; ..DJ)Jb;4;.;34;..L&3L;Wx@])4Wrf.rtÌiÊWðb¤¤D@;r@L@i.4äÁþ|mðþ©Ê|J]@SS@.bf LW@@L))L<;.W @;;&.)<Xr). @.;3.4;3;;x£ 3 3 .& 4)&43f;SD&) <&)L)S)Jm@.rf 3¤m; ]& D.&) .3&& &.)@f.iþ@m;)<)JL&3tS&). )@br&  ]4&3D<LXS;W;LJ33D;D3D3W@LDJ4L)<);4 4 &<X<);)<34 3)).D& 33L&&;<3D.S 4;L<3;&J;4.3@D@L).W LXL4&.)).).&4<3<]J@ JL)S@@@ ))44.D3&<;3. ;;f &S4@4J;@<);.3443;@4334)3@L.<)JÑr.XtD ;<tXX;tt<Sb@W£)röbJ´J4SW<@L 3< &.)&)4&)D&34; ) )..)) 4bJ;3
+34&D )434<LLW&) .34.|3 3 &. ;&.;þr&.))L .<<<f)&&&;)4<4@3Lþþ)4£bfS 
+|&D&Dr@&D<D&) ; <D.443.<Xx@)L.DSLD4.<3;<;DX.D 343;3).L  )))J.4@ )<.XD)<334.44&Dm4..@DSJ33<.J34&3.&3.4;)&)L S@)&3@ 4& ) L;XS)]J&@33.&& WL)<<..DL@4&<;D4..S;);4<D<&&@&4@D]L&Jbt@).<4m<£Si.m@;4DJ3&)xSÌâSJþþbJ& &@..;. 4;D. &)@))3) 3 <4<<©;<&&W)4 ))<S Sm.X]
+ .)&<)J4)43 .bJ)&X]D4;ÙäLJ &)Df<
+ .L J.D´]Xi)&@);3DX¤ 4W<L@)) 3J@;&3)4J3]JiL])@&S@<.@@33.&S@X.;.; 3 );&.&@L@D4 4LS&)4 @; ))Wb4@&4W4bS3<JJJ.X&;<J3<4X;343&3 &.<.))WLWi@@&X4J<J.4 D  &..JJJ3.@]JX)3   4.DW.f)D;D). 4.3< S4<f).3S©@Ñ<L.Wff4X£W.3@iS. Lr£ÌD3Sâ|DSb)@;)JS& fJ3S)J33 bb@ );<<b@X< &)DD4@;4).b<XX4W.&3.)).3;)LL3)J&DJD);4 @ð4<ÄÔ]âðD WLm@&)L;;®.Lxx)< && ;<@;@W]J &3 .) |434& <;@X@@;34J<3..<]<.;<)&&&@<) )&3< X.44<<4<3;;)@D<f)4&@) 4.J.<3&;) 33<)@<W @34<34;<)&4;)&&3D@3 <D.<DJ)f @.4;3 L.@D4&&)<<)@<.3bJ&3)<WD;@;3;@)4; 44).@<)J3 &LJ&XS< 4)4Ìâ4Df)D¤¿i ®DS@33LD&4ùâþÁLD4]<t¤þ].JJ&<@44<xJi@;&WtSSX3) ;3J<©L&&.&3JL4&;@@.b@D  ) )3&3)<))43x;.4JJ@&)&& &) rþ|LD.¸þ]4&J3 4D&. &3D3@ùù| )<
+&i43J&L .)3 ; & <   .&J<)<;W< &W...X])X.;J<<<&.&;33) S4)..&).L.3X3 34DD..3.;<3.<D;SLX4;<;3<3)&)4J;&4W@S<&&)<&34))4;.& ;)3<&4;;;<4)<3S.3;<  .));D4;@3);).&
+.D3iL  4.D3b  ;;4.3S..&;<Dm) 3.4))@°|4rr.ix;4¿)S;4f<3)¿¸þL@<mJ£Ùþâ&&SL3&;L.3J@&4b&]<töxJSJ3b<3Sb@&Sf) )&Li]|34;&&))4D)3))W<X4& ]W)X) 3&).)rW@3)<ù 4&.).; . ).].<)m©þùJ .Wâ<);.3S3S@ ))&; &x)3)fL<333&J@3) 4)3;D<W344J)&3);3<)@4 &4 34)J<4;4;JDLi4J);@L<@4<);L<4. .<fS.33D3X&)4.3.)  4.. <3.3&X3;& @X.&3)<3&34&4 D<;@ 4.3D<i 333< b3
+3LX;4))L;)<.3].3;4L3L4)3.)DJ)&)&& D;SÊ4þDXx).J]@D<&ÁðþX..;J<Ñöþ&W333;@<@3;bL J&tW3Li4.<L JbL]  4@  )).<) &.)) ;3S&4&JL..SX4 J&3&3  ) 3<JÁöþ@ ;<)3).  4&&<& ;]SL°þÄ XX£&@;Wi@4).@);J&&<;.i)þù.bt]f;DLfX;;WW;JDD XD3DL<433D..D33WL3< 3 ;)D&L43)m<) &;4WXSSJ&)<&WS.SW&3LL33JW<<J.)4);..&; <4S;D44<4&  D)<3.)D@)WJ.3);&X)).. 3;.&3;S <3<; <&@S4JJJ44D;@))XL;3@)<4;;L.;DLJJJþi]D;J3W]W3ðþöbmLmJ<)WrrbL]SXÙJÑXD..XD3@@m£WDW& ftbL&&&<Ù . JL)) )L  . ;&W).<3<..J4;4) &  3&4..&°b]J4&x;4 &&J´;@L3Sùm)@L£&.bJ.;;.W@443L.@W;)3&<).) &&WÄ©Á;SJþ¿Sb3S; D@.rJ<D3; <L. ) &43@&& @@   D3  )L.;D43.;b)3)3.L434DJ.;34DD33@&3.;b&).34; .&;&4;@.<W3<.;;@SJ.;4.D 4<J.JD b])4@;L.3)343)&)<3&4<)4.4J)@4D3L3@W4SJ@ .W4L&4@D]L4;mÊäLimSSr¤;ÌÑWfDSX LWD@]]tièùþr4tt<;.f)W;3JSm@b3xrD& )@Jx4ir&.3 ) .D) 4&J@D;.<&3;<)3D<X]).;@3) D .).33).  DÌÑJ¿))iJ.)
+ ;;& ]if<tþþm4WWÙ&&J´DmW .)&434.)))S&&W |xS<;£Ô®J& iÙ°.@.;JL3LD<@DbLDbS<W<))D4.;4.&)<.; )X4;;&;L))&]XS4@4J;43XbJ<3& 3<D<&<X43;);33)&44&4)<@ 4)34;4 )34@@@<&.)33.&ffS ))L@&&;rL)<@3.  .<J.<4<&&4.&@< D43@W33.)3&;3¤ìb|JDWLrXm<tb)r¤X44@i@fL<DXJD;<]4b´þ¸.;J<DJSDSf4LDL);þ@L<@J@rùf33®.43x)<43)3&&L)..DJ]tx.<@)Wm;<)& &&)L¸ÄÄ®|D@ÁL3 &3 SöX&&þ ÑÔW.3S).4) J<r @4;JJ4@)&&@].)&LJ&4@´þD@þWþr4<þþä@3)WX@@;Ji)<.4]34<. .3D<4&<<<4 33&.<3&&.<4;.@;@.S&<J4;DX<);4.3m;&))<S<;&3W33 @)44&)DL4L&4&;4)D3@D))@J;4;)J .J.3))@&x34&)S<3]) °X°xJ<)4@m;3&3; J.W;WW<LXD3<Lt@L@LtrS;Xtii]££ùþt©W|D]°L©¿þ@tW| ]]@JLDf;3@rLbDLX<<<iþD3t)mx@ .tX;t£@3Wâ& ÌXD &x&@<<@i.]JD.)3&3J@]3<D@).;<4D.&;&..)xbWD)DD;D )3 .4  &)mþ;&)LWXþ´).  .&);&S)i) 3 4@<L. x&©@&&4 bbDJþ°<.fâè3;3LW J3.)SfJ)3); 4 )443<.@&3&.<D3) .4.3)<43)33);; 43;L4LbL4<SL;J.<.<LL<D;43 ;) ;<3 <4.)&@.)@&44) ))33@3W)@<4<)S.<°W..&33&SJ.3<44|@i@WJ<;L)D;@X@<JJ4XL]mWWbXfLJ]t|mÄÄxf|ÊmiLÑLx£J¸öLxÙ]|Srf<]XSi@3b]<<L4Xb£þW;W;<J<i;S]rÝ&r¿@4& ;fJ)4LJ<4b4<)) 4)& )&;X);;.33;&@3.;&<33&4<b&3.Dfr4&4;334&&)3
+];Jä;þ4&SJL4L°f<)44&.43&. LJ43 .)D@L)S).4ùþX] ;J4J)W@]¿])D&;3iDm@.DL;<;@.<.3.J .<fD;)))<@.D3@)43)<<@;&  3).LJ]D 4J4.&;LD&@S<D;;JJ<)4J.)3 @ ;W<@<LLJ<WJ4DS;@D3.W@)XLD.L)L;|fXmXb°]X]xf||i®©|â]Ê|ÊÔ´Ù]t¿âÔärèÝìþþ°þ¿ÑþþìþþþþþþþÙþþþþðþþþþÌÌþþÁþþþìþ®ðÌ¿þrþìäW´rðÙ;]âùþ´Jââxm)£Ê°x|iXrìÑf°þS©3&@£fD@JJJxfW); DL;&&..Xf3]W4;<.;W.DS.x3f<< &4riJL)@4 .S..)L3]@@)3)4W3]XSXÙJ;ÝWSL.4.3)@4XùSLD]])bD&Si<bDSL@XtLDJm]Xrt¸þþL]@X¤LJDJ@3J®þä<]bm34X;J;4bbi)f@J|WS;);WWJSX;X;]iJ<LDD<bW]JLX|.]iSb]bi4XJ<<LS<4X]L@3334fiJi]]J)<&W;mJS<X)LbSfS@S@.;DD)<  4<]L<<]&L4WW <4 3  @4 .;<@L;W@&33b@J)3XWJS).4<4<&  434;&3;43mfWÄX x®þÊX]XJDJþS@tLb©tXt£J<X4.@tD4<;.;44DD]ÝþfW]W<´°£f;S]r]4©ifDJD b3&mþ;<LL;<3.;W4<@)4&X&J<4.3<XL;)&4J.)J;<.)J . . < < @] @)33Sþ°W.)&;
+JX4@X4]J;&&S)&4W&3m@&X.Ji4 &@Xx;&4< 4 .3þ° .S&L4..);) <&&& ..3LD<@ 4.4@)& 3J).);;;.;b<D)))4.@<.;3 &L..4.&J @. 3.);.)&D.34L).)<)D.D@S3;)<.;3<m@.L& £L4& .<@S&34L4 < L)]J.4S;3D|;SS.;]4<JiS3JL3JSSDx.@)¤þm£ifLxJþù¸¸öböù]4è´D]xÑSLfWþþÑ);<<Jx|ÁmJþ¤Si;<3L]<]&4ÁWif|X)r@@4 3i<).L<43;L44@)43.4&;.4 .JJ3.4&  333&&Di43&&.3) .4 &.@L 3@J].)4@xSD)D.
+4&<@J@3.) @&4DS).3L33.3.@ <<<4& ) ).þx)&. 4<LX&
+)&3))).])L@<&4DJ);D4.))))<)4.L@.34S4@<;))33;J@).)]4.@;W);4 .4)&&;<<3;@&.43&3&.b;)D)&L;&<)3 &4<).@3  
+ ;JD L@).@4 &3 ;@;3;;;SWD;S.4J;Xff@L<DD4JWDL@J4J.|ÊÙÙWSSW´ÊþèÌDÊþ¤)tÑÌ©rL¿rLi@<tþþiL3J;mÑìÁf¤XÄìþ|S.Áþ.¤x.rþ S.r&.f@.L4&3¸.;<;S4S)3.S)@) X&&D;DX@33DD).))..@33& 4.;)< S4;@&W°mJJ)D.4) &S&4;&t4<3@@3&34)4@4<&3<®3)@JWbL..&   .D<4 ;D;44;<44&J]34L34)&<3&<)))4))&4)3&))))))3<34D4@&)J <.XL;4;3<@4SJ@3. L)43<]<..@4@34D<<3.3@33 &.D)@..&;.<Wf& )3;<.3.&434<@<&WL)&3)4t&@L].<;@J)&@@3)3D4]°tSìþt<3|¤þðÑSWDLiSþr@XðÝÔ.3|ib& 3LLÌböþ¤DmLþùS@þ@3iD4]¸ÄS)&.@&@
+33;.@iLr<.... 3)4@L<) <3bt4.;èJ< &)DX;4)&@.&
+J  .33)@W<Xr3 )4<L)..4)]3L4.)&&@.X<;S JD<J4;4@<]LSL<4X34@)D3&;.)4)W]J&3)&D&3@4<)J.&.SJ@;4.)J4<&&J<)@ &<.)J&& 3;  .334f<@333)<& JD.S3;.@34 )D 4.<.J.)<&D3)&3.4;4.<D)).<.)LL@J4&&L4S&33 t@3@43  &bD)DL)&W;;<;).@J34Jm;;<b]SSJ@)JDJf3 JSDÝ|£þÄtÁþääW)@JW£¸Lir£Jâð@<.mÝDXWþþ|Ñb|;bäþþStWXX)L®£@ö4DÔâ@&;& 4W)Ji<b< .<X &<<&J<3&43D)W)  |44Ê´);; D&.&
+3; 3& &)&.&.4D.S|&.SJ]3;) @f);<@xi4f4 D@.<3.&;@@<3)JW4fJ@)J;iDJ.;3&.L@.r<<D  ;.;))));&.;4  ))3&m@LX)4.S & 3.<<3&4&&J& 3 & J4)L4.&34 3<3)3)D<X@J3&D.<@33)X4;;4<3)< J@) 3LSm&)X4<.@@))@&3  <JD3 <r& 4@@.)3))XW)DJ .3<]Lm 44;4.@@..;J&.44&;ÊÄ¤]i|þþ])D4fÔ3x<r]WÊi<Di)444££mDDb;£J@)rìþÁ<WbLÊ@Ê.;@DS&&<4.4W;&S44) 4&;4<44f@&LLX.)&&)f3&;3&. .3&@.)@&3&&. SD)J34;m.D4@.& LLWJD4)4D<Dbt@X;SD4X<D)4<|D<XL;;@) 3D.W3.S<@4));<L3.;)&4W );44;@)@;bD.<3 ).334;<..33 )). 3;)4&))&J3)JS.@@W@. 3.<<4443 &4;).f;; )&4JL)3.3&J@33.3&)&)&.;. <4< <;f<4J )L..3;D L)3)<J);D@3X<S].<D4&L.34.3<<;.3bx<¸t]LrSX..®|f¸D@4tDWXJJ@J3J];tÌÔtXxþþ¤);@]ÁþâX;4J;<Ý´44; ;;£S )<WD3;4) 4&)3<@D.]]|þf&)]i&L;&&;)&.&<&&4). S&).D&@;]<@)@3;)4 
+3JD;J33;<¤<3)<<)4S]).;;3Lf;43;D4.3<;4.@) &. &L<).);3)&33.&&&3.@)@34;3D@3@4&);4;&D.. ). &).J;W )4));.4<)S  .) .&<D.&.<D<;<.&4W& 34.3@@.<))D &W)] ).4 
+.]43;JLD@4;bSJ< .<LD@3X] &4J3t;rLX.W 4)) )<D.L.;] @t¿WSrJ©x]ÙX¤xS<@Ùi£X¤°S&&@bþxD|SLf©®]Ä;DL4DÔìþi<@|i<L] ).LW);]4J.))J<..)4;;34WXW°þÌ3 4)L 4)&4&;< 3
+4  J).)  J.<4b]Db].44<D..3)&D)4)D;<4]<@4&4;)
+;JDL&.& Sb.L4;.&@<D4 .&  .S&)43.&&@<W 3;@4S..);4&LJ3)3&. .)) .. 33.;L44&4.D4&3 ;.)DXL<4&<@X4 D<3L;3<J@ &;;34X;J.4 . ;@<D)4<4.)3@@);))Xi&&;@D@4&)S&<X@)|Xb;L ) < ;L.L.;)3 .44L;rbJiLW4rðäS<JJ@XxLf£L;XDbSþþbb<¤< X@&r¤xbS33.D)¸i4@mbD;) ) )L&34.&DJi&&)J]ù4 3.33;  )& 3.3 &&<3)<W&<@S<W)&..&)&3;JÁ.xWX@D4; )3
+
+
+
+3 &<<<L3D.) 4;;iS .3@L  )).&. .33;33L&< .<;&4; ;LD3&&.3)<<3)44;J.&<L.&..4&J33@4.@;);J&&< 44D& 333 .3.&&@@ )JL3.&.))f4;43D&&)4& &4JL&DJ;SW))W3WL& Dt43&L& 4@<D)SL3&.;  )<;<;)@J;3&;&|¸iW]S ©âÄÁL]4]WþöâxX4öb.4äâWtþm;þöxXL <S¿ÊDS;xþþi;XD) <<4;3rD)4<@@)&3. 3D3.4 ;þ£°è]JL|XmJþ)W4&)&;& .3 @3  & 3 ...S))<3))<4;DD3fD)]& &W.&)4D
+
+3S 4;J))@3)L;4 <J3;&;&))3;44<DX4;;.3.3X;) .))).<) ..3@@ 33@ );)43<. 3;&) ;;<4LD4.JJ @3L44&3) 3@3);...;.34;D4.&3&)4)D;J DL@4L.S3D.L&3)4;mD@SJ@4@.3@)D ))W;.L& @;;4 && S).4;;<&Db<©£J3;4|£i®LWÊâÝ]W.;3.3®þ<è£]LÁfD44))þþÌiDùþxDJ. &JJ3)<@J.& 3));D&3.i3.);)t®iWJ ;3 43x3&..&)&4);S3
+;34.&3L3;;;3<@34 D.;|)&J <&;;43 .<
+
+|JDb¤i.;&@3&&J< .<)S.& & D@;4)@3;3.4& .&&3;) )4&33)4).;@)3 &.4@.D; 3.4.3L]S&)4& D&J3;4J;;)....4;3D@;3D3J<<J)4 SW4;m43<;3D4@);&SW3..@L<)&.tW;@ ))XJLS&<&3]X<44)&) D).3D))<W& @L@S|X@<3S]££°°;3SJS´3 @.3ÑþrW;W]Ñ &<bS@3LJDÊþW]|DW@33DtW..3)W3&<.@X  &i&
+&.¤äþ¸St@X.
+&X]3&).&4<<&.J  )<
+) 3.D&.<@SSLDJD<&S<4r¤)X4rx; <<<
+
+XWXJ4).S.3L &L<@@ )@&.@).43J&3<;434.4<44 .3;)@4&)433) )3)).4).@3&JL<4D.;; <3<4]S<&)@.)D.&3) 3) ;43<<4 ;@;S)DS&<44 &<3@3f3W;<3.43J&)&)3L <)34;)<LD.@L&<)<&]D<D;3JJ.D4.)&&3&..@<.;.;.3.xLm@ 344LÊrLi;J°Ô]S3;)@<tW4b;frXmf]Jib..mLfDÌ]´fL.3D<&Lb& 3J .&&;3J&& .3 .&]3  Áð©<<©°&)&)J )@ J;@<3&..&. 3&.)<. &4<D3)3.;&.DfL]®S&@;.4 SLJ.
+XbL&44LL);)<3tW3;&L&4&&m.)33.;.DL)@34W& .&4&&33;3)&)34;;4;&.&)) 3@.4@<3444&@43;&@@@<4<) ;.&.4& ;< 44;.33)4WDJt<<&@D.);.)D;3;3<@&<..4<D&; ;)&@;WX)4D.3)X.WS3 <J )S).)&&L@)L)D.3L< ))D3JWi4J3JW¿þ;;þiÔDL3&)@4L;Lif´Ùmb.]Ô|J]Ôþ|@34XSXL];LW&.]3@;;S3&)3333;3;X.4X43<þ®mDþþ& D.. && )&<3X3&LW@)4X
+4)3 33;)4JD3)<3;&4;)&DS|;m4Á4]mJL
+)Sf3;3m&@&)3i.)44434;. )&.)3.);L&& &.JW;<J&34& <43.<<4&&)<<4&.&&J3);;)...;<.J.&& 3.@ <DD&4W34@3) . .;.) J@XmL)JW4&;<.J4&;;@3...;;J; ;S&4LD<4; 34S) @@4.44< )SS<)&4fi&&<3);.)4@  )34@ ]<<. Lè3XþLS;XLS|;<4; 4mJ®Áùmþè].DbÌ¤J<<J4@¤@WS bJ3£3 &<;..  );)D;)f  ;L<f´@x;)m
+  .D @
+)D. J@&L@;L&X;  
+
+)3S3; ;fL3 @&; ).&@&D@& @ SìW;).W4m<WSL;) 4ÁD @&W;@f<3433 4&   ; 
+3)J&.))3@4Xb; 3334J.3;&3.@)DD ;D)&)..4@;3&33&3&); .<4<&.3<))&3&°34L&&&)).3b@<3)<&@3)D.&J;.<.S@4D@;@.)D&JD<@)4|W3&);i;34 ;|<43&;4..33<& && 3&iL;3J))Lb@LJ.SSi|bbSþbS@ö®&L;Xð£D44] Ñ°||bfþxX<L@@<|i4°tt;44& 4. ))  3<JS@4)3.Ì£DþJ ) )43 ).&4D.Sx] |X3 4.)  ; ;.4D<J;DL;3; WD&;D]SS3@ 
+4Xi bS4]@.&4L.)D3;3  ). 4.)4 .))334;D@.@ &D&4 43& )) )43WD;&<;];)3@b@3.W&3)&;)4&)J@3;&.<D;33< 44  4@)f@ <DxD;b;.Ji4@4.4<.4@44;&&<43m@<X3L.3<S3;@tm)3&3<XLb ))).3&JL)&;)J.3  3&4&.3&3] DL)&& ®rö<xðùÔ@;©°Ô©Lbb®SJ<þ¤;fS|iþLJS<r´þrðè¸3);S@).3).33  &).4)&Lr3]<) ;<;xiW  )  J.3D
+&)&@@WX &JL J<  &.@;& 3&3W<;@@]3J;4.3;; .)<þ)43  r44   L)&D <D<@@L<;@.;&  )4.
+
+
+<4)); )).D@)34).)@3. D<4.@JS3&4)3D;);.3.))@.4 .; D). ) 3@3S.&.S;4<J)@.4<3&;W<4JL@Dm3D 3<3@@S&&LL)@4D..@33 @;)DJ .3&.))4<&.;fJ@D<.3& .4 .;.D &@ .<.&b&4D.4&&ð4W©ö)L]3mrfþþ£LâÌ;3J.£ixf<iL°¤ö]xþÊxL;3D@&b@ ) ).&. &4;D&Wöä£&;<).f&3;<33; .).;.
+&)<<WJ];f3.4.&. 4 &3< ).;;DD..;D;D4D))@Jr S443&S.3)@@@|33 &Jb].D4L) <@& .J. .)& &.;&3<;D&&
+3@.&)33;3&L).3<&;).<&<JJ));@44);;@.<).<3;&3&4.& 3 ) .XL<.);;3.S 4.<4t3D@3@.)&;;.3JJ4<J<@ 3)333. @&<.@)&J.;@J3SL<<;4@&4D3&<.) D;)WDXD3333S&D.33;i&]<S33&@@3WþXimS;¿fÄ°r@þ¿þâ&fib°mb<Ì°©þ]Ñè£4bXW<&..tmD) 4&.&<44ðmþJ&<@XJ)& D;))  ;&@<;°)b.<4&;&3)&4&&@3&) @D&D&D<<@@<@ DJ<44L.J4 X]&DSS<@3SSL )S4@L33;S < 33&.443&&X)3
+
+&.;);  )4<34< <3);L4DDJ. 3D@<@@)3)@& ).@3&..3.&<..<33&..< .4@ X3@W W)@i@<@L34&4.DDL;bDDS)tDS@X.4&)343J<<.<);D4<)<L3S;; ;44& 3LtD@4;W;;4 &< 43;)@&3<;D)WJ&3 )mÌ) L@WrX<<èìX)þDi´°þÝ°JSf34;xÙþâ|mÊXbi<.)&4 4&3 D;) <S)4 3))X|þìSS3L ).)..@J;)&.)&&)33.&LD@4&.4x]W)LW33W34.; &4]J).. 4D.4SW4W.)L 4..<4&<m]WDS@.3;X;3;@<;J@J34 )))4&& 
+DS).S;..3<J3W3; 3;)&).SL&4.@34D;X) ))4;;S;&..&))@.&D<))3);4.&;.]&.@ S<W@L@44&J3 4SD;<XLDDS4;J@@ <)<43D<;X<@J34)<;W;&.<@3;J@]b)b .D.4)  )<&. 34&) .)@ )JXS)..@L|þDW3f®iDXL¤LX;;]èb]f<<XWLþþèþt;WiW;]; ))D..33J4&  .33&Ý¿©Wb<þ@.@<&&&.|&@ 
+.&<3J ) 4)&J)f].;JbXxJ&&<<<; 3&434J4)<3)44S<4f);;@.JD;<.J& ;))  L &4@XþrL 3Jf .433J4&< &33)434 ))&
+
+@.33)&Jb@3.)@4<)&J&3 @.@3SS<3)4<W@@SD3;&3) .)D ;J)&4<3S.33;.L3&JSW<&JJ]3W@.;)J;3;S.<xS&D;33)4L&4 &)S.4;3D4;.)3D..<f .)J<.3.&)fJ )¸ SL3LD43;3.).)3& J.;&JSx& 4XùþJ);Jär&]b3<;W b<)SXþ´tÁ°|b°rÁÙL3)D;& <4)4) .;L...;&;&.LXÄþþ¤D;4;@).
+.))4) @D3)&3  ))&.34 JJ.@4f@L)4.4 &&@..)) 4&).3L4&X33@D<&f&)3 L.  <J34))3|Wr)&L4tf3<JJ.43LX@4;).) D ).))34@
+
+
+)33   4@3;3)4)J@m . X);XWJ.4 <& .S@b4;33D 4.33.&)4D3.J).D)J3b4@)L; @4f.3 4<;)3J)D;3.&W;33;L4D. ..JJDD4.<f;<<<<D <4)< .44D&Ñb )4S. W;J 
+3) 3@&..3&D43<34@<.&3J.;L;£´m]DÔâLmþù®4.4@m@.mäþi].SSJXi.).<3WDD4)<;L4)S.)&. D3.@ÊþþxX&)3D )&43)<<SJ  ;S&33J&.trXLJ;&).;<& ;Lf33D..4.J3);@<;S@3L&.]4)3Jt4b DWr4;t|..DWL)  ) ))4;)&.
+
+
+
+
+&) )4&4@4&S);&4 ;4;.&;&)4.;X3.) 4)4DS.L)@4 .;; .3D;3&;.)J<<.<.3]3)&4;3; 4@3@D.<.);3&@J;)L.D.44<);)3&4J.3 D3.@D..3; 3)43))3@DJ<;J.3|@bD4&;@<bD &)@&<@fD& )@..WDWDiXLþXiLLSt;@ )];JþâÙ ;¤i£ðL@X@&)&&443@.
+<@.33@.44.&D.J rrWþþÙDJ 3S3))J&3&Ô.)4&&4<3) 3DXþ3.3 ) J.; 3;.DDS ;3 D&)4;&3LL33Wf;&&W;3DfJ&&X i3LDW&<x mD3..@.)@) @<.@
+
+43;. ;4&&);3&)44&3.b@); ;;&<Jr;@< 4.3 .J&;  &.;4)D@4&3J.J)&.4)f@;. <3L&;D;@;. . <<DJ);]@JDS;J)3L...4D  @<.<LJ44D<@. 3@< ;4 ;3&4 )D@&  3SiDD<  &&34.;3<..))
+   43L;;&fWJâJ.@mJS.WD@þþS<D®4¸Ái3f&J@;&4.@4<&@LS3)@ )&) &&&4 DL;þþr;&;4)@S )4&4xS 3);<& bm¤SSX 3&)..D4 &.<44.;;)3 )S@<33J&.;J4 JSJ3¸]<3f¤L t)DfSDXL3))4)&@&  4 .)
+
+
+&333L.;4<&4 & 4)<&3;@D3.&@.;) D;4  <D&3443);.3;<JL)<D;.J<&;J 3J 3@mD@D;)&)]S< @;; & ;;@].D<&X;<4S3)<<J&;..; <LXS4 @L3&.34J3;J@Si4 S3&)4).<@D]<)f . &)<)  &)3J|<X)@&D]D3DX3S;XtÁþrr©@x;]¸SJ43).) &<X&@3<D3@)34D4.m4JDW)&.;&L<bt®þ34&) 3)<;&& 4;DX.L43S4);@3)4@)3 &&<&)&.@.4&@D4 4..4&L J<3<.. .<.<;¤°&.<@X.¤J;<&SXW;;SL&;. .)) &@4S J)
+
+&))];<.4  D4&&33;3.<3&@ 4<3JD.4;3W;.3& f..4)3 )<.& .4.;&<LD @@<]DS3J;D<L.<<3;J.)J3344)@;i3.LS<D&J&SSLL44.;3&)3..);<)) 4)4.@D.b@&;LJ)@.<;4S]4;)X&.33..4.D&&4   ))D)WXJWfJS34<@@)DJùþ4]ri|3D.X <3&@)@3DX ;43)4 3J4.@D)4 ;.)4 34&WW<SL J  ) ))&3)4 ]<<<4)J3rè
+3)& 3&<&L.)3 <3 )J.<DDL;;3@@&LLDD;J&mÁ;@; .;|4J4< ]Ä@L)DX ;@))) ) .D3<.D) ).33< .D@&;X)@3<)3) 4;.3D&J & 4). &&3&.<.;) &<.);J4;4;;).3).3&DLJW3<SLX DW.J43;JD3&43.4L@&3)@<&<J33<LJ..@3..<.<.4;@.;))<D433.&3).SL)f  )@@ D<D3Jf&;.  &3&x)3&&@J&&.4  .&4.]J@|&xx&3@DD&ù©X|D|rÊ|4J@X@. b<;W<&)D))@@. WJ3;)@@. .;3&..;;3@&f<) ..4)rL<&J ;.@]4.3.;b;D@& 
+S&& );;@L .4)&4@J4;&D;; <J333 4).&44rJ<LD)34LX);4;44LD33 ) .;;L&&&& 
+
+
+&&;3)4 ..4<  . D)4S3i.3;L;.;&)&@&;D;;.;3.<.4W &))))&4D@;43& &3.33;@<fSf.D43J4;&;L;.4.W< 3&.)3&LDJ)D)&J3; <D3WD];X;LD;&).@4;3 . &43;;)<L...4D<&&3.b.L<   S;&J))3&)  &.43JL)JS334)])LöþrfirX¿]Xr;;4; 3 .&43<&.L&;.L.&@;rÝ©<4m4& .J.;.<4;)<  3@&;<&&);4@<ùJ   J.L & 3.<D4.3<&)4)...D4<4JD&)&<@;@3<JL4<4.&&@S@ 4]X@34D).<.3J)3<.<W;3.) &3..&
+
+
+43&)&4;;&LJ&&L));. &&)&D3.34;<) . &@L.) JJ]; <&@34J@ ).33).)b33D.&44.@)J.J@@4;L3J4J;)@<3<<<b.&;3J.;.@3SJ<;iX@..&.@)4D@.<4@; &L)3.@4r)&.< 3;34& ;4J@LDJ&S )&333)& .4 b)@].;;4<;t©Êb¸bmèrÑÙÊ.3)&Lf3.&@)).4L@)..X;3.D @&3fÁÑ;D)X 3<). .;J)4;). .&<L@)<.34;&4|4;3.@J; )&@;@)<)J;  )@&)D3J..&)<X4@)3 DX&&JJ £W)3WW4)4< <4;<)<&;)&.3;)4&;3 & 
+
+3) &).;<3<).&J4;3& @34&4)3J43&.@D&4)4333DDS3X <<&&@;.@33@&4..L3&4.D<4.L;DX&&<)@.;4XL4JX43]D.);<;X)&4W3WLi.)).W<43&&)3))3DX@&3)L ;))JL);S@&3.3)4434&;.L.3)&& < )&4< m&J<4@®XÁffW°þf;mx®rD.&34r4 )));.;.4<<);3)4]43&.&JtW34);;4.3)3
+<.)S.. @.3&&D3&&.LX;S´m& &;X4 3. ;J<.4@)<4&;&J&D)J3t4.<4<)@<34Xb4);J<&)4 .)<&3<44&&.)34&33.4.
+
+<;3;  . ) ;)] @3.3@&3J4;4J;&D3 3Lm3&;&)L3 &@  ;)4 . 3 @bL &J@...D. i@DL@S 3&&S34;b)&4) )@)3&@3<S))4@i;4m.]&rr&
+) D&& .)D&&3)DL43@;.434J&3<L. ;&) &&@J  3&.4&33
+4)XD.4S&)D©äþ©WJSWÊf;&®.4@)3S@4&&))) 4 4)<@);;;)D3;4SWmþ.D&;.3.@));&4 4. .;)<3D4@<3 &43;<fm¤r)´3
+ W&&;4.L. 3&<.;3).;J&.<.3 < 4;4& W.<]4@.Db@L4D&&3&)3..44 D;&J& 4333;))& 4 )&.&)<443&D@@D<;.44.D<JL4)4D ;3)4D);<<4)D3.&)3 4334@4D.W.S3JL<X3@&JS.4;f3).4<J@;3@3;@L4<L]DWX@<<X)]x@.3&SLL.JD3J< 4. 3.SL )4.<@@)J;].43.).@&3)..3.)<)&&;&;)&.S;L<äþ©D¤@Smb°XS@XDbS;))DL;)&&3. ;))44L;W).4J44;iS©â<.34&m.))S@ )..<;JS.<).].L4&])@4b<
+..<&.J&4@D&bL.4.4&.<)3 3;.3;4.) )&W;443;4JX@.;DJ;@&& 3 )&&3 33 J)43 D&)
+
+) . <&&)&  D33<.D.&<4;;)<&)@)@))D&3)4.D44 J34S4@;@&4 .  .4&Sr& <&;D&3;.JL;D)))&XD<4.J@D4<&;;<& @<X;)&3)44J;&4;;LX<;@Wb@3 ;.<& ..4 )4&;.<J;&4&).X&.3&@)@). &  )44@43<xÑÌmxJÁ£]xrr<f3D<&3)D&@&;.&. .3&&3 J.44@.&<43 )S4WLiÝ]4;4.&J && 34.3.@3. &&]  <.3;;r3&&f3) <.S4&&@J;@;J&)3X33&.WD.<D;SL.<<.3 )..<;@@.;4<3.&.;)).3&&). 33L;D<]33 
+& )3 )& )4)&;.)DS&.D&)L3;&.JW<3 ;4<@&4;4LJ3)<&Ji;4X3@)4< 4;.3)L3X)4S.;;< .W3)&4<) &SJ;.) )4&W.4<@.4&W&)]4J&S<;&;&J<Jf;.SX<@JS4&3&<)43&3@)&;& &)D<);S)@S  &)3 ;4.&43 3)<) <
+. ..W.þ´t©rLiâöÁ)J4<L)X&@b3<<34.<
+3&;) &;344&DJ@;..@)r)D<þþ@<D&<.4344&3 )4DX&DJ&3;))3&4&;|]]).<W)3.. <4&;3D&<4)34&);&)W)S..;.4& ...44.4J3J4J<)JD& &3< ;).4<.4@43.); 
+
+ ;<J)3<&.)4D)4)&&D<@.44.)443@DLJ4)LD<J3&&4.4)D)];<.&3XS...4&L);&@.4)J34X]D.DJ;DS<.;3.34;&3).L4)&&L3)W3fLf<;4&@<3W34L< 3<;4...@43)&D&3.&Jb;<.&4.); 3 .; @;3);3.))&.;;DX¿Wxi©WtÌ£´¤SJ;&<)4)].D3) .3 <3;34@@D3 )@<)4.;JJ3<<@WtbL;<;4&W;& )) &. 4  &4XSiX@)@ &3D4WSLS]4.].
+ <3S&@4. J3D &3.3)W.)@).<<@.)<D;D;4J3X ..;.LX &434.& )44433.@3 3).;) 
+
+&)4.&& )3 ));;)&.)4;. D)3.;<4 &.@;<W@@3.&  ;)43444)4)<& @ 4&4.@b4@ @4]44;); <J;..4&D@@ ;;.&<<<;4<;33&<@3;)@J)<3S4])3<bb)& 33bL)3X<4).&3.X3.4J4L)))<X))<. &.D@&.4J)).Di¤]£âÄD<4...D <).& 3&)&) @3.&&) @J4& ;L))< )LfXX4@r;fÊ)3.;3S))&)) 4<4SS<<W)4J;<X)bW@)))&]b]D&J&J..L.L&&))));.&;&)@@3 &.;D ) W<@<4J3;4r)<<34i)& L].. 4.&3;&44S;33@&
+
+);3; )4 &&J).<)<43;&).) &;D&.3...X@.J3DX<;@.@3D3&)@;;L <J.);43LJ43D3;&334D@<<&;;D.J3@ 4;<; ;)@J4@.L;.@b<S3D3<&)S4;fJ;JDS)@)@ <@D;;). .D.&J...D&&3.)<@S).;3&;44.3)3Á©xD4Á®biè]4;&@W@ D4.)&S4. ;; S@.&)S.4)43<<J.;4.3@<&W&WÔäþL<J.& &3.;333S;D4S;D) .3JW3Sb<   
+34434<3&&.)<&..)@D.J4)@<]&&.S<4 bJ.<X.D..;<)4J)4DD3&&.<.. 4&3<;)@@ 
+
+3. ) &. &< 4@<<)4 ;)D@4J<&4<.&)3L<;);4@bLD..).4J<S<@< @<3).4&WLW;&3;D<D<J@.3;J 3;.@ .3@)@<3<4&D);LS&44@ ..i< ] ;J@ .J&]XJ<3L@4;J)  ;;J)&));..LSL. <J4;) &.).)3 &L43;));3)|¤4xbXr<r]<&@..<]fD<  &);D&3& 3J3;4) ; 4.;.@)3& &.|f@4D&3 4S&)<.)&.@@)).&@iS@34W]<4WD<D4<)<JS3L
+)4S;iW)D 4 4...4bf3&&3.)<4;<;L @JJ;43)) 3W@)& .&D&W&S&D;.)&.
+3 .3 &&.;.@@3@D4<S<).3;4<)3<@D&);.433  ;<;33S< 4))S3 &&SD.J@D DJ;.& ;3SL< 3D<D;43)44L3.@<3J.&D<<<4););3)3&.@ JSX Lb)D<<.3J@<)J@3<3tL.@ @3 LL)344&&3<&&Db <3& ..;W<3&34@;)x.LrJiþ.4;3 34S@343.&@3J;4  <<3 4)&&&3 )D&44DD&)). )@fX@J ).).) ).JDWJ4&<S&i) bbJJ]Wf;;D3L);;&W3);3tÌþ&W&.34&<;Sff)ir@<S.&bD<4<J&4@.3. ).;4@&&).&@D344&4&);3)3&) &) 
+
+.).D L @.)43..D.< 4;JD;;J3;Lb4L .X<<LD;@ .JL);LW)..4S.L3<W)<.. .<J) <&<3  XW) &)3 < 3D)&&@&.@..4 3&<);3J.D4W&3.<rDD.JD;L<3L.43< ]]X<L3&))@ &.;3<D)3..; @D3.))3<)S))33S3W3<.Db|ÁtbD3DJL.3&@ <.<D)D.& )&))@< X<&S)3&&b4f44S&D;43 D<;WÊX.    .) <.&S;;X<D4fmr;4D@  L)4X.)@W&D44L|&33&3W );â4)J3 &).L4@  ;@L4;33.DSJ4f3DD .&..3D)D3&)&J4 )3)@ .3;;&.
+)<<&  443))&&<3& fJ4<@.&4DJJ&&3)). )D )44<3);<)W; ;<@ 3L4b.3@.<33.J S<.)<;&)4;33<3J4 D4 &.4 J@W&;;J@<.<J&bJ)4.L@&;];;.4&&&;&3.34Wb&S])&;33...)4).4.J )< <.4;3) )&)4<Dbr3<|]|mÊ<<)344 4L@.&.;.<W&).44@.W ;&&.@3)4)3Ñì£J4);X& )&&4D &3&4433;)D@L&b..J;44;;.SSD<@DL;.D43J<]<& 3)4LöÝ 4DW&4;  4f3&SL 3D.4)DW4.3S@;;4S&J&4.3);.. &<; )&&  3D)J)3
+&;)3.3&D..3)D).&.&)J@4&DS.J44.33<)]3@<.3DDL@SDD.3..4 4&;.4W3tD)3)&@W43WJ@3; &3)<.DJ<3.))&.@...4334  3Di;;J<34.4m4|LL<;@L &WX 3&]D4@)&& 343..3@4).&.; 3)  ..)4 @D<X¿t3D &W4JLmW4|< D@ .@)4@3@3 <&;J.4XDD;4<JXS4|brþöÙ  &<. @D4.JJ&;3 )3&S4S]@);3S< 44JL)& &mD.3 .4<m;)]4J4SJ X&3&DþÄ).J 33J;L.@&4.L;@b.4; @3)3&;;.; .@;)<3J . <W))3&3&;;D)
+3 . ;&<3;. )&&.).&;@;)&&;;3&433<4 4&4J;J<LD;&4D;JJ)<D) J3&&X<D@... &4@D44;@4)3&L;) &3..);3.S)@3.&@4D3D4;)4@<4@@.;Df.)XDbrW]J4)@;D3 <@4S<]WL .4.J;)J@&334D&  )4.)&.) D)< 33<Sðb .f3Sf@@X<4<&3@<)L..)3 ;4.& ;<)3. 4&@;4SDLL |Ñ]J)4i)@4@3 3.&&) <3b)].D44@@];@)<<XS3JX@43S@f&x4LXJ&)).4@<£â&4]@&;<<)3)3<<D]3;33S&4J  ;@3D) @&& 3;< ; D&&)&4&))& ;   D)3D;).&3444.);) 3<S;.44L4; & 4<&. )))<3<SW@4)3&3)@.&;L &3.&D;4)JL3;<&<&b;4&; 4.33&;X<4J4& J@3;4)<XXD4)@@@D334@4S43.4;@;S@<3;;;W;SD<;334 33.f;  D<).34 .&..&&;@b 3&3Xìùä@D4];D´.L@L)]X) i3@X.JJ]..3) . <3&4;.;;44;& &&@.J)3bbðþ@mJL)  b)& ) ; DS)X3W<34W.DJ<4.<S)..3;J&D43J&D4fm3f3 .
+ð´4L@ L <) ;&.S;<<;;<S3DL;L)4D;bm.4; .3JJ3&L);&)44&&3&.)4) )&&
+
+)&3)4 D&) 43333D4&@ 34]&.<LJ4)&J@@&J;J33@D]J)fL4<@3D4 4 &DL @))4DD&X))<&@4J&;&33)<J4;3.&4].)D<&D<3&<Dt..@W. )<44D))D<43)DJ)@43;..3.;&J)4J]bL<; f@.L;<33;33&3&D)@..34)4JfþðÁ<fbù¤))<<33J.D;.<33;;43& .<;)&J4@@&&&;t...4)3JbJir®@¤)3L) .&.4.3JfDmiJ<Dr;J.LX; ]iS3D;f.@<DLXJ@.bSSS3b@.3mx<.W.; < .&)3&4&3L34<@34<;)J). J.))..< L.;3.SS)&& ).).)). .3D)4)..;333;.3;4;W<&.@<WD4 ..@3.<)L@&3)S433;3X ;;@;;&.;D<<&.3D;4))D;S)4)<D3S.;).))4@<.@3@<4)@;.4.))@J44)J D.&4)4&J@<33.Jb D34;@@4;@D;W<.J@.3 3b;<;&4XD)<;43 &;;<L@rþþrbWtÔÙÁ. 3D .4W <L@ .).¤|b<.&))<4<4)@)&&.bJD333;@ WtÊöÑ&i´&&&& 3;.<bJb<SD<X]@&<3))LS)JJ<3J@4@f@@SXDL<bD@ ÁJ.3f.3)4)4;;Dm3b<&S@)L..)34; ;<)))&) ..D&.3;;)4<;& ;);&) <@43D4. 4  4&)3 ;.))4<)W) 4.<3).DLJD)3;4;3)J.3@&) )D@L);&&&3J ;.33;3&.@&LSD 43L XS)3.<3&&)..<3 3D343&)bD.3)@.@43)344;)<r4@ ;W<b;<Jt3 .;S;bJW<)W4&@J.;.&3)D .@S.WxþùDx]¸âþ|b D
+)3&;4S;.34&4);ÄöÙL@.)&).; & LJ);43)Ñö´. .)J<D<x4 &W33 .
+&<< ;SLW]DDD@@3 DW D LJW@]D@<DJ4@DL3;biJ;& J@|. & ©)<<4&@WS. W4bX]S<3<;)<; W ;&)]@ L..@<D D;)@S&&
+
+  & ;)@<;<.;;.)<&)3.44)S;)<@;3;.3&<)4J.34.S<<<&WD;&3J44&&..4i..D4)J)43@)4fS);@&@3.D D<D);.3;4LL3;.<&4)3 .X4]D.bWL;4SWL J<L3JD;;@DW3D;LD;)@&W.
+DLDD.;W<JW&) . J.]<&.¿ð®WbW¿Ärxx¿3;@4@&<& &&. <þðDJ))3 ; )4
+33<& )&S&&4.J.f4tr&... W 3. &@)3;J@D3@.];.LL<@3<<&4JJJX&r3f3.JxmJS)J.)LXDXri &&.;& 4âx4)&@.<) &)443<.@.<J ..)4<;& 3 &) @;4    
+
+
+&.<..@@D4&&.4);) J<)&J4<..;;fLL;D@W<JLb3)33J<4)@<4..X.@&);<<3<34 44. D 3]@3S@)&. 4@)D33<J.<XJ<.4<S&&4D SJ)<;;3SD<@;x4);4<@X&@@).4@;3@<@3;;;D4LL)D.<@)4@&44 );4..@&;SþDLr@¿i®¿ ;&&&)@.i<  4DWþÌ£4;)3;. &3&4)LWW4¿Ì¤J3L.&)3&&3&;)&))&;<D&;DD.3@W@;ix4xbJ< 33D@<i<<4L]3LS]bLb;S@WW@4L<;fW4&3;;L&S 3J<J3]&.)i;4J<S<W3)3<J44&<;&)@4.3&.& )
+)). &&@&@.;4<< 33 & 44L;3...);L &4JWJ 4.LrW3<D..3;4@3.<;<@&iL4@)3 @;3 << 44).4J3))4;@&@34)@&<W3&34W&4.4&3&&4W443S)@S<.S.3.<4)3. 3@]&.;).@X D4))&L4)4]@@S ;&& 3D3D;þmWXJÊö|Jþ¸Wt3;)
+4 ;4&X4;@3<D]@)mþ<)  )&3)3.;@xXS@<];|x); ;S );<.)3.&))&;]fm4f<@)XJDDS@.W&3D]Lx@&f3SW.D@]]<f])b;mD@J.<LW;J@3.@.<&)DJ<3.4 .)bJ& 4<< )4  <;&3.34&J4J3))& ))&
+
+&.&&433));. ;43).&S@ @ .)4&& )JW.J3J;;)4; ;&@D4D;&@@.J)WD;.);4@3.;.<L&.3)&34)@J&)34&;&.;<.<4).;<3&;J]3;J&XX.;;3.W)@<4 33)<&;4<.D44S]34W&L<4<L4J@;44;3 J4.; 3 )344ÝâÑ]<Xä´J¿¸DJDL<3 ;<&JS<3.<<;è´3@âù3@;&3& . .;;)iJ<Ä3<.Sb&3.
+)<4&<; &L<@3D]@3)@m)<DDW&4J)<SLX@@Jb@&34&&mDf4Jibi<W;J<X.JL;|X4&)]4; <4D..J;3.4.]&43 ) & L.)3;. 3 3)3 4 D.&  )
+
+ )&))&<&;&3& )343).4.;<3<@3&&3)J.44
+&<3.DJL&)4;)3ffD;<.3J;44L44.3.W4&&)J <;3;)..3 . 3;<<;).JJ.)@].<&   4&4L3XD3;4.@ ;X4@@@<<34&f<S3)3L;3&;3&S3.<4D;)433 <JþöxrxW]JiÝÄtJJ;&D&
+&) &&34;3&)44|ì£;<&.þÁ)D;. 3.3<W<<)Dr33)))<;3))@& 3.L3S3b.D4Lr3J4S)4;L4W@;DXX@b)S@)rJS<4b]WW3.@L 44;.W3i< bb34@J)DL3 3@4&.;)< ;))3D  )4) ) &))3.&.4@4<4) 
+
+.&44))4f)3<&). 3<L4S4))J. )4&;<&&3@&.4@3.4&D;343 ;@3)<.&4)3;);.4.L )i<);.LD&)].4D<33L;.; @W)@<).).4@  )) )<L3.D) 4)J@;.DD)43D;W;S;& ;4<3DL;34;3@@&@XD<).°ðm3þþt®þtibDSb)4;.)& ; )L]LJ@)Stäbr&4J3D¤þ  .);&4 ;& J3   3Lb<<)3]&34))))@.X 434@&4DS@]SLS.D@&<;bJWW]mWLDJW@;3<3 .WS)< 3rLSX@@r]]<;).3WXS<44&D&D&4444S3 33J)&.  )<4&JWLJ&3&33 )
+
+
+& )).& D...4D)D&< @<. 34;;.).).   ;4);34.;).S ;.3))&)S@;44.4.@;333)@<D D44))));;@.4J3; J3;@ .L&J4<)<33XD.;@)&;.;;3<.34X4X<]f@3;;4)4&<3D]m;.&<;434D 4.
+333;33&W@S)4þâ]ft3£´Dþþ)L4DDD
+)43.)<4;3 )L;@3WDxX)))3J ;&3<D &3..3&4S&344@.L); .3< &.@ 
+.D4S;3@@X4&L ]<.J34&DDL@D )).D4LD3@bt 44J4itDL ;b&J)).JL)<;]<<S<W3@Lf)&&3&; )34 X&4;4;& &334 .3X&&&4&@.) 
+
+J );&..D&&4)43))).)X 4L@<D&. )
+) &D<&;344D4.3;S&D;4WD<S3D4&L<S33;4]J4.DL)3L4@44.4<.3&@<4@&.W4;<) .3J&)<&D@4;&<tSWD <@)DJJ<;m.&J;.<.D. )334)3<;&&;)&)43)@.3¸öÁJWfxì.â|@x&@<.D4).) &3.XL<. 3@&<4°þ;;..4 LL3W  @3&  &&@4.3D ;3&)@@<< )4.3<J;J]XiL3rD< 3@3JJ&)).bLWD34@)<4WJJ;J3]W3SJX@S xtJ<r;b&<JSr).4 .;<. ; SJ<3 <S44)&)))&&  )..33 < 
+
+
+
+ 3J)4&;4&&)))4J@. .).D44 W4L3;&4]<)D@4L;;3b444X@bxLD;)&<&3<;3;) &L.L3.&)D3.WL<;SS;S.)J4 4;.<. @).@4D. )3.  &3@D)3;DJL)@3;.<;4W3JD<&&DJ.4&& .3  J.@];;)£ùþmLJÄìÙ¤LþÑ<X4 J.)&3;<4< &;3.4 3. ir;)443Dâ;.   D<;x@D;4.))S).)@ )L;@;J;JJ3@DS&J3
+@;33&@J<L.JX<Jm44]LiWf3X<r4t b3X<@D]X4D;D.@D3J.@J@bS& .4<&.3.@@).)3@;).&& @;)4&4;&;;.4& 4
+
+3))3<.)<34X . );<3343@).;D D3&3J)DS33@.DJD@W .S<W&D4)3.;&;4)Jm.@&S4&@D&@J3JJW.<.@D@<LWD43.]L&<&33<)< . 44&.)b) 4<@;<);3<@3&).<; <&4).3;@  X<4 D  S<;<4mþþbf.Jð|´WD34&3S.) 4
+&@D4&33).)&3&;; fm3)X&4.fþW)4 L3@&X<;<&.<. &b 3D4W.;34D<)S)<m .D;<D.<J@;&DiWSff3JXXS3<3@4LS<Xf3JDJS@J;@JDS@3<44)4.;).&4])<;3433)3 3 &.)&) D);@@.4&&. &.&
+
+    3&D34.3. ).S<.3<J4 )DD@; @))4);<))@4..3..)&D3XD]4.<3&)L L 4 S;@)W)<i). D;b3&34&<4L;4 D & &4;&))3.S;..@<33<@4<@&3.;D;&LSD4JWW;;&;3;<@44<S)@3;&<JÔþ°mLiÙ®@´þÑ®SJD).];.  ;).. 
+
+;3. ..& &.@&.Ñ®.]ä<&ÌþJX)
+.)m.  ;r. b & ..;&4; .3;@<43Jb@D<@<@4JW.fSL<L.;LDX;D;;33334@)L;J;<4)@34@<W;SD)< )L4X).&))]D3&43&.)&);  ;   ; 33 ;4& )3.))3) ¤ 33 &<&;S3&.&4.. 33  &4 J &3) );.S)3.3&WJ)<43SL.;&@]&@&JW)@)<])D );4&)W)<;3D@@WL@<;L..D)&& @.3;);] D<D)4Wm;.&D<;3X<3)D<&)&DD<.4 )..&.@ 4. ¸þ°L£þ£L)þþÌWrJ;4 <iJ4 ; W.. 
+4&3)& 4 .&) .<<r;3Ô))x.<)4] WL.  3))3)3 ;&&)SW3 J<4.JW<<3b;<3.)@D@i@34m]JSL4&S@J;r.;. 3Wb]rir;LmLSDJ@3X@f)J )]D<3<;3.)J3&& ; ...;.4@&L.)..3&<D  ).&).3)
+44&D 4D.&;<3& & .@&)4& ;&33.  4L4@&3@)<.< Jf.< .)JSb&).&;.@Sr)L3.D3D))34)&J;4)&..]43<;<]SS44).J44J.3 4.D.<LDbS<4@L&S@J@D@3<33W. 3;L4&.3&3.S.<3.< 44XþþJ|ixÊJWÑÌxJ;3D<D.3&;44 D4D&& 
+L @&@)&3  )&4;.LW@...S]<3);333433;&. &@<3J;.&<L<)DW4Xf ;;b<WJJJ;L& ;<3&J@.@&;L3@4@S)L33X@@W;@3S<tD]W4.b3J;3DD);3&<J4< ]3)4))4&&)..)&4   @  &@&))
+
+
+ . )3)) &&...3&@D)44W J<)<...LJ@3.)33&4) .;@43)S@34.Wm)@.<<XS< WX@34.)D;4 <)3;<;@&L@ 43)&D ;&.3L)3&;<3<  <<.)3&3W.J.;; ;L .;@3i<3fW <S;W&3&<J&. &34))S)bâÑfxtöfþ©þ4<bS<x3..@)..<3 )  ) ) & )4)343r4þ&tþ]4])D&Xþ¸;f)3L4i<&
+ ).).@& &D||DJ&@L))JS);DD.Wr@@fJ; ..;.<<iD) JL@<DL]i<WDW;SJ<WL@;;SfW3<<mLW3@;;LD<44<;;D&<@3;i.4 ;.&)@)&;))&..&&  ;3
+
+
+
+ &3;)& 33)<&)4<&3.X.<<;3..3&)  JJ) 3<)D )3<3<&3&<W333@ <;WJD W3D3&rD)J3)D<3W<3))D3S@3f4&4)&DJ<&4@;)&.S.<rJJ<4JW@<<&L) 4@ LWX3);3)&;4L33 3LL.&D&)JD<þþ4i£¸¤S43D4X<&.3) @<. 4;3);L@)&
+4;<;))&;D©Ñþ DSWÑ4.W @°ùXW<W)X;t4& )b)3.SW4<L]4.LD;J4DL43W<SXS)4LX4<@XLSLtD&L.DfW4LJXJL4<DWJ43 J4m@S@mmL@b]J LJJD@;S;4&XD33&)4).)..4&4 &. &)&
+
+.&&.;&)3&...4 & .).)3&J.3;4)@&)L33 L;;<4 3<<@4J D<<&.)4@.W SS4D4<@4.4<<4 &.<)<<)3@)&.43@)@ &;& ;J&)&;33;;) SSJD&<L;S& 3L<.LS;<.D4DJ;)@4 .;&@<;. )4;<©þrÝþþ44)<@J3).)&D;4433&& X )þ° @&&)  ))&4;D @4;tD4JÄ<&)4S&]ÄþfJ.3;) <.4 .) J;ff] 44&4.4<L;fiJ&;3D<3@]@& DXS4b)WiS.b.;;. Df4bX]<Sfmi];@4]SD4SSDW&.& 33.33&.33W..& )) 3;) .&.&33&;)4&  .
+
+&3&4)  )&;<&@3&3 3S.4@& @&.43J;@).).3.@ ;3;4)<;DX< @ .<3@3;43JS&&33.]&X;3.J4W.4)D&)4 <) D)&<.;)]S3&&<)4)434W;LD;J<;3W)J;]f@S;<)3; ))&;@; .3@L)J343SÌþ®´t°Ý¿]x; .D;<34 ;.)D;<3&). 3&;&
+â)bi.).3).4)WS43;&<&@W)ÑÄ;J¤þÁ.).3&&<3L&44)<@;D@WX<<.; <@L;<J;;;LJ< DDWL3|DD&bS@D<J)r<i@J]@..4<)4])S3XS<SJJ& ].@iX3D@L3)).3&<;. 3.)&.&@L&W&))3.&)3. )
+
+&.&&)).)<4. 4&3D).JD4D)433< &&&D@b&4) )@W;4).]4<)4J;3;D&.SfDD4&3.;@4)&D3D)4;;)43&.;.;33L4)4.S.. <L<)))&4&)SSX;m@&.&&4.&3.& D)L3J)<S.bD)4 3.)J..xÝx|ÙÑ]r)i;J@<.@&; 3.@&;3;.4.;43 
+|4X3<< .4&). &L J ..3 |&f@ ].&3.&S.; ;4xW< b<3;&D@D<.;.JS33WDb3<3D3L43D3)iWDr<L<X4;Df.<<J..f.Lm<LD|;@]LXS;L&3<.3)@3;)) ; & )&.&; &;3&4& 
+
+)J3& ) &);&3& & 34;;3. &@4 @<<4)S34@;)&)W@3< DS<;&@.) ]J<.;4f@ 3SJ <;;. )W;D])43;)@W&f;SX3@D;D 3;3D3@.3D3))<L4.@)3SD3.43.4]@ 3b4&]D;3f&.;W<J3&;4;;).|èä¤´X°£@iJ DDW r...D).4;)33)@)43 &))]X
+))t@.D)&4&D.3;);;.& &;@D3<xÔ< 3]4 )  3<3@]f&°<SDLJ&XJ.L) bSLJD)W]S3)4.@t3@b)@@4<L@3DXD3|;);WD<D).<;3&;]4SLX4<X@;))J;S))3&;)&&;4.3))3&..3 J.&)&  .& &4&3 33&< .& 34)43&r3& &.@4 3&.443@<;;LL..;<&<.44&<4SDJ4J LSDL;;]L )43@;;  )&&.<W..3)4.)4)@.< )3&;< <D ).3S.L4;3S.Lf@<t@D))@@)4.X4D;.3. @)J<;)@b@Sâ£|èÌLSx&D@;..)<33&J@J ;3 &;;4DS<). 
+
+)4|xW3<3))343X44L;4<3SmÁÝ©.D;&L )&4
+3)<WW43SX.).W& DX4S.rSD@ J)fm.& .]S@fJ@4X<b@LDW;t<S D@;bS 3S@bJ@.XS&XD3D4<
+ . ) 3 <&3.&.4. .3& &  .S. &;3&
+
+
+.&&&;4 &). .L<@4 @;&; &4;L@@& 4S4<3.@)3  3D.44.3D3&&XD.X<)m3@D@D);343<S.D.;)S.S33 );).44&))<D.3D<344& &@3  &<W<<D@;@];.W@);<334@XJ<43<@@4;)D<.ÊÝÁJ]£b]&J;J<D.4&f@ ). @;WD);44@&;4334)þ) &W<)3 3X)L)4).b  ));D  < <m@; )34b&@D4L;DDJ&D4J;JX<JS).;rWLL )@<.bSS@;.D;S34JSbL3@J;J3))SJ..<.DWJ)bfD4DD4 4&)  @& @43&. 4) &@4  .;) @ 
+
+3&&&3 )&)  .)<4 ) <)4. 3@ ;)4 4 JS3.D&LD)3..)<;;)WJ)& @..;L..3S&.< <D<D44..&44;@43;;;); 34<4&34;.4.3<3JW;;.&)b<&W444)@<.<]&DJm@<.]X4J &@)3X..3f|ä]öþiL<)D<)<;;);. L@@&4@& 4W&. .) 3)4;&.&®´Jr&; 
+&.J;&&@3) )3)®X)) ;)&3S33;3L@.3|)4 L& ;3WS3;Lr@@SDSS;XD))<)i4.@<DW@D33iDSJSLiJ;&DDW@LDDS4DJDXDL;Db;XD4;@3@&3. ...<@.)&.434.4. &&3 .&&<);&<
+3&.D)& 3;.&) .D). 4&&;&.;3  .).3L.43.4.3D.&))&@; .&)@;J.S) )3LX@@i<Wix;<4S@& 4&;&J&.<&3D43 3)3&3@).4W);W)4&4];;3
+;J3)4b.i.&D.WSJSX3;).;)<4J44J4â¤LfìþÑÑmSbJ.L;34@;D@@4D)S S))JD&.44<3;<  
+
+3)XX£3&33&.&;J.3..&rö3.&& L;...34@;. DDW)Jm|3..<<JWL4DS]<S<;D<D);DbD3LW&J&;Jb4]3@xSWf)L.LJJJ X<;JL4;D]fS3<;L.LJ&)<  < 4L3);). .SW;@ &).4 .<)3)
+
+43))&&;)@)&43))4;D&). .44L334.&J;)L).3.J3D.&WD@;4D3.34S@&;SJit;44J.4)&D)3Df )44333..&  )4443).@@;;JiD3.3)4&JS 3;<3. DD]DDD4D@@.m)ff])D3<4)SSx)þ¤ÔöÑf|D<S<.4.43;< .&LWS.LSW3.;.<333&. .<)@;.|3&4)&.J)&)4;& &&) 4D<.3
+ 33&&;.)43LX;SX3D4LL]&iLD<]]) ) &J.JSDDD343;W;4WWJ@4<.@;L;4@)Xt])W|<S<LLSSJD4<34)4D. )3;& ;&D4 34&@& ;)34)3;& @.
+
+&; &&).&4 ;.))& 3 .))D&3.<;&&43@3)J;3D) 4).3]<; LSSS44&.) 4@;J)4@@3);@;));4);3D3 44.44)3  4)3;  L3 W3&4<;L.)J@<.3@X
+&.&<D@&)D<W@44W)L)&S4S&bffðiÌ©â£rW.@4J)44&@<.;@)3<@;@.3.4 <@.  .<&.& 4 &.&W¸;&3)& 34 .) .; .D &    .;  ;3 @.D;;)D4<3 3@;)L;W.S3<;. &.&LbWDS<@W;4SDW;)Jf4@W LL@@DW<L4J4DW4;fbSWJf@ 4...Sm).;3 3&)&.33 &)3<@))J33;) ).
+.&333&4<@<&  .4;3<3)4@3<4)).&JD);34)<W3<;.)3D)...)4)L<@W3.3;D <<344 3L D;.&@..&34  .4) <.4J;44@<.<3D)3<3@
+&@D;L<D<.@&X@mJ);<.3S.L®mùxtð¤¸f;4J;X@33L ; W&&;)@.4.J.&44&;D)33
+) ;34J
+J3.mD);D4 &33&4&3 < ;L)&3J <;X4&X) 4&433&&])<J) 4mDb&&)D43D.S;LSX3@.S4@DWSiib) L4DD<<;f]if]&J<D3&@;.<4&3@ 3) @&)L3))&4&;J4..) . ).&;& ))).&
+
+
+
+
+&  L4&3. &   .&& ) 3.&;. 3<)JD3.SJ4L43334.; )@).).4;JL.;J D ;W]]@L.. ..3).L.);<LD3&<;&&&3&..X <@4.; <)34L..&< <&D.4;4
+&&;)44<3<44]3D4D3J3)DrL]¸þðÁ;©mD3<3<.3) )@3;X)@< 4<<@))&.34.&.&.;34  &
+& @&;4@ °Ä333X4)) 3W)).@&4< )&&J<3m)4<S  &@<&;@43 @3DL@3]S;;3 34f4f]@<&J]W D&<S4xW&<<S XLS33;;XfW@.i3)@)W<.;4<)4.D.;JL3.J ).&@&) ;)
+
+) )) <&J4. .3 &.&&)3 D<J 4;;;<4; <.J) )@J L. 4343i@.L|m&333.4DL<4 WS)).W444X;)SD&)4.;.;S)4D)33& ).@WS@;<<<3)&J44.D4<.;.X@< W;W&4S< )DL.;;@XþÔèWx]SW3D3434)) ) W.)D3WL) )X@3...@&3.)@@&)D@334.@D3..)@Jþ3Ù<&&)44LS];.L)4 )&3.3@;&);]<3   @)4. W)4 )J&;SD&&D;X@.L&Jf4W).&S|b3fDi;XDX]33&@r<.<LWJSm4)4@;SD<.33;))J&3J|S4&.3)@.&D&4.  )&&))  4
+@& . 3)3));.  ..&& )&< 3&)3L<@  )@SD;34&&SDL;X)Db;).@34)<L@4&JS 4W;4;D@ )LL@;3@&;.@.J3<4)3&<L);)DD;4)S.&D;4.);.&.43;43.@)&44;4J.)@&;.);@;]D®þðþÊSt<).D3;3&&3 @4).)&&<. L&D @.J3 )).);3..33
+&;44 &.34<|S&)4 . 4Wr|X3))&4)<D)<.)&WiL&4
+@..3<<&J3&<J.D&iL..&;J@)<DL]Lf433LbJXS.4D;LD 3)<DDWD@DL<W33; D3<@&&33&.). &;D@3)&)@;3)&&.3&)&3.
+ 3 ;.SL4.;.@; 4)S33)<. 33& .@3< ) &&) .@&&;3&4J.<W3<D3m&J@SD@3)<4;);4<@)&4;]4;)<3&4@;@;@@ ) JSXDD43 ;<@;@J;&&X)JWi;<.4i&33.@3<<43L;.<.4.]iÁþöÔ´4X<J3).@4.@.. )DL&.&;&&)3& ))3J&3; .& .&)  &334@3)34 .J;<& )<SW;)4W)&&<&3..; °;X] 4<J& );&.mWX4 );<<JJ&);D&.)&.S43WS@;DXWDJ]D3i]W<Jm4<rt]<St3.LrSrSXJ@b<JD..<&;;3;4 ))4)3;L4)&4L.;4)&3.&)&<.& 4)4;&.<<4. .&D&3 ]4;)J&. @)<&..)))Df);D&<44..;..<<DD4&J|fJ<&r)&;@34;X.J LJ@4&<@. 3..4)< <<4.; 4@LX b)L;4L@L.3D&;
+.&4.3;3)DL4.©þöLÑþJ4D@S)<D).43<)4 3)&)D & ;LL<);&4;. ))3).4@W& 
+  ).34&;<< ;.@&)<@D4 )3m;& 4J)<;)tS &m<.)) . D<;ff|&iS)ttD D;@]DSbL)S3@@m|]W<;4;;SDX;tW34D<@4<3)<;33; 3@;.  ) ]<)33..4&3 & .
+ &  &@& )D.<.D);&) )3) .; ..;W D)<.)@D)433;.J@@3DD4;D3 D3.D@J<4333.4.3@) Db<J;D )L3 & &<&343.3.444J@;;)&);LJ)D&4<D@;
+4 ;4.mmD]3.;@£Ô©t©¤©iS3LL<.4.3D .)J4< .S L.&&;;.;.&4) &)443<;4@@&&.& ..)D).;@S&f44.&..)|L @;.èm4)) 4Jb3&. f;Dbm]];3)&&)&3X.S@XbW;@3Wi4b]LJDD@4<D4@@@<)JDL£J4fS.)b3f.) 3  34)@J 3;;.) &4  444.<.&
+  &4 &<
+
+ 3& D.4).D)4.& ;;.)&4& )<<&J  4.;).33<43&3..4@3&&;JJ@4.X4.L43) )@)@3W].&;<X)< 4<<4J]);@&;3;&L]@@.4&&)@L..343.&L4.< &;) .]3.D.@D4xÁ®f¿3]@< < 4Sf<&)3443);; 4& ))X;@&;D4 4)& )44&43&3&) )4)).3< ) 4&.<L@W ))4)fD4@44)3;..3.xXS&    &WS4WD]@&).. 3.&);r<<<XW<<4XS)XJ).SD<];D 3b;J;J.JtS3S@b4.b@Di)<J.4. .&;...<;.&)4. 33));3 &).))3&
+
+
+ &. ..)) &)44&)&...@&&4<4 &));3&&.4&L;4J@34.&)D334&3;3<)b<4)L.)@3&4W&W@3J@S3@);S);33...; L  4D)D@)44&D.<4<;D.&S3@<&&.34WW)SD W).&4@LÌþ¿m°ä°;; &.;;)3 4<S<)3@@.;.;;3)D))4&.;L<&;&)434  & ))3 &4. ))@)<3@<;))3 . &.J . <D<)43 )X&&))D&imW ..4& .&bS&@bLW)4WJtDJ)&mW<W4;SWJ.W3]S)@<LSD JXL]WJW&) &;4J4<..; &@;)33JL34.)&)...)<3. <;.3
+ 
+&. ). 3<&  .<;)443.@4;.))<3L &)< J&;4)).;&D<&;.;.)WDL4;])4)3&4W].&<D;<3&33DSD);;4<@4;;.3&&] 3;S3S&;44<4 <3.;  ]X3<4ä])&3@LL.äþä;4.&<@@L.L @)3.))&)3 bJ<4 ;4 <33).)< S;3)<).3D&)@<]LL)4&4W.&Db];;.m))  &.&3&i@LL&.3   &) ]S&X@D.  & JL;3<]43<D33@fi;<J4<@SD);S@DW&;DSD)xJ3;;Xf;|i4&; &33 .&;)4;<) W)).J<).3 &.& ) .@ 
+
+ W)  ).@SJ.]).) )  & ))@ði)@)&))@<)3&.@<)<.;& );bD43.3<4<3D4.3;f)3@3JW@3 <<3<D< ) <)&434;;4JW.<DJS<.J ]@4.&4 <33<D3.34.f.&X4D¸)3;DDmxþtt£þ@@)3.3;@&]..3. )&;.@L 3) 4)J.)L&&&4X]4;JJ.43 )4 <&3. &3&4)<J34<LD& &443 ];)b.3&4&bþ.ÌS& ;@3@D)iW)L])@& 
+ )&<..DW@L3DJX)JWX&3;<@)J)J.@WJ;3;WLS;&JLXb;44;)&@)3<4;&< ))4;@@) ); <;&LD&.3 4&4&.&.
+
+)  ))& .4.4;.)&).)& ))...)rÑÄ&;.&&&;.@L.3..J)&@333 <S4 &34Dm3&D3;<L<;)DD.&)3@&L)D)S&);&4<); 3<SWJ4&3)4D< 4J<@)344J<)  .;; 4;3<@4&.J334)WÑþðr<L&bW3<<b.;& ) J 3)<°þ@&3)&)334.)@Wb< 3;3)44<3&&4 3&& 
+
+;;343<)4 ) iX 3@L;4. &@&4.3)iX)<<&<;.;)<L3mL4b.&&&
+
+33. <4.;S DD<4333L.D]WLbJ;;3JDbmD4r<4W X; @4J3;4.L34 )<J WW3&&4<&; W;3DDJ3.4)3 &<&  &
+
+
+
+4.4 )  )&&.;4.@<)<<);)´Ù
+D))4.S.433;4JL.3.@.&4SD .. @@3S4)3.&4;)4333&3 )3;D ..;.<.3D3&.3.;JL@<)4J.;J@;4<&)@;4W<<.4JJ).<<))3]3X;.;Lþþ]3;)b;.3;&;L4X  .&3..S¤&.3)4.&4]S)&i&)&.);L& 433<D);)3) ) S& 4JL
+3.)J &3S))D&)3  4&.S@J ;SXS&34W@b<t4b))&&34SW 4..4<<WiDJ@4@S<3J@ bD4X3LriJm3L];];)4< ) <<)&..D.@;;J&3;)&3. ).<)) 3)@ &;  ..&)& &
+3<  &&)) ;3@4 3.; J.4)3&)3Li< |t<.;4.44  ;<)D3344).bf 3S;; ;&&<@;@.<D3)434W;;.) D@4))4...X@..]WL4.X<.Jf)S;434;D D)&S.434D<b )3.3)3S.@<°@;S)3;LD.D).4;J3)&)@@
+DL4;  3<4W3SX.&33&;.;;&);)&)&.DbD @43S44).)<D)3;b@L<]3f.fÊ; )DD;4 D3@J@;;3SS@L;rmS@)SbSJfJJ4<@X;D4;;@r&;DD&<4@.X )@SD3; 3.S<3).;44@&&4;&)J& &)43)) .<;)J& 4&.4 );&<44; )<3; 4)xr 4D) ;;4<<&D] 4@4 J3@)4;J ;44D<43@.&@<J&;<34;@&DW; )3D.;@;4))).J44@).J< )bD .3@3@J@;&);J4@  3&D3)tÁþþX&&;) ]S4b;<WD;D. ).4 3< ;Xäöx] );@J<& .3
+ 
+tJW mD))434& )4..D@& &; <3L.bL<3<X4&D)&& D<L@W)@@]@)D )Ñ) W)4& J)W;W&i<|4];;Df)D<@.D;);3 Di)]DD]<r]L.SW.)<DD&& ;3&&JD)3;;DW3f););;.. ;).;4. )4&.])3. 
+
+
+&   3.).4@&&3)&3..3; &) 3@.  3@@Sb.; 4@).J@<&D);3 &.<))3&4D;;44& .)34.4<<3D. SDL;&&.D;b&J&.4@&J<@S;<;4JXDXf J&<3;;f4&&)< D@
+.)33J]®¸ &)4L@rL< .<34J;@L4 @|þì<&)&;X&3X3@WS& .&& .4 ).4   )3&@L&);DDL4<3 <.&WÁ&3;&W SJb)rx;
+&¿; D&43if;.@&);;JXSx.4iJJm<@.@<4D@;m4&3r3D&<@ @&)ibSbJ@..4JD<&)  4..)&]J.J.)L4.3)&.)3<;3 3
+
+)) &3 @)@.&.3.3)<4  );;;3. J3LX43WLDL& .;;.3LW4..).3<.;  D@SJ.<&;W.).&4@3DS;)3@@.)<X4X@  .;44 @&;@<@34.4;)WS;3.4 . 4  Jmf4WDmL3.& <)4;b34<3L4)<&.@34&4];WþÁLX3443W44
+f]..D<<)3W)3.<;4... ;).@.3@ S@ <@3)&& 3 & .4&3&DJr.Jmx333). ) &&;;S44 3@ .;.tW4D)J4JS)]3D)DL<SS)iJ.m4<)J44<).3<4.43).444L3D.)4<<.)).433.4..<.L))))
+
+
+
+4 ) 4.4)&.@;.&;3;).DJ3 )&&4@< &ì<3<3.;...X@.;433D4<344)4<&.) <)))4 &@&<<t<J434JJ;X&)).) .S .W 43&J])34.& ;LS&D&4S4W&<34LL @JJ3)&X.<4LX4&  &33)
+.)4.]W&L<4X)) &4@] <<x3;4@|L&Á]3 )â.J;)&).J43&;]b).3..) <..@4 ) 4 4)L&@@]x3]tm). J D&X&;.<¤33.3.& @&3W.;xmJX@XDJ;<b3<;<@]W); D4bL;f]S.433& &43 ; &.;& ;&;)DJ.;3)3. <4&4.3 &.3&; 
+4&.4 .&4)@.S)&34D&. &D34<.3 ..434f¤..<@4;<@.&;4)J;.&)3.@3 <m.;;33<44bJ3@J3]4.;)<44;);3 3@ &&4)&@&4.&]<.4@&)D<;;)<D@4@3.;&)@.;&@44D)LJ434D4).4
+;&) &.J LÔþÝ<iD] .)&@3<&&&3 r ;4@&Wf ]m4@.<LJ&&&;&44..WJ4)mD4 &)) &;  ) 4.); SLD®XSSLL 4  33 @@ )D.;&.)<S D]@@4]xtL&bLfX.J4WX]3W .;4L@XDD@X3<i<.    . &)&.&. L@4;;;)S.L44<33.3&&)@) & &
+
+
+.&3; .J&3 &) ;;;;3  .3&W.@JDD<D &<3).));.]@33)@&S<;)&343J)<SL..3t34.@SJ.@3<DL34;4D.));3.<@3 )@;3;;&&4<@SL3;;4.&3.<.JX44J4LJX;& S))..L;).
+rJ<X
+LXf;b<ââ; DWW;|.34D;S;&@|L))&mÑÔ) f<4&)&)X<4 &D&3 )Xm).&;)  )) );.4]m ;&3DD@.X.;&S.))SJ .&4J)< L3;4@3)D]b&Db<4W43|.DSS4DJ4;)3<DWJ4]3L S ..3&3.4&&<.]. 4343)3)4&..4&.3@;).D.)&..).&
+
+
+)&3. <. 4JD.&)  & 3@.&4 .34)..Ô¸]3&34.&4.&<@33;;3. .))J;@;4LJ; ;J&4.4 D;J&)&;WD) @.43)DJ<S3SJ@@W.@3 );.@<)4.J3D3..4;;) X<X&<D;&<3]4;@@rx<3D3<4 &)D;þ<4<<).3°þþ&x3@3;@3&4´;;<& rX)b&;£¿°b43&< ;3<X3J4WD3&3W..;4.)D&D.<;3;4;.;))..&<.4 3 m@D<43)))4 ;.;).&4&3XbfL;DX4x<S)J]LDW.4<@<LS3SL)4<@J;@@& .<3)3L)&L4D <44.3;)D3D;WX<) 443& &. . 
+
+
+ &3) )< .3 <& 3.@@) ;);<.))&&]iD) 34L33)D3;@4<))3&)@.4 D3;J&.L<).)@<D&D4));.J<3&J34)@&& 4)&@ <<&&)) &D@<)4.).33)@3.; 3r3@J<D@@L<D44S3).)S þÌL.@D@£Ìþ<34;<4& .;;þD@)3&
+.W< W@))WâWf4@ )4 S@&D)4;;@.D X &)&.D ) .) & 4)&4.43@.DJ< ) S]X.  D4W )4.;<L]bb@W]tmW@WS&WrftriSJSLD];Db)<.4.3&.&.]3& J) <&33 @)@]3)4))&..D3&
+.&&4&;.@4D4 4 )4);4.. &;443.44<D4.@; ).@)DD)@4.;& ;4&.;...JS.<D .)44)D)DJ4.33)..44Db<;D3D;D<&D]JJ3& < );4.33.X&3@]J4<.4.)&4 LLSDW@4Lb..J;] ;;4&)3..x¸þ£J&WÌöä.. J33JJ&)t;þx] &.JbL &3<äxÔ..&&.D3@4& @)L ;&<4@ S;¸Á&.&.4.;&@D@ @))3<&<3<3Dm)D;)&. DL ). )3W)3<.Db @L<&3..x3@J@ t;D4J<;);W434.; <;44D L&@4) ;.3<@ 3@4).4WS@@W&..@ 3);& 
+
+
+
+ )4&33.<&4 J X]J)S&4.44.<S@)3;34&<;&&..DJ)<.3) &LD;;3)4XS@DL)J3)4;)<) &3@J))&.@33 @J]D.. 3J@4J3444);3X<4LDD.;4.344;f44&;.;;JX<;&D@S.W]<L.<J<&4Dþþx@.WþS&34DÙ¤t  3 WmJ&3&Df<&ÁÑL°x )3<;.S);;))D4&  4&3 &3&D. 4@)&).;;;)3..;&;;@4&)X)4@);DL).&)D3DJ]<S;;]<;D<3S)LWDD;f]&@SJ]b;;]XD@4S& L333&.)&33;3433LXD..L.;;& 3.. .D&).))
+;& <.J43<<3<));3 .)&L . 3)xW.@WJ);3))4;<;<D ;&344<.D&@D);3JD.4DJ4X);)4@34&&)@4J).DW3..4L@4;;) ;&DJ&.@3D33.;4LDXL<.4;433JL@.;J)@L 4D<<<J@3L<;&&33XÊþX4b.<)<3¿ìJ;43.3DLèþ4bJ4tL<<&rþm44;@ ]@& &<3
+J]  4@S4.. )D@4&)4);.XS; 4D<.@;&. .&&<X3; @ @J4<. W@&@;&;<)xJ<.SXWtLDD4X@]W<D<D@Jf3@bLL)<D).W&<.& 4 . 3X43;) 4))@3)L&).&)33D 43;& .3;4@).& &@.)34&;<@3.3&D.<&£ 4;.SD3D);;J;.<3& L@<;;3...) @@@L3. 3;)3DD433&43 @ &3 LS44)@< 4&L.WD;;;4S4&3).J&4)4.D@4@)&DJ4<< &@@@<;4]44.3;<f3 W]  ;&@@Xäm<f;@<WèùL@4&&|JXrbþD &).þÔ <´W<b.;SJ3).)xm@D<)&34;@&<b@3)JL)..@ ..)&)..@)  )3;;<@S 4.< 3 33; .;; )] 3f&J<& S4@3LDf<S@S;WXbf<W4XWDJ4J;W<;;3);&&)<4L<]).@&@;;); ;.. 3)4&3  
+
+
+
+D )   433;..&.. ;D@.D@.).. <4W )&3@@JL<.43&4J<@)<@;@D4.44.SS3LS)<<))3L&<.3<.3;J; )LL &)&@< J];;3.)<<;LS L 3f&3))&.43...<4@4L4.4)J3<3;);&<43@D)L@DLD3D4.  W;©þùþþD´bÙþir ) ) ).f3f<XÙm.DìbL<¤xffW)4;@   ;J&&)D& )&S®3]XÁìè)S.X& 34L@< .;@4.X&JL3<S4)) &4@;<&34<S44)4W<X4W@W3;&;3@@f<@L4ib3@ L&]S]X34.@)3 4<D4 )).<;)@  @<.&443;4;. &D&&.@
+
+)3&4@J4&433.4; 3433.S.<.J<<;mè@L3&3<D ;;J4LJ) D D.D).4;4;JW.;J;J3L4;))&JSS@)<J33&4@W..4;@D 3<4<. WJ;3<4@ 33@&@4)DSS)).DL;S)3; . &W3 D4.;)DJ4;@3; @&LrmÊ´WÝèJbD))&)WDX) 3J   )3þXì;@iL)@&;@D 4).  þþ&<D3.D 33L)) .3tm3)4t);J< 4;3&S3 3;<;;&J3@334)J]DW@)&W;3;]3XX.L..L4@XSL<]3JJX;S;@mJxD <4.DW)3<.D.434.34)<4@;.4L3W&) ;&43J.); )&)&3
+) &)&.) ) .X&)3)3 &3)3;4))&W<XJ3;;.<4 3.@)J<@J<L.<;34DW 4<L<&&D@@&;)4L;4;4i@W.34@J3;&34J.;3 J..L@3).4D4JW)3& &; ))4 .44D).<S<;. )3) .;;L&44S< )4<4 .<3<&3..&St;&J¤S<44;)  34L3©âL;D34DD)))3]  3DJ4&.4J&&&&&@@ 4);&3  .)3JL443)@;&; )@@& 3D@4X@<&4&3LS;b];;3 JDDLDJSXSr4.X) WX)L3;3..S;34;J43<@&J<)&< 3<@))& 4&..4)L&L<<W.. &.) 
+
+
+4 &)&X;4W&&3) D) & 3&) LWS4<<3;W&)4)SS&&).)@) 4.))<J.).&)4@4@34i L)43<) 3.4)..;)D3&)J;L)3.W4&)4DJ&;JS&<4)DD;3@;4;<.<;)&34 <L3 <D 3;.<DL@4 ;J444;b&JX))) &]3@.&4S.43&3 < W ) 3X@.X<<Jx¿þÊbDr<].3&44..)&@4&]L4<D<.L). ) .4&.JD&;33@;;<.L&43S)&& @@<X;WDb43) @&4]W4b3JmD.XbfD@<Db;J<@3@);< &J<. <DL.4 J3;4&&.J3L&.b4;3;) ;& <4@.4.4L<<..&
+
+
+
+
+.) ).)4..3 3&; ;)) .& &fXD34D;<&; @.LDt@]3))J.&<.434;.;.4<4f;SL;3WDX4&3&&&... )&.;;.J 3&J. 3;)  < ;L3)&;&)<W)4@;W&< <..;L4f@@D&..&<3<<43@f<L;.<D3)44<.D@)4)  &LJÄ.DD3S&;<<@J4&3 &iäXD4&3rf@;<.;434&;<& 4).&4 34;þJJ<&3@<;4)&D.4 44.&.).& JDL.&)4<LX;;iS<< 4D)SJ)@JX<S;<;<D;]Jb Dib)i.@.&.)3.;@ <3.&)J).)@@ )&&.;3;&;@&)3...&4 3)&3   )4&)&).3.L&343; DD&&.;3<<4.33b&&; & 3<])L&);)D4).@;&3fD)J;.&<SJ.4@S@<4.&3; &J3  @& &.D@J)D<).; <;43).<.)434;;34L.D34<&3<L3 ]DSWS4<&4]4&L3J@J44;t)S@;S.@3<)..@);´S|;3@&) &33)4&)3|&;]ffW3&S&LJ3D@4 ..3.@t&) 
+)XJ.334&. &3 &)34.3;);))&&<]@&43&.D&@X3;DL3@  ) <
+Jm<LL)<<DD4;DSS@3fbXL]SL&3D))4 ;4&&3 3;@;) )<&X;&&.)3).&;<4S&.44;43.)33)
+) ).3;4&3;3&<..4.3).;W)4@3@..);<W<3@&33@;<LD)@ @44&LD)@44)4<&S@;;<@;4DJ44X33. 3J) <<3S);] &DJ @)<4);J4 4;. ;.<J<3)4;<4;)< <.<3.)43;DJ)J<) <)<; <.)L .4<. ;3)4 ;Lþ®4@<J&4 .344.&&.@@@Jxtþþþ©i£W<Lb3)43&3 4<&)Jm3 3XSW .3X&.&J;4@44<);L.4 44.DLS<@);3S;SJXD];<DL.&xfL;;4<LDLfJD.|WL34b|JS@;<&3<<3&4@ 3J.;..< <;<)&)3J .;4&)4&@@&. L44&;@
+
+
+) 4   ..< &) ) &..<D <)3<.LJX L;3<W@) @t ;&.&.W4  L .;;&33);SJ3S&3)XJ<.;@3)))4&@@&.b33<<)3.L@4&D4));L44 .3.3<4 4< @ 4< W3.3;)4XD4.) @Jb3<;&&&< 3J L.WS;&)).4;))@W & )J  334@4] ) 4444.SJ´þSX<m¿iLÝiþ° .&<;&þ£ )& @@)..<. 4L) << <)D@@...&&;@ J3@)) . WDr3@D.D)WD&S34.)43;@xJL4<<X@ 4<4SJ<<b.DS434.4; 3&.&3);J4.W<3<<.33;<. ..;.<;.&)..3..  3
+&3 &).3L&@...&4@4J<)<.&. &@@;J4<;iDi)43)D@ )&4.@<@&3;S) ;&X;&&3D <3 ) ;@;J.W.)&.3&4;&.W.)&J@.3;)<;&;.4W3@.&@S3<&)DJX.S<L)3@3<.<@.4 )..;34L<<.3L.&3&&4L.]JLD@@;3.4&...&.;)@..&.)&4&&.<S.Lf&.SXþ°<tèW)&&4X;4<4)@. ff;443&) @))S <.;)&);;<4.) &; < 4D)X;xJX@b3SDr3X)J;;<]&XS&.DX SX;4J.W3;JD< D)&.)3 ;<& ;. D<.&@;;;J<<4)&.);.&43L&4S34)3
+     ...)3 ..<3).<3&&J.<. );;.)44< )33SLD4]...;J;;3&;&3J@D.)&4)4.<)JL3)@LJ4 3)).&).3)b;@)b&&<44<3@@@& .D<3 Db3;3@33&)&D34;LL&3DD<DLSD43)&.& 4]43@J4 .t4@  .&@3);4©<.)) &3&<)&)&& .@ &.&3| D<þÔ3WD&.
+im@)&3 ) ;J)&@<D34;X&3)3&))4;;4J|@J@JSL;mmXW DDJL43L]f@SD3)bD;b)W4Dr@.WW3&@4&&<.&)4;S..)LS;&<. D&.J])&D<<  4@; &3&@.4 .&<4&))4&3 .&);@@;.DJJ@@J3)JJ)3@LW;L4))@44)<43b;b344<43L<LL 43)3&3S<;43 );&<<3&JW&343D.;;...3<&.<<.&3.D33<D&33W)4<..J)<3Jt)<;&)f4@.J.;D  ..b4L D<4& b.44&J ; 3&34&3&4L 3&&);3)4J;4.S ) Wù|ÔÔ@&
+.4
+JWW  33.  .3J4 .<@&D3&)4.<.;3.<;@;.&33m)4<@&@<J&.@JW@mJ];4 3|r;WL@&3&.@S<4iJJXLri3 &.&&  4)<3&;&4.))3;D33; ; D@D3 ]43;  .3;4D@.. ).  &&4.DJ.4);<&&33 J<;;3&;4Df@)S;<3;&L<4;43@34S3 3)<34& )3&)<44 )DJ)))&)@@.3<<@4;f3 D.@J3&;;3@&;)) .3]44.b3<&4<4;)&LD3J4.)<)3S4 .. <).&3&3@;DS<)4)3)J<W4J<4Wb;<<<&).S&&44<®.@J&&)334&33)L43 ;S34X Lr)þ.3&);&L3Wþþ4)444333D<)) .]44;&;) .34..&@&)3D;4 ..3]<r<S&LbL<<J;JSX.4bxXL]4)SbJD]<;)4;;Df.3&&J3&344J;) 3&)433&J)3<33)43)@b4f;43 @33 ).<&33&).
+3)   & )&)  3&@&.)&  &&;.@L@S;@<t..D3&&;)3J3)JD3 D4&).4&3&34.)S4f@.D4.)444&<@<).L;DD@D3&;@W4.)D4;&D  )&.&4.3&4&;<)W)D4).;443&<)@) DW;4D@S3D.4&&.&.S3D< 3@33f.;. J&3DL@&3.4&;3434&.<J)b3)4)& ;&&ÄDD&&S;.&m&4<]mþJX.<4 D4<)4)<& )4&)LD< &3;4@&)ibrL]@L<@f<] 3<&4
+ );S.]<SS@J444xb).]]S<4 ;&&)4..&&&<4..3&S3;&33SS.433WJ@&...@b&  &&
+
+&&& &<  &  &@).)&34<)) <LL.&&3)3<;D@L&4)).@))L3.)4.J &  J4;3<;<<&<3D;J<.4@<3;&3D3 33.;))43).;D);3L3);4;b43&34&4@4DS@)@XD &;Df]3&D)@4<344f@);.<;@;&;)D@&iJ)iJ.S 4J;J@)3&).@3);3;.3  &.D4 & ;@ .@.X &L<rS&
+@3;) ..)|)<.3;)<4&&3 .; &4 &4.).34)&;W4@L@4Di<DWtS& 
+&XD)4.iJS4433)b4J.Wtf<JX &)))<3 &@  ]3S..3..@.<<3X<;<)J.@@&))4 .<&&;3.&
+
+&&3)))&3 )D &.4&D4)LfL&. ibLL4;@4]&@&; <XL34.;<L4JS..&&&;43@S&4<Jf.L;&D4)@).W.W)4&).3; 33JD)@)3<).WJX& &]<@..&33))33334D3L)334J@<4@J&S. 4<4  D.<))33;@SSJ& 33))< ).3W<  &34<3&4)&&4&D&3D3))©X3 3&4â))S;4@&&@D3 33&;33)@&)..)).;@b;@]Df3 ;@]DW4 &) <&@);;4.3)<<4Ji@XLX4J<. ;3 .)4;3);)3@)4)b3)))3S4 <4X@  4<J&44&X<;) 4  
+
+&3&
+3.34 <J<&4 ;&3.&33 )  ).<;3&)@@; .)); .)S)L4<.)3J3D   ;@ JD @ ).;@ J<)J. &)@L))LL3 ;3 .DXL444;333.&<. ; &<;]X3;LJD3b @3L && XS. 4))@)4<3<3).4<)<3@33D3;;X.;3)4r.;Dt )]m3&&4@4. )& .<.@43&.).&..D@))J;3W JJS4).<)D;<L4<4]@<3 .);343DLL&4); S@3<;<4<;;.3f34SJSLJ.<.]34..SDfJ;<4J <S<3]Jm43)DL;4S& .&43. . 4.;;D;)&S;)&S. 4<3J<<@..3@;4;J))  
+.  &.)  .)4. ;@)4.3<3) ;tJ;34]@3@.;3&4L34JDDX.)3&L@34. D.3WD@&43.3<;33 .))).JL34@<3J344J@S3&4;..D.. )4 4<&D4)3S33&.&J;.)@fW3@<3)@;W;43;3J<44<J;)D3)X J3@&);@b4L&DWD))W..J).)&&))° &3 4.; ..;&D3.&D3 <)<)@ b.3<4¤¤W3;&@D33@JW;&3 33&D<3S&4)343)3 ) JbSJ;XXxJ)@<SD3&<@JW4)J])@@<@LJ3..L.J3) & )@.4.D)3. <.S.W.3)& & <b mL&& ; << 4  &
+
+
+&.&@<4@.J)3&4@&3 <43))&&;D<@.D.@)4.JfL <&3W<J] 43;;3<.44;D 3)& 33.;J&;@b)3.X4.4.&4)));)&L;|).S3;D3D.344.)4).D&;) 333);<3;&3&@3;@X4J&33&4;X)34..) 4.S) @D)&W;DS;4SJ)&&)mi&<]3)&& ));4@<4&34<& )34J.&&J<J  4)  3SÔ©3;<3.4D@L< 44<J &) 3@3;3.344;L. 4Wf@4@3SLr3)3..;;J4L)3<;&&]4]L.)4<WDJ<33)D;)<@;333W&)4. L34 3DWS4< ) ;.;D.&@..)X4))@4 ..&))4
+
+
+3&4<)))  3<;.4434.<W]SD;<rLL.JW;3D<4|D D];;J;43&<@ <433;;L<.). )4@ J.3)JJ@).3&D&)J@S )@. 4)]@.4&.@ .)@))4<@& &S<4@4@).;J4WD.&.&4)L<4S.4@@;@Lr;34.JJD <3S&&D;&3@<mD3 ..3;&; & )@ < ) )).&.)3D;&D;L.; 4)));3&4S4.4L&34DJ@..4))3)&).<&3&3<<<J|33)W@W WD4W.
+S @3;. J3.;b]DJ3S.J@&J&;<&&&<.J<4 4)333;<;&D@ DS D<).X<&))D4D34< &.3
+ 
+&&.  .3;.@))4 )4 &)&3)W@L]&33JL..4JJ)& D@WS34<&L4@34.DL;@3<4D@.& 3);&L.)<&W&;&))3&.<@)f4J)@3;&&4 ;44&;&34S3)3 .) &4 .;4 3;. 3)<) .333L;44 <tL&34..@&.DD4|;@i.L&@&Xr)i)..4J)3).  &&LJ& .4@43t&.J4D4&&
+ . &f44@4;L.4) 4).3;)&3 3D<DJ)<&)< 3;Lr)3&LS;;<fLDL])4b)S<<&<W.4L3W)b@J;<3;; )J4&&JX&3@..4D4  4&@4L;..;@.))))3).3.J< @&&&
+
+
+<   33 4& ;L) 4 ) 3))3  &;WD3.tm3<@3.)4@J D43.<f;J]3D]3&@@W 343@)<;.  .<;)3 ).<)< ;X3;L;J3@&L& ;;.D;)4&;4)J< ;334)<).43;4 .L@ D<i443W;J&4]&;3L.< SSJ )tiX<)34&.&)3D.J;Jt3&.   
+
+)4  44&)))3.br&&&xS& @JJ.. 4.3)3L4)DW4@@.&.;4@ DL.<&&).  ;L@J)<@)3S @@4S&i.D<< ;43<LW<LbL)|SXiJ4 @)33)4JS @.)&<<@&3. .)3.3&..JS&;&J33 3&)&4..&))
+
+ .<]L334W 3t..D.D < 333)X.;<@ J);&) ;S;;;;<<i4& ;.;4 <<@@JL.; 4)&4)); 334 ).@.;J.4). @.&JW4@.4D3J&.<.@)4<D &J<&)D.;).&DLD .34 )<;&33@)<<LSD@;;S<).W..3)44J]<J)).4).<L..&);))&4&fJ&@)J;)
+
+S<&).&)&<;.4;) J;4&))
+ .S)<L33 &))& .W]).@&;&@3 .3<< .&.X .S;;3&WL)<X&.DDb&.J@.;<@;3<4D4DbXJJ<JfL;;&&; ) ).)4.D.J)L.; 33 S@;&D .D;4S)3;<.. 4DD4 D.J&&. &  
+
+
+3& &.@;))&&)S4 < ;@4 @ 34 .D&<)<4LD&J4;.D3D43&<&4&D4 ;<]]4]<JX;b@;3;.;&@; . @4))).<4&3.4)@;<@4& ;&<;.3;3.<D&)))D3&;))LD<;)4& .4<J;3L&S.]4@<@.;3;<<3S;S<i;4 3.X .&D4)X&&3D&@S@.@.4)
+ &&) )DD;<D) ; X&;S)4;<. 3;))& )33<;J3XL  . 3 .&@))  3DD;JX4<3;.])DDL<4;)3f<;W<S<<<;Wr]X;;i< &4m;3.)4;;;<)L@. .;3@4@.))D4D@. ;3&.&.. <34;< &
+
+
+& 3).;4 ;  @;@4J44 &3..@)<D@&W; )4;;.)4<<;3443;3)L@;i@<3SL;;;S4;<S.&).D.<@;.&4&WJ @;@X4W;4L;<&<.@.;@&L)<4X)3@..3;@ &WD;&4@34&.D<4J&;;33L.D;L].4.<<;<@J<..@Dm34&<fiJ4 )X43J.4fD 3<LW@4S 
+&.
+33&&.<<3   4  JW& );J& &)) 3L..&.3);J))&;.<3@3.344J4)&.)4r<J33]bD;J)<L].3
+ft..)@43]D3J;WJ;;<4)  & &J&&W<.<) <..&LJ4<.<& ..J3.].<3.).;)4..3L@
+&3&&3&WD<J4.4@@4.D.;@J@4..;4&3D;W L.3WL)S.@W&S<4;4);3&@.@L4W44]&3J&J3.)<D& &D.4 ).)@J<D.D;..4.4&S4344)DDJ. . )3)&)444 <3<&3<34D3.4.@).3 @;)@;4)WS3<&D3)4D@<x)&&;D4) @@;W).L@.°fL )) 
+)@S4  ).&&4.4)&4)@;;<&<J&4f).3.3 3;3 )<X3<]JS4X;m;;@W J4&
+<@b;.43SJmD<@ri;b;33@43&X3D)m34&&4&...)3< <4;<;.X)). 4&;  J@)@. &
+ );;< &...@J)@&3343)3@.4&]@J3)&.
+44;3;<&4S J3).;3;<)<@3.4<J3;L;& .<))4@&4D<<D@.;@4);<<.&3<L4L );;. )J<)) <43);.&J3)&f .DX43X)4LD; D34@&33.<<)..@L33@L)43SS4@<4@S3&JJ.m&&J<4;34 <LLL;Jf]D)))
+ )L4< 4&&&4.þÌ;); &LD @4&3 3 @;D3L;<3; 4; @ ;)&3<4@<).)@.<;Jf3JD&.<mbSJ<4JS&JbiS<D]LD)m]WDD.J4<@444&<@JD )& 3 &b&D;JW);@44W43)@3 W44@);)&43
+
+4& .DL3.4 ));.@4 D<3 )43.&DDLJ.)@;)3;&WJ4&43.D) L)3 ;.D<<.;<)<DW.)&J@&&343;<@4S<.;@ &33;D@.@3D<<&.<)L&@.&@;4<3.&&&;))3)3 ;).)D3 &<D.@;.)WJ <<&;&443@<3&Lm<;33L&.4< W;D)].@&.<D3))@i]L @
+3;þ <@<<)@  DxX ;3 .) JJ& &L)4@4.D.)33.;4J4)<bL).3.@.L)S44D&.X 3@J.LWL34)X@LJiSLS44;)@D<<4@)4L4;3 &&;3.@<; .  4L)D.  @4.)b..D&));)
+
+@&. ;.333433@&;&3DD4<)43W]r;JS@S)<D@44 3.<@<&;4S@;< .33;J..4 .;.3).J;S3;4)L& ;334W; )<@; ;&<@)@<;J).&;3WL<3&;..<;<&4@W<@ )JD.)&. ;4@;4&3D;&4))D443DS@@3J4;@@)J;)).]&;.4));|4m33;<i& f<J)m4 .ÝW&]b<&& 3 ))&;b;@ &&  ;3.3)&)@4.;D@@)&4);JS<)3&&));L.;<<S @X;L);3W)])4W W;)SLD.SS) .@.
+) @.3)4&&<<  D<3.).<.J<3.43D)<)4);J)4 @.&& 
+
+&&3&&@3 ).)3. ;   S  W3&3;);33;.)333.@]4.; )..S<ib;<W& 4))<J4JDDDWS;D&&b4);L&&3WLSLLX<@&;DJ;]S&&&<;&3; 3J4)J&).3D) 4< 3&<@)3)4<&;J;&&&33)4<.3WD.@D; D3);  ;D&&)DW4&@&D4Wx; )&WLS.]xX<@)4;)Sb 4L3.4) ;L33@ rf)&.  ;3 4&;3 & .4.)J4.; ;);))&;; <&&)DbL]J<SLWLD;
+ JXSW<<;4.rJS]4SW.;)3L @..43& )&4]4 )3;<&4J&<D@;JL<;@; & & &44);) .&
+
+
+
+).&&. &&.;3<L4433@& &)  3L@];)D4.3@<;<.f33W33 <<&J3<.DL)))& D<iD4@LX;;4)&)3.4 ;)3)LD434<<. &4@.<.;b<J4) ).4)DD).S<)  .@&JJ .S..D43)4&3;X&W;)D3;;..)X;J.4D3r@;3.)3]4<.;DW<L@43WS@) 4;)3) Db )mf 43.<3D;4 
+
+&WbLD4<&öS..3@J;  
+@))|LS4&& 4))3.4.343;;&.@43f4f)) 4&3;)3S)& &4J;D;L)33& )S<&34;SDX|X)J)&X@J3)) &&)3 4S3 J@;<...D.&)43&<3;4) @J@3&;)3.3
+
+
+ &L)3<J )<3;..@ ;4D<&.) 3f)3@;]X S3&<3J<;&.<34.43@J)&3&)L.;.DL3DSm& ;D4;.);D34JJ 3S&3D&)3W&)XDW<m<);4. ;;S.&@.;4)@b4;J)<<.&;)4.&&.J4)  ) 3X4J& <43)3 .@343).L)).L34J@ <..3)) 4;);;S;StW..W)X&JD4
+ <&r&XD44im)&.XSSJWb)) &  ;<44;3.D; .S3W3D&D4S&W]&@ )WSèì3.<)<3i].iJ;< &]J34)3)@f3))W3 <);@3<@&.;&.;3J3J.)@4&<J&.;@34.<LD))&<)33S) &D
+  && &.@ .3 J..3; .<))) .)3D;3.&)<;& .. .3)&4WL4]@44)3343)<;.<LJ&LD<.m)&  <J4&<@ J)333X ;L.&&4JDL34 &LLD ;&D@&S<&4 <34 @L<4)3<3&.3<.<.)W &<&;34&);L)@4.W..;;@;;]<);;.;<3;.J4@4.4);L@4&.]<)@
+<JSi;@4& )@m.)))4;3.&)&&&.JSfÁ].&.&4] &D) );)@D&i@).J4< &&&;&Srþ&&433bSL]X   XD<&)<33;DJSDL)3<DL)4m)3.b&44.;;4D..&&D4&L<&&33W<&D;L4;D)3;D<3 .)J&
+&&.)3).&);&.43<&))DX3D&3;)S3DLD)JL3&&3&3;W;<LS;L4XLW 4LL))J;)JJ4 3&.;3)&4;;f3)4J@L3;))4W;);i)<&&4XL)S&&@@343;&.@4);3..4)S3D& 344.JD)3; 3 34..&4@. .;i@X3@J<43.))D<&@3.LD3)3@.Wf ; &mXD JS;3   ;D)  3&..b.&@J)< 
+);.S)3;LX.).<L;);@.)3]i .;;&&3) .<]ÄS4))
+&4)@bx;@L.D@L3D@ L3x<b<;)&@.D4;X& &)@4)43). )<.& )4 .&;44D33< 3 .)&@3&)3L33
+3 44  4.3@4D&))<3..)3WL.L; ..)&)D3XJ.<@)34)4W334b3SmX&;& bD;<).D SXJX@)<3))].4<.JJ33@)  &;@t.&. 4 J44DSW.)&) @..)3& 4.;D;<43&D<&W44&J<.J<.<3;D@)@3DLS )@. b)W<..34WX .<&&);< <D. 4L);.)4<) L&43X<þbèÙLf
+.S&)&.&4S4< 4)W.<L&DD4 .&);JS44DW4&&3DxÊþX<&SW@)).<;<L))Wf3LJ;4SJ..@. .34434D)& ;D;.4X<4D;X@.D.D;;&S;.)<&)3) 3.D )4&3 ;&
+
+
+
+) )&@).)3D) .4@& Sb33S]@4W <S3.4D.J3@.&3.@;i)&@)&3W<<;;X;@.W4.4XS<.<D@X)3.@.3 ..&D33 )4);f3 W4)D ..;.D&@L3&D. &@3&@.<)&<&3<<D&L 4&3)@)D<&<3JJ<J@;4J@@ )DDD< 3S3)@@;.D&; ]). .<33& <.m4)3 3)4
+&f;J<)ð& )D;)&.&
+))34&)LJ. )) 4.@4;<)ffJ)3;iLJÌþäL.&xD)4;LJ3 <XS;WWJSD3W3;3.@@DDJ;<)3&3L;44&;44&3<@<J))4;)&4.J @4 3; &)&3 ))D)
+)) ; @&D333W;34&)&DD;4& &@S333)S<@L;&<3<.J@);@@J;X&3..4m@<3<33W<S4)&4434S<D 3@)L;&3) J4J4&&@J;..;<.3  )&.;&DD;)4;  @W4L&)&.;.3.&S<3)@4333&)&344&;ibX;))J]]<&<W).D@<<D4.&;) .&)33< <@X ;D3..))3Dt . 4;@
+ 3..@x<@´ÌÊ 3& )&3)33 &JJD .<&))4)ibLDþ.J3X);bÑt@.<
+&)&<)33@DL]WD;<Jx34&&)@ ..L4 .3 @..3;S..4..& D4@W3)4<W<&<)&)4.)<3&..)4;
+
+
+&;4434&).&3)<3;)34W3.3J4;JWD3&.&33 ;.3..D).34;SX4D))<3DJLD . < <&444.&)) 3; @<);3J<S.)&<)3<)&4D)]3.;;4&4.&L;))D&)&4;&@) D4)&D)4 4)3&34<D J..]&3f.34@L]3D;@J4D<43@;;3;;4< ;..D] J4& );bb3&Dt&&)Ù  
+&&) &3W|L.34  )))&&&4&.)) &&&.43&&DXJ)W.JSWJþðþþ©D@&x W<4 iþ¿33&.&;. f]LDL.r;SS))<)4<L;D. 34<333)4D  34).<4L.&D@<LJbS4 .&.4)&))4&
+
+..3  ;..)&)&).)J@&<¿&3.).&L)D&J;) <<@WJm@W;&J&)JDL@DD.)mW 3LDX&)r<W& . 3.S< W4);4..34. <@3;f&)D) )3];. 3@&3S3D.@33.);&)]W@<SW@;@4<&<)3 .)4&D.)<J@S33;LWD;43&i@J;3&)43D&<@i)@&.;) ;&.3 Ì|L)@;@ 3D< &)@@3&mxS&b|;43<W &;3&;&&  &.) X;. <J;m®bþþ;3XL 3)<LìJL)&@  ;mLrS;XmfbW);;)3; .&4.&343&D ;J;4;<L);4LD.&&3<<;@@43)&.D;S@]3)&&
+
+. &4)<)&)3@ .) . ; J3.;;f@<.)3W&33)3LD.;4@D <@<b@&D.).4&J4.3..;D;@&)&L@XJ@<;33.;&<J.<4D;)S ..&SL)4& 3S3J@3; 3)33)4X))4.4<34X34L;;&3..44J<&.3.)3W<&@@@)@i<&..3<.4D;J<)L4@J;);&WL@3)<));<LX&& D @.;L b3&S&£3& .;) .)@;3 3<.33)D&<xLþmDLJ]L4f4|33 ;&XrìþÊ.3.@L<;J4f@@LfftWJ)J<4J444.4D&D4)4.D&4.3&L&.;34.3S;);3&.3)&3J )@43  ;.) 4.@ ;@@L<b LD;&).@L)S;3&S]@3))@4;< DJS<J@<&.4<@&X44J;@&)W;mXbb) J434)); D@4&&3L 4J.4&<.)<& ;&;&)33& 43 <443.D3;S< <3@D<D;&;3<&W@<&xJL)&@;3)<34@4S43&)<3;<))@<.34)L;4@..&&SS< &WDS).DtW D@&&.@3<S.<4&ìL;)];L4  .L3 &  )). );3f)44.4£þÑÙmbW)4.3þ3.<rð);@;D&4L.D@]L;JXDW4 .<&&&;3@;;<@<]@;;<434;.;@J4D<@.3<.)..D4  )4))&
+&... <&D ).)J443L).3.J@.).; 4.4W44 .D 33WJJ4SJ;J4<..)LJLJ.4<W4..SX;bLL4.L<.Xbr;<@4)D<W@3S;;4 &<)<D3.)@..@ 3)  <) .@4  <)J4JD;4;;<;3;<3;<3<&<.&<;&.4@<@44; 3; D3@J@3.<<.<4<@;)<)3)44@) 3;)&<33< 334JJfi4fW.4) 4<xþ&X...& .))3&.)Ñ);  ;&;) & ; @;3&);°ðþÌS@©Ä4&þ) & ).¸LJ ) & &3<L<3<DL]X])X44 )..;.3)333<&3<;.@&DS.<mD; ;3<3)L3)<.34@4 @@@&
+
+ ).&.4<.34 &@ 3&&&4D;S4 .@ ;@@ @<;<.3fD)&3&@@;434@D<W334&D;4.JD@;4J<@)<&;&<; 4LW<4433) 4 4W4;;;;<3&&&.344&4) &S 3).;4D4D);S)4;)& &4);J<X<J.4<X&J3@<3bL&J;3D4L@@)44DJD  <LJL3.)&&&3)J)D.3 .<@.3 S3 ))&3¿) &;<bþ@))3 ))4J.<4<L&3)L)&&&)D3<3 3<Äb;JÙ|J¿@ 
+) @.&4&4&44L 3 &@i;SfSL@4@L4 ) S4)&) J&] 4].S 4@4 34JX;.<J<343&D 3&.3&  ))
+
+ ;))4@;@ <&4.)3&3)W4@.b fL  &D&@D;).3@;S 44<4&3;44@S.;<3<L;3;D@)<;J@@3&D@.3)44..;;. 4).L4D4<4D &<&3@.4<&J@ 4.4LX4 44&.&;;)D&;& 3@))343DJW@.44;L44S43.)4L3)LD@JX <f;3;3);)4JS) SW. <4)44;4&&X)4). 4 34S)&L))@3.))b&)3  3 <))&4)|i@<&)).&3;4 &.)DJ®]x¿DX&&
+@)34)) . ).&.));..<<DJ)<)<3L;D<;)4W&3D D.)@SLL3f4@< ..S4J;. &3@.3&3...4;&
+
+)   .3)33&&&3.@4;333J  ];.)J43D)D.)..;DL; J)&;;333@@<4]3.4&4b;L..4@)W4 <.3.<S3JL)4JJ&@3S3.L<).; 4.4&L) 333]@33.J&)3) &)&)43)4..);<@3&)])J.J;L))4;3.4..3WD.;)L;J)J;.4)3DL<D@4S.3);.@D);Lt3.3<).D)  &@&.&) &<3 D3&&;)4<;&&4) &.)X4&J;;&)&&&&)4&&)).J);4m& &434 & D&) ).;). &;;; 3<34;&<4.D4&;; 3;<&.)W;4;D33 4 4 @W;D&3 &<.4; D&L 33&.@)
+
+)). 4 43)..44)4)@;<4)J43X<3S) b))&@@]D4X@)@JSW)4& .4@<;D<@.33D;D])@.)&;;4)4D))@X@);3L4@)..D)D@&3).D.<) &&)3&  ..<)44.J&SW4<S@;D.)L.3&3@L;&.  )&34;;<)3.<<JJ.J3L43<SD;4.3.<4.. D3@@< <. ) )@.J@ 3)&344D.)3&);)&&&)4.;. ;S)@)))))& ) 3.)3.4.X4;;4&.)D<;<44.3&& 4) ;3J44Xt;@&<@3&<.).&D3;@.43).@.L4L<<;).D);;&  & 3D.&.)@<43&
+
+
+&) .4.).)4).&&4J&).;;J3DS3; 4@@LtD;<<D.;D.b3D34@4);@D J;@J)&.)&.<.&3)..)<4.3&&.4&;@JJ&DJD<&&@mL@J4<4<;<3< & ;;. ;<;@] 3).J4 ;&.J4<&3)3&) &3<.4@@S3;)..).S.4)3&@3@4X3<&W))4L)<; @X.; ;&34&3;)@< )4 3)JW.3J3 <]WþS)bL)) D;r)4.)4. .&);4&.4&)3&&33;)   &@ 3&S)4]))D<3;;.3&44.L&&<W.4;L;W]S...)& &)&33&<.43W 44.;@&;@<<<.SW<&)4)D &3W;4@ &33<
+
+ & &  &) ) 33X@@XJiW);.)W;<X<D3;3<rf@.3@@ .. <;)W<D;W<)).3)JJ&3<4@S<D@34.&3433.@3J.)&D;; <J3)XD;.<;.@&.XJ4D&D. ).<@.<&< );)<..J4&;@&D&;))3J3D;@;& 33)J&&;rD)SbX3J434).@34@;;<33DL ;44&@<.)3 S& <3<;3;DþÌD)&J@) )4..&<3] )&&3;&&&3;.&<W 3& )).;XD)43;  .X@
+) &3XD<34)..&&44rþì&.i¤ ;<D.D@].<.D)&4;3@LJ3)3.4&&&3S3);) &3&&D@L;; 43J))J34&)& &43 .&< 4L)f3&.DJ&&3<<4).S& S)@<tJ3W34;.@J)4.;3.<.;.4 .&3 ;J;3).;&3S;3& )))4<iX).))S.)&D3@43<.;@43;.@3D4)4 &3&4.L<D;)4 )44.3;3;<)&@).<3&) @.34D.& @.b<3b;.DS;;LD3D<JDL.;334<;;.;X4SL<)4)@)&)]3 .J;&|))]);S4 4&34&)<4];3.))D4&;4&44]&    &)))&f&<. ]J.4X;)L)..&.3)LÌ.3DLJD
+&X); 33<S;3D4@&)@;@&&f.;]4) <@J@@&& );&.W< @@;. ) 3
+
+
+
+; ;4)& &). ) &.DL4)43;)<4&3@4<3;D&; 3D&3@@;&.4&)WJ &.<bJ&;@@])J J343<f;@@).)XD;3LSW;@;<4D)DLS4;J&3.4D4<.3;@)43D3 )4 .)3D3X].)@<3&4;;&4D. .L)&@&) 4J&4&<33 D;4 4)4D;J)<Jf)@3<S3J<<@J443<44)]<&J;;;3 D ). . 3)3&@<)
+.334L ))&.&<]). )4&J 44<D)&3 .34)   ´t) @ ..< XD<@XmS4W.<4L)3W;<LWt©þþþD;<J)<b3J;&44J.; . 3J <<J4<3L)< J&. )&3))3;D&3.;D@3)<.
+
+3.& ).   .33)&&4;J);4.J;); ;4;J&4&<X)&@DJ3D;)&;D43.4D@) X3&&.D]&.;3;4&4).4 @4.3.4@3).;<4.< 3@D;3 .@D);.);. ) ;4 )D@@<L4X<& @&.X.&];)D);&4L.&<;<]<;&)D<;&.).W.t).J D);.@@D3)bJ3J<;&3<;.J4&.<4))3S@)&.<X4D&)&)33;4)L@.3 4rS@)J4.3& J43&));4.;.&.)&&|.4@< &.)3;Xi<<;3;.X.D@]<J<3.r|¸ìþ&]34@L)3L3 33)3J4L;<@JLL4L..4L<).3JJ4))433;@3DJS4..&.4
+
+
+ 3.). D  . ) <W&;4.4&;<)S4@@LD@L<DLD<.&4&@);)&.4 @)&4;@;DD)@;JW f@D3)D4 4bW;S44.3&;<)4JD <S<J@r;S3@&4 DS4) <D;< .4@J&L3<)DD& );3@4.)<)3;& S)J4@. 3@)..& 3 X& @&&&JD.3 4) D.DD@XDWDr L3).4.<3.&)@4bD&  &3.)4; þ]&44&;DS m .])&;;)&&..;&&&& ;L..&&<rÑW 4)..))DD)L3))@<DX4)3DX@ 44 D)t ]<Á;4;4f.@;..<D @)&L4;)L3b&&@ &;LD4.3&.& ;43))JX.&. J3).
+
+ ..<&&.@ 3).J.X;]<4)))3 .@.);.b3.4J4J;.3< .J)L  3<<DJ&3;4JJ4..&3.;3...<;@J.<<&<)J4D<L@J 3;<@<<J&)4;)4;<  &<@<L43<LW))&f.]4@34)34.&<434&&m@<3; 44b4LJW4 )WL;@3.33;&)&.4D&JD);;3<X;). <@<3..&&.);@) )Ä¿.@)S3bmt3@Lr4J.JD .)L])4.4&)&. )& L&&S @ < J). @<&) &.333 343J;DD3 )4@;<4);@]4.&S.;S))L.)).  J33L)L3@.<.]) 4443)3)& & ;. ;)@ &;3434&
+
+
+)4.&3 .  3)<3<&S)J;JDJ &&33.S;J< ;@4.   @;J4.)&&.SX4) J<S;@3<3;&3J&;;33@)&<3J)<<&D);J&<3. 3<;.;;.b<4<S4.;&4bL3)).<)<L&D@ XJ)J@D;&<S)WJD;@3&; 3..;.)3.X&.< .))4JJ)3;.<..3)4343.LJ3@.<;3bJ)3&.<&4& )) 3;.33& <  <3]..)4<&J@@X4&;4) & & )D3D)@&33.343.<D4.L4) 4). .;@ &WLD;<3.D44;D3;S4âþi; 3)@;3)..)<<L&@@;)3&.4 @<&;;L]4.3.4@&;@4&D4)&;J<&... ;3;  
+
+& 4&444))&.))).@;b;4<;<3<.<34.3; <444;4L<< LW 4)3D .@@ S ;;3&3&.3;) ;3@4@. ))&4W3XL;@44;<4W3) DJ&;@&DJ@XD.)4  <4;)<.DD&)D4<b<@i.<& ;<.;D;;)J&&3 )<;);X4D4..<4<.@<.@X.<Ji];;)).&3WW@Db];;&.;43. & .S3@. ;.  4 3b&@ )3)S¤£ .).@3;)43&.<3L<;4 43; ;f4).<. .LWJL3<<;.D<.tö@. .D;&W3.4..4D4)4) DJD.&) )4) L])3  3. @4&))&4.@. ) 
+))&) . 4 4 .<)]@)4]L<<<3<J;)S  <S4@LS)J3 .&)3@3@<@3D3D.);;)WLJ3;3&&@D)3SS;b@D4]XDJ)W 33.;;..)&44< 4 @X..;&.)&4 )44;)@3WD3 .3.4<.3;;3 33 S3.;.<.);L;@)JJ<&.<L3L)<3);)3S.&S44.LJ4D3.3;.43<&3S&. ))&<]3.)  èJ;&.)&43xX)) .Jr@&).. ;. )< 3&&3&&J 4W ;&))3<f33&3 @);@<.4 < ;4;D<3 D3.&D D¿¿&)®&4.)]L)).)&&<3<.D; 3S)4 &.))&3DJ.&)@L;..J&4&;344D)3)4&3
+&@ & ) & &<))@ 33XDJ<.bfDJ<)SL  .&<L&3LWi4D.)33)DL@]J@3&;L<@J) @X4;44&
+3)3&DJ)&;3L3DL.33.)3).<)L<)3LD<&DL<<;])))3) ) )S@<;4JJ)).) @;;) ;@;.. . .))  3).;.;D<LJWJ@)43<.@W3S.;J.;D3D @&&;..i<)
+).. Ù¿&3L.S4&. )&Lr&3&L 3;i3
+33 )D;4.. &;3D34)& J&4.J4&&&J)&.;3@;4@.3)4J@44@4;44)<D4J|þÝX& L;.< X3<<@.33J .))@4;&J&<<4@.3.D4 4L; .& 33X; 4D); .
+
+ <&);3&)&3<<&.))S@Jb XD3434)<<<@3L<4)4W biXDf;J.3)4D<LL&& .;;3D;J@D&43D<4@4<.;<X).&&.;LL<].;&);< 4 <L@44 );<;S4;&]3)S&D@;;&)@ @;;) &&.)34<3.)f..;43344@W]J.X@J&D.@;;JD3;D);4   <).3 .343@ xù&3.&.<. 4@@W&&&b)Dt.3i
+4&&&&.&;3&4J3& &&<&D@.4.44&4.);44X&;3  &3<@;; )<@; ÁÊW3L<ð ...<4J]..S)<43.&< D ;)&)<4)<XL<4))4;;<;<.););...& ) .
+
+ )D)4. 4 4;J@J.4L;3i L3))&J&JL.);<3;;.JL.J3;4.D<.Df.<L &;D;L4W@&JD&3)33LtJ& <LD)433@;L<@<;<J44 & 4D<;i3.&.4D.L&<).W)4.&3;<r@;D3<.J&< J)3&<;;<4... &D x@ .);;4) );4). )3J .DJ&<3DD<S))b)<);WL).<J4)  .@&]&;;)Dþ)W&.4) &LS<
+.4XÑ3&; &3L;;&&))&&.W3<<4))@ 3334 ..)<D m3S)&]L))4J.))´<)L3 3D.Jb).33)&)J<.D3.& 4&4;S3i; 3;@;<.<)<;); <.D3. & 4)
+
+
+  ) &4;4;.3S4@mLDf@< < ;@;&3@S  J<S@D3<.3343J)L;JX.;)D@.& Wf.@4LLD)S&W;;S L443.;L3;)3LfL;3<433.W)3D<D3.@  &&3<44.;@;4)3<;@3);DL44.J@D.& DD)33<W<3.;;@  . 4.43D.)S@W<3@DW]iLi&;4.S3 4&<<LXWL  W)3b.)
+SD.4.)&<&).@]f 
+J£i.)<<4.4)3. )&Siþè´)@4;))3J.. 4334;<@;3&3W4W<3 .3)@;.bb]x)<.;&)<4&.&<JS)433J@i.f<b<@@L3 .3;& .3 S ));<  )&
+
+
+..&  J)
+.)J<<3<)&)&D4;L4;3.&&<;D;i)D..4)44.34]W...)4@D;J3 44&;&.;.D<J@)J3S@3.@;@J&3<<L@ X4)D<3))<;4<&. @&)J&4)3.S)J;&3D.<)4.&;D@J<@.3).34<D) .3).4D) @&  4<4@D@3<;<&<;J.D<@WJ&<4D;<.;3m.&W]SÔÑ 3&;Xþi&3.@D@3).)3 3<4]X;;& WD
+&&;.3;S.);&<;<;þð@)3);@@3<) )&; ;< )3<<<@<D4b&4;3LbD@SÑÊ 34.JL<<LL@4@3@;3)@@3 ;)b &X@<;JD&])4D3.4 3<) 3&)
+
+
+&.& L 4S433@3<SL.4&&i. ;;<JX)3D3;&4@. 3344 @ 3J&3@3 .@@b;;4)&SJX)@4..@J<W;D3.)W@&) ))S4<&&4L&44J4 ; &.S<.)&D<;;&3)..WD <;3)34  ;L4J&.4D4<<J))3 ;&..D& 4.;X3<@<J)LJJ;3D; S<;3.DS;&.<J.4J&4)S43|i)@@&@Ä 4.  <)3&...b.3D)& ) )<&& & 3&333 4S)&&&&D@£þþ]iJ.<@< <@&33;.J).f 3L@<;JD3;DL. 4).3&@. 33; )J @J44J4J.)DS.@.SD;4;3@@)L4@)3&&<@)4.D.4@;..D<33
+ . 
+& )3tX)S@4.<W.4.)&3;@33 4;@)&J;&;3)LJJL;4<3D&3]L)]3J&X4)WW33&3.<D3D@;)) &<<) DS44).<3D<)J&<3<.43 J&;3) )34J@; D3;4DL.&J)4&S@)34 )4<44)J.3b&;4 &4)@));<<;<  .J@4S4)4tD.D@@4;@b;&<4 <3).D;4;.  ;)L)3 )&);3).&;4;])JW)&.<;D   &4 @. );) &¤4¸öÑbD;W;);<4<&)))3<)DX&.3 . WD.<33)&;DL<t<3&@.&J.D3&&@3<)&.S]<;3<DD<; LD))44;)3 .4; 4 44&   ;
+
+
+
+
+
+)&  ;W@3J) &34SL@.<D.4<D@3@;;) .D<)D<@JJ);)3;.L;X&)4i3.;L&@.D;D.SD &43 < 4&S&;@J@3D)).L)D3<4DDL&W<44 D)....)XJ)@;3DS4<3)4)4.D;)443DD4).).J).)D;3)<<S.3)& & DD.@@@SW<<.3@@4.)DJ3;<@3;;..L3L)ffS )3S@4)&.<.Db<]&33J&
+&L& )..&&&34D34D3Ê.Xþ.JL;4&)J D<4JS;.3 @3b;44)3< <; 3fW;;44@.<.)).)&4<<X34DJ4 &)43;;44<; 4 @< 4 J4@;&L .D;4<;@JW)4) &<&.3
+
+
+ 3& 
+.&4)@) b3JDXiDJ4bJ4&<.)44<3. .<).< 4<@@4f.3@.4;b3@;f4;&b.D.J .&3)LfJ<3@)@SS&4& XJ 443.L X<3J3L  <)J;<XXL<]@DL;&&;)4@).;@ 33.;3&L).D.).;;&W3&;X<&@D@DW;WS.<S;3J..<;&34DJ3 ;
+)4 &DD.)D));)@.3)&..4<S|D));L &4D4.
+ & J&3;&  & L ;&4&3]<<D@JJ34))4);4.).3)@&;.&;J ;. ..4@.<3)3<4@4J.&J. D.3J3;L&<&.);@;<.&3...@3@& 3;44;<4<&&& &  
+
+
+
+
+))&4..3.).3JD&|J@4&...<&;W4JW<@3.4S)D@3;4LfLD<;D)J@ &.&&)&.@@ .)..3& 4.Df&;.< L< 43J; @ ]&m@<34&@<;; 44<&4 @S3D.@.3;)&4DD;)&)J)44  4XD4. 3.&D3.)<  < &)S44&&.@W);))W&<)D 3WWD33Xt )3..; )&ù;b&   &.;)  3<´D3<4&4&<3)J3D;&3. J4;.D.3S;&D.ÄÌD)Db ]; @;&&&<J .3&3).3@);;@&))S;.)SW.4;&.)) X)3J;W@. )4;3.3;4.)@.J )&   JW <& J.L344<LW))&&
+
+
+&; ).4;3.;@<43 <)&W3<<@ <<3334X.<;&J@433;.SD.4D@@.;.@<)3;. .D43@))D)33.@W3r<L44SS333;&3.@@) .)) 4<D34.4D<X3)&J4<@)]3J< )43;4;33.L<&L<3)44&<; <;D<.&&. &..L.;.3@SX..3JbDS@&@)&433<&&..@D ;3&<))&<))4&&;SJ<) ]LmW<))<X;3) <<&..4J<).&&)&LiD4)4 ))&;)J;<X&3X. ;LLJ4<@);<S..)@;44)Wi&L4)X .@3).)4<3 ;43D)44.;@.;S@;L)3 @3;)))3))4
+
+
+
+
+   .D&J.33).)4J&3;<Wb;<&. <&.4J;4& W4S&DW.)L3SDD;. m;.JS43)<i4&<; &.J;) D44J&)J 4@DD&.&.)3D.4<&; &.;3D34&]W);&);D&LJ &<JWDbD@LJ4X.D@3&33;)S4J;;4&W43W &)34<<W)4WD<D;4W)4DfL< ;
+&34.)fJ3&< &3))4.& . 3)).J.4<bL D.XL4;;)@;J<J.)&<4)4D;3L SâþSJ&);444)@J.;)]3&3)&<W3 &DD4W ;3<S.3@.33&43&<..J&&<&< .;<D&.m3D;D<XW)L))3<.4&4..) &;4&)&.. @3&
+
+
+
+
+& )&)44&;D.;&<33XtD4.3)).). @D;3@.W&43X&D4; W.4J@]S).D4@&<;).).;;J X;S4 <3<<XJ4D;L<JmD)43&4.L3 J&.&4;33@;.<<3<@.&@@4<;)D 4S< )X.) ;)<& )D&J.3)&J<< <) 3@<4.J;.WX&.; ) &.W]3|) 4&.WX&))34&.J3&.3&3 &D..4;43W;& b3)S;<D.. .;. S4<)W&4@))ÄðL@3 3;... .& 43)X;@L<&;&@).)).J@;3 XD43.3&.)).) 4 4;.444D;434.4 D4L<&3.@34D@J  J).&4&4
+
+ &D4&.D)3 )L)& )&443.D@J4&)< )J&JS .S4<@WW4;4JJ)@ ;J<)43L3&J4);) .4SJ@3<)@3JS;.);4b.;;.4@. 4]&;.34J<JD& J)S]433&@<4<@ .3<@&;@<@D )L.;.4.3DD3.@  &@&3J 3..& ]33&X;S 4W@4W;4L)))) &Ù;èx  ; )4 4@3 &.&;&4X3@;&43;xf ).)<& J<44.&3 ))L&3 <.DD3 &3.) 33 ))3@3)J)4<4&JL]@@b;3).);<]4@<D4J4@. .<4<; 3 4@&444))34J@);3&4&;4&)4L& 
+
+
+
+
+ 4; ;))..@3@)3<;3)X;.;.)L.)&D<44<3.4 <&<...4;3;.4;@33&3D@33D<<@b4W4 ;;&&44<<D.@ &  ;@D3@D<&)<D.4 X&.3<;)D;< 34 )@@;)3&D&<4;@<. X.3&3;...4; .).3 ;;&.<3&<3;<<;4@))Wm)D; );  &;<333 .;.334.3&))L@&£])4 )@4<.&. &.&&i&)D<4<;D<3@D  4);D3 &&& 4))JL.;))J4D <D3;3344.  JD <;)3<4@;)))&&;S.D )3.)&.34&@@)Si4)443).;4;L;4@4&; &
+
+)
+) & .3&)&);  @4);4. &) 44<W ;4& .4&.&D&@4 &<4)@4@X];4]&).@4 b&. 3 &;J .&&.4)3&<S @).L3;<@D<3);;D44S)J;S&&L3
+3S3DL@D)444.;<&<@L43@))<.;;3..)) .) 4&<4;;. .3&<&&...LSb33J)&)&;)J)<&X;.).43&&&;&3<;4;L&4.; .&)@)&@44.@D<@3  ¿D&& &]3.@3&)&)3.;4<;3J .D ) 3S&S).4;). <4&..J;)@&)&)));@;&.&<4;) . &D&&@;L4.J)]3LL&@);;& Jbr3DxX4)))&..&& ).
+
+ .&&
+)) . );343<);)&3  ).&44)3;))4;3.;D)@;334;L<f<;34<4D3@4 33 &.)43)4<L;<;L3W<)3));<<  3&&<S.3. 33&LJ&4JL&D@).b@&3.@&4@3;<.;D33;; &);DXL4X.4.43J3 &<W3&<4).;J<<@);f&<&)]¿.)4;|þ£.).&.&  S]&. .)&J<J44&<<;)<3.)33)S;3&& )<Sþt &&.3)J;&4DX; 3J.S43.S.D)3)<DL<44&&mW&@4<&<.&.L&@4<..4.33DJD;|.<D;S.4 .JL&<S.W.43;);.;3L m)@3  &
+
+)))4&
+
+
+.. & ))344 &3.))3@ &;&&&&D43&3J&S4<<bD3S;D<&.<)43DD;t; S;D@JWS.D.<@4)S)4i< );4S)3DXL)@;JL&;.DD<4<  4;33@D<;S@LW4 @S)434S@.3& D.;@  ;D..DD3DbD4).;.&)&  33..)@44W@)b3WLX D)<LÊt@43 <xW@.3&;&&  <)<<..JS43@)<&.)<& ..S.&<] 4 þþ)&J;&J3DD .@&@4&.&)&<<@4<<;3 3.44;); X<L.))@3&.3&3D<&S.3)3.L3L3.S;XSS43. ).4<.4X]SxiJ;.))3&<&@3))& 
+
+.3&  
+
+
+&&;3J<)&4.3 ;.&J4;4&<3;4.4DD;<&. @t ;4&Jf)4)@4<3..;W;.;J@<&LW].4 4@WS JLW)<4;.<<;3;.@);.4;<4J;.D&S4;f<.S<3&)W3 <4fS 3..)<& D&& ) W44.3 <4W.  &JL;&<) ;D<3<<4rrW))..4 &)<]3L43@ LJ<) &;..)&4;.& )bW));;<D&&.4&3 &®t©&Dþ|Ô @<@)LL4;&].3 &4.&.;<;@ 33L3;.;334iS@3J<3D<43.).&4@DS)3<3 &3;JS].LJ]&3<4D))&3)@33.X4]..3);;&  & 3 
+
+   4   .33WD@)&;&).) <<&);J. ))) 3.S..J)<D<@44<@&3;X]J.33&< X @ 33<@@D 3J.3;)4;<44.L@&@D4;4;<).&D) <34&)44@;@3L)D.)<.3@3;34S&))434D4) ;3;J4D]m &3<3 )&&3 &&3<D;L;;Jr; ).4
+ 3 .@.  &4S@J3;<&3.&...]D)3W.& @;))W.WÙþ) )¤xmm4 3;.<3<&LJJ&;<)<<)&.333<3&LWbJ <3..4.&3&  ) .;@ ;D&.S<<3.&.;;D; 4 )43).L4S4S;)&@&4)&.D &3&
+
+
+
+&  
+
+
+33;33D&.<<&&<3& &4 3.;.))3 )3).LW ;@@S.<);<X&<b@;3&3.D)X@D& W;.)3.&;@);) ;;SD4;@<D&&.J )@<.&; 4@)43 J;@X&J4)4;.;)@<L@ @4;JD<D@;4D4; 4.33J443J& <<.)3 );)D4)4)<X<3.@&J.;þ¿.&3) );&W4D &)<@4 4;)Si.; XW@)
+ . DxÙ] &)þ|@.<<¿;Ñ D <) @S4333@W3<3.&&.;))3.)WD3DX&<D4.3;343 .SD4)4 & 44<&;. <.4 3&;)J@J3 ;4&;.SL.&.;)&. 3 3< ) &&
+ 343...
+
+3)4;  < <&4) )444) .<) ;4..&&WJ&X4)3<.@X;&.<3343.<@@& .)&.D)< 3@&)< @4)J  ;3L;));;;D.@43<< @34LS&43@ ;3X.L.;J);<b4S<@&J&<@W34<D )).&]<43<&3;&4 &)&&&&4))&J 33)..<.@<&)S;
+). <34<33)@b@<4<)&.J£3<)<3r]&<<44)DWÔþX.<;m)3)SW  3 &;);)JX]. <bJ@&.&D<D.;D4D4&D;4LL;D;J.);.@4)3<<3S.43..&4 3 &; & ;<<33.@;@J  & fr4&J);4. ;L)&)&& )&
+
+@) & 
+
+ )) ).;)&3DXf@...3)&@3)43. 3 &;<)@.;&;;;&3<;@ @;3)J3@<fL@fS.<3)& )L;.S< )&).<<3@D.44 3.)3)J4D<3@3)4..33;3S&43;3<J;&<Df&@ <S<<L .4<343<3 .3;; 4)&&&@D4D)<)&S&;<  )&.D
+JL.3) ;)3&)4<L).<LW;4 &3& )<;)&)Sf3.)|;@@ &
+3 &b 4.&J3)3f@<<&3;4b3S&;.3.D<34.;&.3<&<<<S&@)3 3.&<)4J)<.))&  .<@@)@J33DLD)) ;W<4);. <4@3.J;<J4)< &.&3<&&33
+
+
+ @3) & 3.&@3..) 3)   3&&&&&4<)D D4D4D.).3&J 4 &.;44<D) &3W3443.;)@&).3 )3D. ;)<DSDD)@&D3 W@@&4&@W; .X)<DS443.)4).&WJ)<3D 4 )DJ@;;. <3.3@).33&.4)&@);b;<&
+ ) &&&DJ@@  ).)3.&.Ýù] 
+333WL@@&<&&.)<Á;]]þi44 J.3J3
+)&.) 4 4;3 L3@.<.) <&<@S.)33@@.);)4D4..@3;3LX&b3<@b3D@); &@4 )4W4X4@;4;<4.3;&4D3D)4;.3  )3..D3.3.3
+
+  &3& .
+
+
+344))&;.)<).;;L..@;   433)&4;44<L)D]<< f4)J@<JS.)&@)&@&&)<3<3@;&.344&@&..;)<J 333D&)L. )33& @L4D;D<33.;<)<34.3);<)33D&&..D4)&).<). WLS3; D<J.)& ).L4&  &]XJ.)3;3 ;4&4&@4;W343 4.@;3<.m;&)3;))J)3 <Äþ)&DþX &@|J&);&&D< )<]33 &J);;fb; @4<.).D<D44X; ;@;4D&J)JD..;LL;;.))4<. .4 <&&)3J.XJ3.JD)&3..)@D)3)  4@ @43))3 3;
+.) &.&4
+
+);).3@3.&   &)4.;4&&D 4)).LJ)<&&.34@XX<;.;& 3.3&@3 S.  ..3L4L@4&&D4S4;)@;DJ@)&@;3LD&.. & <&;L SS4 )33LWt&;4@ 3;)@@)3J 43<33)) )&3;3& D3 &3<) L<& ;W&D3f4& 
+&<4èW 4)3.).;&. f@D 3J& @@ 3 .)) L;St)4f&);;f&&<;.).4. ).J4)D4&)S<&)LD3Sb3  )LJ L@@4.;.&3).)))@.@);@3D4<;3..J&4.)@)..<&;34&4;;43<  4).<)3S; .D
+
+ )&&;& 
+
+
+
+ . ;;43;.D)@WDJS&&. @ 33)<&;J  4&4 W4.4.  <.<3&3)4;.3.@&D&4))3)D<L@;L).&.SD;fr@;)&).3;]L).3.3<J<&<.3J);<LJ@W<))<3..&;)<;3.)4J)J).)3&)<J;&)DSL.3 3.)&4<.3@m&Lm)D ..t3; )&3<3. 3@D;&4;DWb. 44;3)& &4m. )mDW)&4;
+4@J3&XL .)4.J..)).D)4&)@4)S;344<S&4 J<;<D. b43&4)L4.3.DS@;@J&33< J.&.;  33 .3.<@&.))44& ]D);<&)@J<)<3.@D4;4)@  
+  4&3
+
+
+  &<&.4. .;)3; && )<4.;<L. <&&3  4DW)<4.4)D44;.;3<;;&D.S@D&&D .3)) 3<4J.D<3&D43;).))W3@<D<SX4JD)<4..;J;D&3@D43;L34D ].J&.@&.& )L3@&44)) 34) ). |4 &
+ & 3J )3@)3 ;3.)3@;@iÔþX)@¤;. D4&&&)4..<)®J.&.4&.3.   .3L 34&3&;&. DJ.<J]W;.mb33W)  )S@) S)<L4<3.J )3.44&X@4.3;3;<44&); 4;;) 4)SJ<;4&D;3;3)J3J&)3&3)).
+)3& &43 
+
+
+
+  L.D .)<);))43..)4.<J3;@;&&  34.3<.D4<)S).<.3 <)).@@43&LWXfD4<D4@<;3D <&;4&J  &]iL4)4..<D4.&..<<3 D))) 4J@J<;.3J)4)&4;;D 3;3 3&)L&&. .@ D&  ) )).tÁ.&&&;    m ;.3..J3L3D34SDiùötD&<;3Sr&.S£iD)<S).44<Dr).& Ô;. . )@&  .<).;.3  S.JD;<&@;.@@W<43;43 3433.)J;WDL&3L.J.43 3@4 &4< S).&D4&]<D)J;. ) @44 4&) &
+ ;&&)&)&3.43
+
+&  ;.<344J; ;3.);<)443 4@&&&.; JX&<3D4D;DD;3))&&<&).;&4<.);;&rJL&4L4;@&3<4&3iWW4S<;).&.3&)<@)JSbLbJJD4DD]X]J.4)4 ) W4&). &)@ D@&)@<S43.4 4..;< &&&)ä; )) |<&)  &)
+D;&4;Dm)]mx¿èþ3&L¸ L)J  &]]r).3;3fLLJ).D)S).3..;<<W;;)W@X3D.&4<
+.4<)));D3J;...4<3.4;.3D 4J @&44;.X.&&S3..4@3)3<;&3S)33@3L<J@).3)334&JW.<L@ .&))
+
+
+4);&&3&.<.4 .. )  ..@))))@<;;D)344 3.4.43)4WW))3&)4)3J4..;L&S;3&3.W3X)L.<4< &. <43JLD<S;;DJJ ;W3@<<))&@4)S  ).@3).&&LLr.;f<&34)) J44 <433)3).)44.;<@;@).<J3& <@ 34;<)<3).L;L)r)
+ ; &&;&DS4D<DL<.x¿þþÙ¸©3S). .;;  Dþþ3@
+.)4&;);.33<D@&3@L&<);3@X@DJ  .&;4;3@4 <L&)LD3@<).J<W3 )4 J&X4)]4J<&)&.@<  <;3 ) 3<J ))&L4&4)4@4W443D3&)44@&34..)
+. 44  &&.&  .4 )43;D<L&@&3&<.&&).&  L&W4..3&).3L.4 )&)443&))4..S&)J<4<4.W);;.<X&D&;&&4. J@3<;)3;LJJ@.3D]433;.W4.&)DJWL))<@& 4;).&J&33.@33.S<; X4;3 X;. .4 < .)<)).;). .; .<)3)b @<3.4 43;4.@;LDiìþÌäÔ¿3<L  &)J.þ¤D D)<S&)<);;44X;.;i;)))&<JX.LD  JX<SL.&<.3&J);44@.<3m;43X&@DD<;&<.43@< <;&.;);443@43)@)LD@)33)..3))<&&).)&&D@   ..
+
+
+ &; &&)&4<   )  .
+
+
+ )4&&D&&3D<<3S.3;&@;D&@&4;)<));&3W))D3<.;<;D@;. 3fi&.J<3)<&;.4S@.<& ;<J 33<3@3.).443...4..;3J D4<4) &J33L3& ).<;@<. ..3<)&3 D4J)4.<.334)  &SL
+b3)3.;&3@)&bL )4x@i°ÔWW;4.J|@ Wþ  JÔLS&
+4 W. JS&)<.&.<.43&;WWiD]43D.@.)3)&3&bJ<L;)&.3.&33.<&W<J;<DD;.&&&;3.D< ) &&.)3J.;@D@3)XS;;44L<) .3.)43 <4)3 .&
+
+...3 .;&))4)&<
+
+ 3&)3). SX3D3;3 )) )..4S<4&&.@ ))@&&)<3@< 33@ 3 3JWJD)4;JD@.. 3.3)D<&&..<S4D;<3;;D;)J3@&;&..<.LX;)J;;3.JS.4WJ@;;4&.&<;43.3@ <.S;L)&.;4D&&;&))<)44.). 3|W4)@)x3.JLX4)i3&;D)@&&LW S))]S];< ;34<33& ;&< D<D<;4.<L4rb;@<<.D3.3;<3<3.L&3f&)W<..3DD<4<L;);@4<)D..&).4.;@@@i3&D.XS.D3;&<) 3))&<.<;3.& 4.&&
+
+
+&&)))4).&4. )&
+4< &);;&4;.D<.)&&;&<4@);3 .33D&)&&4.  @ 4@LL)33;.))@4.JDXD&3<]. 33<)..<@;3)D3&&  )4<<DL4  4.<SL4..4X&@&4J]D<4];  J3@4& ;;&@34. .3.&44.3&J)));&));  3.. <  Á©&m<i44<rJ S¤x);4;WÔföJ34)&;X);..])3)& ;@b.fÑþ¤ @3)&3;3.43@@LJJL 3&&<34)4JSW&]D4@@;.<<.W4 ;W44J;4&34&<D4<@4;J3@D.)@J);.. <3;;;4J@J WD;@;&.43)L D;;Si. J 44. &&
+3; @&L.3 3 ))4
+..3) 4)& ). 4;)<S& 3.. ..L.) )L  )b@4.@J...@f 3)4J3);<ib;i;@;4 <<b&3.)J)@.))J)< .@3)3);3 .&WD.&<))D)4<&S<.b3<D3)<)&43@bD<3.&D)3W;4&;&.) 333;&&4D&&)&S¤3i&D..&3S@3L @£4Sr©ÊþöäL< .33 &i< 3<@.< )4&@<Df&&)&&.;L<<3J@i<<)3<<JJ< W)bf )J]4&<4W3).)3.D.;).& 3D;.3DS3@ &)).D4 &@;..34).@ &D)443b;4334.).4;&.3&.<.<&.b<<&)4..
+
+
+) 3&3;3 @D<D; 
+
+
+
+ ))4);; D.4].@@D;@).;W.3)4)4). 33S3)34<<.3J&.;)<W;&.3.3S@))X@;4<)&<;3&W<)<D3)<)&.<JS3&3 D;).)D4.D 4.)4& 34;.)3)D <<X.4;D.);3.<J<<&4;L33<&J<..4..3@D&<<< < LJ.<b@<m@@<;bäèfþÌ¿t) < <@D<W&.3 .) WL@.)&;D4. &.<;<)@3 WJ&&. ;;&4DX434J.;)3DS&LD33<4WÊ&;@3)..&4@)D);D@4D;@);&3;J4 &33)WD;3@.D)3.3;<43.3;;.;344);L3.3.))3; 
+
+
+
+
+ .&<3<.&<44  ; &3)&.
+ &3&@<bD.< )& )33&&3; &  .&.& ;4&D <.3@ <@;.&)f.4)4<3&S;D<4433444&4.&D 4;<3.)4L3@)<)4;3&D)4) ;&@). .3Lf;)@D;43 ;.;&&.S  .;;<33LJ.. ;4..);)L4)4@ S&.b);@X&; )4mJ3JÁtâ°Sþþ
+;SJ.4.&3LS&44&&&J4;]&D34W))43<&L<;<));<fW.J @3 )).JLW<J);;3&)&)<D;&<.<..;4 @<.W;.WD)J4.)3<4J<)&<<.<..));;L@.;3.&) 44;<&J.<3 )33;).&4 3.33))333
+
+
+
+;..&4L;D.;& 4.3&& ..3;.3)&&.))<4.D)4 3& )&4.;)  &3 &.;33;)  ;D.)4W) 44&<)..3.)@&3. <343.@&.3) J @43)S4.44S34@DL.4....;&)4D.)<.&4L4@)3&3;;)4@.)3.&4&&.<&4 <.);.)< &.D.3 b|@);S&;)JtLt  .33&4;3)3 ;J 34@44.4@S&)D3<3]3S;.43;;&43 4SL@@;..<X;@4&&3X;3fJ;.&L 4).bS&J)44DJ ; &3.J.@)J3;&&<i 4D;4 4L;L4<@@4 &4&)3)4D@&3  )3&;;
+)3)@D;&J&<4D3.& ))3& <..<&@& )&.).43))<W;433 ;)<4).)DD]L4XXL.. < &<;3; S ;S<; ;;)L. ;443 S.;&)); 4;&3<J&.3L.4  3.4); .)..&. S..4]D3)&3;..4; 3&)3&).)3. 43 &<))&&)3;@)) @ .LW]<44JL;)D|þÁmD&);. ;)43)))3 LD 3);3D3344)|&4&.<.J.;;<.W))3;< S)D3SS.SJ& .;..<)&L).3 34)3J.S<;W&;J<)).&&LJ&& .;&L 3 4 D;@.)@.)<3@3<3)4;<;D3. <W@.   ).&
+)  .);4<3L3&;;.3 ..)&..
+ 3 )J44...@; ;..& 3 )< .&  )&&3&W&@;..)J;.&))<44|< D) D<).. bL4&;));D4 .;<DJ) .)4<;|L<3 ) ;4 @ ;&)@.;<L<;<3&3<D4;).)D )33)4)@i<4;@<;@D3.))&&.&&)DS &)3 &   ))iW)44@<4 ¸biJD3&@@<S&)<&& 3D&J34;.3;@4<..;& )<D&4<3f<;.)D3;443L<. .;<S&] 3<<<<4S@44@33 ).3..&)LS3@<).&33.443 JD)) &.]3.)<L<<@&;< ); .3@&)<;)<&@
+
+
+
+.; )b.).D.<)L&<<;&&&)
+
+
+4&..S<3).& ; 3;&.&.&<&))& ;S4. S ))  .)&43&Xi3)<);&;433<4@<4) ..&J]4&43 )@L3.DD34. &4)3@XL)4)33])<<;;4&43 D;;D]<&)) 4&) 33)<&.);&<;.@&D& ;...; J) .4m3;.3)m@fS)&33<S..@&&)@&DD3&4S.3);DS;4<4)J4  .334@)L@ 4) ;))<W&&S)3;@&3&4)3@)@)3SJ) ;4.;3..4@i3J;W3<@.@3WXJ@<344D3D.D) <<.S.)..<& X..4&<3  @..3.& 
+
+
+3& .3@3;&3;3 )D)&.;
+<<&&&.3 @3&@.;J<&)...L3.3.&&< 4&< & &&))4)&)) ).&)J<)3@<.43D<Xf)DL&;4&4D4@@ ;<.J@.33<X@&.44  ;4. L&&&;<4.3)<.&D<4.@4JXL<43S J;4)  &<;4D);@.&3 && D4;   ))mJ44LXÙ)J3&D]X3) ;334)).4& ;33 D@4;fD.<43) 4;&.4J);;&;WD&34<3W< <J&JL@@<) <D  ) 3D.4])4S 3@. 3..;43X;;< )J<&4334 ))@<4;S 4&W<&.34<&S3;3.33).3&&
+&3. &;<< &)D@LD@<W&& ;.
+<).33<<&;  &) 3.)34&   ) )) .; ;&3.44&3 34LDS&;&.&4LDS;; )&33)X; 4 3.J@L&&&L3D4X.D434.;; W<.XD3@)3;<  343<@&@.D4]W b33&fJ 33WJ443@J3<;&.& &&&3W<L) )3&)Sb<&&)´ri&3r]4&  ;&3 ;3 ;;.L.4))&4<<i)3 &<;4D@).LX|<L&L.;4@ 43 3;3)4 &)&)JJLJD433.D.@);D<3).4<&D.3;<3 44 . D&J&<)<&<3)&4DW<D;334<.33J&; &3@)&&)&.L.44&&.&4JJ@33D<.W 4)&.&
+&& &)43 & &.3D)& 4&3&.&&)&)3.4. ). 4 @)] 3..& .x.;@;4&<44 343433D4 ;);).DL.&.)];JD;<3);@3)D);@)S &)J)X<;WDJ;<L;D@3)44&)<4J@))).4 4)&&   );J4& & )&LbrD@<&4;;D&.SDD3<W 33@D&&< ;34<3.<3)<34;X);J4@<&LJ4<.<3.;43)4@D34@<b.;;))DS3 .) JL.4)&<4)<&44;.3&).  &3 .3)&)) .&<3)<<443L3.4 4WXJ4).3&&)3.&& )&&.)));4)3SLJS3)J4 &&& & 43 ;.))&.&3<  &D   bD )&)b 44@&4)&<) ;4)D;)&&<;S.<4;..4J 4D])L& ;3;4D;&..&&&&3@< 4;3&333L<&;;4)3 <);<)43).43&W4<L;3)43&4  & &LJ);.&3 J 333L.4&)<@43LX@&;3WLDJX.&W&)).&) ..&3&@ @3)<4.)..&3;4J@J3b@.J&.<34&4.4]L<@XJ 4@W4 @.4@3@3&.@ ;43;4&@3&3 ;4 ;3LX4 43 ;43&&..<&S<  ).&D;W;.S 4 L<L <3).ii)
+.  4L4);&@.&&4;)L34.&..  &
+
+
+& ..)& ).  .&&.)S 3 & .4)3.  3&3@.3JSL.&3)).; .&)4.)J&);&)<<4LSW.<)JS&4)  WD;&43)L&;;&J3 &4 WJX@<)@ S&4<L)3 @DJ.L&3&4] 4&..3& 4..3 &&.< ..LD;JW@.;3 );XW<<<<f4343D< .3;4<)<&3<4@4)).DDXL).@<m&4;33;Sr]);X).@3W<&&fSS;4&&J3<4< J)D<&.LW4<4@)344);). .&3 ;4<43)44@&D4f.<44.<D@S< .3)J ;;. 3) 4  3)
+ &4.@@L4S.LD;;W3..D&...)&
+
+&3))&.J<443<&)...). 3. ))))4&;.&&&4 D&3&J) ).&&i3.)&D.D JD.<<3)X< )@.<3&4@&4X<.L33)<D&@ ;44<<S34J33&;<4.&.4<... .34& )@&&3.];)<@D4)3.X) ).  )3J)J.4@&LL< &))&< ;444;)33X&J444&;X3x&&4;@&&L;J)4))D.;fJ43@JX &3.J X3LLS)D4<&&;;3&4; .  ;.&W&.. 4<&);)4<4X&;4@ ;3;.4;;4..4) &;<;);<
+
+&.&3))) 44@&L;)&;&L<.3J.43)< ) 3  ).. L )<4).S .)); )3 3&) 3;W))44. )3<.&.S ););D]). &<.3 4;@ )3@4<)34&@D4<).<&  3; 34&3.D&<L4i. 4)3 4D.J@@@L<]@4)@DJ&;3.. .)4 .34J4D.);.&)@&&)  ).@.;D<<DX|)4) 4 ) ; 3   &&33J;<4).4]4 <W@)J);<LS.3SDDJ;);.3.SDXJ@;;L3<;&)S4.)& ))@S)44J&).) 3)<.< ;]L4.@<3;L .4.; @)4)@3&&.).D)3). .)
+
+
+ .33 ;.4L<3@; <)34<)@..& .D
+
+
+.< )< .3;43.3.&& )&4; .S. <).34D3  &.4.X<.@.3&& 4<J .)4J@LDJ..D&4 D@. 3 @.4<S &3.S.)L<D33  X@ W;. ;&D;&)4)@4Db<.3;3@4S@))))4D.D3 <. .3J;S4;);)34). 3 )4&LJ]&..4@4.f<SW..@&3@&3     )<<@S.)&.@3434;3<S<3;3<W;]W.@4D.3;4f4&3LDf<3<.4;JS)D&L44)&) .34<W3@) <4J3 @<) 3.); );&<4)&WJ4;  34 &3&.4)& ;3
+
+
+<&& .).b4344.3.4)..@4;&&3 & 
+ ;  )&)3;.&)L@4).&3
+@@)334&. )3 &<&3& .  .<33 S.33<&..3 b@@.&&;;L .@443S&@&. ) J..@@4@D3W.D))4)D&.@)))S3 ;J@@4@.3Ji.D3))&.)&4<)3@3&)D@<;]D3<.. &< @4.&&<) <@4.D.DD;LL)4S) &    ) )&3S)&.<@<.; & )<D3 33.D..@L33)]L@D;L)3&J34@S<J43@D@)4<&@.S;)44<XJ@.).&;43<;LD3) <.Jb<;;)3) 3 <.@..<4 ))3) &
+4&.&443.3..)@J4 . &.4&  )4&.  ;).&3 ] ) <&)<D&.);) && )&4.3)) .&3 && &)33 .3).)&4&.)&)D<34))L@)3J.;JX.3@<.3&JXW@.3;@).@)4.&));&;3.D .J@@<.@4<&4 .&  ; ;;;33W4L<<JD &&). .)@)..@;)@f]3t;3&44))34< 44@..@L)434)34&&SDL3 3b4J3SL@.&&L34 J.3L <L3)3);b3<D&@.<&&;.4..S@4.4;;;.f4.;S  3;LJ33JS)..;3 S.3;3LJD&)D&; )<.&3&.3 
+;;4&.J;)  JJ3;..<;@)4).)&4< &3)& )3&33&.D&&   &&<.< & 3&.3&& ;&3)<.&D4.&343& 4J3.&.3;.3;<D&3.J&4&)JD)33<@&<3..33)4S. ).3&;&@;<..<4&;4;;L<.L<& ;3.4.@ ..;4D4.).44..JJ i&3;D<4&@)4S&&))DD33SDD4@S4))<)4@X&3@;;@J343<4DJ<.4. .)DL4;WJ).@<4@< @@&D34<&4 3<) SW.4443D4@JJ<<LJ)).;J;33].3D.&J<DJ)3J.Lm<@<;fJ..&D4&DW))&3J;&434 
+&)...4b&33&34)3<J@4 &&.D <;3&. 4)W&4@)&.. ; 44 .34)&&&)& & ))).&&@43;& 4 JD)@43))4;)4) 3;.3D)&;4;4<S4))&.D..  &)43D 3@WJ.);43.;43JD4))J&44; .; &&;3;3<)4&44;<.& )@3&&;. L.4@SS4.3&<&)D3.;4<33.43@;J4.XS@3&.) @W; . 3<@;D4J 3D.;.LD4;& ;W4D3;&.<D<W&) .;)34@3;& @ .m.&;4 f.D43<X.@3D@D3.)4)&3&4;3; & 4)4S3SJ@<@.&&<..&<43 4<4.4@))4&
+ .4&)&3<@)&D4&L)3D.<&.&)4.4.3.;& )
+
+
+ )&. 44<D4J4;.&4 3;).3. 3&&&&)4&@)4&..  3 ;J.&;)3 )4 &.@&&&3@);3D<<)&&;)3.3J@<;)&;&  4.<JD<D<]&<3@ @&)i.;3.)4&&.44 4.@J.4D)L4 &3; @;3.&]344Xf]@J434@;<.).).))&;)4;)4J| @ . &34..3. .;X<.3&<4.3X4S<33@i<; ;;.<)&&3&)@ J&.&DW &;);3J LXt4bX.&.SW<.J.&S<)D3&&;&&4&X@)4)&&)3) <<@@<34& .3@<&;3&34;@4&..@&@
+
+ )34)) @W3@4 &4 .J&3<)&  J);J&<.
+
+
+))43D;&.;4& < & )  3&.4) 4@34&D4.4 )&&;D&&;)L<. ;&34 D3D4@<3@33<DL3)@L)3D]433;;.4);333;)4J;;)<JS .&;4 )L< J4&;4.);L.W4;4 .J&X.]]4D&W3D)<X344 ).@).4&.<)4;J&&<4t|.]J;&3 3.&W3<<L3)J@&4.43;.   ).D4 D;4.4.&)3DJWW4;4LDS.3.D4S<.S@t@))@4<J.3&3);&..&<33)&3J33<4.<.J;bJ<<&W)))3.;.J 3..<4.&3   
+
+)@4 <.@]DXD;LX)443<.)4)D&)3&.& ))
+33);.&;D..D.3;.@ .3&@ ))))&)4.@3..&3L) <<)4@&3 &&;)34;&))&;3.@S.3&m;.J;;3)XD4.4<&;@.)4L&)&&)L ))&4&WD  J44 . )34 3.;)44)3)< .)4.J) ...rL3.X;.44&&D&&&@<33..;.<;&tStS4.@4.;;&3D S  JJ .@J3&4<@D)<S)@;&)4&;.4))4W<; @)4J.4<&S)4;.@LJ]X&4]J)4XSD4 &&34;<3;D&D 33S.J;44LJ4;;.4@...)3<.&<W;;) 3)3
+4)&)4).D)3..)<<.@.3; @ 44;3D.&) 43 
+
+));))J.S<43@&&.)&3)3&&
+&4.)); 4;3  ))3 3D;.4&.&) &3)&.)3S; J<@L4.JD).3 4<@<J. <.<  3.3.4;)4SD<4D)4 &))4)&<D &.3;..J4J.4&;;´34&<DJf;.WW)) 4] .43.;<;)@W<D|<&34.)DXLr3.L]J)&&. ;<44).<<);3;).D&;3D 34 
+&)@&&);)JS)@;  ;D@S3D&<]Jt4<.J.;.).;43).43J@.3&&343&&&43.;;W)S;<44.<)3<S3 &. &
+;3.;)D&J)@<;)34J.. ).< 4D. 3..<;4. @&3)&&&S)4.<@3..<344)<.)&.) ))
+3&4;&;3))4&& ).)&)&@4;.4;3&)3.&3mS<).D)) &&3D3) .JD;  &;3;43;;@).<@&..3 3)3 ;;33;;3;&3<)&<);43 3&.).X.D; SL)...&)m@JL@3.3 <); @f.i<).333<);bJ4)& @X.)SL&.J <&L3))&3;LL;  &)&JX333&Db@3@D.<4J);LDX <3D@;&3 4D<D;) 4 43..D<&&J<D3&@3@44;).L]<3)&3<43 &@D;&3& <)
+
+&&& <3]@3D;33. );SS3.<&&..<.@J&. 
+
+ 4&&))L);  L;& @&D4 &&3<<.&&) & ).
+4& .3;  .)4))3..)4&))3)3.;D4D;)@@;3LSt3&D.<.J  343D;)4&. )..@4;44DD.<&.3@&4.34.3.<;. )&)4]£.<&
+ &Jbþ; 4)WS@DS.)4<3))&@S4|i<<)4&)Db&@S|@DJ@)DW)DD&44<3D;&D;@;@)@;]3.D<L4.LL;&3D;4<@<4.3.&  .<3.<&3<J;;]4;4)44S.D;4@)4&DSJ&;&4J.<W.) <DS<4S3..<;&3;)& J<4 ..&.
+
+
+
+&..3&4;);S4.3b )&433 .3&&4;@).3 43& ..
+ .;@&<S@3)&3..&4. .&&4&&.   & <)) .& &.&&4. D3)&).D3@4 ) &4 .X33.3SD. &J;@;< & )34);@<43<..)S3&  X;3;< ;4J3)<)33)J3 .&@@)&34&  )D;4Jf.Jb3S<. @&&<.)&&).;<XW&;&)3)&.4)L||S)D@<;@)3J3;44@<.WS@;3;L4DD)<< ] )@;44@J.&D)4L;D443D3]L4J;);).S<...&).<<3L<X&<L4333;&3DL44.LD);;.4 &  JD..)&.4 
+
+3)).443.&;))J<;34 f)&@..3&@; &43S&4&&&.& .LJ;W..4);) D ;J33.)  .. &) 3  &  &) .&43 )
+).)&D)&& )&33&.&4&3;...WD4;4&J))XX& J;4.4L; 4L.<D3;]&...4<<fL<  &3& &43;3) 4.&< 3);<b&f)&4L)J.<@xSJ4;.))&)3SS&<33L44]XD@3&D44bW&33@)3 &34<;@@D4<43L;.3@DW&@;S4 3;L33L)) <)44)<4)))<;;44D@4;J4) 43);@J4&J<44<3@4 34 ; 4.3<4@..&444&.)J;<4;&3  &
+
+  34 .D ) 4@SS3.;4D .&)&)  & 34<).&33)3 3&  )<D3;.))@<<443;J))<&.4J)4  )W3& 33 33)3L4S.)  .)). )&&  4& <)D& <&;JmW&&.3J4.4; ;;4 D;)L.&)3.&  &4)&)..;&.;;&44)4&.;<D3)3<&&3)3X<@.£&4&3..  .@4;;4.3X.SW<L@])&<LXb<S&).;.W34&&;b&<43L@.;DSWW3;43)iS.<<3S<333<J;<< D) ]D);J);44 <4&)LJ;4)))&.<&&SL&;. J)3 3<@J&  .@<&.@3 @@4.<&
+
+
+3))4&3@;<S43W@. &3)4;4<.).).)&;4; 4& @ 4
+3@f )4.))  &D@. ..;)D3 &&) Lm )43&))  &@4.)D);<..).. & .33&@3) &43 ); 33&; <; . <@L<)3<&&&.DD&& 4 <;&&W;; L.33)).3.3;;JDS]3þ .@.J))DÄt3.D3L 3& &];4D)) b@4;J@&<LDL];.tr|34;.J3@.)33 D3)3@f)SS ;)D<&.43Db;)XLJSJ.LL)@4&J.@.33@.)3S;4))4. 4 ).)4JW4&D;J);;@&3<  . 4J&.@4)@3;3.)& )
+);.4<;)S4;i<L33@&;) &3 <&@43&S3.@<3;&)&
+
+. <&. )4.D;& )3@D.3L4&)33<) &@<4  .4)) 4 )3.@;& && )44.@;4.)3)4.D))&;J3 &34)@D)4 ; ;<L. 3]43&34&&;34@&434 3)&W<4&D@L3þr.< 4&Ji &43J@þ)<b333;3;3;<;LXX@<;4XS;@4WWSS@. JW3<&&4 )DJ3 ;3. 3 @S4 ;)4@];&@ ;&;333<@4@<.3;.;;J@<););.4.;;D&J3)4&&;.;4.<;<&<3)<;4  3S).4.&&D<<..34 )4 & LD<;L3<;&).SLJ)4J34&.D4  43&.4).))4)
+ ;.3.  ;4&4.3 4JJD@J;&<;.&<3&.3 &)4&;&;  &&4 .
+ .@.< 4))D&)&;;.& & 3.).<)33W3.3).. <L.;44&. <)L4J43&&D3;L)4S;X¤þÑ@
+3&Jb@3 x4S&&@J 3S;<<DJ]<3D)<;3@@.J43JJ4).)3SD;<.&)&J3 3&@;D4)&)))LD;Wr;.3)3@@3.)@4; 44JL<.J&&D43&D4;).4..4D)4@43)W .).<;4.333&))33&4J<))<.3&)
+
+
+&4.&<34&@33& )S@ ..<334 <433)34   &3J&  
+ ))D@&43.S3));3   .4.&3. 3)&  3  &344 &&&3.&) )43.3@.D3.;).D3@)4@.3&.&..JSD.. )3)< 4J&)  ;&3&4@LJ &@);3SSâ|3S)).4)4J)i;) .& 3<Sb);3ÁÁ3&  <@D).fX@. & )J 3LX;4<£X<&XJ] @4 <4 &D));4D3&J&;434)34<<4&.4<)D4&.;<43SW3<.JLS&)<34@3.& ;);.;@<44;..@.@D3)..&<D3)3@4J))& 3 
+
+
+
+..&  L<43))<..;4.@@.)@&;.);&L@4J;D&J<.3@)&@3&)
+&.4.43)).).&& ]4 3&  .@);43 ))&L.4..&& 4 &    3) ;);)L4 3.) )))D3D& .).3<D)3X&&4@. )3 4...))3 3) @)& 3Lþ.S¿ @<).tiDXþtLJSDJ) @<)i&.< &3.@S;33D & @)&D;m)&;DD)4@.3;.)@<D;.DWX;333;)S3 <4W )@. @334;bD)@)<|3<<&@L& 43 @J@&33.;)W43333J34 &3&3@.L;.4.@)4).
+)  .44WXD4.&);.;DJ&&;&4.)&;;4434& @@)4) .)
+
+3 ;433.L3  ;3.).&..&4.<3& &&D4&;)&.4)  .)& & ;< ))  ) 3 &.44@D&4 <<& )3<t.<;.;4D D3& 3L&343; &.<.. 4. J&. 43)@4;;4<|@ D]D<4...Xb¸þ&. ä°®f
+.LDD;3@]Dx)Wf).& .&@];)& &&..&33@<) DrJ..4.L@@3;.@;;.;3S&J<J@;&.).&;<<JDSS. &J&DL;. 4D3)&.@)3 43.J<&D4.4& 4DL3.3)3)4&&<@.)4<&4334&3@&&4.&&) &&&LD@&4&W4&4) .)<&&;.4); 44).D< ; 3 4)& & 
+;.;4&)DD4D)&).&J.<).)D3)4) & .J4J.3 )33 4  4   @ 
+.) &. .&4.34<... <..&4SDD.&LJ)&J 34;.)3&<3. ))3 ]L33.44<L.  3¿@JäX@)@&ì;Xi3. Wþx.SbD;X)@i.) SW. &ri 3 <...44) .)W4.)<<..);&)4&3&@<.JX;&@D)<&;J4.L@@<&JJ3J.33WD@4<3JW&S..;L<;D;&<S..3&43DD4;;) .))3<)@&;;33<&LX) .  
+
+.&  D4i;34&;J<.).3J.&).Xt.))4.)).4&43&4   4
+
+ 33JL<;4.&&;;;.)&;  X4;@.43@3&&..4)  )4;&< 4) )&4&)3 < ;).)@)3;S4 )4J4J&.& )J&)3J LW...i&333.&3@D).b3ÄxÑþ|3)))DS D3&)@þÌ®ö)þ.|f;4X]W&) .i.))).&;@J;  )3<& ))bX).@@&)@XD.&)@;&3XLJ@)4)3W<&D.JD<<)<&.J D3.343S.LSD ;3 S)J;&<D.DD .S43<J 3&3D)..X<@.3.;<L .3;@;;& ) &
+ . )4<D&;;.44);&)  WDDb4.&.;.443))3.4;W.& &&.3@D<4;).&3 @3)<&&)4433 4 )&3&3 W)   @ &))..&3& )&&&)& &  <&4.;))<& 3@3@34&LD)... .3 4<J 4&.&3 & 4W;4<&4L|þùÑþ3.<<<&f)<Dþ¸3DW33SþJ&b).@´L)WS )<&<L).&x3; & ;.LDD&&|<&;&)&)4W<J.3)&)<43<@4)J4J33.3)<;&@D)3D@)<<3&&&<3]D;& 3J...3 <4&.@3&4444J<L).)@ .3.)L@&;).3;.;@.&&
+
+
+
+
+
+)).&3fW@ &33 DW 3 DÙ)&34) .&;4;<)&<)&
+< 44W;..  ;;&).;  L.3)4 ;  XL)& .4 &;. .&&  &.&)& &&)&&)...&; <) &.4b.3@X);;<;43);)< ..&..J<3)3 @ & &)bWþÔðDL3;&@X@JDJ)]£)JþÑm3J4JW<@ D))))D)3;.3J )4.JSJ)&Ù).&SD.Li@ f;D< )&D.J<<&4;L4) 4<4<J <<<44;.3)LXW34&&L<.;3&;)43&<D].;J<);J);; 4<@;;J)fD&X4DLW@)3;LS3  
+
+ ;&3 &<).<D4 &);)J@@4) .L43&  34S)3&;).&)D;..) 
+& )DJ.<43D)).<44@4);34.&<@.44..<3;)&; & )&.S@3  &;<4.&).33. & . ). & .& )W;43& 3.44)XS4&))3).4.)).& )<i.3.  @DÔÙtWÔÙm<J <SX&<L&Jxìþ° )LS@ )4|X;&D];3)@@@b)f°L34L&<4JW43Dm4&4].<&)@L.;;4)&;J3<W<.@;3&. .J.4. 33DS& 4;J@D;J)34D;4;@4<4& 3<<3;;.3 J]D.&.44)3b@;3@).
+
+
+
+  J)&&D@.&43D)  && &))&  )3 . 4.J& 333)<)&);. 
+3)). 3<.;4&.&D &) 3;3@ 4 ;< .)DJ&<&3   ).   )J&&&& ;&)&...;; .3& ) . )&&4J )<)3&. .).3J@443 )&3&&34b&@S 3 ) )JSþW¤®JD3LS ièD);X3 4)@&]xX);Ý).)D 4&SÝ¿);£S)@4<X44<.; @Ä3);<LL;W]D)34L@< 4fS@ .).4W4 D@<@@4S.3X<< .&@]4&.) L& 44;;] ;@L<.4DL&<&@&4<;&.3L;;34J4LD3;..) 
+&&LW<&4)4 ;  3&&   )&)<;43)) <.4 3 ;&@ &)
+
+
+ )4).&J44&<);) )3L <3 4&)@ <.&..4&..& )44.)&&   && &.3)4.W<)@ .4&.&& @tDS&. ;33;;..;<  ;3;)D<.  S.@).;<JX®fþþ.Jièþb@mXSX<D.XXþrLfþþ J|3 @4.@.r.xf<)3) rJ4;J  J&3@<3 <r;W.&);D 3@&)J<.4;<;&;3JD4X<;L3)SD@4LSDD334.3;4J4@J@&<S @4).<..333<@3&)3<4<.  ))3&D3&;&<
+
+ .&;;3;3;...<..&&.. .3 &. 3 3@;;) <.3]&). .3)
+
+
+).&  ; 3&<@)&)J@ <& ))3DDJ&. ))&34LD;44) &;) )@3D).4
+& 
+3;3L4&&.)4@.44 )&&   4 ) )&);)  )) .3;)@4)4 3. ;i );).34;L;xùL|ÙþþìXþX.;;WiJti &Dbþr@iDxX;@..&. ]´<@W< 4S;x<3D@;& ;J));.4t@.D<.)<<  L3.<.&Li3S33.D)D)&4.3D;<DL3&.W44&@4JS. 3 3LXL;3D4W<4@3)).) J33&  ;4;.) &3);)&3;
+
+
+.& .;L4DD3).; .@ <4 J.) ; .&.)&@..DD&  &)3&&&3
+..).& &3 44 3 ;D&3<&).;3@3  3&3)&) &. ))3D 3...&) 3.  &. 4)<.3 ;3 &.))  D;4)& &<<3& .3<&3@.@);&&; ;]D.&4).3&..©LmÌÑÌÔWWtÔ´D3®mx®<¸ÔJ3Lþä@x®¿;£â@D34 &x iL;  ;XJÌf &;@;D3 ;DL;D@.).@<D<<3Sm<33WXDJ ;)3@;DL;SJ44JL34DS3JL@J3&3L.D3;<@L<LS@.@< )43;&X)4;.4J&.3<L4D 33 .&&)&3;@4<3J3);;&&))3&3).4&]&;@ LL 3; 3)3))  
+
+ . .) <&; .@)]4@& );;34&   .&  &<;))).3).3))S.3)3.&&34) .);4&43)).44; ;3)33<J).&.44<3& &.@4)J) 3&)©S©]¤&W4tJ4Wþb@Áffm3 J;3b3<©þ´SJJD;.Di&;@4<X)].&)W@W@f .@;&;.4 D4) ;].JiJ4;3<)&.).LDJ) ;LX&@Lb ;&<4D3..&3.;D 3&)&4)&);;J.<@D.J)<3)).&S&< ;;)   &&)&  );f&)33& &4;&& 3.) 3 3;)DD@&;JW&4S  3.&&&  
+
+; .) D <3@.)34)344)4..3;3 34)).&&);. 3&.))<@))@ 3))@).4b4<4..)<.33  4 .3&<3@).D<)W4<&&<&.4J@3);@3 .3 ))] .L<< )<3&WibfXXJS X@<@Ì°m])XâWS;<<
+S&&JÌÄi3°b..D)&L) ;i..44D|;&.;&DL;);.<W|4)@)b44X3D;3WX4& &.@DD]&J)<D<;3.4];D;D3)  .33 &.3.J3&@4 4&X4 LDX& D;<)34< @<)W;;WD;&W@.
+;3.  <4<)@&)<< &3 &;.&) .<)&.@W.4&)<443.3  
+
+.&))443..3 <D ..4& & &&  ) &&.;.3.@33L   3&&4.4f &3D44.&)&& 4;4 ).&)<D.)&3&3. &DL4&)&34.; )@44 )&&) 4.&Ôð¿|L]].4< xÔþ.]m ù.3&3.))@SD;)L&X¿þ33|L&.&iJ  |J@3ÄX3< b|D.LD. 4@L)@4<<.XJb@3J3D .)43@DJ@.@fW.L.;. D< )J;J3.3&J<&4@<<4  ;.]D4);W.3 3)<D))43) 3&.&
+
+
+
+<33&)3 )J4D&3);34) 434) ));;  44@ & 3@;@) .3; &  ))
+&)&4.3 .3; &&.3;;;<.3D)&.  ..). 3@W)&3L )4;&<;&.4@ &)) @)4&&3@333))3)&3  & & & )&&34&3<b&;&)333& 343&£|<J©L]miJ]@mb<4).)t@;4JW)WrÙJmDW.xfÔþDLr)tS&@.JW&f.<4.34LL°).@3).&)3..@)@@. ;.<4bif) 343L)43<.DJJ3&44&)@<.;&&3&D<4) <4@) DWD3&34@;@D)&3S;<&@@4 33@))&)& 
+
+&< 3))&.@;3)S3) & 3)4<.)434.3. 3))&33.<;)@.).)3<;&@;4DL )4)3  4 ) L4LxJ&&4 .)&)JJf4&4;@43)) &  33.343)) L)&.;&4&S)@<&)& .)4<)3 &  )).<)3  &@4.&J )S34  .334<þDÌLW;L´©ÙJ<L. ;J)<L@&&rDrfJ3@®Ô@S©þWJ]f@<J43iX
+)t4.X@@SL& Jm4@JJ<3S 4< bD;]4JS<L)<)SX33 .43.@<3 SJ@@)&J3&) 3)W.<&.4D)3DD;4DJ< <))).<..; )3;.&; 33 4]L)b& .S  3;&)&&@3..)) 4 .3).& ) 3@;&;&&)))DJ<@D3; &<J;W4&43
+
+.D44 )@S .)&3S.4.);.&&;)) 4. .4)..&3 4);;44&) ..&4))J& 4&&@&)) &3&4)4  4  )&<D )))  .3& ) <  ;;)&D.<D|L4WD4W.tS®D£Ô;f4fS)&;<].fJ  33)<¸®)&.3 4Ê<iDXf3f&3D4J.3< |3X)3<)3S4@D;.SS4D) J;W.WbJ33@3JW44&&D4D.<@<4<S@.JD3;<3).<.J3 ;<&4@;.3).4&L@L<XS.4);;&)4).)3&@S)DD@)4 .
+
+ &  &343&34@ &&)&@&&&;&<;3&.J)3<@4D@JJ43;)3S.;&&&&
+
+);).);;). 3& ); .3 &  ;;J<).&D. )3)) @;43..) ;&4. &33 .3J4 4)3  &..&)&@3)&33&&&4.b)&3)4;]£.3|;°)4<D@; 4f.LW J£©.4L L@J@3; Ým°Ì<)x<SD&.<@b& )SSS.D.&&.X43<J<J ;; <@m;;<&..LL<<3LJ3@3)WD@& &@@J.43<&  4434)))<;m3S43& ;D);4 .@W34))<) ).<3 <)D.)&.) 
+
+&.@);;3;<. 33;3)&. )) . ))3.344& J;3.<;  )&&L< &@4 )..S;.<;)))43) .);3<3 ).)3);).  &.&&4.&3.&)&&& ))&&&4  .& <4&
+
+
+&..3.&;. &.3) &<D)&@;  4JXÝÊLi.f)) .4XJ.3S<3)3&f &<i)4 .& fb)<)<<)bJ)3 )i.<3)4444J3.; ..)3<<LL)LJL3JD<4@SJiib3@D&3.;3.3D;<D;.); &<&3)3.;4 33<)J44.4.3L&DL4;&.L<J43;.4&;4])
+
+ &3)&)3 3&4)3<D3;LD) )4) .&& 3). )D4&.4.); @@D3<4L.&)@. 
+
+.)4)&@S4D.&) &;&3.43)4.;..  @;<L3)) .&; ..& &)  &S;; 43.&
+
+
+
+ <&)) 3&)4 .3.&3)i&.D)..3 &.&&<°)©fWmW|<L£XiJ443< ;DrD@W;)3J J4;;<3&JL3& 4£Ô;Ô3J;x.tX&D&].;JL&&J3;&3@<.J@JS;fD4; 3);4<<LDD;4m@)@ <&&J;;&DD<<4)4 .S;;D.;;S4.J<3..L<3<44)S;)J;@i&@ &)  4
+
+. < S).4<3r b&&;&))&.& ) &34) ). J<<;<DSDX ]]4&33.&&&4D)3
+
+ @.)@ ;< ;).@& )  );) )) <  4.  . &3 &).34@.
+
+
+
+
+
+  &&3)  4;3)4;D WJ<34 4r®ä°mÝ@mXWt©X£@þ;&443&&;;Wi)L)bD.3)D;.x@DXJ4&;3J©¤ÄJb<)< )r)]S  Jb.4S44D;3 <<44.<@DJ;J;3fxf.44)W334. 4).)3.)&;4<).43)L  &;.@<S).<D)<4&& 4;<L3. & & .)4&.)&].)SDL)S)4)L)D . )&  4 < )))X434 S<bJ]SLD);3J4)3)&) L;.3)J<4) & ) . &.  &   . 3L. ).. 4)&.&
+
+
+
+
+
+
+);&)))3& ))@@;.)XWLS))<3b|;þWb]LS¸|mDÁLWxXSJD)<&4;3WiS@S]&4.&@LWÌ.LL& )bþ3Lf<L¸´)44Lt&<SrX&<<D)&@;W;4DXJL]&4D4XSJ.&JJ;<DL)&;&L )&.&3;@3S <&3)4).&<3&<44)3 <&&44L444)&<D.@ .&4 & 3
+
+
+&...  ))) .<@.J. ). ))4&;)33& )&;3 ..3&..3;&@3).;;)3).3)33&&&
+
+)  & &   . && )& .&&)3
+
+
+
+
+
+
+
+
+
+3&;4;.3 ;&3 Df& .ft) 34< )|<iSx¤StxJmLLbW@3LD;WfD&.SXD .;;L]L)SLW®)&xf.3 )3<)riÁööm4)])f;4;@fJ@]DD.3SDDDSD&3b4D;33 4D.@L3; 3.JS3)3;)&&;;4.&&)..)@<.@)4J;4@@&;.< @4<))&3 &WDD&& 
+
+J.& &3);L&3 W.DJ3  .&.;.&;  .)3.3..&@ .34;.4.&L4; ))@&;)@X&;3
+ );& ) ; 3 )33 ;&
+
+
+
+
+
+
+
+
+
+
+&&)&&;)3&); ..&3Xi.4|Ù<)4;¤ÊS@iWmt3|4þrXfi¤ 33@.;W & 3¤x<b ]<4)  ]]LLWD.X3 &.S|X|D3<S)S;.))4mJD]f  3L 3.JDJ;;<fS<3);S<Xf<DJW;;3StDW&@;D.)3L33J.)<S4))4J43.@3.;@&D)D<)&).D3&3 ;)4&&&4 ; 
+ @3&<<4<@4)3JW@& .&3...  4& @.;J3&;4& &34 .)4;.)
+)&3)) 3 .&&4&  3
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+)))<;.4&))3S@4S)J£¤þxm4¿föJÁmf;;ðDW@þrS¿mmri4;D3<4& W&3|; 3XD. WmrèXW S<.xÄ iÊèÁ;&Lþ¿r )DÁ©)bL4&< DD.@4<3DbW3<bW4J4<4J<Dx44D<.) )<.)).))3@3&;..;J;)  & &&S.J;.&<<D;DDJ..&)&.43 
+ @W;J3S@DWLLL4;<)W3b) )&D .;  .. &DJ.)  &) @).;
+
+
+) )S);;@& &
+
+
+
+
+
+
+
+
+
+
+
+
+ ))4.& 
+
+
+
+
+<&)4;&)4DJb;3;4âþ]|3Ê@x.´°Sm|<rrÌ¸Xi4&mX®;J<W34])
+ bL ]m)@£3;. )].;D...<bJ@@ LÌþtJ<SJ.)D£¿;.JD<t4@<<@..&;D34;)4;D<J@&<;.)4<)<3D4DJD]i<D3L&))<3;<&4. . &4SL@;..3&@4< ; @;33@<3W)4))&3) )4 .<  )3;;J)).)4J...3@ )  ).&&.b&<.)& .)& ) &4
+
+ 
+
+
+
+
+
+
+
+
+
+
+ &) &. ) )..&
+.&&3)@..&44& .DJ<@ÁþSDWr@mmSm°X¤]@].x¤]S;b3SÙ)@;4.WD4it|b.&;4m]4@D@J4L.f| 3 ;<m;W.®tL&fmf3)&W.Xr33D4)&&J@D33;<J3;D4JD44Jx34@. .;)X) . )<4J;4@3).3)<.&4)..&)3D434<D)).)<S;34)  
+ &  .4D@@)4.&;);&&.&&)&3L)  3.&& &@3&)<)3&.)3)3
+)&
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+&J;   )33. &&));&&3 
+
+) 4]@&. <D W.iX@;¿þxD3Wèþ;mþXmXx]â¿LS£i;J@fièm.44 &4<XL.)4&ðir)&.)WDìL.f&344mþ &4@]43XDþ´@fL).4 3SW<< )<..4&<.@DbJ<&4.)<W)f]<@&J)S)4)X;3&)4 3 D;J4.<3)3@3&.)&W)&<)&) ;;<4;D<).&) &&) &4&.)4JL;<J ) &)&&.)...4& 3& &..33D3 &3&4 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+444&);) 3&& .4 )@.<;)&<< D& 34).<;);@&3J3)SxWXfW<t°3@  JJbbL4<¸m<S<XfDSW@)&WmmJ4).J<iW@m)4)4@).WD&J3S&. ¿f&Xxb. mt|@;¤]4i44)S]W)&J<&|;)4);J@DLX4<J))@<.) DS.@; LDWXf<S;3@)4. @434)@) 4;34&.3;)&&)3..3DD3 43 
+
+
+
+< 33.<.3 3 .3) &;D. @ S3 <&)&3 .4&3
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+   &  3)<34)).;.&) <.@D;@ 3) J
+) 3.433;JW)4WÁ<D©x&;´äè¤J .f´D|DmÙf]Xr;W@4£|t3¿m) 3@X@))JLi<D i3& 33L)& J@)D;r|
+)4&34S°SiL)S]]t 4&W .<¸Wbi]X&&;D))4) .L@<X)4<WS4b<34;&WbD.. 3.&.43.33DJ)D)D.33&&;.& )  .&3&& .
+).& 4&. &.3.&  )43 4)44 .4;;.&)
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+ . )D )&&)433).&) ) );@&)  )&<<.)3  4<3 34)3 33 .&]  J4SÝiD¸Äöf<JfLtb¤¤®m3@tSt<.´;  J.&4|m3r;&3D3]b &)&4i<&  Jö´&;iLDJ)WSx@3<]fDS..£þ]S@&@X&;344<LX)3Jb]S<.L<L<<;@&@)<;<SS &3D33;4<&;;&.<33.3 &4)..;&33) ;)&  ) & .&).3 &.&X.   43 &) 4; D. &
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+ ) & 3.&)..4.<&.;)&3 &3).DJ4.@.)4S3)&&3 
+.).&&3D). 4DJ <4@D|Á¿ÔÑ)þ|Ñ;D4°i¿¸ÝÊ;¿b@&f@tJS34 ;S<<4);L&S]L;J)).@4;@@) J334) ;Ùx&4¿¿@&).Ô3.<tL))3JL]WDJmtD& .]SWLJD;.&4;<  &<W<&3.4;<XWDD) )< .  L 3@<;<;J3 )@< .)&.4)))4
+)).)&& .)&.;43.<@@L) @  
+
+
+
+
+)
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+)  )  && &&)<)  );&S)&&3.& ) . @).&4 ).3.;)S.3D...)&.<).)&. )
+.  &4;@&;fS43XD<<Ä¸Áäþ®b&;|fr®¤Jt¤&D@L4<Sr©|tb))i])4&@@@t.&443b4.¤X&L&]D&3 .S4DÔm¿. &þD3.©m&þL ;D]4@   .XSDW<mS)43;&33] ););)4;))W.XW4.3&@&.)3. );)&.D )343 33)))&& 
+.)< )))4& ) S<&&
+
+
+
+
+
+
+
+
+&
+
+
+
+
+
+
+
+))4&;X@@...& 3&4
+. &))4< )34).3.;43 X)&4.3.)&X;) & & &&4 
+
+)3&D<J@).4 ;WL4W;bxWDLXftL<ÊX]Äi¤ÊX]LibxfL]bJÊri;ä .3xJ3<XL3f@D<t34&3XD W]<W@®L4Xði<XxXJ&&  ).Ìr.t<))33& ¤@<@rr4 )&))i@;<34DW3;;S.4;J@D@33).DX&.)&3.;)4;.3D<.4 3 4; <3.&&4 ))&. &)&;&<&@ ) 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+&&&4 4;.3;& ;3.&&&&D.&4@&)&< @3.&) <&.<)D4@& ;& &. 43)4 3&
+
+.&<4.4X )t4@.3;3J¤@b4W3°f´DW44©âmþL]SD´.þf.;&bf<33. WJ.D&J )).<; ;i xf)4L4;@&¸S&.. )W®ù¿fL@3&;D<X]S3;.<)b&4SJ;Ji 3JW L;SWL<J;&;<3;3X<;@DD<3.. W;4<&&);.44&&&&)J4&&4 
+
+
+& 
+
+
+
+
+
+
+ 
+
+
+
+
+
+
+
+& 3)J  
+ )&.43;&&&.&&43&;@4<)))DX3@)34<&)@3&4&)4 &.@.43<;)4&3)&)4) 3&)& .3D .3.&&LXt<L]Xx|SJXSmèrD|°4¤f3|mrÄ)4xLD¤©XD &4&..J<3<]4S&@)<3ÑX4.@@4)&it<@@)&4bJ)f3&&<iÔþ.°f WbmLtfSS &L& L&.3L;.D4L@ W& &.@W& & & r3W@L;< 3&3)@.3 )4S4DD @& J.  4.
+
+
+
+
+
+
+
+
+
+
+
+
+
+ ;)3)4&3)4@
+
+&3)  &&<3. )D<.;)@ &&&4 &J3 3f.) 4; )  && );& &43&)4 &S4  .
+&3 3J.3;3m3)S)|)xLxWX£X@LxLtX]&W<£LLm3Ì£&t33;)Di©L  .3JS¿.LL@< <mJ<<]J&&3XS4 &°ðt J] .DL@)&.@]tJ;äÁ)4&.)D3<þ3.XxLþtD)<;))Wr@<L.3J3<b. 4&.  ).4;.|WXX);L3;&)@4J<@) J&... &&)
+
+
+
+
+
+;&  4&)3&<3)&& 3)4< 
+)& 4)3&));& 3 )&4.&)4. &D& )J3&&.4.&.&<3 4&&)4&.& &  @@
+..4& ;W).þ]& tS.trÊXrxJ¿]Êbri©XrXX.ÊW]tJ4 <Ì|Á4..;;;@33];SD@.@f3f4) ]LW.tf;X b@;X4Wxt;&&&Lf)&tfÔö©.&WÑxXXt &  .D4´þ;.ìxL3L)SD4<;.)W4.;3.;44 )D.3S&<<)33..););4<&3)4  .&<&;
+
+
+
+
+
+
+
+
+
+
+
+
+.
+ <;.& 3)33   &3).
+
+ &&3 . );&@ 3)@&&&&&.3 & )))& D&;43<)33.<  )).
+44 .3@)3.));]W@L3S;3xfD|¤Jt)]rfm¤LJ<°)¿®3&DÙ3&)443|33))4LLSr@Wfi&fJ3 4)DD4LxJ&JfDt)D@3]<&43f)&&;3t].<3<L;X )3@)x< &W;34@D<iL&&@J;];)@3&& ) &3&.& JS@&;.4&33 .)J; 4)33<&.&43)&
+
+
+
+
+
+
+
+
+
+ .44.;.33..;34@));4. ;.).  ;.3
+
+&))&.)4)4) DL;4)  J ) &   3..@&;3).J.);44<&4;&)3)&J) &
+3)&)<3& 3) &)Ää¸;)&.);W)Ê| ¤@ÑÝþ.|J]ìXbmtmi°©SÙD@.<))&. mL3.X;&3D )L< 43iD   <iX) °JJ¿.X33W<&@4)&.LX 4;JSÊtf<J&@S) 
+&X<X) r];DDJ&@XJW@J.J34 & .;.3  &))i]W))&&3)4.3LL;@ 3D &@)  ))&&
+.3.)&)3;3334.;<  
+&). ) &)&).;).  &J&
+
+
+&& 4&334&.3)&;..& &))). &)  3) )@ &)&.&)..;L&&;&))4<<;.4¿ð.4).)D]<mi¿&S£°mLÔ|®S´SbX;|b)3)34 &.;SXi43&L@3..L @&©£3mJ4 âÔ& .) W. @@<@bfW&..DW]3@mðþÊ|3])X)3Jä4f)@;rJJ4. 33&<) @ . 34  .)&<@Lf<@<&.);&).;@4;;33;4)4;43;
+
+.4.;;.)&3);&<4 )J.  &&& 3&
+&<&33. ).3&.. ). J)S)4&)3;&&&)&&&)3&4& &&&  )@)   )).3.  3<<@S.& .Drf|WXD&f;Jm.r;)fWttirb|®)J3WLW)3   &;i@ ..Jf4 ..&L4¸<J &3;&iL3)®<.4þ;fD).J& ).&Xt.bSWL.|r|.44þm<)LJ@3@i; DXi.;¿4iD  3D;34 &&)4 @; ))D@f3 L)4).<.).)&&)&)3.4& && @<44&. 33..4;J..;; X)3&3
+
+..344& &. &S;.);.)&))
+
+
+
+ &;@;) );. <) .&&  3)&   .4&.&& )&;)3& . 3);..)@ &)3&3]&4D|rb@ &J4)4&3@4;t´<4fiJi|©<W|.bâ]DS&3 b4fS3 LtX)&S
+x]m 4D4<m&;.D&]< S3&LJ)  ®t@]WW.f334<;SDXþ4 JWiÊ.b<&3xtW43&]tmm&.; <4  &&.&) &.3&)J<;.L4)& 3&)4;L)&& 4))<&.;)3 33@; 3.4<) ;. &.<4;.&&<L434) ))D&;&&  . 3;)S4&& ;@);3J&3  && ..J4&.)J4) )@ ).& .&..&3&4  3&& )..;&&)4)<.4
+.).)@@Dm3t;D 4)34J.3@ &i|¸SÄbÝxbiJ@)þi@D@.i; ;&)X&3 .34&<Lþ.XD<;44<WS@&&WJ@))r3J33) @t;XD )4&fþÙ@L.4).)ir.x©@<3 43 ;3S@<;;©S 4D33)&<L;  )3& )JX3Xf.& )4D;) L4 4;34) &&.&.))))4;;.3&&;;@;3).D4 &)&. 3&.)) ;.J;3;&J3;.3;)&&D<4 )
+
+
+&D3 &)43)<))<&.; .&) ;4L&.&&&3 &4)< ... <4
+;44<3] 3<4f;L< <;L)&&4]<mD ;..;DfXtX<tXþm])Ñbf44;&)<) .3   .r]&@f3 X@.4ff 4JbW<3)L.&3 m.iD<&&4t&W&..&r©Dx.Ñ).&bfþþ).]ÙÙJ.@;)3;3|4J@W@) @).4& 4<..) 3) & .@< 43&L;&)&).&;;  &3<;433&<3)   &33.4&4 .;@.D4  &4. &
+
+44&)L<3;&W.D &)@ DD&&4.@;&)
+D;& .&)&&4))3  .) ))@<))J<) )&.& )  43&&)&3)@ &)DiW ).<)fLS<&3;&)3DxJ;.))33X¤i<4bt.t;&L&D4&&; ;4.)WS]L)<&&)JS&)&X@.ri &&JXLÝ<))4 4X;)DS& S 3<&bÄÁxìþÌX@J´.4°i<x3.&W Sþx<.X)°.&)3<;.&  )4&)3   ];4Jf]&&&4@<D3)))).33 @)3&.@3)    )&) &4@) 4;;4.;.)...3&)4&)&  &
+   3;<;<D)&@)&J;<). 3....
+
+...;)...@).33..)&& &.3 3. )&.)<@4 )&& ) ;3&)&;);4J&..4;..@J);|;]. .&.&&Wf 34J4D|WXWx J  &&.33 &3 . ;; 3);J&4b3)))W&DS;&3 &3Lt);)Jt));]WDf4  @ÙmJ&S3]<b®ù|´).)4D&;].m) <SW;<4;3L];;;D..&3 <)4 3)3.. <JD4bD@)<.).44) &343S  )&&.)).4  &3).  &&<&&. 3)<);&&433 @b ..34<43  &&))
+
+
+&. );.&&&..&<3;.& )<4.<3&).&.;  3&.&) & &.4J3&&4433 ). )W3 4t)) <<4J@&&. .3D 4;4]i@t<@xr&) &)3@)3 
+@@JD xrt]3&XD.x¤.&XW )) JxWt@3))4©L))®;@4)<)b4 )&DfxäJxþ]3 &3D3<4mLDJ3)@3..@DX;;.;W]S)@mt& ; &)) ))&&& . ) &.)D;JD];4<3L4L;3. 4.<.) &)&D@J4]4  @.43 &&) ;.4& &.)<<..  
+
+&;&3..D3& .)..33)..;; 
+.& 3;@.   )&.&  & &.) ;<&
+;)34&))&.) &.3.))&)
+
+@3@&D|]®3. ))4SD &;&4°SfS;).3; <m@xäD. & )333&..f@)34 X33br4) 3&<r 3@;W4;JLD; 4. .4DfW Xb..;W)&iD]])WL..J;3r.tþm.3 W<;))D<]D)XW]
+3S&< 4).  &.&;)  . & ;&3]DJX&4&< f)@);<J3  D;J.;LD3 ;@3)&.&4&3<<)&  ;&33)
+);)@3&  & 3W<<<);)3&
+
+
+
+
+ &.& 4;)3<)< .)34;).D3)) 3).<.) &. &.3)) )&&.&;&&
+
+3 3J)bSr@fb &&.W   &@W©f£D&;¸<&£;&<) )))&)3&;4;44);   4L<X.4 .D@;mX<4JL<).DL34Jr..WJS4D4.@L&&4Dèfb4]<@<f;&3i®þÙJb]3&.)44J3<]@.4L &x&43;)&S<&)&.43;.3S3@4W;..XWL  @ ).Lm];))J3.&&4  4  4< 3&43.& 3)  3
+&  
+ @)..&))&. &&SD3 &.3))
+
+
+
+.&)& &)3&<&D;;; J3;;.) . ;; .)4)4)&3)
+)). ) 3.<3
+
+.&));3<fDr4D.3&.))J .)4W).3f.;; L)4&.& . ) J< D&3<.ÁX&ixJ&&3)DDDSJ&)LJ4@@  br@Äf)&S. ]D&<;@&)f & DD®þ©&)@SX©i@ 
+ .&3<<<m4W4L<Ñ3@b<<D@fti&&)3.4.);) ..333&4)&43mDSD;D)&;&;..4@;X<4))44.& )4)))&) .) .3  & )) )3.  )33)  .)&)<).). 
+
+
+ ;.@&D &S.L;;;;. &))& .  ;&4 ..4  &&  .J<D&&)@3  . L)X<LxÔi]@.&.4 )LL&;4D.<&)4J))3))..SJ;&x&D;D<D&&);W 3W@XDSX&)4W ;))& &)´;Áþ)<)3X4);@.<;<S D&.& ;fXLf& W& £ )tb&@;<WðW4@@. .S)JÄJ;&)&&33@) ..)&4)&@&&...)J;SXf ;;&<D4)3 .@).)D43 &&&  &3&< &)  &3&&& . )) . ;&)& & &)4D 44&&) &
+
+)&3)). D3&.  ;&) 4&&) &  )&3.))& &;4))4 &
+
+.. ))LXfWSL@;.@&&4.Ñ3<)&4<.<L;  .&3<<3..3SS4<)Df
+.4))<@®4W..;3D Srtm3 < fS)XS3J.);&34&4D&)44;)3xfD.3X.&< ;))Sibt 34@@WWX<)ÝDJ.))L)3;3&L&&&&3).3@ 3
+&3 3)&@]@L.)&&4ðþ4&&;<.)3& ));3 &))) ) 3&3)<&D.&.  &344 )). 4&;;.3)3<&
+
+;) .3;J<.& .& <.& ..<..433; )<).33&)3. ;;
+
+ )D<]tSrxt<;@<.D&&&.;3)))44.X;. ; 3)&@.)])]b3<.D )& 3xJ;.44.<XW4  fS< |Jf)&4.&X.4;S4& ;. &X©X@ &ri4L&m3bLJþ<3&3<âùLÌä.|]<@  fi)< DX<).); &)J;4.&);) ;&<@&.&W S<b;J;D&JJ ..  .;3 .)4)3.3)))3&)& &3&.3 ;3).;.))  
+
+ &  4&&3JJ& .&&&.&)3)JSD 3.& 4 &3&&) ; .< &) 
+
+
+
+
+
+
+
+
+)@m.S;£]L3S|.J3L )  &D;JS;)£@4&&.. D.)))X< .&J<3.& 3.)Wi;.JXb&¤&&f&4 
+D<<<||WJ4.4@.J.f4;S)3Si<.X];LfJ3J 3LS&4|Ñ<@´è¸L&.J@ L3X)W<D;]@S);; D.)J3<<33&4< )D& )<;<@. ;&).& )) ).&3&)  .443 &4<)34&)  @< &)&).. &<)&3.4L; ;.@
+&)).333D&3 <&...  ;4;;& 
+
+
+
+
+
+
+
+
+
+ .4)&@fJ3);f)J])
+ 3L<L);<@©t.@. 3 &
+.);)S&.4;<4<;J3Ji<D   .&.34@]xi&&X4&<.3f 3DW);.3]3 3&®44S3r@)@ &4mW)3rù&  )JðS£|SW|@. ©W;r@ @|SDJ@&&).444@J.W &&.3@3&@.J<SLX3.3&)3)) < &&;). ..;3 &4.)&33) )  <;3&) ..& 
+
+
+
+)&34)@ 4J& 4.4
+
+
+3.3).<
+.&&& .. 
+
+
+
+
+
+
+
+
+
+ )4 ) @3W@J) rb<DL@J< ]]]4;D3&D.))<L DS&3XJ@; L;L<;LL4..&& .mSr.&D@XSmf&W)LLS 4|&; 3@L3;b@i.3).]i&&J 3) 3 &<@4SLb)&.&&.ð þäþ;;&JSi)&Ô.)X3XW;L ; D&4&.4&). ;4&.@< ]DD ;3@4.   3&4;4).. ))4 .   .;.4&))&&  
+43))&&)<@3D ;)4. 3
+
+ @
+
+
+
+
+ 
+
+
+
+
+
+
+
+
+
+
+;&<mft<@@
+;4W 4LD4D.&4 &DW; X)SDL 
+)D.WSSxJS)r <4<;<b434    &.&. )&<X®3 <<XW33<b<x)SmS;)<)3. 4)|iL))<  ;DbD)&°þ©4D) Wr|¿Ô©´  <|D;J<X<x) LS) 
+ &3<; .) .D 3.&&.&<&;Wi;;))..&.&.3 .4 34 &)&)&); 3< 3&4&3 <& ). &&  
+
+  &4J&33; .&;&
+
+
+
+ )
+
+
+
+ 
+
+
+ 4<.ftDJxm;@&J.3)
+<X3Lb@); <;t4D)@  4;&;.<;4<4<L<J<3;D).L. &)&. f3@btW.; &trrS& XbL< .Xir3XW&4Sr&...)&D)&3f 3 3LS&iJ &&;£ÊD;þ°33W;S3 @@S3;&L4&<)4 
+.)<3)@<)  &   &D;J<;3@<..;&3<;) <3)<&3 ) )&  . J ;  ))&WD;]¤;..3 )&3))3
+
+
+
+) );.&.4;4 @
+
+
+
+
+
+
+3&
+
+)
+
+
+
+&x@ &f¤&<. L.S;&&;; .<tJ &S@)Wt<W );.4)JW&.ib<;&<<])&J)@bL .  ) 3& W3S4@m¿L;S&)3X; .34<)<)&<@;4LfÑ3.X;&4|< .)&mW3SS<WiW]< )L &r))Ltm&;¤r4L.b;<tS;&X<JD
+3@& .&.&&3&. )&3D3&;S D@L@J& ).3..3&3)3.&  )3 ;)..<4)J<.r  ;3 ;&.)< & 
+.&3& &;).) ; 
+
+
+
+
+ )]&;&      
+
+
+;L  3 W;3WÔ<
+fL.D.
+&W D&if3 ;@r.;3.;).33&D@@DJ);4;&bi@.3.&))&);))&)@JJDmL<3) 4&3@;<&);<r3&3f & 
+Sb@ W;LD@iLL)X  LW)@4i3t<.;& S ; x4D S®L LJm<t 4fm3) @J&<)  ;33 3..)))@ ;. 4D;.<bW)..& &. )3& 43D ;).4W&4&&Li£©<;)
+)
+
+
+
+.&&33@4)))4
+
+
+
+ &3&)]¿ ; 3 & &) 
+
+X. ;]&<°3b..Wf.);.r<3)4)i  .)Lr &)
+ b]< &J.3;)J@LJSL&D;3&)@;.)) )   J4¤b|b;4m;&<;4.&JL<&]D& ;.m.;.tm<<þ<f@4)LX4).3&.34S&&&<W.) . 
+rJ;4;iL.4®fJ ;&ÄfL))J.&&.43)&<<&... <)&&3  33<.;fS.4. &&  @&3<.)&   33&3 &<DÌþ <)34.]þâ3;3)3
+&
+ ).&&3 3&@ 
+
+
+
+
+3) &)&&L3r)&D)4<. &44 
+
+ 4..3J3ð]@4&iLLL))@)&&4þ< &.4.@ri®)WW..D4L4)L. D<D;]<. 4
+ ) &. &])D|DiS; .S]&..x3&4b).X&.D4&DXmf3 i. XX 4)fS D;L4  )b3& )@);°LD3J&b&SS)< 3.tSÁ; m@;;443<)J& ).  &4JD3SL L@<D&3; & 4 )3 &  .& & &.  .  43ì]S3&]D<<).])4ÑÑW 
+.)& &)& . <&
+
+
+@&&& 3 34L.3;&W <.;fÙ)  &&.þW 
+
+) D@ )@@34Diþ)Jr )@3@D)343.)J4)| )<m<.4.3)@)J<4J.SL&W)3; 3@3)&&  4¿ L|fb)3D&fJJr. 4i.<< <W34@;@J&b3&@m@.3@)))@ ) <4J33@))Xb&&33.)äDWx3X434;DJ 4m<4)J&Dr@ 4&)))& & 4<).  .Wb@3.&& .<)<.)))3& D 43Wxþ;.LLLb& ¤þ<  <3.J&&3).
+ 4 3<@&D &L.) .L.]) &&)&
+.i.4&.
+;3)44<;)3.&f.)JJ@b.L@&4)Lb;SD 
+]3<&3SD3<@44).S .)&&<i@  )  ) 3&))&|m .);@<W&& & .&)iþ|&3Sm)<)4|; ;WS)J.J3.
+J]tì<.t 34)&SiL)frmS&ÔS).iþÄÑ)3]4<3&3W3<X4;&  3@ 3)334;3&);.3J<4i3 )4333) );.4&&&)& )@D  .)rr|];4&.&33Ýþ°t&  &; &&&&
+
+4& .;&  .&DX;&33L ) )).3D Wþ@)&;;& )))44D;..<tDJ4;4)Jr)DX3)D&D;4tSLm®<<x;L]&@33D ;DS.)3D)D)<W.L3<&&3 .&)]).m)LD.;.bWW.)4|x))tJ L
+ <&DJX3xWLf&¤  & DrL )<44W´Xb4<&£m.)&.;âèb;]Xþ4r.WD& ;W@3 4< .)<@.;4;) 3).4;3.;)Dþ]t<<). .<);4. <&)).@))..)).DXö;Jt´®.<)).4)4®þSS]) .) 3
+
+
+
+ )<3&<. &)&).iþ´<tö;  &xä;;&;þ4¿LJö4&)b.3. ..
+.<<f´ ]iJS4<J)]|)t|m4< .&bS .]@W3.@S<)D@4DJJi])JDr<.<]D;4L4   <D3 3.|..þ¿ <i.D&) @4J]JX&;4<D3 &3)<@)LmW i r<) &<Ù@4&)J3D4X))L<;)4;< ;)tÊìÑ.®W4Dþm4.|i). <)&@@WD&3&@<.).<.)4)L&.b33£@.)D4<)3<3<33 . 3<D&L4]3 .&4&D.<´©@&f bÊ. <©Ýþ<4©@ );
+)
+
+
+ 4&.4&3&<3 3;4;<  D.Ñ@ DL)&ÑÁ4&.)i&.<L <JJþþfÝL&@..4& )&&)4xb)<)X)SD;f4)4¿
+&&
+JL<WW &mf)3X
+..D3 )<4D@3L@DW.JJ3W@;@4mW 
+&3f& )&..]f3]|4;))43b4&&&&;4)4.3
+)xf)<|)3;W.4)<4i3&4D&3LW Lf]&J;3);.@&<4)4mJiþÄ] ¤f ®..3.4 <mx.;.<&3J3 .4)X<<33;)4&3DiD  i@<&@i) 4.43 ;&4&. &.4..3));4&<XiJ¿Xb4@m<<DW£þþ.&.)iX&3&) &.44 ;&.L  .;;)&@@¸öä;.J 4xDtþDx<fäbJb.mþäÙÙìþr¤.¿J.&&3&3b&4.3i;<;LXJ3&..3];bÁ.;
+)4¸S; WW®.;&;SL@.D)@@3D.]|&@3<4DD&<D°r4x43)& &Dxb4).@X;<;D.J´L34)i.&.33X® JW3;J3D3.L;4 &);34@& @|4  SL.<r3 ;J 3m3L&]<.i&<]J]þf)L..L°@<&))J) ;;;. ;3)4.<@3<& 4
+&4<;&4&<&.&)3&<);3&  D && 4)<;Ê)D&..3) @mþ¤&&SÙ&&S.
+
+D&& ))4;) &@ ).3& )<XmþL3&SDþèþù©®þþäÁ)b£¸L|.Dm¿.);&3 ;&)WD .|)SJJ)4))@4i4rx3<&J43bS & )S@4@D)]3D< J &.)43)4LJJDS]Dè]&
+ .&3)
+ 4.)3SW.<)@LX3f4];<x) .L<S3J.4.3<b34;D<)&))x<@;&&DxLL f &.S&&;þ4. Dx@<< )]J3 &4.)X& <))3J&3; 43&<43Lb)].)&&&DSL) ;  &3 &3 ..4) &4 3;4.ÄmD<<;Dþ3;. X3]ðÔ<. 3@J
+
+
+4)&.433 ))@)  .&))).;&&@&&33&44]JSmXèþþþö<<WW]@.;t <L;  ..3;@ &&)@<3Lx3& J) 44 J¿b<4Sr .3LDJ LLb]3J4@.4<;&4.@W@DD&4;.X<rD .43&
+& 3.  )x;4J;Lb)4LW&3&; &m ).)L@.äâ4D@@)£bb;@tr<<bmmJD.;D.r3<S&3  J´þm)D<<DÁ  ]LtJ&3;.. W;& <4...;.3&@.)    &XJ)) ;;4) .)).;&)&;.   ))b;&. ..)JS3&4t.J).SL4 
+ @&.;&33DDJ@)DJJ. ))  ;4.3&; SD;Áìtþ´þùöþÊS..J@;.<3tþ&;4i¤D<4)f .);3.;  3<4S3 &rJ)) 4@DL3&) 
+4tL©D&4) X).WX<<@@S.)@S;]@4SS);.Dr4bS@@43..;xXDS;&<D;  D3.;4D].;<W3mSDLD&<;@ r&miWr) &J )D@DJ<)@33S@&S.ð3
+3@;4&.mSL433)J3 . @èùW)<.3m<DL. 3)D))3@& .4&.;;Db]);  &&4.J@3f)))); ).4. ...< ..]D.&3 ;<3 Sx@Ù;4i.]L)
+3  &.D)34 )  3W43444<..;&3);;tLX@&®mþÝðþùðrö£;Wxþm.S)4<X3mLtD<S&ifL4]x.)@J<;3£;J@S4tLSDWW3
+ iS3& Sb)]D]XS  &&.&@;.&.J)34..);;)XS;.&34WJL@.X@4&)@)|ir.&& 3)&S @ 4&&D) XW.&&@..)&;3)L34)¤®
+&3<;i3))x&4&]@Xbt<f;4..rW3b)<SS<S¤). LÑJ
+.;SX&f3)S@)L&<4&3.)i3.L)3 );D 3@@.&)3 ;S3<@. D@4).43&&.3)D& .) f;J4 .)4S43;S4t]Sþ)&)..&D <) 3    ;&.)43).4)&.<33£JS´ÄðÑr]SXÑL)xfi<LffWäL)XJ34]..)|b@;)rDD4W< XXDW& 3< rÌDb4@b&SS<3&;@3..;]3JS.@S<43;3< &;@3&);& 3&&..3<))<<|;Wb .3;@f.@fxL.& 4.43.3 D&<Sr3.|f@33 .&S@.ö<WL;.m .&r]D4X fD)J)4;<.3..&& r¸S&DÔ4&D.;;4W3J;<3L;;<)34; ;..3 &) 
+ Lb4S.D) @)33)3))<)3&..<WÙ@3  .4&;.44 3;<J3.  .;&4;&;3;3 3)&& <3J)@..3J 4°X.]D4). <DS4@.<3Lf)3äþrS£W.4434;3&|L<3XX.b.JL&JD<)  ;3D4f)@@&3@J@;|SJb.).<D@&)J.3<;3.<))<;3L;@.).4<;)@3&.L; m))¸ 3<)).JJ;X4)L4)@LXDS&&);S33L] J&&).JbÔWWt.4L
+4DfJb3)D SD@;4D .)&;WþþS&& J)|Xb])4@t<biL;S<.);3.<D& 
+
+3 &...4).4  )) &.)&@bD<)@4©þþiW);&)&D;W. )3LX]f®3)&&)<4&&;D34 &&3&&&.D;.<&J34<Ì°þþ£äX)<Jb&r<S<rfi|<).@4@JXL&&)3f4.þ<iW<t)4@3®D.;&3L .&iit&))<J.3&]|t)&L<SD@D.S]r]J)L&X@f3<&&S.<....3.<<.4@3.33@.X &D ;)3|.@@bD)f<<Ìþ©fDL<|.)Sb);J&&4f<m<
+S]@.&Ô¤S;@3)D<m&<¤if
+LX3;x<)@WþJr3&<3mþþ&SS<3S44Dm@S3&;D <®;3&)&XW4<&).)&4&44<4&&4S&. 34;3<©öÙJb.@)rþ@ &;@;<£þbL.  
+ 4 <.;&;)&. )4&.@ )&&);3 ör&.3b<DJLWLþ°b¤Ñ<<)&) &D;.mxr&)& <)ÙÄþ;)WX]S44Dx<b).J;3&&&<J@ &JÁ<&)43&SS3XbDm3DD<44<<3b4;SbL4L )J)DJSX ;<@.; 33)  .4L]W4 f] 4;S)3) .3J¤LJ..3&mÁW.)b.);Dm3m334&xi& 3)3@34@&);<¿t. &S.bi.4L| iW& 4) f)XrÌb&r¸<<bb.@3.xW).]xb&&.x)&&.)343 ))  <...)34).<3WW)L3m;XXJ®3 JJ3ÑÑÝ
+.@.@¤ðf4&4
+3<.343)&.&..&) &.&&&.3 .&<X@<3S .3.. 
+ .L);&<.]´äâ]@X4J4xLDf£]©] 43< )J bD3WJ&43L;Wr< .mX<r)&4<b 4b&DSJ.S; 3@D<4<3SD34L@WL@.3@.)43 );4;3S3@DDf@<&. .@&&JWb);&D.Wx]W&.;]&¤ 4)L3;; .f@©3)&.@ 4&&3DJ)ft;f<&)<iW &iix3&bD. Dùm&&Xr;r.&tm<)i.D)&.i|èL)..&
+<& @& L43&<..&.44)3))i<LD . @)@b& 3.ù¤ )Sè<;|J;L&
+)&;;))4 <.4.&) .& &&& 3;;ixþ LXD.@3)3@<3 &.&&;&))3 &ÝþÙ@f3@b;&.) |4D33@34]&;;.4;  @44@L<WùS&bJtbJJ.)J;&.D<34bLtL)D<&L3JJ3)@DW@&.)))@<).;)W)@.&)34])bìÁ.<)))J ;it.&4)tm;&4LDX 34.D4 ¸ÙDSif;b.4;L &DriS.;LX)4<))
+&)D.´X< âD 3J]<xLè°];3b;)fDL  )4 i|DxD& ).&3. ;.Wi@3));
+.S;) &&433@S33L.L.3&L.) ;.;iþJ  4 3SW&¤D3.<&))4&4;3& .3. && &.44 J  4]&S;ii< ) &.33;&.&]33);DiÄþÊ<.3&34;J&;. .f& WW.3<&&;4.X<) Jf)4.  44@D)J)D;@3<3W)Si3.@<L&&;&.4X@.)<X3Db.;&4D)< 3W<<;)&4 &<D 3J)4r°ìL<
+. ;f)&)D4WDi<34; )4t)fb|.DSD  W3&4DJSJ&xr<W4JWt.<W)S3.f@&.&3J;<ð;@& xiÑÝÙ34;b4SxW]J )S.J@) . 3W3þì& 
+ 3&.]J4);44&&;34)@ .tD&; D);¿J;&..&SJxrfr;DJÊ 3.4&3  ;.&4)@&&;).L .4;3&44þìÄ¤Á¿xDfW3 .)@.&); 3).@.@.LÙþ¸Xb) ) .&4 ;D). <LW .&)4]x))
+4S)& &@<4..)JJ;3@ D<LDm;rSW);D];.)@D<D&L3<@;.. &333JLW)&3;.3]& .&<@D<þ°J<@;;<t´.4;).&|3fbJ..;&W;DXL<fJbX3Sf4). ©34<]DD)S<S3m;X&&)
+.rfJ3Jmb;&3Ê@&; £xfxþ£þJW4i&)<@mD)LÔ;&; .&))¸. &)&. 4S@ ) &&)& ;;@))<<@ & °þ4))&3<LSþtSJJx®bf
+J.@)&;  ) &D).;< ) &&)&.D;|£WmfJ¿þtþf3@&& L&)&.)<Wt;@@bmþrþ3t3;<&<LxS 44&]S)4<3Xm&.
+3@<;@D;D.@;4)&L@@LL<)LL;WJD;@3L<)D<<).S4)D)3 43&W W<];.& @4.]S) @<)&;JöÌ.&.;@J.;;4 X3J;WD3<@D@<&&Jxt<bfb@3; JLbm))@)®).<|ì<LD<& S;|W3<3  @. 4fX £LSÁ¸Ä]S)3))< ;JLfD))|@).))&.. <&) & );)& 3&.)]f;)4 );b)S;&&<&;þ.D<<3L&) )]xfWÌìþþ]<
+& S ;43))3.<;@@3&) &&)4t£¿ÌÊi<® D)&)&)<.4 &&&£&ÄäW&<;DÌþmþ))34&4SJ .34&D&Wt34&X &&m& &)4<.4<&S3.L4<S3@@.44&.r.LDL<t.bD3<<L3&Lm4@@ 43@<<)&@33)D))3 XDD&)4);@.<mS<& .4]b))..&b@J)<;L;< X3¸f .)&<m)f4DL@;@@<D)D.&f¸<þW;3<3LJm@XÑS;.4L.)]XJÑðâi3.S)&@ )WL&3J´XD.
+ & x@.)) ). ..;@.;@f&<);@JxL<] J.ö´J3;@;. ).3þùöâ@£)&. )4.4;4... 4)) ;&&4&DxþðXLf]4<;)bJ)  ));&;  S&<L¸ì3 JJ@ðþ);)Jt).&<SS4& &@;)4fS .W .DJL3&D@4;4)<L .)<X4SS)JfD]X@L;J444 <))343;;LW)4 &D.&;)&4.)).<3)S;.)&)..<.3@;D)4&)43J@; .<WJD S|XX.3@<4;i]b)D4.@W@S@) 33XS) &..;.;3.@xâ3WS&.Ù@)D)3ä®£]&X444<3))) ;3D]|XW@@&@fS<.3&  .<W &3&&34.)  )m.@;4x.SJD)]iDf;WS)&@D)))@Wþ£<J4
+
+).&.<< 4))3.  ))3.<@WJ]|°J°|©L|SL©33  3))&) )).xþ xJDSL4]â& J< &x))r ;  3@)<< ; .;;.&S S.&)<L W.;&4&4<;bWW<SDxb<fWJ&tm&4JW;.3.)L <4S <DJ 4& &<)D..&.4D;@&&<4& );4@&.J&;3D&;;.]@S.W<.@))&i ;.SDS 34J]Wþ´b&& ;J;J4.bJ b34 ).J<&) 4&®<;&3D)JiÔÁ©x@ 3f.i.L.<4;3L&&@ÁW4.D4&.
+&3<J&; 
+&&@33)&.<|S4;J;bWD°W;f3&S..D;3âr]4&;
+. 4&)<.3&<.))&.;&&..  ;<LÙèð¿S3 <b.3ÁJ;. S ;  ]r@& ;&&4]&4S@Jr£;r33W& &J<  
+ 44&33)b ) <@)D) @; 4&.@.&L<L3D4i@m.b]]i;J.JD4@&;L&3S@D@&)).3J44)44.L.L)4S@34W;X&&&;@&;.&Dm.@; 44&D@DS4L<;)|;< . ;t@4L4St]&4&mJ)D iL.S@)) b©@@ÄL4 );)D4&4) @<& <J@£.&;|ÊS3¿ÄfW;.);.4LS<  .&)&) D3. 3@i)&.
+W
+&)&J|@4.)bðì)@ & <]4&& Dmx;<.;)& .; J&  )33)&)&&))@.)&LD)@Jr< iSL.tf 4& <4D)<)4.4 @J@.3tf]3  &).4m<x.
+ J4b]DWf;.;;4)<4&J;)&< 33..S]@;XX&<L;<.&.<;fS)W<ff)))D43)JW&;;&;@ <.&33J.);@  <S3  .<4.).3L4&J4&4.< @)@JS4L;3;.L.@<f@;&]bm4b£.J<L Jm43)<L<&i4@3LiS) 3;<&4Jf&<b<))
+S@3LDXXL&ÄÁ&@@.4&4SS3L@3&t<4&<J&.X °.@t] ;)
+
+XSt4)X@X<@DDWi3&&.;Sb)3&@. Lþi<;43.)&. &   ) &4)  . &
+3.@.J<¸S´¤£DJ))@&&4.)@)<;@& ) ;S  Di<3DJ@Jx)tX&Di
+<Jb&3@@J; )<.3J3.@3&)b&<4 @3@DbJ3L.DDi])<]SXDW@<J];4)< D<<)&&<;&<.;)4 .bL.34W.)D;44.&;3W4W.&W)&¤4<@).JJW]JL ]D&DXX¸r)3m.bW4;3S);@3t4iX.3.W X;&iD3)@&.X& 4r.3 J <XÑ.3 &D3J).D.4£¿S<.W3& ))) & )D ¤Á))&  WS&D4)LD3D|D;<3;<&&@34;<S]Xþþ])@&&).));4)D.& ) 3 3& . &&&   &.SSÙDJ.LX3) @J4).@@¤< &<3; .&4&D@]L).@3]3. &Lf  S.)@)f])t;.)<<D@<3<4L4D@;343<<;..J@@L]Lr@@;3D;3r );4&3@@D.f&&;&@@3)&;b.D& X<.3.X@.3)S4. &.&x;34]&4& 3&.S@Db4J ´3).<tDJf)b4SL4&@t 4&3WL.xJ.@43âW43m4<@<.tD;Db&DJLtDÁþb4&4DmþäÄ4 .J3JDfW).Jb]f &b..<  ) ) <<D&D&&.;)3J@.|J4&4LXW<)LW;..;.D;4@JSmðþ.JXW;.&)<&&)D3&     )  3D&@    ;;4r3)..Áþ.).)S@] @34S&& W)D3&3.fÔ.))4&]iSD&3.Ì].)&;i 4.3 .. ;;;;3 @<;SJLX@JD<. JJL<<)LL@. .3)3.;DX3J)3J34..)4&X]<b;b;;&;@)WJ333 .J ..4L;)S&).)LLJ L<)@JLtJ.|3&L4)SÝb.<bX 3)&JS®.<<4@xL;¸rt&SDL3);ÊXXX3¿D4)W&.@@S;<S©Ù¿&DWW)X])Jr4)JL))<D.L< )43<)]3)3Ôèr34))3.J@34Xi4t<.4W¤..3<)D).&3t3ÌÑ& &3&.& &)<;4 <)&<3 &@  D.4& .343@.L;.& .¤.3L@.x<<. .)&)L .L3<  4<3&4X<xr] 3;&3;.4D @ ) 43@&43<W);<D;3;;<Sb]S@4&<;@@Lf)& );)&3L)<44&.;;444]<@X<@<D.)<)&@44J..S) J4& &&)<J <X)@3JJ4D¸©þöDW&@<©) &4b&]&J&.<]S4.&&ibb3]
+&;@tJfD).3 i¸xL@;&WS.S3<|b<@|;Xx)44 ¿|).|ÌLt&)4L@ )&4®);S&X&iS@.&) ;&D.@DÙèiS<<@@).3DDJWt).@&;. .3D)4L &)3.;4  .)&L @4L.&f¸rSD&< @&rtþþr&.@@]W;)34.4L@JJD3;DSJ)4&3J)]X&4&)W 4; <D 4& 3;)LJ<..J3.<)4L3@3D@;f]fD;3@DD<X&;&4)))D;4.S43<LX;)&W.J&WLJD34W@iJ;3);<3D3@&&D< D  &.&&3DJ4 L3@3D4]4)@|L|äþLbb 4;rÌD)b@@]JS;&J] )3)DSJ  ]4;D4;4W|< 
+S3 .4]b©))&&;.xÌ|&)£t4i|4<4L4<<3<@3X3]S4&  S;&  4;þS &@&@&4)4|DS;<fJ4.&3<;.&34ÄDf);3  ;&..34  )3;&&.).)&4;. .L33x34|fiì))L&&LJÙðìL4<3Ñ43WS;X..&.4D<L. )3S.)X<.SWD.& LLD@LJ4&&)&&W <S&; 3L43D.4).4SXb3LSJ)S)44.& <LLS@L&&;)L3<@D3);)44JJW@J<;@WSbS)@33J.4<. ;b]);4&.&3b<4)443LLW4434.3Dr]4D4D ]<.XöDSX.@S.@&4X4]S@ J <3)4iSW4 3DX<´Ñþ&@<;)Säèþ
+) LD´m@. <|LS;4&).ix@m;3)&4@.33;34)&&4&)).@4JD..3 .LD|J& ;&;3´]m<]XbJ  
+&&.;3.) )&&& ..))) 44&. ); @@)r@¤þf ..<f|DX<LDi44&. J& 3 ;.W);)3 ;&<4]X;. ..D<S;J4.&4 DD<&X) L)4  &.3.DL)W;&L;)DW)S;@&DD)..&33;@4@ ;).@4JJ);@;@4S@4JS]XSJSi)<J@DLX& &.&&WJ4<J@&.&4D]<&D3<4@..@& D D;@)b;&3L]<t3&t|t4|)DL]3@)LX@  )3J<34WX&<&< b< .)rD& L@JS<4)DXÔöS.&@3)&räS  &<âä<bXJb4&<©mLÌm..@Ù).&&. &&)r..&;¿44x)]J;@&<&4.;;bþ@@;;)S3r´£iù.D .&& 3);.4< ).  )  &&&.     4 3fL;D) þWJ°L¸;m4&&.3SJ.& D X4 &&&|m @& &4D44)W<&)L;D.J);L&@3) 4.J@;@;;<@@.;.)<L;.4SJ)&3;&)4.33 . ;4J3D ;.);LL.r;D3@<XW@@4f4;;J<&;@XL<S.. 4). )3<3<@ @@J3; .@J@ .&X< .t].|3)3 r.J<).<&@x.;´ÄXX).3D)..<3&)& @£<..;X3rmD).3.f;S  JÝ&D°©.&°þ<&)XL)4.D..<4;r@<iÑfD4 .X@.@))3Ñ) X|þþ|&)3Xþ@XJfSLD;.& ;;3@&<b@4ÁmtÝmS&)
+@4.&&&.) .&;333)3;.3&33.3<J &DJ|Jm&mJW@¿@x@@<.33fDLm;@;@4&D& b<)&;<.r&W.@D.4 4D);4@i S&)3DD4LDXD)<W)434&<;;;D);4334)L) 4DW&& D4..&.f3)Li<3J;XJ;;)L]L;..4&;<<3;XDDW.)4.&3&@.;;LW)<D 3DX) );&4))]b3;& @& ðmt&JSJfW f&@33  4<J<S.]i4@ WS4LJ))W.@]3W´b 3¸WJþ¤ &LW&<;.L&LmtmLìL]¿Xf¤f)4@mJ]S)&)<iÄStù;XL4LS@¿þXJ<J<â<iD|tSXðÌ4;@@ )34   && ;;@&<&&)3. &&&.)D&&&
+@&Xf.<;) rD@;X3tX .43&<<X.4xb.L@b|3 4Xb XfrD<)S&;WDf&44.)@@&3&4).@;)JDDW4);4)4&; JJx;;&;;D;& .34D&L;&  &@&.;3.b@4J;3L]3&&3W<Wb@<&];f<W<4X.;J &3 .33D3 <@&4)D L3@b<3J. ;]WÊxL4<<4;Á. S3®;LD&L43&XJ b3)m.X).DD&)W X<;@4tS) &) &r.@;3&)X33)3&;xâ®m¤iJS;fWÄ
+).¤þt@.mbJXxÌÌi;D;D&..@4XL.LJ @©JiDi].<; )@&4W&&;43)33.3)&.&&.& &4)).  &)Äð@3 &xä¤Lþ34)&43W¤@.L 4L)&)3;  .)Wi&3W b4DS f@.&)D4 <)3D@S@ <.|]3L; &S;&Wr]WX.<;<.3W4). ) 4  333 3 &&3).443<)XSXJ<J.DJ3J)J<W.<4X@L)W3@DJ@.W;fL<);J.@.3&<34.3.)3<)DW.3J&J]x4&ft]3<@;<JSJ  44))&b4&f&J&£D mm&3);J4|3  4JtJJ4&J@D <;]<43)WS&); 4W.£b&4<<¤rS3
+ 4b®D 4r@4X£þ®xÔ4DJD;D3W&.@SiÁD<)mW.3DfrÔb@D34&4)4. 43 ;). & &4   )& 3&&4£â@)x3þ4 3;] . XJ)33Jt43@@<)<) .].&JXD)J;&33Wr&;); &)&3;4).4&@.)@;LJ4@@&;i4SX.&3S;)@3&;3&)3 );)<4).).33&. 3;4@ ;<..bWD4f;<@<<33J@D<S<ir<D@LJ<@J3L4x3@).4 <W3&W@&4<);D3;)L@WJ&&<b® 4tWJt&;¸Lf]L&);L)èL 3Ä|r©W3)
+;ft´; ¿;S W@&4L<D))Á@<&).J)))@SLþ´L3iSxþþ|XJ))DX4S3X<WW]þð´3Ê@<4 ;.4WSbþ ;<if.&WiþÙ4.@@ &4@)&<.. &&&344D) &3<&&X].W.W°x..L4&& <4.;L.@ ;<)33)& <.<DS33)@;J<JS&)443.;DW@;D).3&.X;S).3<..@444D.)344X4J&.L4 3&)&3 )&.4 4;3.@b4@;;XDDWLX3W<&.;4JD<;x4DS;J]b@J@ D4)]D< i;;@4DLLD ;)3SD<)X)@3;<XLLbt33)3&.3r.Xr .iW)<.ii)) SJ@ mâ]JDJ4)ÄbJ3Df;;3J@b))i@] Ñ&S&Smi  <Sm| mW3<JL©|Ô]Wm4)t3 )rD]JèJrþ]W]mJL;.L.&@;fD4&4&3&)D)4m4.)J4;..&).;4D .). 33&&&3J.Jb);)4Dt&3&)D4<J)4<< .]S)LW<@<.<4.. .]W3.3<D)@.) 4;@&33.&<&4&<<WWD3.;J.34<Jf;&@4.4m<;))DD.X3);3D)<4;3;J3&3.Dr@<Lf@]J)b4S.34)3J)J3&S3.;.4;3)..<3@;mDJ3;S4@<)J43L3J&.&.D@]D|3<<XLS4i@3D)&&D34ib;4f@)Wf;4<<4<Wm);@]4;]@.;]3Ji 3&&&;WJ¤&Dùä)©¤ÄSiSfx)3)f¿]´<WL<&<]4®X@Jm<tþþL)]<@S©þ ;<LJ.;&i @&.WL;@@;;L3)
+ J443) <;);&@  &)&3))<    4 J.J  ;;J L. @.;3)&)D4.&.)W]Ì3&D4.; );4)4m&Jx]  )&@;< .&S3;3;&<; 3bD);J L)D)D4; );)D@  .).;<J4 4&334)3)f&@&<3L;)W<D@D]i<4@D)b]4J44<DD4i;DD;JD;&S4&3<W4)J 4]@3@DXD)3)@;L.4).<.4)&X )3)4m4bW;.34 DWS);)< X]3 XD3 )S4|; 4@)<S4J&.&b©£@.)&&3þìÙ|x°°S;.&]<@¿ÔbâÄ<Six)3)4@&;;)4Lbmmf£)<J<DÙ]¿)Êf; D)3 ]xD 3<)WS.D4). &  )& 3)<3
+ D.< &&...&)&;)|r;).J;.) ;);.) 3D 33 3&<&L< ;4<.;..3Lbi&3t;)<433i;@@.<.;.@WJ)S34&&.3& @3& ;4.4J<3< 3...3J&34&3S@4)4;<43 .4<3.3DJDL&44<.)WX<;.@&D;W..)4;<@;@J4tX4JD<.3.34) Wr<.&@3;)J<D4rJ@J)@L&&&&@&.3.3)X&X]rL)XD 3f <L<X]]]<];<S4W )44]4@D S4<¤´Dm)@;]f°ÊÌ]D3&;´4. 4@DmtJDD WL4Ý®);¸¿°ÄÁöÝ4b)X<Ùðþ°DLS].)<J&3@S&44X;;@34&  @44 )&&& &@)3&.&)44J £¤¿X&.)@34 D &444W4) @<3]W3&3).3L44@)X < 3J@34.]&)..&<.]34DD3&D @)J.<)). 34.433<)4 .@&43f
+;@.3.J<J..W.L))44@W 4LJ.SfXfS;3J33);3&;)&J)<<3W4L4JLiJiL3D3@;D4rm);;&&;J&3@43.3; 3;3WJ33)...L@3@))43@S4L<]3W;D<xfÄ;;.4Wâþ&;x@& )) @& 3.;®¿X&J4;°ì£b)   4.)XÑÌþ@)@þ£W)4ÝxX@)4W&3S&;mL.<WmìöþSÄþ£èÔ<X&&);.3.;.<@3)43&)3&<&;&.&))
+;& ).) 3).;&   Di434<W)&&;33.; 3 .) .J4) 34)<4& @34]3@DW&@@;&;4&< 3. D@.;43@<3 3.3@@<D;.] .@DJ@D4Jb344@3)W3) 3 4WL.&)3))4&.3)44D.WJS4DJ&)imJ)@;)..W4.3D)]S@X D<<4t;b443)3<J))4<J )4JL.3X@SbJL<f@;.;;.<.S<4@<X.i]<&@]x)xS<3XxL4 
+.]L&)D@;|J<4D. 4W);3m]D]
+x]W]t|@&. &.4Á¿W;<°3W&4 .þÄ) bf ;&J©S3fDXb¤öþ þðþf@]fD&3t¿<4L@4&; ; ;)  .)&
+. &.3)4&)&.;;)<.&;)&&4  ;3.4  ) &.;.3JL)<)J X4;34J&@)&D;;3&3DWXL33&.3D D < <&mJ;4&S;X&3D&4;&<&&b)3;X;&W; <4)4J@<JDf4SD;&Wb&mJb@W&3;J&34]3<&@.;tf;J<<@@@W )W<4&D3@@4&<3)@)34; @D.J4)L3JD;)4.L@LÄ £´b&))J®4 W@W) 
+tJ&<LW;D@;3& &.)@.3<mb@r33;bf) ¸ÁfÊ))& @X<  )]öÊD3)Jf&44@t£J)Ä£SL°þ£4¿fJ  S)&44m4L;°3&3@ <. D .)& ) ;)&  D4 &X& ) ;.& m334 ;J&. .)<&<.;3)<3L.X;&<; &4DD&<3D;&J4. <..S;))fX)4;]@&&;<;&&J<r<.&L.@.).)J;&.L&S]J.& 43)34) .3.)))4;;X<)4&J4.D)S3 ).JWD3;J)LJ4WD3J<<iJ4rXiWL&3<D..;3<.&)44.]3@.34@D]WSD)S;)3L].S4.3@L&@&;;irS<4L).<L )]iD3 ib <@.3mfW<.3DW Ì|W& 4@4WJ<)bÔX .34Jö|X)L.)&;.Sb;3]rt|btWXm£®44L 4;£SW&<<Ù]&mJ)))  &.)44.33 ).)&. &.X& )..33<&;  )&;4 .)4.. D  3&<3]&<@<<@).;3;DJ.<W)3X)S)@J 33 ;&4.<b3D <  @<4@.)J43J )4)@S m.))<4.<34W m<JW))XD3JD4f<4<<X;.;LL.DD;44tD&;X;iJ]fW;Di4.;<;&JW3<<3.4;4X)3L)XD<.@@&..)<J4;D.))3tJDfX.)4LL..&bL&& ))W)|3& 4©4) &Jb.@ 4& );i) mr@;x3..Li3& )&´£ 3WbL&@S.DL3)b£D.))@@4 .3Wmiþ®fXXÑiL)3&;<L&)D3<<)bD4&<)3&&)3)¸.   &)4.) &3S&3SX& @) 3&3&3LS )4.&4<));. @3)&;33@3&f3;L4;L.@D@;<@3;.DXD))b 3&3..). .S3b 3&3.4&.3D @) <J.S;@3S))D)L)3&&;D)3b4X4<)33D4JJ]&]L;@DJ &3J3W;33@;<S;44b<¤m@Lbt@3bD<t;<<<33; <J&LJD@D]..J3<&X DW4;;43LXr|& &W@))f£i3) 4JJt4. S;).@@S.33&@) WX;3 D ;Smi. .DÁJ .W4D<3&<3W&&)D)@WD&i).;XJf3)DÄi&&;)X´þäi¤fD.& L tS))DL;bW<@));.  3..&...).3&W &)).&b S.;i<SJ.);3 );@]];..)&;3 3..4).L.)J4;;L..<;&)3.4JJ3)3L)<@3 4< W @<.;.XX .S;43@J;J)&@.4D 3|3J4<;XDL.43..S@SJ)D< <;SLJ&) <JL@SSD<L&rX.]L@LiiXtXLLX]4J&&;.W&&3SWL.]3.3]Jr X 3.  ;)4.)b@<;;X3&@4.LþþiDiS&)4W;DmS@&]J& J]S3D&D3.
+&;¿&;<4&WSDb@|;mD)b3tm;&<3&.L;.D@3&]D;XDSW )D<4ö´]¸f<&4)   4)&...@S.)@W.3 .&& ) )
+&  .))3&&)3m4) 34t<)&3 33L3;.tS  &) 3fW.&D]L))L;33  S.&43;<D;);@4]4&J)<<.<J  34<4)@.< .D344<.. JJ;&)J;43& @4D&D.3;;J@i<W<4|i@4).J<D4<)DS;@S@D<X3LLWJ JbLW;.;|b<X;X@.S4.4 ;4.@3<;&m;<W3@))SDSL34JSi@@;&<@&3]@ìSW3|&4)i3f@f.4)&;i33@)3J. Dm;mÊ]&&. @bt| &
+XDXW
+.<]  J]& @.<b@D@<X.@ö4   <m@4t£<JXÊþÄ4L)).®4f3bWDJ@@&)J<))34 
+&& 4.33S&;)&.i& ;) &WW£<;   |&))& ;m4 )43))&f<S 4&33)3..& &@ D4 ).D4<..)4 <;;3D3<3.43 .b<XDW ;@4 3 <D]LL;&J);@4@WL4@b.b3DXxf4JLX|XLXWLD4<3);3Dt44.&<;<<@.4D<<);<@3)4 4)<D)3<<D4&3;];<Jb3SLJW@;L344Jf;D&W&iX&)]XtÁ.;.&&&;4&f3@<@L¸Ý SJ@&J4)4<&;@.b.LmX<))¤b< ).4b; ; .&)3¸@JÑ<&D;fLW¿S)|]þþD<®X)3<&J<Ý4´@3J);L;34S3@&3.&)&)).).W&3 . ;4LW3)XD & rJDS@LD.DS&).4L.4).4< @)&3D; )D@.3<3 4<L43<D).3@. @D<@@W.&&3WS@.@&.34& <;<<.)4&.]f.3JDS3;<.LL)DJ)LJ3D;)iJrLr.b&L)3tSD.J3@@;@WS&3JDJLWL4bDWLSDfif D&3J3;<J);4J4;4;3&;DX].;;)@L4;&).&;&&@3)f<ibiJJ4ft@3;3L<S&@SÄ&@&JW)XXLJ4iL))J]&..W;X; & ;4bD<ÑÌ@4&&@&& x) 3tf3LJD3 .Ìð@JSÄrÄÝ4.ÝD&´@4)4 L3&;DWD& J)&.3;4)4)..  )3& )&).;@3D;).W&X<S.LW43;L433<þD J<<.D;J4 J&3@&&3 J;J& < 4..;&L<.)4)&@&;@)...&L;<@3)DS@; &@)..4 .3..3LWDD@]4;;<<@<J&@&;;4.@m..3<@W;<bD3@@W34JD@XDS3iDDW&&<b43;4<L]m3<b4L.SSW.;S444D; 34..D3).@;<<L<&J;3]J<..DJ @)< ;W.S3]X;
+&W.]@&Ê]3&<]3<J.S|LL£D)<ùf<J|m43J.@J4;S<þ;;&¸rf.; )<4)<Jr;DþJJ@3it4@) @bDt£X3Ì¿Ôi¸þ©SLiWSþf.ft3& D<f & 4i@@LX J&))).J43 3)3  D34;.33W33Di3xX@@]&)3&X;& &b ;DX.&SD.4@3<&  DJ4&3)@W@<4@<<)4@D&&J44&;&);&&3&<J@<@.@L;@3D;]&)..;)3X4;@<D@S;.@);m.]L<W<3<34WLDD4;J.)J);&D;D4LJ<f3;LfS@;S4L@<@34LJ4.L<LS)<@WW34; )@&X3)..3S@4@@3J33D4. <L@&3J&;4)3&3L&LmS4b&@|) ;X;&DL;3r&  @þ3L34X¸<mW) SWXJ))@J¿b.&)X];))@ <L@ i¤WÌxt.;3.3b  f4.þÔþiþSimrD3.4imD;i@ <L©@;<)&)DbLmtL4&3;))4&
+3  &&. 3@  34)3&;4W.D|S4&&D.&JxS))  &3&)&.&<@34&33J;J@.;.3;)@W<3D3;3); ;@4<;3)D<;;3;D;)33)4 ;;3J@4.;@< ;).4  @<Jf@ii&.S3<b;&DX@W34<<W.D4<@<D4tbD&4f@&J;.4SbbXJ@WL.4@<&<XJLri4;& WX]4..; &  &;)<)<3X<)3)).3.WSJ .@;&&3W)Wäþ´iiD 3)S ;SDJJ@Ô4Jfì.D33DJ;;tL3)3rL<<þ&.S3)x44X3.)& .;4&fS;)tb;Wf4| ]tDb)&]ðÝibt¿£þâ@i|t).4iJèì  ;);WS3.@]4@4;....)4 ;& & .& .)....3))3J;W))f])  );4ib  @;344 JD.<@4.4 ;;.@@)43)J &4;3  b)&3DD@)3D..4;L.)@LLS L.4WD4433D& &<) 4@;L<4<S)LSX3.LJS;J&@S.X<;S3;3W;XfDLWW<WSXJXJLL].Di<&.]@J3XL44 bWb.3W3L@ <J4JD<S&<&LL3WD3<)..@im]bJ4L)434;LLLS<.LJD4x|<X@J&xS<&xD)) L@&miL&).4Jm&3S.Xi@D&S43)  3<®..WLÔ)].44X®;mWD@xWbtÌXÌþWX; è;.rm@)). 33W<X´ùöÙ434...&.& W3 .).&&3.)  ]4&..;&;@t &.]4&JD&;DW.)Xt
+.)S;3)D)3;r33<W.J.W<4)..3)&@@ &) && W.L;&@)S&<S4<<4J4@;3&4J33.J43LW3;4J34)3)<S4S;<WJ;;@SJD4<33@.;3W<DD&4<@;JiXL);4SJD4JSJbWDmS3Jr.S<]i]];L<W3)D;@4@.S;)43@4334.&.)&33).J<..D;4J;D)3<@)<D)LDt;W4;. );bS<WiDX4@´X4)S.&&.@&DrWW<.f;J&J)&Dx|iX) 4<&4i.&)XJ3);;<.f.X;4WW3ù°|XþÄ.;S;;Ä4 .& 3)D´è   .3;W;&; )&3   
+ &WJ&bD@ &4DD<.x@;rJ <&& DXW <3& t3)4)X@)@) &  L4) D @;@4. ).<4D3;.<@ ;&@4&)Lb&)LL)3. 3<< ;@S)<)D))&).;<&D)<3D.<D.<)DL4;J4;)X)@.LD33W4J.&iJXX33Wr3.44&&L<fxi@;34&f3L4D@@W.@J D<<).. J; <L&<@@&@<3&.@44XXJ&JD.m@J)@<;.DJ3<J;XJL4<mxJ34;Jf.@LþâW;@f W @@&..)@rD3&).3D. &<rW< 3))bbDb<)S))34XWXþ¿3]4L4&< @LfþD.miWÔ°J4Ý®´&& )&S||JSJ4<L;]3))4 ) )3 ;X@<3i3;X.;)JS@; )) @ &3&)<&3J).]. X).4)L@b4.;.&3).;&4.3)4DJ<.333.;44DJWJ@<<)L)<.;)&<)D&.D;;).<3)&34iJ.J).) 4J.;3DD@DDL@WL@<@ 34DDJ&<S<W.)J4b@4;b)D4bLr..]f<LX@JLS@D43JJDJ;bLXJ;rm;WS) )J;@WWt;.@3D.<;<i@<3JX<J@3 <W3J).&JD<D4X)@x)43 )LrJ4@fS. fX3;&.LDW DL<&)@tLS<3)4 SD|W ))´3£DmþÝ@.L£D;])34);<4ÌÔþWJX3L)®Diðf & &.;<@<;))@<3iX) 3S&  .&3rJ4D..)  D4 &SL&; )4@ 343<))W )°L &<3L]4  .;4))&  3J4<))3444;33 .;@4<.;D) D4)4;3&;;33 )D3.LS.43.3.DS33<J<3<<4J)S)<@DfD@D<J; L4@J<L<<LL.@.iL<D@@@;@@)S443LLx]);.43XL@;J@ @&S4)L 3;...@L)<J.<<<<@.i; )4J]43&4;D3S3X4@4)4)&43Á &Lf &) )LJrW)3]&.LrL) <b|b34t4;D& &Wf&.43S;&WDD)  Sþ<.L&J<@. J3;34°W®fLWÙ;) )3 );& WS.3J3<D3@S& &.3.&&)JL&LJ;)Jfr&&;S &.34)&<@.) 4);34@ @L3 J;L;))3.D.3)3&4.D44 D@&)J@LX;;4 ;)44&JW<..)S.<.4XDL@&43;J; ).4SLL <@&@<.4..LJJL;..<<i.@L<.;WfD@.D@J4<<;4LWL4f.<&LS&@X.<3 D.i])rS S&i4Li<X4 @LWJD@.D]&.]);Si) )4&&J;3.. LL)&;.3<@;@@&DJ.J; <;f)b4SJX&&@W)@D);W.XD4< &<)SW@@LLX4 4).W& .@Dm]3 3XLJ4JL@&X )@@]¿4&;;D43J<D4@bmxD¤ùX)3)  &i. ))L)..3;4S3)@ ;&3)&&;)4)3 ;D;¿¤L;<3&<f &<&)D3.J&3L&)3J)SX;3.4) ;44.3)4...3. J44)4@J@@&&;D];<)3@3&.L).. 3;&))4 ;) L3L<D@D4L;)]3D);L3).)<S<)@3)J@L33@@)&;.@&4 X@;D.43<@);&33r;4W<m]XXWJ@4&S)]]<DSLL@@.D;@<3J4LLL)J.J@m4);S..D3D&.3@J;;S4@.<<L4;JJ ;.<@3)4);;XJDJXD3@3XÄW xS DD;4D<i3 )<&SXbD]&<)) W@4&4L&.tD).)®JWb)& &.4b4@fLL@4& WS@S.3.i¤Ì©@;]S.&& . .; L 3))t<XL;;&3@J&))<@)JJSÔä@3rJS.S &JX3 &)34 ..Lx Xr&3<<;)..)D4)34;&).<.&&3.&.@@<)4f3J;b <@)@<J.<&)D;&<D@;D@@. )) .;W.3@;@.;3S;.434JS34.;44..< .<3J]4<4.4D@@.<.4bJ..)4.<3DWSL@@L&fi.@r4)X]t< &3<@<);L;4J43];3343.S4.4 &&&<@J3LS);D))J3&J.D44)3<;4 3@LDx)44 <WJ)@b;4;Wx&;mf  <@r)XÌi. @3&4W@S)  )f43¤b4.&]XXâðm@@<|J&@D;@@SJJJW@J°i&@S@)4it3
+3f¤&
+)<|DL& ) ..@; ;);)@SL&L.  @) .<D43´þö´@ .;X3) );Db4.4))..)&&)J.|<).&&L. 4;<@;.&.)4&@4& && ) <S@< W43SD@&.)<4) 3; <3&;SJS& &4)).& .3S.L .3&b3 4D&J3;;WS;.;Lb]SW .@SX&<.4JfD3;D@r3J DXm<fXD@@J;JXmDW4XJ ;W<mr@@;&4&;Jt4)4W@3);)<<<<;;LW&)S44) 4W@b<..t334<@x.]f;&)@33.J4<44J£))£W4< m]4&SLDS4.WiStiLbJS  m)@ 4.3]X @4W).tJi.;JÊJ ¤ )@@ti)4JJÑ.3;DL3.)&@4.<&J4.;| )3<< 
+&)L33<3Ä4)& 33&3));&.J)&@ <4 &.;<4< ;.4)J)J< 4& & .JD3.;443J ;D3&;43@W3.4 ;&)<D3L4L&3&;;4@););@&)<L44)44L. W<)&].4..4JD<D);L;DmJ<&..;@4<Lb4.<JL;X)W3Lb]).<D<X).f3JJm@3bJ<XL3&@;3 << );JDJSJ.);.3JD<<D<3)3)@34&&J43<)33XSJ]@@)<Dm]tJ
+tJ ;&SSXJ;;tèS)3@ Sm3f ;&@SJf<L..m°|3)LS@4r.]L;)S4LD.m.4;JWx4 &D.@])@£Dâì°@i<@4D4&)3.&<;4))<@@L;|m]
+&&<@)4X¤@))4 3;) )  4f.SJD)4. J@W&4)44;..4J&J& )@f)D3<D@3 &;)<).4DX<f <);D)W]m@@@<LWx). &&3 S)J DDS;3@@)&@&.3<)43&<;;]<@W<SD4<;L<&&mXm4;DbJ&WS;LSD<<L3<X;)W3LJ@X@J3]4XJx.]) ;D<4XSDSJL@)LL@<. S;. D3);4)X;@)34)L4J@L]D|Ì;JW)3.< &X.  D J&&3f£<@f
+@  &)SSXiJ3ri3<.LLSL;&;|bri;JbÊDÁbm|;4]DS.4WÙ4LJLD;; 4)t4&@;3Wb)3.@<¸b@)&@.)3<<.&.)W<;;.<if.3&3X&)  3].4@S44) ; .3)3&;3;3<<. @LS)4XL .)& )) J] L3S44. 33<)3;L&&.@));D&@ JD @))]4& )D<).).3<3).&.3&&) <43))&&<S3.D;S4&.W&W4D ;];<L43L.@;@SxWD@@4D4.@WL<mm@fL@.L; @W<<<L3<X@..3)3)..;)3@W@]<]4 r@4<D<J.3)X D3<.;SixJD3<SD°)fmf;Di&)Lb&XX3£]¤¤Á@3  W3 .JJJL33)&m.DfX4<;LxmD.b3Lt3 ÝðþL x];34<þþS]Xi&S; &&fÁW&];4<&X)bfèþb 3&  .&<)D;JiXfi& &.<L4)X4Jr <.)) &&)tm) <<JbWL<@ .43 i4<@4 3< b3)<@];4@W;4<J@;34&&D<;@4<J) L4b4;<LJ < ;)4;3&43<& )&..&&;J.3D;&.XD< ;).4DDLL.JL4S@L4<LLL4&@]LJ.3D<<;L.&33&;]JfJSJJ)W&fJ3WX;&3&.]<W@;)D].@J333J)b..&).;S<4XL4<&&@)<XmmrXb]L@@<. J&@S3@33S<4;S3t&&) )3Á<þD;.@ ;þÄþ&Wi4.m&]<J)4bXSÔâþL3&@|@ <J<r;tL3..&.D&Á<. 4JLWSä]t)X°èJ  <& .4.)D &¸.JfWX;.
+.]|;;D DX4;4W;.
+<3<) 43&34D.;4&DJ <3)3.&D&JS3&3b.J@ Xf.3;LD4<4;3 &mD43&.);@3;L););4&4 &W33.3&; mD3.D&);) )J& 3&);<)JW&<<4@W;;X3DSD<@WW;S34S<SXS3D<;LrX3@@4;Dri4f]S4LL4..;L&4& ).);<]@<;D;L;WWLJS.).J@&443 3@) &3&W;3)X<DS°DSbW3 @L&<&4.m3&)&X©WJ&f.4&   <X)Jmt4 34WJ;;D<<3<&3L.r4;J.4D3&|mXL<]&3)m.r@bJbXf)4&)...¤XW.XX34&.&r®)&. .@   <L
+Sxf<DD<.tD&L<)4LL4W&
+&  4L;. JL@&<<4))&];<44 3D.34<  ))4;4)).4J<&J<))4.<@&< @;3@;D;).&4<34<< <D@L..))4<  ..S@&).<WL.<@W;;4)<.<]43&DJ33@.JD3 4bDD3& @@X<JLWJ@3bD@;@@LJW3JJ3JSL S4@S4&SWJ@m)f<DS@@;44W& S3D;W]&)).<D.S;43 ;<;LDxW<4<fJLJ33)X4&fi@  3 34JLLDL@Lr4 &<3;; .D.)J&Jr&. 4@.m©W33<.444 &;;Jm4)&br4L]J;i.  .bf;4W<.@;4)þÁL3. 
+
+&).3&& ;).43)D@44JD)X; &3;.©4@)D3@)<44S3J .<)<;43);<...<.3D@4&D&)f<3;<<. 3..@<3)LJ)..<  4;XD<43.;44 ;SL44<3.@@S4< D<.4&)@&J4&);.J3))3D .L.<;3.J&.  @D<)L)3433WWbrmiX4<JLm4W;<i33;))<.@SDL;<@ ;S<S )X.i3D;fW4);43bJ;@]<m3<W)&.4<3;.fW@<.4Lb]&4i<4t ;) J;<4&<3<4&&.@3<iLfX3<@b  . )@ ti33)âmf)44 <Li.;&f@J3 ;3<<iJ]L@WDL3JJ)& )4@£m&L@4.JS 3Ä3 Ä4&). 33X)& X)@)&;3WJSW&3 )LD.;fLLD@&4)&|]X@.&X..X& ) )4&&4;3<4;L)3.&;;.3L)3 .43..);;J) .)& L&;@3.<3.4&;.&3<J3...;@43< .D@4&4; @ @4 J&4J&D;W<J<b4f;).L;LW<;4344XD<<JW&4J<<;@W44L3@3D)<]3WJ)f]W;D);]<4 33<<.4SWJL<3;J<SD)b3LS4 . D<43W<<L;)<3iDbD3;4.4.]344D3&JS|&&3&)< &;fX4.]WL4. 3;).4<i43JD Jb®&SþS3. SW3.¿L)44
+3frLb)@|&&<)&J];@i@3 f¤ . <<<4;@)&¸Ái& 3;&.b33D33 S.&3&)&JD4)< X;.)44 Lt;&@&34@fb3bD43.);)334. <<&);..;4b@b)&@)D&<; ; &3 .))&;<<)3J<&;4W ;)D<).J 44D).&)4.33L..<4.S4LJbDSbr;)4 D@<SXL)4]D.<D3i<]X@.W;@XLJxXSm<Wf&W&SSJ4;i3<J)3LD<W<.fJSSL)&4.S@L <.J@33@34.);;&&<3<ribXWW&<tD@;Di3m @<3]3W;))@34 3XXDJ< 3X)<.& &;3LöD&&<Ìâ&Jm< &33 )bJ@°S&DW&<rþL)rJ;<.;JX@)3<D)&)m;3.3<b)4.&þx4&&& )<)i43)L44W4i)S& )@@J<.&  <4;.Dr;4;& x3)<r.) ))<&@.3 3W4@<;;&].D.3L4JD4;&4@D3 )34)< <3&@<<.4<W.3&).&;);&)..3D).@LW4.@.3&X<)D33@;@W3 4@&)).&@L)J.L)4<.SX]L44L|SDb4;f3)@43XJfb33<<;@;)33 @S.<<<
+<L4b.34@3&J ]3J@3J i;.&4&D3<.@JibXLLS..bJ&S<3b.4@@;S4D;&JL<L<@&;iL3&&LJJ&)4) ;;WXx. &);];i].& Xr&&4b&  @fþLt4J)@Liþ 3þfL D] 4@J;.3JD ;; 4  );& X;3))L))4Jmr3Jrb )J D<J; .J) <W;);4;4@))&<X´D3 )D).  ;3<3<.@4<3W@3D.<)34<& 3 Ji44 343)4D;D4 &.;3;3 )4 J;3@&@<& JD4.;3)W;<@).3D4&L)DW&;3. 34JLJ<3@.43;&DJS.f;DL3X@&4<&SS;<3m@)J33WJ3]WD3f<43S;3D]4;&44;Df3)3J)@S4;@.X33.)&DS@]&4t<L<])34@  J@LD34S;;3@@  .<XW<3r))<m43W<4¤S)  J£bS<.).LiiJ)))3&)<).J;;¸©tfD).L.@x3]<D)r3x3&..)4&;t333´D&.;)<&&;4)3&4SìS)XLJ<@3.))443L@LW3SX<;.)JSb 4).  3. D<@;@;)4.&&..);@ 3; 4SJ3)@4@.b.3 3.@)4.&.<);3J.@);.)). )<&);34 )3.3&&.J&@X<.)3 3D33<)34@SS<@4.))J<)L<LL..<. DDDD.L;).]4D3J&)))3.Jb<4<<43..)@X3Xb<3D4]LS<4S@3]XS34i;@;4mf.;DS&.D4D;;J3&DL@bfJbS<D3&  J]3)]])4|D3<WD|X£S&Lr34J;;iJ©bJ@& 
+&.&m||4)).W))J<3.)b<J.iÑðöþ©<&D3<3fb®ÌöD<D&iJD).3&.fX)t34)&;4)& ..4;.&4&&)33®´43@|J @4&S &4..S¿b)
+)<JD))L& & 3). 34.. .3&@&<JJ  3)W<3))L;JJ@ ;<@ 4);J;&4L<&J4J<D .)J )4)3@4 &)@ JS.;@&;&.@4. &.J4)@J3.<).)J);)X3W4)W@&.;&@tbJ&r4DJL.JL<)JL4;<D.3W3))4;J44@.;<3@<DW<JJ3)@;).X<SXS3XX;WJ4@;.J&33<4bL@ftD]L|;.L))3S44|3D&]miSi4D fxW&
+.m|4;]3)].;;<) ;]SJ&St&@;&;&)@L|@3tXSJ3&Xr4.@Lt3°fÌiSX<@f &4bbJ4@44 4.tbL3;4&@ ;<þX3)fLLr3D&<@@DiS; .L<) &3.J))33.&3)3@;34; )&&<33); &)44Jf&;3)D3 ;L;);&.;@J3;S@ 34 .).)4 3J3))3).)L.S.D4&3&)4X.&)<DJ<&;;DS.3D&;@3<<J&44L&33)&;.DD44W<@DD4&&<).4@;LS<X@JDD]LX@WS3S34;DWW4D.DLJ< 34)tS;DL<;<DW<DS<D4J&&<@.3m|XfW<4f|r&;X&3;X&;4<44D|f<4DJ&.4&
+
+ Êb<&i) @&)D< &Si433 3J@   4&3.&x@3<3<Ù;3 f]ÔÝDö©W;. m¿.)<ÁÊDL@.&4.3D)3S.3D&X
+ LDÔr||@tmW D& &;D|)).).<4;<S.b.) .<& ).4@;<<...;< 4). .;J343&4;X3 .<<4@.4)4.)<.;4D3J3. .;.JDJ..)&..)@DS.43;&&..@;.b)@DJ.S)..  <D<@J)4;<J;<@&;D.;X])].<<3f4)SS;44D])<4;J& & ))4.D3)&4b;4<JD<J<LJ4LSJi@m)WL<@)))S&L..J@@S|i@Sb®SD3t4<< t<D|3@J3 4LXiD
+&f°;J &4tD<x4  WS3;]Êxi & ®m4  )Jb4m3 DD.  ;&mrrJSÙþÁ J ]3)).&Sbb´<4& S.)<X;]@;&Ì  ¿3XJ3@Á°þW<L]@4DLD<<)) D;333D4 @ .))L )S)..&L)  SJ3<)4;34 <<; )..JX4LS&33..@4)J.&<)S@33L.<3.@ .&;..<XL&3;44.<44&3@L&S3i<.&<@<]L.@.3;.4<D&SJ4@;)<<@)@.)@.3&f&L4D4<;r<4L.D3L4@<4LD4)D);DW;XXL]&3;;)XDr<3b<)3X.@XSX3 <44)&3 4D;Jx&m;3m<D @m]f  4D.SW|iD4;i&;f.);3..3f)L3)bX°@.&3) rS3)L3 3@;).)4m]4xi<;;3&J... ;<4@JDÁÔ´t)4).4.4|<þ4& )3b;f;) m&.@þ@ 3  3@W¤´@JWJ)<).@J.J.)3;&..<L)34W@3 &X;.J&;)D.<&<L<);   3<L4W;;WJ43  34.D.;3&.@4m@3.@XD;. )L;)&)@ )43D3;X;<<&3<D<4<W4J@ @WS)3@3D)DD&&@&; 3W@;J<@@ &4)@b3WL@3X@<J4L;@3;JDWD]@3<@JJ.434] L<DW.<;@WLL;Xi4LJD3W).33tJWD]b<3L3<S&LJL<<.Wib.W4i4<<W
+ ) )LmLi
+fL<&<iS& )3)&LSD.@rrb&&&4.DX)4 WWJi f)&@;S;<DD< ;@WLÙD D<SSDJ44J¤;4)334ÌÑW  3;®bJ4b4&.<Ô.&3@©ÊÑ4LD<<S S4;D.x.;J&;3)SD;.4@;&)).D&D;;  && 3.4&;L<<;44<)4). )))&4&]S;SL;<);).W ;4).J4@.&&3 3@444)34D..)@ 3@3@<4;&);;4 .3.D34<3;SDJ44W3JJ<J;L4<;L&4LiDXLS;.b;D]3DS3@<X<3@;<D4<<@<@33;L])X SLSD<33&bW<W@;.J<.SXSbD4<4DWXSDS;JfDx..4DLSäxJ°|&4;3]x)Wi]<.f< <J)D..D@43XmL3b@L;
+&3DL|@L))
+.L|)3J&3;.D&3]&. 3 m.SÁ|tWÄL .3LD@LÊ)<44Ý;@W®¸]4Lxb.) t& 3<
+ XtSLDXJ;<]<.D44r)m33)@&44).3))<<
+DD3J<) ;4 & .;) ;@)@SfJ3 3.3.&34..&) <4)L;3DJ4;3 ..&3.&@D)S&;LX<3)4@J&4.)fXX;@4..D<33LL4);W&3..W<3D)@W4.&3< 4S..@D4@4]D.4WS;LJSS<DD@L4;<D 3X.L4Xf&&4.<3.S)J< .3]W.D)]S.<4x<J4J<XJiL)D@3&43@<JJ4;JJS3D@m<4S;S3)<))i<)rf&34@] 3&&33r@i4t3 &;3)W.&Jfi3W4
+..).)X<D)3D).&3)4££]..;Áöb)3@SJ;)è£ <.4;3@&Jþþ®JLX®þ<;.t& @©ÊL.D&JJ<LLmW&@3 @ &;)3<XbLD) 3;334 4.;<S.JJ.)334<S  D & J&;);4)<4&4 4 ;;)33D S3)JD;@4DD; &.; <<D.4)S3)D4J;3.;4<@;444W;L)33JJ<.4J.D&;3 .@)m<D3.<;3DSDS34bJL&&.S)X@D<3@.X@DWbL&<4J&; JLL33fx;<34X3J4<;;))J<WJ34JDW;.L;]];DJD@@bL<biL&)<)@J@D
+bt) &)).;]<tf. D)33.< D©S<4& 3SW;L
+.r.J4W  <.&.<34@3@&&xJþ. &r&L]X<;.Lmþð;@).;;..<SÝÄ¸.3]bÑb.3)) ))JÊ|t@D&WLLbxD°<&).))D <D;;.;W..;S)))@ &@@;W).rW3@..3@DJ<&.WLJ)&.&@.3<4334;.)&)3&.@33DD.<; 3.3.3D@ @@))<444<<<33D<.)D &LJ <@.<;<DW<34LSD) )J4@&XLW)W@W)]@4@;;X<XJ3J]43Sb.)f.<DJD...DD ;LD]D3SWX;@ D4Ji<D3;<.4<WJ.L@]D.]]<XL3JWWJ<fJ<.. 34D®Xb@) 434DW;4&3.ÌD&3) .©X;WS   S&&@;´; JDW&&4.;;3DS.4& <X©.)<D4 Ê4;SSLW<ixX3©©b;þ@XS´L Sþimì@ 
+& &.x]3txJ 4 .Lxi
+.)4])&.)&3D)|f)D&;<;)< . )3&3;43.;33.<3;3 )3 WJL&4.43@33)3<@&3;3bJ.43L3;D  )@X<@D4DD4)X3DJJ))X4X4JSxJ<;@;)3;).D) &D.@JJ;&D3<  <f<J3<.J<)];44;;)SSD3|)&4]rD@<L<;33;44&;L)).)DbS3WD3<;)&&3r.;W.3Sf&L<@]iJrD<43DL<&<WJ x3<;L .LS@. 3©X4
+
+)L<
+;@J3&@4) 4b3@;3)LJ &   ;3;|)< )4  © <f3)&&& )&4XÑÄL)L3@)X¤þbSþþö|;D&&<.öÙ|& 4).)@.]W@;S;@ <&4<  34&.;@3.4.bm3).&<&DS<@3@i @34)J&3433.)@D@;;3.&3)..3.W;<<4@ 44W;.3;..b4<JJ@J4L&&;<3@;D;r.&34&W)@@.@3];;J<&D<4J&3<.<&@JJf@<&3]<r4DJ <DLDD@DDS4b 43;&@W]D;W) .33SS<&D.3;;W&<J]LLD&.@rS;;SJ3 4bL4.D).)@bDD<@;4f4@<3;bmJ)&34DJ ;Xxt)J)°W&)L);3WJW)i)&;S<.&;)@iL  ]Db <<4&; <S)& .&);W)3&&;] .3@Sðþ´iL4;@.3r4ðþr´¤Ô<..;&ÝÄit) . ;<ÔW  &@i<;i43J)&)&.4&3< <;3L)&&DX<;) 3; .J<;<4)@4;3@4&4))<34333LJ4L D4<< b@&4..f.J.b3443WD4D44J4<.  33&).&4.;L)@&3&&@&.
+4<D<Lf.&@S<.3LLDS@.< 4 )@3D.3fWL; )D@;.<;4&iS;b&;L<;]L<4L))@&;.@&<<W.4.<DDW3;<L;f))DWL@3]4i.4b3SL@W3;3;;D;;))4;. D@<rrD;4&. 4.3;) m<<  )XâfL3<  fxS.DS4&JS|);@3.34|<&43S..&<@@  .<bDfJ&4)@3@rþÝL&W)JJ.èþ£<<@ð3&  ]¸Ù¿L<.).)D¸<.WD;Lb;44<DXt& . 3<.444L444 XW;&Lr&))33.<@@&4.@) LLJ44D;. ..4.&D;.;44);33.W 3 4&)DLS...;4). L)@W)&@;3SW;.  ;43J4W <);))3..&J. &DJ@);D 4f D;@Db<D.JS<fStS3SWmJ)ffLW]4S4XLf;&; &<J@@@@33&LDDD.WJ3<S@Sr;<J@WWS) L ;£@4@;&);J.&S.4<W<)&3;&)L3;b]S)& )iX;4<<J.¤mJ4))S;33@]&4®J)<34<3.m. @D&<i.&&¸©;@  ..&3r® 4D)L@4&4LDbxJÄfJ<.)SXfDÌ@)3 Á|LSm<.i r3.&i. W.& .@;&44 )D&4@X) . ;..3@;)WJ).&4@4)D 3@3<; ).<@&) @S]4WS3;.@4 &);J44.;S3&3;;;@)4..&).DJ@;.))3 ]
+
+ 44;3.. D;;@3 @4).& . SSLiDJ<34Jb<L)W;.<DLf3;DW 4S34<).X44 ;;]mDL33@DD&L3DJLS<J<DDD<.4<3&L;Xi<S;.<.fX3.J43mDiJ3@ )4))) &@W)3<©3]& 4bbWLLbS4L i@&)<;x34Xb)&)  LÑ 4&3mJ&4@<3JSÔ´)iL.3..@ Dr¤<S4rxJ4fJ;XÄ;)®]@4;r4Ñ )4mi& .t.&&)&JW;3<S &.4) ;S]@@4&<<4<&)@ ; &@;;;L)D4&< ;<W)3).)DS<<4.@.L33;J.4<;@&3J).;J 343.3@.3D);;@J;< 3.L)..;L4..t @4;<<D3L);@3@<;)4 343 .]D4L]SDD@L@);LD)L J4@]X4Sf  DLfb4L4@.)&S.@3WWr.b&) S<<LW&@DL]].3DJ4;4Lb;4rWi<b@33XJ3) 3 DJ@4  3&;3SJ<r<JWS; Sf)mWJ
+34;&4@@<]&)&  )@]WWXm 3 Wb3&)¿44)& L)L°]) ).4.))Wr ¤þ|33<|m.3r4WW4¿4f@3 þ¸X£3J<bL&.3Lt4 ; ;@4L|X3&D)&4DSD4W3.4.< ;D )&;.43JD&)4 D; ;&& ;3.D;;4<<@L<D<.;3.&)34@)3)<J<&)&<SS ;D;&&.)&4&33].X4.L4<<f&4<).;D<3<;<S@34&4.;.X))DD343 4<JJ;3&&DLJX@SDrS3&&4.3L4SL;)4)XX@@4WDS.WDD.<S4;44]WX4i3<bD] 3|.3<;D&@fL;4;]W<3b.; ]).)JJ]&L..WD;&i@bXW<@&). 3;<3&&&&)@|LL.W;4)3ÊJ.<  3W@Jb&&JþbD34)4®Ý@ÙìD).J)X;´WÑÑtLib@WÔ´@b¤XS&SL. 34S|&& 33)<@);4@SLiJ @W)L&@4)4.&)@4&3 3D);&@J)3< ;@33D&.;4@.3@@)J;DJ)&@<)4)&&)4&3X 4J433.SD<;.SW&33)<D34&&4 .&JD))3 )Ji.) JW;4)@L4;@< .LL3DJ)&< &S4b<)DDWb3;<S@4J@;&;@DL3L;L;J@LJ W;<;)@D.)W3<3D.43<SSL<D4D<L;4xf4)L@4;3;&Xmim@)f334@.43.);Df@ b3< f4.tL <]@;@iX;.3)4;]bi&&i)&  Dì.Xâbb.)mS  D.)3<4<XbD@3mþfWDXL44<|Ä <|<Jföm3<<LX¤J3&&Jm¿tW)Ùb¸3°mL.<3@&3).<.3<&DJ 4tL<Li;JD;W.;@)3;S4W@& ;4D;<.W<&W& @3JD4.WLL) W )33L43.J44.)< S<;4.)<   )3<&;@ 3W.3;);4);;)3)44DL XXLD<&@; .L))&<WW& ..&]@3D.L&@J)D4;X4X;;@@;LDJ43.J;<LW;<<LJ&)J)<;|43&JLL)XD.@;@LL3.]bmLJ4&);i3;3.<.tD4r]S;]4L4&  DJ4L;)W4  @);3X@4&;©S3  &. ) @ )< @<S34.i£ 3&W<.  &3<¤´)4W<43Wb|D4; &S3D. @Sör¸D<4J ®Ììfi&)b]W< 4 itx..X.)3& &.).;)33.S43<x;r)3; &;D&&;<3  .&);3S  @)))3 .D&;SL3J&&DD;3 )34)3&@@;)J@&3;.&@.4;;))J 4.33.4JW3.4<).4@<b@S3 )rL&3;&LD3.< &4iJ3;3D3<.tDfD]LSJ3L ;..)4&4]3@ D3<SL.4;J4L .S3.3 .@<4;)4D4D;SJ 3)<SJ3@D4rJ.;@|&& W]3;33DWiL<X&. <S.3;3.|Ô33. 3WSfD)3tJ &
+ &J;D<JÁ<.Ji@3W&3¤4& &<3). 3;&;<.4.;LmD <SÙâf.4L ;fWr@3]Dbf4<&&.&&4&iii@4 L) ;3D@3  L 4XD@L]) J3&&3;;4J.&& ;S.4X@@@4;&&D<;<@& ;4.@ W@J<4;.X4&.&4;3)3@J).3;&4).DS4)JX]44&);LJ3)&4)@Äfi3J&b<  43L.3&44)3)<&L<@@34@t ]33DD<J;3<;)<<J; LLi.J)@4J3.<tSL<DD;&3JL]J@4<@JtX.iiW)&@) ))SJ]L.SW;&DL@r;.44D. 3&& @b&).]D
+)@X))&Jit...44L;&]]m3.W  .<´]S3).  & 4;;;.. ; 4343;;&3<SLLJ4Xb@ L4è£4).fLD4).)& ;;]J;))&.&..) 4&).D.;;.<;L4.<SW<&3&)4<4&<3@& )333<)J& ).&3).S@<));3 )&43.@<W;&<&4X)<D)<S;3;)@)J..3 .D4D4@&&.J3<3& &)<));m4J|L3);3;<LD .X &).;J;3JD )<@;J)4<4;]D.D43<Xr]D3& 4D<X&@LJ4@<4.4); W);<34J.;LJ;]@4DD<fmLW3;SiLW44r.]&fi3LW)4.< @<<<<X´r3<<.L3WL.;<D&Jf4];fÊJ.r4
+.)  ). ;;t.&&4<;@.L4<&L.3)D.3.;<)L)@<.  LLDD3ÁÝ<33)@Ý|þùÝ@.JLbm);LLS.&..@i)xb;4<)<3;L..&) 4&;SD .33<b@4DDD< &D&&4;.iW).@< &;<@).@S &<3L<&S.)<L L<<4 );4.LL<@WL@DWX.<).4D4LJ3@]@4&) & 4<3.34;©t  3;@X.4S<.DX3 34433.Wxx.L<LDb<bLXD)<WD@.<<<@xJ3.L<S W3S<J];<<3.);.;S< @.;< <3.<D;LLi@b;);&L34WJ;S&]].Lt.<@|& @b]X]r @&.&].@3;4DS4&)])J.@&;3;&3 3.)D3S.4@ <WS&@@L WS]  33;D4.®J&f;mÁÄ].)3Wâ3mr4X@SL4.)3;3@.34
+D&<)< 43 .@<<; &D4<..<LmL]J.L3X;.4)  . .<& )i.3@<3&4W LS&W)DLD;.L44<D)<) DJ&;3&r3;4;J4;4;<<.X 4D;.&.DSJ.)W33)34<3).
+.))3.4&S<&LWr3&JS;<<S;3;D<]&bJ<;@D@.m<L34;;L44 @;;@D)3.&DLJ]W)4.W@b44;m@@J3.W3D;3@4&L;JX3]i
+.]@f|<4<<Sbb3)4;@3<;& < .))3W 34;)f¤b<.4r&3f<|33 .@<4L).Sx¤&J<r)<)<@þL;;. @ fD) @]@;4)4¤£ÝW@L4@&L]LS;)&.;ri¿;);<J.<)L4
+
+4 3<<4;X)44&@)XD)D3.44 @3@SJf3. ;33)L&4<LW. @L4 3<)  ;&4<@SD.@L.&<&;;4@@;)L&&<;4);&@J4@33L..<) )J)D]44<DJLmW.&3)&<&3&&3mL3& )4)4 3W<<@Sb;L4W<@<.3<b..DD.fJfDXWJXJL;DWJ@@3Jb<@W;WDDf44W@LD<;i<fW&4.&.@W4<)m ; <]¸LS;)JDS<<X<3D;J;DS.Jrmr&&33)4<;S).&.4©tL).]& ¤¤D 3<44&fW)<4  @;.JfL)¤.@ 4&)3|3&L)3<|@Wi)@ &3) iWiÙþ)&&@&&&)]&JJ)<Ê¤WD;.;4.L)&3<
+
+).; D))<3) <&LJ@<<LW3W<<4bLr<@ 4)4.33.)br;).r;4)).334.&@J;@3D.3D.D).; J44..3L ;S;4X&JD<<JL4WW<)L@4.<<4444D;)<W 3 )SL .X;.)<W&x.i4&&D;&.bL)Lr;);DL)fLD LLf DXbb;.D4<.J4@S34<.SJfSLS3D<L@4344;LDW.)4;)WW]r4)L<)LX)@@;@LX;DSf&4X<<]@J3) .b43i<))3 ;4 .3J .4)L&DDtDf  LS)f;).
+J&)@|<J.3<;J.@&&4<@;Jf4) )
+&;&SW3D4J3D3&34&@3 âþ©&mWþJ|S<S3  .J
+3&3&.3&;3X.D;)4 ;S<DSbD;4DJ4 4D 44<i&@L3W);))4<]X33;343<).&3.<&.)4&343;4;)Sf4.)<L&f3 DD)W.)@;& &S4]b34L; ;f]J4& W&33 Sx<D) 
+ ) J;4XDSS3)@LJ&]L<D]r3xiS&;.LW@fLLLmDDL3;33;WDD4JWLD3)&X)3;|3L&@DSi4.&;iW;JLtLL@3<@)W;)]<S&J)f@J;&;&<@D|; .X3LXW£)tW;4iÌW) 33.im;D&
+)W& &4f4)<) )&;fÄþ@)& &4<&3tÊöÝ;D;S3 )S.4))X;.¿þ<L| tf4 ]<D)4 .&
+J&.3.D&@W34&.@J3D44 <W4D))WL)<&;;&W&&]&.3J34D34J);;<<3@WD3X43@@3 <<4) .33).;3W&  .&J.)<.<3 4.D3. )44D..b<33 .LL.SJrf <44<DbX.
+&4<W<3DJ@J43S44DW@<<4]4;< .;< <JL<D<LWW4<4WW;&@<LJiJ;J<LS43]LD<@@x)@ &4@@fr JD3<4&)ix@) W3)m 4 @.);&3b])<)b&;3<34@<WJ W<)&])&)¤ W).3.. DS4JLS <WJD.)) &@SmSb¿b&)&Lx)X. &;<Dìf]W< b).&t;D4.&öJÑâSDD&m<;3X3)   
+<. .<4.@.;34D...&3<.););<.SL4W; 3..<3@) ) .L3D@.))3X<44@.@D;<; )XD3&<<L;;4);))L;&D).))&@)&4&.<D.)4<4.<3)LL<S.L@@ <xJ;.)&&  <.3t)ti& D<.)Lm]J;DiD|WL4;&<SLSXLfrS.3.<<S@3<J;4)@L@@..D4.Wf]3m@S4DDJfD<;<JÁt©D. 4D@S@SD)4SDX.)Lm 33W&SiD 4<& ).@4W;&X)33;<.);SÁÝ   ;]]&;J&&;DS@];fJ. J;.3S.&f4)W;L))@©L3 ))£J)<.]..4;m  43<JL)D&)&i.XXJ4D<D4 m;S4.D3D .4L ;;;)4)J;.<.43 .);).&)).)3<@4S)S  D];4<@.;W;X J3.;3;JL].LW4L).L&4.S&)<b443). ;33;4<44@ 4.@J. <.<3W.)D;.;S)S&@;;;XSL;4J L 33.fS4&)@&<44)WWD))<D4@S<4<W.&X@<J<D|W.fJ)bW.@4f.<@@&XbLJ;D]<J X]Jr.4)i¤;W))D<<3D¿3t]@<)]3XWJX;&4S.f4&S]&&4D D3 <LL3&  ;<.43&.3&.b£ .Äb@i.)34&;@43D;&&D4Xm)&)).))3.).3;DrJL).3J4Wxð&< D©J4@.&rrf3@))L;;r3i@4X) &4
+
+3;@;D4&3) <@434))3L;<3)&&.<4&L@4)<D43&;tJJ 3.33;;.3&;33<3.&&<4 )))3;;D4L)& 3&)L@];)))<J4D4& @];33L ).@3).))J <).3]4JJ@ &. <X33@4))D;<3;DLLW.b3L3;3;4L)<DLD];;JJ4<W)SL4J;<XJL]J43D3D@W)L¿@). ]fb4&<43]S&W.<DX&L3D 4X@&& ;f;WL<34;WDD3<fJ@.  < ;3J;43&3 ]®S<4&4@<  D©34W).@ )4@
+ 33 .3) .;3W3´b<x&&@)D&..Ôù°SLÑt4 bX;;@LX|Wt34;<<.<<
+ 34J J.@)...D) ;3;D.@ < .)&;;WtLrW)).3D))D4.<;)&).3D)34@ )43@@D D4X4W.X;3&;@D &4;.@ W43<4W.33.X4 . &@L@ )  )@) .;<)&3&<;f]4&;)3&S;4JWD<S<<;<4;<4;DS4;D];3XJ @LD3@4W).@SJ;;)L);3@W<S&34Wt;3&@<@&J33.;]|)4LX]W&W3@i;SS f<.)&@bJ&.L <.<S4 3t L<;..4)&D3f.33J;)Xi&; 44X4)JW&4 ). <DJ)&SW;J&)4 ´34).3¤©|°x3 Ù|.fJ.. 34b<&3@ @J3);@. ));
+4. 44<<3;)).&));;@3  ;D ))3DLSW)W@ t3&frSÁ;&3.43J 3.44)34@J3D4.3J]J44@3L<<D<XL;@;..<X&L@ )@34<;4S;3f4]3 ;;.3;.4)&.<.@.J&b <&;@mW<34S 44@@&DD...i;L&fJ&fm<4WDL4<@W4@4J@f]4L@b)WL@WXmÝS.3Lmt|&&)<.J;<;@)J@SLJJXX&b)3@S<DSD< Wm.434<)J3J;J)3; .SD&. 
+WD.J) .@3. 33;.4;bb3&@m;L@@L@. D&33X<33 @&W .W£rf<;)W@4)f°S@)3bþJJL<&) ;W).].@&4D&33&).4.)&<. &4 ;&D&4;))).44 &344f33X4<;&&i<.xL 
+J<34<.)&.;<< . @.W.3<&4<S4L DW@@SD<&)&@;J@4f<D3L.)@34)S4@WÌ&&mS& );<34.&)D<3@X43W;Df4@;<D@4D<D4L<@<3WLLDi;@L;3LW3;43JD]4WD@X4xD@@@L<W@)<i)4L°&bW@<D;.W; 3J@&&3S)&JLD& &;i @)LWfJ.3;.W4)3<);@t)Ji.&.;.)&&WW)r@3.)L´J4D.LW J@Jr
+)b&S& rS..&<&iÔÄ)&f;;<4)LX;@4&¸W)ÑmJ£fJ.;L<;]@&))]J) 
+
+D.<<.3.&&<&3. 43J<4X &<&&@&<3D<<XD4<3|Sx4.3&. )D4@.;W@D J3L))&4 );D&3SD@4@44&3D3 ;))4fWD..J.&@;)&3)3DL|m ]J4;J°3).&&J@D;;44.D)S©;3&&. < ;)J]]@<@&JD@ XDLL@X&iSL.LL@<@D4b@X@D@L;@<@f;Xr;&SX&;@;;D&.3WL&.f£@)@DJ 34.4&.)W).@;i33.3m3&xL&&3<;)DLL ;&L3&3;) )3<&;i3).X.& @4)4&<J& 3&<f. ;3)).&44ì©þ<.)<&4S<3.3.;Ê@X..<£ÝS3JS]i3)3D3]))XL&3i@.;)34)X.3L@;D4<;;)4& ).;4.3&&4 <D <L &)S]) ) ;;4.W L) &@LLS.3))<;;;SJ4 &4@<; @3] 34J..&J))<;S).Li;L3  <44W3. )]W4W.&)3)&; 3<4<3XD<DJS£X &;4L)@4D3)4@@.LD]JL34<L<;t4@<<@3;@&J|J < 33]SD);J]t3;© @.&J3 3@S¸@&3S3;]D34&.3xLS<& f4;; ))xmf;4&<@<]D3&4).J;)4&;.3 t°<.DJ;<&&@@3b4J&433&.&3DÁWJÑJ
+  )i< 3 .<<|]D<4<&<@; &@]f&&] 3<)&4@)&3.&;.D..< .D3<))W343< &@4L& 3L&S<43@.;3.3;&;.. &;; ;X4;;3<@3<@@4))3;JL@@; S4& )S.J)3<&J@&3)<..<JWJ)D4<44
+3iW3&.;; ;XD<<3D ;.&< SJ@S<x<)tL...D]@3;Wb)<&i<4Wx.J<4J&J)@S4<D;iS.3 ))&4.WifD;@3)tiW;@<;X3)JL@3JD&]W&3DmWmW&)<S;;SDSLX;<3X3&]L..)) ; 3´J&
+&) 43@D|þ4&33)).Xm 
+)Jf<W3þ´i.
+) Xi &4¸r®m¸S&WJS @;.&&©D.44&&]L ;L.3@J. 3).; &<<;J&&)D.)@..)4@)J.34W&J;;
+&.44&3 4)@ <4)<&)&<)3)i) ;)43;44@.<&.3;)D<W&] W@SX&<; )<;D;D@@J&@L.34.@).]b 4))&.3..b3& .4W4 ).& 43L.)D)m)<.3)44@S)W;4;W4) D S.]<LD&4W..f|m@bS3Di .X]WJ4bm3]L)mJ.D;b@mX¤).@DL W  D 3);L@<3&<<. )fSXDLt|3@@W)<@X©)& .&x3&.))&&)4D.t®þ4.@.J..));@ ;D&4W®ùW 44 &;m&3D©®]SJ]@b4D3LS.S&;.@@)&J. D)S&D&<.).J3.&D4)4J&L;;44;&3&mXÌ<X<3J))t..4.&L.;.<)3& ).;L&4)@t<S4) 3. &33L@))3&@)J.3@W3 LW¤J   ;<<<Df3).4.@;&)&L4.4WL)&.3.4@&S&4;<f<&)4. &SS;4 &&S3DD];L..33.4@D;þ¿3Lf333 &.J&;J]3DW@L<33 &4D33XS3f3@f4.;3<;;S<).@<)D@;3)3J@mJ.)b<.4;)L3)S43 ) &L & 3  )<;S]3DS33J;)< 433))3) ]þÁ´SÄ.
+&. &43r ;WfW]m4;]m D<4.L.. &<<S@W @X;3
+.3&@3.&33 .3J; )L.;&J3.)@3 ;r<L&.DDfD D<f<)D&.&< 3<;)4..@XJJ . 4J;;;;)&.D 3 &<34 ;4J4<J @ 3&rf&33@J;))4<i£)3&..).;@S@; @&4SL S  .3.4)&W43@f<4S&)&<f@4;;;4LXJ4D;D4L)t]S J;SXt))f@)D3]WLL43LD4@;W@&D;  &3@SD&4@;4) .DJ@;.3; L@X3].3L4tJD;<..;W<@.&4).;443)J & WL  3J@4J&.|S&  4& 
+L°â)3@Lf   &  D3;X3.b.L]D.@S3@).);3 3b )4.;;]4.4Dtm;3<D4;Xb&D3))< ;.3)))X3 @3;JLþ4S)
+.S<@.]D;)   @X&433S;4D;4S.W.)@)f@33LXD4@3&).&<43;;;W;<;@4&3)m;)<34;4@&.þD & ;444 3J4.&<4&.&.  D.43X3<XL<fJb3<..& )b4S4L<D;J3<@XS@]LWW;W]|xX@4;) &J4]@ 4 D)434)&.LD ]..;mÁ<)) Jf)3<3<) ;;&@]]f4XS43SXJJ3t&r&S<)&3X.).34.@;f.   )&Jt. 3;<S&DS|S@JS &&.DJÝt;b3))b]&& @L.);&]4rJ<Si4).L@3 .4)x. 4.
+ 3.JD4&.bf)
+ .;D)33<&;.J<.;<<.4@L&))D;ffb;t)@W)L3@&.. 4; ;D.D;34D&S&&;&D<44D .4;&3W;)S.D]3 &;4L&<@<L &<&.& ))...&;;4 )34@.&&34 .<i<4;D]);S4)<LDW]SL4444LS@]3<4;XWfW34JL<L;|@b<D). D.&f3)&mSW]3]D)&JX<J;<;4L]S )W.<3.Dr)).4f; )XSX;) 3´SiLJ3.W4<&J.&;).4t;Wi3 &  @&3 ) SD3DDi]..r.)&&&@)Jþ4X4)xt@
+.34)<D4|r@.JXJ33;S4|)<.) 
+&D)4J4;@D33  ;4&3JW J@&4;4.4&4D;; 3&34<J|3X&
+JSDW;
+XxXJ4)@;;3&&@J)@)<..i4X)4@.b JX3L@L&@@)44D;W@3])<<;3J3J43<< &..4. .));3<@J4<;)..<@4LX<)4 )&@.L@.<;)J<&]);<;DX.3XX3DXbXSbD@mJi4bmS..X;)3&).4 )@Dfm.D.&<4<S&@Df<LL4L@@&&4|X&J.&D;.<;;  )X@3..;J°;3 tfL&4) )&.]rW]|<D)4D D)&343)iXbX4.<)mb
+4&;£;S|Jx)3.WJ&))@4<Wb);3bL@3;.X<X;4&&
+L)& W..&;@J &<43.)<3D.&3D;.3 &@)X<)©<4X@;X4f;X) 4S.W.3&4;4 3&44WD 4@;3J))J@.DL@334.;W)3J@4)@;4mf)&.  JX) 3&&)4.
\ No newline at end of file
diff -r 8b1af7363833 tutorial/python/presentation/images/circuit.pgm
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tutorial/python/presentation/images/circuit.pgm	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,6 @@
+P5
+# Format d'origine visilog
+# Maillage hexagonal
+256 256
+255
+																					!!!&&((((&(,,33<<<<CCCCCGGCCCCCC<<<<<<CGKPTY]dhhoooooooohhooohhdbdhooxx~¦­­¶¶¸¼¼ÃÃÃÊÌÌÌÌÊÊÊÊÌÌÐÌÌÊÃÃÃ¼¼¼Ã¼¸¶­©¦¢¢~xvohd]b]]YTTPPTTTYYY]bddhhhooooohhdb]b]bYTYTTTTTTTYYYY]]b]ddddhddd]3		(((&&&!&(&((((((,3:<3::<CCGCCGGGCGKNPTTTTTYY]]]b]]bbdhhohoohoohoovx~~~~voohhdddddhhoox~~~¢­±¶¼ÃÃÊÌÌÌÐÐÕÙÙÞàÞÞÙÕÕÐÕÕÞÞÕÕÌÊÊÃÃÃÃÃÃ¸¶±­©©©­©¦¢¢~xvoodbb]b]]]]TY]]]bdddhhooooovoohhhddddb]]]YTTYYYTTY]]b]bdhooohhbG!!oohhdb]]YYY]b]ddhooox~~~xxx~~~xxvoohohooox~¢~~x~¦­¶¼ÃÌÌÐÕÕÕÕÕÙÞàààààÞÞÙÕÙÞÞàÞÙÕÐÌÐÌÌÌÊÊ¼¼¸¶¶¶¶±±­­©¦¢¢~xvoohddbb]]]]b]]]]bhoooovvxxxxxoohhdhddb]]YYYTYY]]]]YYbdhddhhhhK&		<~xvxoooooovx¢¢~xxvoohhhhoxx¢¢~~~~~¦­¶¸ÃÃÌÕÙÙÕÕÕÙÙÞàçççàÞÙÙÙÞàààÞÕÙÕÕÕÕÐÐÌÊÃÃÃ¼¼¶¶±¶¶±­©¦¦¦¢¢~xoohhd]bb]]]]Y]]bddhhooooovoooohdd]bb]]TPKNKKKKGGGGGGKNPNKNKK<(3b~~vvovovvvx~xxxvvoooooovx~~xxxx¢©¶¼ÃÐÕÙÙÕÕÕÕÙÞÞàçàààÞÙÕÙÙÙÞÞÕÕÕÕÕÌÌÌÊÊÃÃ¸¸¶±­©©©©¦¢~vohdd]]TTNNKNGGCGCGC<GCGGKNNNKGGC<<:33,,(&&&	&Po~xvoovvxx~~¢~xxoooooohoox~xvovovvox~¢©±¸ÃÃÃÃÃÃ¼¸¸¼ÃÊÊÃÃ¼¸¶±±­±±±©¦¢~xoooohdb]YYTPPNGC::33,,(!!!										Ko~~~xovovvvvx~~vooooohhdbddhoovov~~xooohd]]TTTNNNNPTTY]dhooooobdd]YYY]]YYTNNGCCG<:::3,,(((&!!																																3bo~~xxxvoooooxx~xvvvvvvoxxx~xxvoohd]TTKKNKGCC<::3:::<<3,:<CC:33,((&&!																																											3Yox~ooohb]]YTTYYYYY]bbbddbbdhhdbTPTTPPPTNNTTPPNCGKKKGCC<<<CC<333,(,,,(,((&&&&!																																											!&(!!,<Thvvv3,(&!!!&!!																																												!!!!!!!!!!&(&&&&((,33333::<<CC<<CGGKKNPTTYTTPPPPNNPPNKNKNPPYYY]Y]]oovxv																																																											!&!!&((,3333333::<GGKGGNPPPTTY]]]]]bbdhoovooovoooooohb]]b]b]TTPY]bdddb]]bdooooovxx~~~x~~~~~~xxvooooohhhhooooooooooovo																																																										!&(((33<CNT]bddhovxvvx~~¢¢¢©­¶¶±±¶¶¸¸Ã¼Ã¼Ã¼¸¼Ã¼ÃÊÊÊÊÊÊÃÃ¸¸¶¶±©¦~~~~~~~~~~~~xvoooooovxxxvooovvvv																		!!(,3333333333333:3<<<<C<:<CGPPTTYTPTTY]]YTNPPTY]]]doo~¦©±¶¸ÃÃÌÐÐÐÐÐÕÙÞàççïçïçççççïòööïçïïïòòòòïçïçççççïççççààÙÕÐÌÊÃÃ¶­¦¢¢¦¦¦~x~xxxx~~~~xxvoovovo!!!!&!&&&((,,3333333::<<C<<<<:<CCCCC<CGKKPPT]]]YTYYY]bdooovxxx~xoohoooooooohoooooov~~vhoovxx~¢±¸ÃÊÌÐÙàçïïòòïòòöøýýýýýýýýýýýýýýýýýýýýýýýýýýøöòööööööòïççàààÙÕÌÃ¼±©¦¢¢¦©©©©©¦¦~~x~~~~xxxxxvvddYTPTPTPTYYTPNT]hoohddoxxvox~~~~x~xvooovxxovoxx~~~~~xxxx~~oovx~¢©¶ÃÌÕÙÞàçòøýýøøøøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøøýýýýýøöòïççààÞÙÌÃ¸±©¦¢¢¦¦¢¢¢¢¢¢¢¢¢¢¦©±±±±©¦¢~~xvovoxx~xvvoooovxx~¢¢¢¢¢¢~~¢¢~vvov~¢©¶¼ÊÐÞàççòöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýööïïïïçàÙÐÊÃ¸­¦¢¢¢¢¢¢¢¢¢¦¦¦¦¦©¦¢¢¢¦¦©­±±±±±±­©¦¢¢~~~~vvxx~xxxx~¢¦¢¢¢¢¦~~~¢¦¦¢¢¢¦¦¦¢¢¢xovx¢­¸ÃÌÙàççïòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøøöïççàÙÐÌÃ¶­©¦¢¦¦¢¢¢¦¢¢¢¢¢¢¢¢¢¦¦©¦¦¦¦¢¢¦©­±­±­±­­¦¢¢¢~~xvxvov~¢¢¦¦¦¦¢¢¦¦¦©­©©©¦¢¦¦¢vd]Ydo~¢±¶ÃÌÕçççïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøööïïçççÙÐÊ¼¶­©©¦¢¦¢¢¦¦©©¦¢¢¢¢¢¦¦¢¢¢¦¦¦¦¦¢¢¢¦­­­­±±±©©¦¦¦¢~~~~x~¢¦¦©­©©¦¢¢¢¦xvoxx~~¦©­©©­­­©¦¢¢¢¢xY<,(&3Ph~¢©±ÃÌÙàççïïýýýýýýýøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöòïçïççàÕÐÃ¼¸±­©©©©©©­­­­©©©¦¦¦¦¢¢¦¦©¦¦¢¢¢¢¦¦¢¢¦©­¶¶¶±­­©­©­©©¢¢¦¦¦¢¢¦~~¢­¶¶±¦¢¦©¦¢hTGCKPbox¦­­­­©­±­©¦¦¢oK&,Tv¦¶¼ÃÊÕàççïöýýýýýýøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýööòïïççàÙÐÃ¼¸±­­­©­­±±±¶±±­­­­­©©©©¦©©©¦¦¢¢¢¢¦¦¦©­­¶¸¸¶±±­±­­©¦¦¢¢¢¦©­±­©¦¦¦¢¢~¢©­©¦¦¦¢¢¢¢vP3!Gbo¢¢¦¦©©±¶©¦¦¦¦¢¢oC		&T~¢©¶¼ÌÕÞÞàçòýýýýýýøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøööïçççàÙÐÌÃ¸¶­­©±¶¸¸¸¸¶¶¶¸¸¶­­©©­­­­­©¦¦¦¦¦¦¦©©­±¶¶¶¸¸¶¶¶±±±­±­­©©©­¶¼¼¼¶­­¢¢¢¢¦©©¦¢vK			(To~~~¢¢¢¦©­­©©¦¢¦¢¢¢xG					&]©¶¼ÃÐÙàçïòöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýööòïïççÞÕÌÃ¸¶±­¶¶¸¼¸¼¼¼¸¸¸¸¸¶¶±±­­­±­­©¦©¦©©©©©­­¶¸¸¸¸¸¸¸¶¶¶¶±±­­±¶¸¼ÃÃÃ¼¸¶¶­©¢¢¢¢¢¦¢¢xK!		,Toxx~¢¢¢¢¢©­­±©©¦¦¢¢¢¦¦¦¦¢¢¢¢¢b,	:v¦­¶ÃÌÙàçïöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöööïïçàÕÌÃÃ¸¶¶¶¶¸¼ÃÃÃÃÃ¼¼¸¸¸¶¶±­­­­­­­­©¦¦¦©­©±±¶¸¸¸¸¶¸¸¶¶±±±±¶¶¸¼ÃÃÊÌÊÃÃ¼¸¶±­©¢¢¦¦¦~P&						3]oox~¦­©¢¢¦±¶¶±©¦¢¢¦©©¦¦¢¦©¦¢h3								P±¸ÃÐÕÞçïýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöïïçççÞÕÌ¼¸¶­­±¶¶¸¸¼¸¸¸¸¸¶±±­©©¦¢¢¢¢¢­­¶¸¼ÃÊÌÐÐÌÃÃÃ¸¶±©¦¢¦¦¢h3							Gbox~¢¦¦¦¦©©±±¶±­©¦©­­©©­©©­­©¦¢P!								3o¦¶ÃÕÞÞÞàïøýýýýòøýýýýýýýýýýýýýýýýýýýýýýýýýýööòççïçççççàÙÊÃÃÊÃÃ¸±¦~xxooohhhb]YTPNNNPNKGGCCC<C<<33,3,(((:h­±¸¼ÃÊÌÌÌÌÊÃÃ¼¸¶­©¦¢¦¢xK!					,Toox¢¦¦¦©©­±¶¶±©­¶¶±­¦¦­±¸¸±¦¢¢x:								&T¦­¶¸ÃÃÃÌÕÙÙÕÊÃÃÃÃÌÐÐÐÃ¸±­¶¶¼¸¸¶±­¦¦¢¢~xxoooodbTNTTPKG<:333(((&!!!!!(d¦­±¼ÃÐÌÊÊÃ¼Ã¼¼¶­©¢¢¢h3					!Kdox~¦¦©©­­­±¶±¶±±­­±¶±­­©­¶¶­©¢x3											&KY]]Y]]bY]b]bTGGKPPK<:3:<:33(!(,,3(!!					(h©¶¼ÃÌÌÊÊÃÃÃ¼¼¸¶­~~~~~~~~~xxx~~~xhT]hK&										Cbovx~¦©­©­­­¶¶¶¸¶±©­­±¶¶±­­­©¦¢¢o3									3x¢±¸ÃÃÌÌÌÊÃÃÃÃÃ¸¶YYYYTTTYTTTTPNKKKNKKGGGKNKKGC<<<33,&(									3Yox~~¢¦¦¦¦¦©­±¶¶­­­©­­©©©©±±±­¢d&																			!!&!&(,,3,33333(G­¼ÃÌÕÐÐÌÌÊÃÃÃ¼¼										,Thox~¢¢¦¦¦©©­©©©­©¦¦¦¦©©­­­¦¢b&										!!!!!!&&((((,,,33333::<:::<<<::<<<<<<<GGGKKKNPTYYYTTTYY]b]]]]bbddhhooox~]3!T¶ÃÌÕÙÙÕÐÌÊÊÊÊÃ																						(Toovxx~¢¢¢¦¦©©­©¦¢¢¢¢¦¦¦©­©¦¢]&						&!&((,,3333:<<3<GGNKNKNPTY]bdhhoodhoo~¢¢¢¦¦¦¦¢¦¦¦¦¢¢¦©¦¢¢¦©­­­¦¦¢¢¢¢¢¢¢¢¦¦¢¢¢¦©©­¶¸¼Ã¼¼¸¸¸¼¸©o,(h©ÃÐÙÞÞÙÙÕÕÐÐÌÃ																																	(Pdoovx~¢¢¢¦¦©¦¢¢¢¢¢¢¢¢¦¦©¦¢¢h(						,Nbhv~¦¦©©¦¦­¶¸¸¼ÃÃÊÃÃÃÊÐçççÞÐÊÊÙçïïïççïòöööööøøøööòòççççÞÕÐÊÃÃ¸¶¶¼ÃÃÊÊÊÃÃÃÃÊÊÊÃÃÃ¸¸¼¸¸¸¶¶­­­±¸¸¸¸ÃÃÃÊÌÊÃÊÊÃÃÃ©h,,o±ÌÞÞÙÕÙÙÕÙÕÐÊ																					3Tdooox~¢¢¢¢¢¢¦¦¦¢¢¢¢¦¦¦¦¦¢¢v3							(T¦¶¸ÃÃÌÙàçïïööööööýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøøöòçàÐÊÃÃ¼ÃÊÊÊÊÊÌÐÕÕÕÌÃÃÃÊÐÐÊ¼¸±¶¼ÃÃ¸±±±¶¼ÃÊÊÊÌÌÌÌÌÊÊÊÊÃP&:ÃÕÞÞÙÙÙÙÕÐÕÌ!!&!!&!&&!&&&&&&(,,3333<<:<<<<CC:&										3Tdhovx~~¢¢¢¢¢¢¢¦¢¢¢¢¢¢¦¦©©¦K					:o¢¶ÃÊÐÕççöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïÞÕÐÌÊÊÃÊÊÌÌÐÕÕÐÕÕÐÌÌÊÊÊÃÃÃ¼¼¸¸¸¸¸¶¶¶¸¸ÃÃÊÌÌÌÊÊÌÌÌÊÊÃ¸N!<ÃÕÙÙÕÕÕÕÕÐÌYTPPT]YTPPYTTTTTTTTTTY]dhhovvooooooooN&									:Tdoovxx~¢¢¦¦¢¢¢¢¢¦©­©¦¢¢¢¢¢b(							&T­¼ÊÌÕàçöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïàÕÐÊÃÃÃÊÌÌÐÐÐÐÐÐÕÐÐÌÊÊÃÃ¼Ã¼¼¼¸¶¶¶¶¶¸¼Ã¼¼¼ÃÌÕÕÌÃÃÃÃÊÊÃ¶~<!K¼ÌÐÕÙÕÕÐÐÌoox~~xxxovoovoohdoooooov~~xvvxxxh:									!CYdhovxx~¢¢¢¢¢¦¦©­¢¢¢¢C			3d¶ÃÌÕÕàçòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýïççÞÕÊ¸¶¸ÃÐÙÙÌÊÃÊÌÙÙÐÌÃÃ¼ÃÃÃÃ¸¶¶¶¶¶¶¶¶¸¸¸¼ÃÃÌÌÌÌÊÊÊÃÃÃÃ¸±C!T¼ÊÐÕÐÕÕÐÐoo~~xxxvvvxxvovxxxxx~~xxvoxxoP!							3P]dhoox~¢¦©¦¢¢¢¢¢¢¢b(	&T©¸ÃÐÙàçïòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïàÕÌÃÃ¼ÃÃÊÌÌÌÌÌÐÐÕÐÐÊÃÃÃÃ¼Ã¼¸¸¸¶¶¶¶¶¶¶¸¸ÃÃÊÌÌÊÊÊÌÌÊÃÃÃÃ¼¶<!h­ÌÙÕÕÌÌÐÙxxxxx~xxxxxvvx~xxxx~xxvb3				!<P]doovxx~~¦¦¢¢¢¢T(!Gx¢¶¼ÃÐÙçïòöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýööòççÙÌÃÃ¼ÃÃÊÌÌÌÌÌÌÐÐÕÌÊÊÊÊÊÃ¸¶¶¶¸Ã¼¸±©­¶¸ÃÊÊÃÃÊÌÌÌÌÌÌÊÃÃÃÃÃ±o33x¶ÌÕÕÕÙÙÙ~~~~~~xxx~~~xxx~xvoT(				,KYdhhooox~~obYYdo~¢¢¢¦¦©¦¢Y3!Kv¶ÃÊÐÕàçòöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöïçÙÌÊÃ¼ÃÃÌÌÐÐÐÐÐÕÕÕÐÌÌÊÃÃ¼Ã¼Ã¼¸¸¶¶¶¶¸¸¼ÃÃÃÊÌÐÐÐÐÌÌÌÌÌÌÊÊÃÃ­d(<¸ÌÙÞÞÞÞ¦~~~~~~xxvohP,				,GP]bhovovxxx~x]G3!,Nhx¢¦¦¦¦¦xP3&!&(:Y~¶¼ÊÐÙàçïöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïçÞÕÊÃÃÃÊÐÐÐÐÐÐÐÕÙÙÕÐÊÊÌÃÃÃÃ¼Ã¼¼¸¶¸¸¼¼¼¼ÃÃÊÐÕÙÕÌÊÊÐÕÙÕÌÃ¼ÃÃ­d,<ÃÐÙÕÙÞ©¦¢¦¢~xx~vodP,(GN]bddhoovxx~x~~oP3<]o~¢¢¢©­­±­­­ohdx¦¶¼ÌÙàçïïööýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïàÕÌÃÃÌÐÕÐÕÕÙÙÙÙÙÙÕÐÐÌÐÐÌÃÃÃÃÃÃ¼¼¸¶¸¼ÃÊÊÌÌÌÐÕÙÙÕÐÕÐÐÐÌÊÊÊÌÌN!NÃÕÕÞÞ±©¦©¦¢¦¦¢~xohdTG3(!!(:GPY]bdhoooovxvxx~~~vP(			3dx¢¦¦­­¶¶¶¶¸¸¼¸¶­¶¸¼ÃÃÊÕÞçïòöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöçàÙÕÌÊÌÌÕÕÕÙÞÞÞÙÙÙÕÙÕÕÌÊÊÃÃÊÊÃÃÃ¸¸¸¼ÃÃÃÊÊÌÌÕÙÙÕÙÕÐÕÐÐÌÊÃÊÌÌÊG&T¸ÊÐÞ±­­±­©¦¢¦¦¦¦©¦¢¦¦¢~voddb]PPGGNPT]bb]dhoovvovoxx~~vvY3				<dx¢¦©±¸¸¼¼ÃÃÃÊÌÌÌÊÌÊÊÌÕÞàïòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýòàÙÕÌÊÊÌÕÕÕÕÞÞÞÙÙÙÙÙÕÐÐÌÊÃÃÃÃÃÃ¼¼¸¶¸¼ÃÃÊÊÌÌÐÕÐÕÐÕÕÐÌÊÊÊÃÃÃÌÌÃ:,o©ÃÌÌ±¶¶¶¶¶©¦©­­­¦¢¢¢¦¦©­­©©¦~vohdddbdbb]]b]ddooovoooovvvvxvhC				!No~¢¦­¸¸¼ÃÃÃÊÌÌÕÕÕÕÕÌÊÌÙàçïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöççÙÐÌÊÊÊÐÐÕÙÕÕÕÕÕÕÙÕÕÐÌÊÃÊÃÃÃ¼¸¼¸¶¸¸¸¸¸ÃÃÊÊÊÌÌÌÌÊÊÊÊÃÃÃÃ¼ÃÃÃÊ¸x3,o©¼Ã¼¸¸¸¼¼¸­¸¶±©¦¢¦¦¦¦©©­¶¶±­©¦¢¢~oooohhhhddddddhooooovooovvvooT(						3d~¢¦¦­±¸ÃÃÃÃÌÌÕÕÕÕÕÐÐÕÙÞççïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýòçÞÕÌÌÊÃÌÌÐÐÐÕÕÕÕÕÕÕÐÌÌÌÊÃÃÃ¼¼¸¼¸¶±±±¶¸¼ÃÃÃÃÊÊÊÌÊÊÃÃ¼¼Ã¼¼¸¼¼Ã¼Ã¦b(3x©¶Ã¼¸¸¸¼Ã±¦±¶­¦¦¦¦¢¢¢¢¦©±­¶¶¶¶¶­©¦¢¢xvooooohddhdhhoooooooooooooodC						Ko¦¦­­±¸ÃÊÊÌÌÐÕÕÐÕÕÕÕÙàçòöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòççàÞÐÊÃÃÃÊÌÐÕÕÕÕÐÐÕÕÐÌÊÃÃÃÃÃÃ¸¶¶¶¶¶±¶¶¶¶¸¸¼ÃÃÃÃÃÃÃÃÃ¸¶¸¸¸¸¸¸¸¼¼¼Y&:~¦¼¸¶¸¶¸¸¸±±¸±o¢¢¢¢¦¦¦­©­­©©¢~xxxvooohhddbdddbbhhhhdhhhb]b]C!								:bx¢©­¶¸¼ÃÃÃÊÕÙÕÕÕÕÕÞàçïïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöççÞÕÐÌÃÃÃÃÊÌÐÕÕÕÐÐÐÕÐÕÐÌÃ¼¼¸¼¸¸¶¶­±­­±±¸¸¼¼ÃÃÃÃÃ¼¼Ã¸¶¶¶¶¶¶¶¶¶¸¸¼¶N!G¶±©¦¢¢¢¢¢o:<d~~xxvoohhhd]Y]YPTYTNGKGGGGC::GGGC<C<:333,									,Yox~~¦¦­¶¸ÃÊÊÐÐÙÙÞÞÞÞÞççïöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøýýýøòçàÙÐÊÃÃÃÃÌÐÕÕÕÕÐÕÕÕÙÕÌÊÃÃ¼¸¼¸¶¶±­­­­­±¶¸¸¸¼¼Ã¼Ã¼¼¸¶­±±¶±­­­­¶¶¸¸­CNxood]TPPTTN3(!:CGGGG<<33::333(((((&!!!													(Nhox~¢¦­¶¸¼ÃÊÐÙÞÞÞÞÞÞàïïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòççÙÐÊÃÃÃÌÌÐÕÐÕÕÕÕÕÙÕÐÕÌÊÃ¼¼¸¸¸¸±©­­­±±¶¶¶¶¼¼Ã¼¸¸¸¶¶¶±±©­±­­­­±¶¶¸­x:(&!																								&Kdvvv~~¢¦­¶¸ÃÊÐÙÞààÞààççòýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïàÙÐÌÊÊÌÌÐÌÐÐÕÙÙÕÕÕÕÐÕÐÌÃÃ¼¸¶¶¶±±­­­©©­¶¸¸¼¼¼¸¸¸¶¶¶±­±­±­­­©­­±¶¶¶¦o3																																																!Gbooxxx¢©±¸ÃÌÕÙÞÞàààççöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïçÞÕÌÊÊÊÌÌÌÕÙÙÙÙÙÕÕÙÙÕÕÊÃ¼¸¸¶¶±­©©©©­­­±±¶¸¼¼¸¶¸¶¶±­­±­­­­©©­­¶¸¸¸¸¢d,																									,Ndovox~¦±¼ÃÌÐÕÕÞàçççïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïàÙÕÌÃÃÊÊÐÐÐÕÕÕÕÕÕÕÕÕÌÊÃ¼¸¶¶­­©©¦¦¦¦¦¦©©­­¶¶¶±±±­­©¦©­©©¦¦©­±±¶¶¸¼Ã¸N&!!&&&&(,3,,,,33::<<<<<CGGC<<<CC<(												,N]hoox~¢©±¼ÃÌÐÕÕÞÞàççöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýïÞÐÊÃÃÃÃÃÊÊÊÌÌÐÐÕÐÐÌÌÊÃ¼¸¶­­¦¢¢¢¦­­±±­©­­­©¢¢¦©©­©­­±¶¸¸Ã¼ÃÃÃT&33333,(,33:<3333&(3CC<C<<KNYbYGKYY]]bhooovv~~xoooox~xvY,							<Yoovvx~©±¸ÃÃÊÌÐÐÕÙÞççöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøööòöøýýýýýýýýýýýýýýýýýýýýøöçàÕÌÃÃ¸¸¸¸ÃÃÃÊÊÊÊÊÌÊÃÃÃÃ¸±©¦¢¢¦¦¦©­©­­­©©¦¦¦¦©­±­±¶¸¼ÃÊÊÌÐÌÃCxvoxv~xvox~vo~©¢¦¢¢¦¦©­¶¸¶¶±­¦¢¦¢¢¦©­¶¸ÃÃ¸±­¦¢¢~T!					!Gboovx~¦­¶¼ÃÃÃÊÊÌÌÌÐÙççøøøöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöòççÞÞàçççïïòöööøýýýýýýöòöòòòòçàÕÃÃ¸¶¸¸¸¸¸¸Ã¼ÃÃÊÊÃÃÃ¸¸¶­©¢¢¦©­­­±­­©­©­©­­±¶¸¼ÃÃÊÊÐÕÙÞÞÊ±¶±±©­©¦­¼Ã¼¼¸±©¦¢¢¢©¶Ã¼Ã¼¶­±¶¸¼¼¼¼Ã¼ÃÃ¸¸¸­©¦¢¦©©­­¶¸¼Ã¼¶±­©¦h3			3Yox~~¢©±¸¼ÃÃÃÃ¼ÃÃÌÐÞççççççòýýýýýýýýýýýýýýýýýýýýýýýýýøòïçàÕÊ¸¸ÃÌÕÙààççïçòýýýøööòçïïïïçàÐÊÃ¼¶­­±±¶¸¸¼Ã¼¼¼¼¼¸¸¸±±©¢¢¢¦©­­­©­±±±­­­¶¸¸¸ÃÃÊÌÕÙÞÞààççÌÃÃ¸¸Ã¼ÃÃÃÃÃÃÃ¼¼¶­¦¦¦¦¦¢¢±¸ÃÃÃÃ¼¼¶¶¸¸¼ÃÃÃ¼¸¶±¶¶±©¢¢¢¢¦©±¶¸¼Ã¼¼¶­­¦](			&Nh~¢¦©­¸ÃÃÊÃ¼¼¼ÃÃÌÐÕÙàÞÞççïöýýýýýýýýýýýýýýýýýýýýøöòïççÕÃ~hh±ÃÊÌÕÞàçïïöööòïïïççççàÙÕÊ¸¶©©©­­±­±¶¶¸¸¸¸¸¸¶¶­­©¢¢¦©­­±¸¶¶¶¶¶¶¶¸¼ÃÃÊÊÐÙàçççïïöøöÃÃÃÃÃÃÃÃÊÌÊÊÃÃ¸¶­©©©©­­¶¸¼ÃÃÃÃ¼¼¼¸¸¼¼Ã¼¼¶¸¼¶­±­©¦¢¢¢¢©±¶¼ÃÊÃ¼¶­­©©¦¢¢~K!	:b~¢©­¶¸ÃÊÊÊÃÃ¼ÃÃÌÐÐÕÕÕÙÞççïöøýýýýýýýýýýýýýýýýöòïçççÞÐ¦b<&&<h±ÃÌÕÞàççïòòïïïçççààÞÕÊÃ¸±©¦¦¦©©­­­±¶¸¸¶¶­­­­©¦¢¦­­¶¶¸¸¸¸¸¼¼¼¼ÃÃÌÕÙàççïòøøýýýýÊÃÃ¼¼ÃÊÌÊÊÊÃÃ¼¸¶­©¦©©­­¸ÃÃ¼ÃÃÃ¼¸¼¸¸¼¼ÃÃ¼±­¸¶±¶­¦¢¢¦©±¶¸¼ÃÃÊÃ¸¶±­©¦¢¦¦¢oC3Yx¢¢¢¢¦¦¦©±¸ÃÌÐÐÐÌÊÃÃÃÌÐÐÕÐÕÕÞàççòöøýýýööööòööøýøöïççççàÞÌN&G~©ÃÊÕÞàçïçïçççççàààÕÐÊ¼¶©¦¢¢¢¢¢¦©©­­±­±­©­©©¦¦¢¢¢¦­¶¶¸¸¼¼ÃÃÃÃÃÃÃÌÕÞàççïöýýýýýýýÊÃÃÃÃÃÌÌÐÌÊÊÊÊÃ¸­¦¦©­±¼¼ÃÃÃ¼ÃÊÃÃÃ¼¼¸¼ÃÃ¼¦¦¶¶¶±­©©©©­±¸ÃÊÌÌÊÃ¼¶¶¶±©­±­­¦xG(!3Tv¢¦¦¦¦¦¦©©¦©©©­­¶¼ÃÊÕÙÞàÙÕÌÊÊÌÕÕÕÐÕÐÕÞççïöøøööòòòïïïïïïïçàçàÞÞÙÐ¢P(	<x©ÃÌÕàçççïççççààÙÕÕÌÃ¸¶­¦¢¦¦­©­­­©©­©¦¦¢¢¢¢¦­­¶¶¼¼ÃÃÃÃ¼¼ÃÃÌÕÙÞàçïòøýýýýýýýÊÊÊÃÊÊÊÌÐÐÐÌÊÃÃ¶±©­±±¶¸ÃÃÌÕÌÃÃÃÃ¸¼ÃÃÃÃÃÃ©¸¼¸±±­±¶¶±¶¼ÃÌÐÐÌÊÃ¼¸¸±±±¶¸¶­©bG3(((3Ndx¢¦­­­­­­±­±­±±¶¸¼ÃÊÐÞççïàÞÕÐÌÌÕÙÙÙÕÕÙÞççòööööòïïïçççççççààÙÙÙÙÐ±b(K¸ÊÕÞàççççààÞÙÐÕÕÐÊÃ¶©¦¢¦©©©­©¦¦©¦¦¦¦¢¢¦­¶¸¸¸¼ÃÃÃÃÃÃÃÃÃÌÕÞàççïòöýýýýýýÌÊÃÃÊÊÌÙÕÐÌÌÌÌÃ¼¶¶­±¶¶¼ÃÌÌÕÙÐÃ¼ÃÃÃÃÃÊÌÌÊÃ¸±¸ÊÊÃ¸¸¶¶¶¸¸ÃÊÌÕÕÐÐÊÃÃ¼¸¸¸¸¸¸¶±©¢xd]bdv¢¦©¶¶¸¸¶±±±¶¶¸¸¼¼ÃÊÐÙàçïòïçÞÙÕÙÞÞÞÞÞÞÞÞàçïöööòïïïççççççççÞÙÕÐÕÕÌ:	!]¢ÃÐÐÙÞÞÞÙÕÕÕÕÐÌÌÊÃ¸¶©¢¢¢¢¦¦©©¦¦¦¦¢¢¦¢¢¢¢¦­¶¶¶¸¸¼ÃÃ¼ÃÃ¼ÃÃÊÐÙÞçççòöýýýýýýÊÊÊÊÊÊÌÕÐÌÐÕÐÐÌ¼¸±±¶¸¸ÃÃÊÐÕÙÙÌ¼¼ÃÃÃÃÊÊÐÐÐÌÃÃÃÊÃ¸¸¶¶¸¸¸ÃÌÕÕÕÕÐÌÃÃÃ¸¶¸¼¼Ã¼¶­­¦¢¢©­¶¶¸¼¶¶¶¶¶¸¼ÃÃÃÊÌÐÙàçòöøòççààÞàààçààààçïïöýýøòïççççàçççÞÕÕÐÐÌÌ©P:­¼ÊÌÌÐÐÊÃÃÃÃÃÃ¼¼¸±©¢¢¦¦¦¢¢¢¢¢¢¢¢¢¦©­­­­¶¼¼¶¶¶¶¼ÃÃÌÕÕÞààòöøýýýýýýÊÃÃÃÊÊÌÐÐÐÐÐÕÕÌÃ¸¶­¶¸¼ÃÊÌÐÕÕÕÐÌÃÃÃÃÃÊÌÐÐÌÐÊÃÃÃÃ¼¼¸¶¸¸¼¼ÊÌÕÞÕÐÊÃÃÃÃ¸¸¼¸¼¸¶¶±©¦¦¢¦­±¸Ã¼¸±¶¶¸¼¸¼ÃÊÌÕÙÞççòøýøöççàçïçïïïïççïïöøýýøòïçççççççàÞÙÕÐÌÌ¼:T©±¶¸¸¸¼¸¶¶±­­±±­¦xxxvxxxxxx~~xoxxxxvoo~©¸ÃÃÌÐÞççïòöýýýýýýÊÃÃÃÃÊÌÕÕÌÌÌÌÌÊ¼¸¶¶¶¶¶¼ÃÌÕÕÕÐÌÐÃ¶­¶¼ÃÊÊÌÌÌÌÊ¼¼Ã¼¸¶±¶¸¼ÃÊÌÐÐÕÌÊÃÃ¼¸¶¶¶¸¸¶¶¶±­­¦¢¢¢¦©­±¶¸¼Ã¸¸¸¸¶¸¼ÃÊÐÙÞÞçïöýýýýøòòïòöýøøöòöööøýýýýýøöïïçççççàÞÙÐÌÃÃ¦T&!	3d~xoohdbYTTTPTPTPPPPNKNPNKGGC<<<<:333,((((((&!!!!G~©¼ÃÐÕÞàïòöøýýýýýýÊÊÃÃÃÃÃÊÌÌÌÌÊÊÃ¸¶­±¶¶¶¸ÃÃÐÐÕÐÊÃ¼­­¸ÃÃÃÃÊÐÌÌÃ¼¸¶±­­¶¶¸¼ÃÊÌÐÌÊÃ¼Ã¼¸¸¶¶¼¸¸¶¶±¶±©¦¢¦¦©­±¶¸ÃÃÃÃ¸¸¸¸¼ÃÊÌÐÙàçïòøýýýýýýøöýýýýýýýýýýýýýýýýýøöòòïïçïççÞÕÐÃÃ¦T!!&3::::333,,,((&!!!!3x¦ÃÌÕÞççòöýýýýýýýÊÃÃÃÃÃÃÊÊÊÊÊÊÃÃ¸±­­­­¶¸¼ÃÊÐÐÕÌÊÃ¶¢¢±¼ÃÊ¼ÃÊÊÊ¼¸¸¶­­­±¶¶¼ÃÃÊÌÌÊÃÃ¼¸¸¸¸¸¼¼¼¸¸¸¶¶­­¦¦¦©±±¶¸¸ÃÃÊÌÊÃ¼¸¸ÃÃÌÐÞàççòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöööòïòççÙÐÃ¼K!									G¶ÌÞççòöøýýýýýýýÌÃÃ¼Ã¼ÃÊÊÊÊÊÃÃÃ¶±­­­­±¶ÃÃÊÌÌÌÊÊÃ¸±¦¦¶ÃÃ¸¸ÃÊÃ¶­¶¶±­­­©­¸ÃÃÊÌÌÃÃÃÃÃ¼¸¸¸¼¼ÃÃÃÃ¸¶¶±±±­±­¶¸ÃÊÌÕÐÌÊÃÃÃÃÃÊÐÙàçòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöòïàÙÐÃG!				!]¢ÃÕÞçòøýýýýýýýýÊÃ¼ÃÃÃÃÊÊÊÊÊÊÃÃ±©­©­±­¶¸ÃÊÌÐÌÃÃÃÃ¼¶©¶¼Ã¸¸ÃÃÃ¶­­±­­­©¦©¶¸ÃÌÐÕÌÊÃÃÃ¼¼ÃÃÃÃÃÃÃÃÃ¼Ã¶¶¶±¸¼¼ÃÊÌÕÕÙÕÐÊÃÃÊÊÌÙÞàïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöçÙÐÊ¢P!		!!!!!!!&&(,((((,33:3:33CCGNPPTTTC&3o­ÐàçòòýýýýýýýýÊÊÃÃ¼ÃÃÊÌÌÊÊÊÃ¼¸¶±­±­­¶¼ÃÌÐÕÐÌÊÃÃÃÃ¼¸¶¸Ã¼ÃÌÌ¸±¶¶¶±±­­­¶ÃÊÕÕÕÐÌÃÃÃÃ¼Ã¼ÃÊÊÊÌÌÌÊÃ¼¶¶¼ÃÃÃÊÌÌÕÞàÞÕÐÊÊÌÌÕÞàçïýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïàÙÌ¦P!			&(,333333:::<3:3:3:33:3:<CGGNPYYbdddhhhohhovx~xvvxx¢¦­±±±±¶d3<ÃÙççïòøýýýýýýÊÃÃÃÃÊÌÌÌÌÊÊÊÊÃÃ¸­­­±±¸ÃÃÊÐÕÕÐÐÊÊÃÃÃÃ¸¸¼ÃÃÊÌÃ¸¼¶¶­±¶¶¶¼ÊÌÕÕÕÐÌÃÊÃÃÃ¸ÃÊÌÐÌÐÐÌÌÊÃÃ¼ÃÃÃÊÌÕÞàààÞÙÐÐÌÐÕÙÙàçöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöçÞÕ¼o(			!GYdhoo~~~xxooooxx~~¢¦¦¦¦­©­­­­±±¶±­­¦¦­¶¸¼Ã¼ÃÐÕÙÙÙÕÕÙÕ¸h,KÃÕÞççöýýýýýýÊÃÃÃÃÃÊÌÌÌÌÊÃÊÊÃ¶±­­­¶¸¼ÃÌÕÙÕÕÐÌÊÊÊÃÃÃÃ¶¶ÃÊÊÃÃ¼¸±­­¦¦©±¸ÊÕÕÕÐÃ¼¼Ã¼¼ÃÊÌÐÕÐÐÐÕÐÌÊÃÃÃÃÊÌÌÕÙàçàÞÙÕÐÐÕÕÙÞçïòýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøçàÞÊx,			Co¦¦©©©©­­±±­­©¢¦¦­±¶¶¶¶¸¸¸¼¸¼¼¼¸¸¸¶¶±¶±¶¸ÃÊÌÕÕÙÞàààçàÞÌK&!YÊÙàçïòöøýýýÊÊÊÊÊÃÌÌÐÕÐÌÌÊÃ¼¶­­±±­¶¸ÃÌÙààÞÕÌÌÊÃÌÌÌÌ¼¸±¸ÃÊÃ¼¼¶­¢©±¼ÊÊÃÃÃ¼¸¸¼¼¼ÃÌÐÐÐÐÐÐÌÌÊÃ¼¸ÃÃÌÐÙÞÞÞÞÙÕÕÌÌÌÌÕÙàçïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïçÞ­P!			Gv¢©­¶¶±¶¶¶¸¼¸¸¶­­¢¦©­±­±±¶¸¼¼¼¸¼¼ÃÃÃÃ¼¸¶¶¶¶¸¼ÃÌÕÕÙÞÞàààçççÞÊK&&]¢ÃÙàçïïöøýýÃÃÊÊÃÃÊÌÌÐÌÌÊÊÃ¸±­­©©©­¸ÊÐÙÞÞÕÕÐÌÊÊÃÊÃÃÃ¸­©¼Ã¼¼¸¶­©¢¢©¶¼ÃÌÌÃ¼Ã¼¶¶¼¼ÃÃÊÌÐÐÌÌÊÊÊÃÃ¸¸¼ÃÊÌÐÐÕÞÙÕÕÌÌÌÌÌÕÕÞççöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýòïàÃv3		<o¦±¸¼ÃÃ¼¼¸¼Ã¼Ã¼¸­¢¢¦­­±¶¶¶¸¸¸¼¼ÃÃÃ¼¼¼¼¼¸¸¶¶¼¼ÊÐÙÙÞààçççïïçàÕ¼x:!3v±ÌàççïöýýýÃÃÊÃÃÃÃÌÐÕÐÊÃÃÃÃ¶¦©¼ÌÕÐÙÙÕÐÌÊÃÃÃÃ¼¼¼±©­±±±¶±­¦¢¢©±¸ÃÊÌÃ¼¼¼¶­¶¸¸ÃÃÊÌÐÐÐÊÃÃÃ¸Ã¼Ã¼ÃÊÌÕÙÙÕÕÐÌÌÌÐÌÐÐÙçïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöçÞ±],K~©­¸ÃÃÊÊÊÃÊÊÊÃÃÃ¼¶­¢~¢¦©­±¶¸¸¸¸¼¼¼ÃÃÃÃÃ¼ÃÃ¼Ã¸¸¸ÃÊÐÙÞààààïïòöïçàÙ¼~<!3o¶ÐàçïöýýýÃÃÃ¼ÃÃÃÃÊÌÊÊÊÃÃ¼­±ÃÕÕÙÕÐÕÌÊÃÃÃÃ¶¸¼¶­¦¢¦­¶­¢¦¦¦­¸¶©¦¢©¶¼ÊÌÌÐÐÌÊÃÃÃ¼¼¼¼ÃÃÃÐÐÕÙÞÕÕÐÌÌÐÌÕÕÞççöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòçÐCCx­±¸¼ÊÐÕÕÐÌÌÌÊÊÊÃ¼¶¦x]PT]o~¦­±±±¶¸¸¼Ã¼ÃÃ¼Ã¼ÃÊÃÃÃ¼¼¸¼ÃÃÌÕÙÞçççïòööööïçàÕ­d(GÃÙççöýýýÊÃÃÃ¸¸ÃÌÕÕÌÃ¸ÃÃÃ¸¢¢±ÊÕÕÕÕÐÌÊÊÃÃ¼±¶¼¼¶±©¦©­­¢x~~©±±­¦¢¦¶¼ÊÊÐÕÕÐÌÃÃÃ¼¼ÃÃÃÃÊÌÕÙÞÞÞÕÐÌÐÐÐÐÕÞàïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïàÊC!3h©¶¸¼ÊÐÕÞàÙÕÕÐÕÐÌÌÃ¸Y3!!3Po¦­±¶¸¸¸¼¼ÃÃÃÃÃÃÊÊÌÌÃÃ¼¼¸¼ÃÐÙÞààççïööøýøïççàÙ­],G¸ÕçòøýýÃ¼ÃÃÃÃÃÊÊÊÊÃÃÃÃ¼¶¢¦­­±ÃÌÕÕÕÙÌÊÃÃÃ¼¶¶ÃÃ¸¶¸­±±­¦¢¢¢¦¶¼¶­­©­¸ÃÌÐÕÕÕÌÌÌÊÃÃ¼ÃÃÃÊÌÊÊÐààÞÞÙÕÌÌÐÐÞçïöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöçÞÃG&!Co¦±¸ÃÊÐÕÞàààÞÞÙÕÕÐÊ¼K!!Go©­¶¶¸¸¼¼¼ÃÃÃÊÃÊÊÊÊÃÃ¼¸¼¼ÃÌÕÞàçççïöýýýøöççàÙÌK&!KÃàòýýýÊÃÃÃ¸¼ÃÌÐÌÌÊÃÃÃ¼¶©¦±¸¸ÃÊÐÞàÞÕÌÃÃÃÌÃ±¢¦¸ÃÃÊ¼­¦¦¦¦¦¢©¸ÃÃÌÌÃ¼¸­©­¶¸¼ÃÌÐÕÕÙÐÐÐÌÌÊÃÃÃÊÌÐÌÊÕààÞÞÙÕÕÕÕÕÞàçòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïçÞÃdC3(3<Tv¦­¶¼ÃÌÐÙÞÞàààÞÙÕÐÌÊN!	Go¢©©±¶¸¸¼Ã¼ÃÃÃÃÊÊÊÊÃ¼Ã¸¼ÃÃÌÕÞÞàççïïööøöòïààÞÕÊG!!Y¢ÌàïøýÃÌÌÌÃÃÃÃÊÌÌÊÃÃÃ¼¸­¦¢¢¦¶¸ÃÌÕÞÞÞÕÕÐÌÌÊÊ¼ÃÊÃÃ¼¶©¢¦¦¦¦­¸ÊÐÞÞÐ¸±©¦©¶¼¼ÊÌÐÕÙÙÕÕÐÌÌÃÃÊÌÌÌÐÕÞàççÞÙÕÕÕÙÙÞààïøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýïçàÕÊ­xoox©±¶¸ÃÃÌÕÞÞÞÞÙÞÞÕÕÌÊ­b!			&Kv©­±¶¶¶¶¸¼¼ÃÃÃÃÃ¼¼¼¸¸¼¼¼ÃÌÕÞààçççòöööïçàÞÞÞÕÃ~<!(d­ÐàïøÌÌÃÃÃÃÌÐÐÌÐÊÊÊÊÃ¸±¦¦©­¸¼¼ÊÕÞààÙÕÐÌÌÊÊÃ­xÃÐÕÊ¼¶­¢¢©©¦­¸ÊÙçàÌÃ¸¸¸ÃÊÊÊÊÌÕÕÕÕÐÐÐÐÐÊÃÃÊÌÕÞàçàààààÞÙÕÕÙÞçïòýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïçàÙÌÃ¶©¢¢¢¦©±¸¼¼ÃÊÌÐÙÞÞÞÞÙÐÐÌÊ¼3				3b¦©©±¶¶¶¶¸¼Ã¼Ã¼¼¸¼¸¼¸¸¼ÃÌÌÕÞàççççïòòïïçàÞÞÙÐ¼<!,o±ÕçïÌÌÃÃÃÃÃÐÕÐÊÃ¼ÃÃÊÃ¶¦¢¢©¶ÃÐÕÙÕÙÕÙÙÕÕÌÃÊ¼¢ÃÐÊ¸¶¸¶­¢©±¸ÊÌÌÕÕÌÊÃ¼¼ÃÃÊÌÐÐÌÐÌÐÐÕÐÌÃÃÃÃÊÐÕÞààçàÞÞÕÕÕÕÕÙàçïýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïïàÙÌÃ¸¶±©©­­¶¸ÃÃÃÊÌÕÕÙÞÞÞÙÕÌÃÃ©T!				!Co¢¦©©­­­¶¸¼¼¸¶¶¶¶¶¶¶¸¸ÃÃÊÐÙàààçççïïïççààÞÞÙÕ¸x:!3v¶ÕçÌÊÃÃÃÃÃÊÊÊÊÊÊÃÃ¸¶­­©¦¦­¸ÃÌÕÕÕÐÐÐÕÐÌÃÃ±vv¢ÃÌ¸¦­©±±©±¼ÌÕÕÌÃÃÃ¼ÃÃ¸¸¼ÃÌÕÕÐÊÃÊÊÊÌÊÃÃÃÃÊÕÕÞÞààÙÕÐÕÌÐÕÙàççööýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýïçàÙÕÊÃ¸­­­­¶¸ÃÃÊÊÌÐÕÙÞàÙÐÐÌÌÃ¸3				3Y~¢¦¦©©­­±¸¸¶­­©©­­±­±¶¸¼ÃÊÐÐÕÐÌÐÕÕÕÞÞàÞÞààçÞ¸o3<¼ÞÃÃÃ¼¼ÃÃ¼ÃÃÃ¼ÃÃ¼¶±­©¦¢¢­¶¸ÃÌÌÌÕÐÌÃ¼¼ÃÌÃ¦¸ÊÊÃ¸±©©¦¦¼ÃÐÕÐÃ¼Ã¸¼¼¸¸¶ÃÃÌÐÌÌÃÃÃÃÃÃ¼¸¼ÃÃÊÐÙÙÞÞÕÕÌÌÌÌÐÕÙççïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýïïççÞÕÃ¼¶±±­­­±¸¼ÃÊÊÌÌÌÕÐÕÌÊÃ¸¶T!				!Cbox~~~xvoooovx~x~xxxxoooov¶ÐÞàçççàÕ­],KÊÃÃ¼¼¼¸¸¼ÃÃÃÃ¼Ã¼¸±©¦¦¢¦­±¸ÃÌÊÃÊÃ©­ÃÃÃÃÃ¸ÃÌÐÐÊÃ±¢¦¦¢¶ÃÌÌÊÃ¼Ã¸¸¶¶¸¼ÃÃÃÌÌÌÃÃ¼¸¼¸¼¼ÃÃÌÊÊÐÕÞÞÙÌÊÃÃÊÐÙààççïøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýööòòïççÞÕÌÊÊÃ¸©¦~~oT,			!,3333333,((,(,((&!!(]¢ÌàççïççÕP(!P¼¸¸¸¸¼¸¸¸¸¼Ã¼¼¸±©¦¢¢¦­±¶¸ÃÃÃÃ¼¦¦¸¼ÃÃÃ¸¸ÃÌÊÃÃ¶¦¦¦¢±ÃÊÃ¸¶¶¼Ã¼¶¶±¶¼ÃÃÃÃ¼¸±±±¶¶¶¶¸¶¸ÃÃÊÃ¼¶±©¦¢¢©±¼¼¼ÃÃÊÌÌÕÞààÕÐÐÐÊÌÌÊÊÃÃ¶¶¼¸ÃÃÃ¸±±±©¦~xohdbb]TPNG<333333333,((((((!!							!d­ÕàïçïçÞÊC!(h¶­©­©­±¶¶¶±±¶¶¶­©¢¦¦¦©±­©±¶¸¼¸Ã¼Ã±¦¦¸ÊÊ¼¸­¢¢¢¢©¢x¢¶ÃÃÃ¼¸¸±~~~~vxvoo~~~x~odb]YPPPTYYY]]bTTPTbdd]PKC<GGGG<33,33:33((&!!!						&,((h±ÐàçïïçÞÃx33~oovoxxvohhd]v¢­¶¶¶¶¼¼±¦©©­±­¦¦¦¢¦~xx¢¶¼¸¶­T::<<:3,&!(333&&&(&						(CN:!!!&!&!3~¸ÙçççàÙÌ©],KGCGCCCGG<<CCGC:33,,33,&!!G©¶¶¶¸¼Ã¸¦­­­¦¢¢¦©­xvx­Ã¼©¢G!							:TT<33,3,33::<CC<<<CGKKKKKPTPYbhoovxxT(C¼ÙààçÞÙÌP(			G±¸¸¸¸¼Ã¼ooooo¦­­©©©©©±±©¦¢Y(				!&!&!!&((,,,333,33333333333:<<333KPT]]]Y]bhdbbK(		&<PT]doxx~¢¦¦­¶¸ÃÊÌÕÙÞÙÕ¢Y,!PÃàààÙÐÌ¼G!								<­¼¼¼¼¶¸©ohodYh¦­­¦©©­­¶¼¶¢xx:!!!(((,33::<<<:<CCGKKNPTTTY]]doovxovx~¦¢¢¢~x¢©¶¼ÃÃÃ¼¼¼Ã¸¶b(				!3Nb~¢¢¦©©±±¶¸¸¼¶±¶¶¶¶¶¶¶¼ÃÌÕÕÞàççïïòòòà¢N!(]¢ÌÞÙÙÙÕÐ¸x<						G±Ã¼¸¶¶¶©xvxoPNo¦¢¢©¶¸¼Ã¸¦K,,,3,((,,3333333CKGKNNNNNPNKGPbddho~¢­¶¶­¢­ÃÊÊÃÃÃÃÌÕàçàçàçòòïïïçøýööýýýøøööòòçàÙÕÌÃÃÃÊÌÌÕÐÕÕÞàçòòïïïçàÙÐÊK!&:Tv¦¦©©±¸¸¼Ã¼Ã¼Ã¼Ã¼¼¸¸¸¸¼ÊÐÙàààçïòöøýøöÕ<!(d­ÐÞÞÙÕÌÊ©h,(<o¢¶¶±±¶¶¶]Nd¦©©©¶¼Ã­¦hdovxvox~xx~~x~¦©¦¦¢¢¢©¶¼ÃÊÕàçïòöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöçàÞÙÙÕÙÞÞààïöøøöòòøýýöçÙÌ¶d3!	&3Y©©­±¶¶¸¼ÃÃÃÃÃÃÃÃÃÃ¼Ã¼ÃÃÊÐÞàçççïïöýýýýöÕC!,o¶ÐÞÞÕÐÌÃ©h<CGGKGKPPPYPPPNKK<,,,3CPPNPTYh¢±¶¶­­­©¢¦­hTvxo­­¦©©©¢©¶¸¸¶¸¸±±±±¶±±¼ÃÌÐÕÙÐÐÌÊÊÊÃÃÌÐÙçïøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøøöïçàÙÙààçïçïöýýýýýøýøööçÞÌC!,Go©­±±¶¶¼ÃÃÃÊÊÊÊÊÌÌÃÃÃ¼¸¼ÌÕÞàççïòøýýýýýýöÐ<!:~¼ÐÙÕÐÌÌÃ¦¦¦¦¦~]dv~¢¢©­±¶¶¸±¦¶Ã¶x©¢xo~hYbxxx~¢¦¦­±¸¼ÃÌÐÐÌÌÌÊÃÃ¼¼¼¸ÃÐÕÙàààÞÙÕÕÕÕÙÙÙàïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöççççààççïööøýýýýýýýýýòççÞ¸o3(Y¢©©¦©±¸ÃÊÃ¼ÃÃÊÌÐÐÐÌÃÃÃÃÃÊÐÕÞççïòöýýýýýýýýöÊo3G¼ÐÕÌÌÐÕÐ±­­­­±¼¼ÃÃ¼¼ÃÃ¼¸©v~¢©­±¶¸¼¸¦¦±¶­¦¦±©¦±¸Ã¼¦¦­~oTNTbv¦¸ÃÌÐÕÙÕÙÐÕÐÊÃ¼ÃÃÊÌÐÕÞçççàÞÙÕÙÕÕÙÞçòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýòçààçòöööòòýýýýýýýýýýøöçÞÐ¦b3(Ko©­¶¸¶¶¶¸ÃÃÊÊÊÌÐÐÐÌÊÃÃÃÃÊÐÕààïòöýýýýýýýýýöï¼h3K¼ÊÌÊÊÐÕ¸¸¸¶¶¸ÃÃÃÃÃÊÃÃÃÃ¶¦±¸¼¼ÃÊÃ¸±¸Ã¸­©¶©¦¶±¶¸­¦¦¢~~~ooohx±¸©¢¶ÃÕÙÙÞÞÕÙÕÐÌÃÃÃÊÌÌÕÞàçïççààÙÙÙÙÞàçöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýòççççïòööøýýýýýýýýýýýòçççÞÌ¢d3&!,No¦±±¶¶¶¶¸¼¼ÃÃÌÐÐÊÃÃÃÌÌÊÃ¼¸¼Ðàïööïòöýýýýýýöïïç¶],&T¶ÃÃÊÌÕ¸¼¸±¸¼ÃÊÌÌÊÊÊÃÃ¼¸¦¦±¸¼ÊÌÕÕÌÊÊÌÊÃÃÃÃ¸­©­©±±©¢¢xox©­©¶ÊÐÐÃ¼©©¸ÃÕÞÞÞÕÕÕÐÐÌÃÃÊÌÌÌÕÞçïòòççàààÞÞààïòýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýòïçççççïöøýýýýýýýýýýýïçÙÞààÕ¶P333GTh~©¶¸¸±¶¶¸¼ÃÃÃÊÊÊÌÌÌÊÃÃ¼¼ÃÃÊÐÕÞàçòööøýýýýýýöïïà¢P&&T¶ÃÃÃÊ¼Ã¸¸¼ÃÃÃÌÌÊÊÊÊÊÃ¸¢¦­­¸ÃÌÕÙÙÕÕÐÌÌÌÌÌÐÕÌÊÃ±±ÃÃ¼¶¦v~¦­¼ÊÌÃÃÐÙÙÕÕÌÃÃÌÐÙÞÞÙÙÕÕÙÕÌÊÃÃÌÐÕÙààçïïïçàààÞÙÞàöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïçççàçïïòöøýýýýýýýýýöïçààÞÕÐÊ¶¢~x~©©­±¶¶¸¸¸¸¸ÃÃÃÃÃÊÃÊÊÊÃÃ¼¸¼¼ÃÃÐÙÞççïïöýýýýøöøýýöçÃx:!!!3]­¼ÊÕ¼¼¸¸¸¼ÃÊÌÊÊÊÊÌÊÃ¶¢¢¢¦­¶¼ÃÐÕÙÙÕÕÕÐÌÊÌÌÕÙÞÞÊ­¸ÊÌÃ¶¢©¶ÃÌÙÙÞààÞÕÐÕÐÊÊÌÐÕÕÙÙÐÕÌÌÌÊÃÃÊÊÌÐÞçççïààÞÞÞÙÕÙÞçöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïçààààççïïöøýýýýýýýýöòïçààÞÙÌÊÃ¸±­­©­­­¶Ã¼¸¶±±¸ÃÊÊ¼¸¸ÃÊÐÕÐÃ¸¸¸¼ÃÃÃÃÊÐÞçççïçòøýýýøööööòïÊx:(b­ÃÌ¸¸¸¸¼Ã¼ÃÃÃÃÃÌÌÃ¸±©¢©©©­¶¼ÃÃÊÐÕÐÐÌÊÊÊÌÌÕÕÙÙÌ¶¶ÊÊÃ¸­¢¢©­¸ÃÊÌÕÞàÞÐÐÌÌÊÊÊÊÌÕÌÐÕÐÌÌÃÃÃÃÃÊÊÊÌÐÞàçççàÞÕÙÕÙÞÞçòöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöçàÞÞààçççïïööýýýýýýøöòïççààÞÕÐÊÃ¼¸¸¸¸¸¶¸¼¼Ã¼¼ÃÃ¼¼ÃÃÃÃÊÊÌÌÊÊÃÃ¸¼¼¼ÃÃÌÕÞàççïïïöøýýøööòòöòç¸o33v©¼Ê­±±±¶¶¸¼ÃÃÃÊÃÃ¼¸±±¦¦¦¦©±¸¼ÃÃÃÃÃÊÊÃÃÃÃÌÌÕÐÕÕ¼¶ÃÃ¼¶±©©­­¶¸ÃÃÌÕÙÙÕÌÌÊÃÃÃÃÌÃ¼ÌÌÌÌÃÃÃÃÃÃÃÃÊÌÐÕÞÞçÞÞÙÙÕÙÕÙÕàçöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïçÞÙÙÞàççïïòöýýýýýýöòòïççççàÞÙÕÌÌÊÃÃÃ¼Ã¼ÃÃÃÃÃ¼¼ÃÃÃÊÃÃÊÊÌÌÊÃÃ¼ÃÃ¼¸¶¸ÃÕààààÞÞçïøýøòïïòøøøòç¶b33o¦Ã¦©­©­¶¶¸¼¼ÊÊÃ¸¸¶±©¦¦¦¦©±¶¸¼ÃÃÊÃÃÃÃÃÃÃÃÐÕÕÐÌÃÃÃÊÃ¶©©©­­¶¸Ã¼ÃÌÕÙÐÐÃ¼ÃÃÃÌÌÌ¼ÃÌÌÌÌÃ¼Ã¼ÃÃÊÊÊÌÙÞàçàÞÕÙÙÙÙÙÐÞïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòçàààÞÙÞàççïïöøýýýýøòòïççàÞàççàÙÕÊÃÃÃÃÃÃÃÃ¼¼¼¼ÃÃÃ¼¼¼Ã¼ÃÃÃ¸¸¸¶¶±­©¦¦©­¶¼ÃÃÃÃÃÃ¼ÃÃÃÌÕçïòïöòïÞ¦T(K¸¢¦©­©­±¸¼ÃÃÃÃ¼¼¸¶±¦¦¢¢¦©±¸ÃÃÃÃÃÃÊÊÃÃÃÃÌÌÐÕÕÐÌÌÊÃ¶­¦¦¦©­¸ÃÃÌÌÕÕÌÊÃÃÃÃÊÊÊÌÌÐÌÊÃÃÃÃÃÃÃ¼ÃÊÌÕÙààçàÞÙÕÙÙÕÙÕÞçòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïçàÙÕÌÌÌÐÕÞÞÞÞÞççïòçàÞÕÐÌÌÌÌÊÃÃ¼¼¸±­©¢¢¢¢~xxxoohbYYYTY]]]YYTPPKKKKY¸Þççççïïà¢N!	T¢¦©©©±¸¼¼¼ÃÃÃÃ¸¶­¦¦¢¢¦©±¸¼ÃÃÃÊÃÃÃÃÃÃ¼ÃÌÌÐÕÌÌÊÃÃ­¦¦¢¦¦±¸¼ÊÊÌÌÌÊÊÃÃÃÃÃÃÊÌÌÊÊÊÃÃÊ¼¸¸¸¼ÃÃÊÌÐÙÞààÙÐÐÌÐÕÕÙÙÞçïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòïïçïïààÙÙÕÌÌÃÃ¼¶±¦xvoooohhdb]TPPNGC<<<<<:3,3,(((&&!&b©ÙçççïççÊ<&]¢¢¦©±¸¼¼Ã¼Ã¼¼¸¶±©¦¢¦±¶¸¼ÃÃÃÃÊÃÃÃÃÃÃÃÃÃÊÊÌÃÃ±¦¦¦¦©±¸¸¼ÃÃÃ¼¼¼¸±±¶¶¸¸¼¸¶¶±±©©¢¢¢¦¦­¶¸¼¸¶±©¦¢¢¢¢¢¢©¶¶¸¼¶±¶ÃÃÃÊÊÃÃ¸¼¼¶¸¸Ã¼±¦¢¦¢xvoohohbb]]TPKKNGGC33,(((&!!!!!!!!	,h±ÕàçàààÐ±d,3¢¢¢¢¦­±±¶¶¶±­©¢¢­±¶­±±±­­©©©©©¦¦¦¦¦xvoxvvxxvoohbYY]]YTYTTY]]b]]TPKGCCC<CCGGC:333:<<<3333,,,(,((&!!			,o­ÌÞààÞÕÊY(ovxxx~~xxodb]]b]NThooohoohdb]]b]YYY]]TKKKKGCGCG<CCC<<3:3333((!((&&!!!!!&&(((,,333(<~¶ÐÙÞÞÐÌ¶C33:3<3:::3:333,33,&&!!!						!!&!!!&(,3,,,&&,3333333::<:::<<<CCCCCGGKCGKKPYbbb]b]]bdhooxxx~P(C¶ÊÕÙÙÐÃ±x:														!!!!!!(((,3,333333:CCGGGGKKKKNKGCCGPPPPTT]]bhhoooo~~¦­±­­­­©­¦¦©­¶¸ÃÊÌÌÕÕÙàççÕN!(]ÃÐÕÐÌÊ¼T(																										!!!&!&&(,(3,33::<GKTTPNTY]]dhoovv~x~¢©­©¦©­¶¸¼ÃÃ¼¸¶¶¸¼¸¶­©±±±±±¶¶¸¸ÃÃÊÐÙÙÙààççàççàààçààçààÙÕÕÕÕÕÕÐÌÌÃÃ¸¸¼¼ÃÃÃÃÃÃÊÌÐÐÐÌÐÊÃÃ¼ÃÃÃÊÌÐÙàççïòöøýýç¢T(!PÃÕÐÌÊÃ¸Y,																	!!!&&,33,(&(,333333:<GNPTY]dhooooox~¢©±¼ÊÊÊÊÕÕÕÕÞçïïççøööýýýýýýýýýýýýýýýýýýýýýýýýýýýöòçààÞÞààààçïòøýýýýýýýýýýýøýýýýøöïïççççàààÞÕÌÌÊÃÃÃÊÃÃÊÌÕÐÙÕÙÕÕÐÐÌÃÃÃÃÊÌÐÞàççòòøýýýýöÐ~<!3o­ÊÐÌÃÃ¼±K!!!&(&!((!!!(((,3,,333<NTYbbdox~xxoooooovox~¦­¶¸¼¼¼¼¼ÃÃÊÌÐÕàçïöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïççççïïòöøýýýýýýýýýýýýýýýýýýýøöòòïïçççàÙÕÐÌÊÊÊÊÌÌÕÐÕÐÙÞÞÞÞÙÐÊÃÃÃÃÊÌÐÙàçïòöøýýýýýøÌ<!3o©ÃÊÃÃ¼¼±&(&((,,3,3:CGC:,,,,(,3,,3333<GG<C333CGCCGCCCCGGK<<3CGNPTTYTbddo~¢¦±¶¶¶­©©­­­¦¦¦­¶¸¼ÃÐÙÞàçàÞààÞààçççöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöïïçççïïööýýýýýýýýýýýýýýýýýýýýýøöïïïïççàÞÕÌÊÊÌÌÌÌÐÕÕÙÙÞààÞÕÕÌÊÊÃÃÃÊÌÐÞçççïòöýýýýýöç¶d3!C±ÃÃÃÃ¼¸PTPNKPPPP]hvvvod]]d]YYYYbdhooooooob]hohovvhYYbbbddddhhoovx¢©±¶¶¶¼ÃÃ¼¼¼¸¸Ã¼¼¼¼ÃÃÌÕÞàçççççççççççòöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïçïçïïòöööýýýýýýýýýýýýýýýýýýýýöòïïïççàÞÙÕÐÌÊÊÊÊÐÕÕÕÙÕÙÞÞÞÙÐÌÃÃÃ¼¼ÃÊÌÕÞàççïïøýýýýòçà¸h3Cx©¸¼¶¶¸¼hoohhoohhv~~~~~~~¢ox~~~¦¦¦©¶¼¼¸¶±±¶¸¼¼¼¼ÃÊÌÐÙÙÞççïçççàççççïøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòçàççïïïïïöýýýýýýýýýýýýýýýýýýýøöïççççààÙÕÌÊÊÃÊÌÌÌÐÐÕÕÕÕÞÞÙÙÐÊÃÃÃ¼ÃÃÊÌÌÙàçççïöøýýöòïçÕK!&T©¶¶¶¸¼ovx~~¢¢¢¦¢¦¦¦­­¦¢¢¢¦­±©¢¢¢¢©­¶¸¼ÃÃÊÐÕÞÞÞààçççààààçïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòçççàççççïòöýýýýýýýýýýýýýýýýýööççààààÞÕÕÌÌÃÃÃÊÊÌÐÌÐÕÕÙÙÙÞÕÐÐÌÊÃ¼¼¸¸ÃÊÕÕÞÞàççòöýøöòïççÐP&!K¢­±¶¼ox~¢¢¢¢¦¢¢¢¢¢¢©±­¢¦¦¢~¢¢¢¢¢¢¦­©¦¢¦­¸¼ÃÃÌÕÕÕÞààààààÞÙÞàçòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýòççàÞÞààççïçòöýýýýýýýýøøøøøòööïïçààÞÙÕÕÕÌÊÃÊÊÊÊÌÌÌÌÐÕÙÙÙÙÙÐÕÐÌÃÃÃ¼¸¼ÃÊÐÕÙààççïööööòççàÞÃx<,]©±¶¸ovx¢¢~¢¢¦¢¢¢©©­¦¢¢¢¢¢¦©¦¦¦¢±¶¸ÃÃÌÕÕÞÞÙÙÞÞÞÞÙÞÞàïòýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýïçàààÞÞààççïïòøýýýýýøöòöøøøöòòçççÞÞÙÕÕÌÊÌÊÊÊÃÃÃÌÌÐÕÕÙÕÙÕÙÙÙÙÐÌÊÃ¼Ã¼¼ÃÊÌÕÕààççòòøøöòòïççÞÃv3!(]¦¶¼vo~¢¢¢¢¢¢¢¢¢¢¢¢¢¦¦¦¦¢¢¢­¶¸¼ÃÌÌÕÙÞÞÙÙÞÞÙÕÙÞçïòöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöïççÞÙÙÞÞÞàçïòöøýýýýöøøöööòöööòïçÞÙÙÕÐÕÐÌÊÊÃÊÊÌÌÌÌÐÕÕÞÞÞÙÙÞÙÕÕÌÊÃÃ¼¸ÃÃÊÐÕÙÞàççòöøööòòòïççÕ¢T,:o©¸vv~¦xx~¢¦¢¢¢¦¦¢¢¦¢¢¢¢¢¢­¸¼ÃÃÊÌÕÙÞààÙÙÙÙÕÙàççòöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïççààÞÞÞàçççòööýýýýöøøöööøøøöïïçàÞÙÙÕÌÌÌÌÌÊÊÊÊÌÐÕÐÕÕÕÞÞàààÞÙÐÐÊÃÃÃ¼¼ÃÊÌÕÞàçççòöøýýøöòïïççÞ­b,:o±xxxvx~¢¢¦¢¦¦¢¦±¸¼ÃÃÊÌÐÙàçàÙÙÕÙÙÞàçççöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöòççàÙÕÙÞçççïçïöýýýöïöøøøøøöööïïçÞÙÕÐÌÐÌÌÌÊÊÃÊÌÌÐÐÕÕÕÙÙÞÞÞÞÞÕÌÌÊÃÃ¼¸¸ÃÌÐÕÞççççïöýýýöòòòïòççÐK!!G~¦~~~¦~~x~¢¢¦¢~x~~¢¦¦¢¢¢¢¦±¶¸¸¼ÃÌÕÙÙÞÞÞÙÙÞÞÙÙÞççïöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöòïààÞÞÞààççççïöøýýïçöööööööòïçàÞÕÕÌÌÊÃÃÃÃÃ¼Ã¼ÃÃÃÊÊÊÊÊÊÃÊÊÊÃÃ¸±­©¦¢¦¶ÃÊÕÙÞàçççòøýøøòïïçïççÞÊG!!K¢¦¦~¢¦x~x~¢¦©©©­­±¶¶¶¶¶¼ÃÃÃÃÊÕÞààÞÙÙÞÙÙÙàçççïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöòïçÙÐÌÌÌÐÐÐÕÐÕÕÕÞççàÌÐÙÐÐÌÌÌÊÃ¼¶­­¦¢xxvvohd]YTNNTo±ÃÊÐÕÕÞàçïòööçççççççàÙÌ­h3&T¢¢¢¢~~ooxx~¢¦¦©­­±¶¸¸¶±©­±¶¸¼ÃÊÌÐÐÌÐÕÕÕÐÐÌÐÐÕÕÕÞçïýýýýýýýýýýýýýýýýýýýýýýýýýýýýòïçççïçàÙÕÌÃÃ¸¸¶­­¦~xxvohdddbYTNKKC<<:33,,,,,,(&!&!!!(T©¼ÃÐÕÙÞàçççïççààààÞÙÙÐÃ¦b,(~oovx~voohbdoox~~xx~~~oo¦¦¦¢©­­­©¦¦­­­­±­©~xvoooohhbYPKKGKC3:33,,(&!!	&Y±ÃÊÌÌÐÙàçççàÞàÞÞÙÕÕÕÌÃ¶T(]dovxohhhhooxxvoo]]YYbdhox~~voooddddovohbNKNKK<CGKPPPKGKKKGGC<CGKKKGKGKGNNKG<:<C<<:<<<CCG<:<GGC<3,((((((&(((,((&&&&&&!!!					(b±ÃÊÌÌÕÙàççàÞÞÙÙÕÕÙÐÐÃ¼©P&GGGGC<<GGC<<<<:3:<:3333:<KKCGPNG<:333,,3333,(!!!		!3o¢¸ÃÊÊÐÙÞààÞÞÙÕÙÕÕÕÌÌÃ¼¶¦o<!!											!!&!!!&&&&(&,,,,,3,3333:3<<CKKKPPPPTTYYT]]bdddhdT:G~©ÃÃÊÐÕàààÞÙÕÙÕÕÙÐÐÌÊÃ¸­d3																																!!!&((((((&&&&(!&((,,,(,,3,33333:<<CCGKKNPNKNPTTYb]bbddhdhhhohdhoovoox~xxovxx¢¢¢¢¢¦¦©©©©©©©­©­©¦o<!K±ÃÌÐÕàààÞÞÞÙÕÙÕÕÐÌÊÃ¼¶©]3																	&((((((((33::<CGPTYbdhhdovoov~~~~xx~¢¢¢¢¢¦©±±±­±¶¸¼¼¸±­±­¶¸¼¸¸¶¶¶¶±±­±±­­±¶¶¼¼¼ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃ¼¸¶©d3(]¸ÃÐÙÞààÞÞÞÕÕÕÕÕÐÌÊÃÃ±­¢P	&((,(,,33:<<:3:<CCC<GKNNGCGNPT]]Ybdhoxxxxvoo~¦­¶ÃÊÌÕÞàçççòçççòýýýýöïïçççàçïçïçàÞÙÞÞàÙÕÕÕÐÐÐÐÕÕÐÌÊÃÃÃÃÃÃÃÊÌÐÌÌÊÊÌÕÙÙÙÌÊÊÊÊÊÌÐÌÌÊÃÃÃ¸¸¸¸¸¼¸¼¼ÃÃÃÃÃÊÊÊÊÊÌÌÌÌÊÊÊÊÃÃÃ¸¶±©]3(d¸ÃÌÙÙÙÕÌÌÐÌÐÌÌÊÃÃ¼¸¶­¦~!!!!&!!!&,,(,(,&((((3333::<CGKKGCCCCGGCGKKNNKGKNTTT]bdoo~~¦¦¦­­±¸ÃÌÐÊÃÃÊÃÌÌÐÞàççïøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýööòòïççàÞÙÙÙÞÕÕÌÊÊÊÃÃÊÌÌÐÐÌÐÌÐÐÕÙÞÙÐÌÌÌÌÊÊÊÌÌÊÊÃ¼¸¸¸¼¸¼¸¸¼¼ÃÃÃÃ¼Ã¸¼¼ÃÃÃÃÃÃÃÃ¼¼¶¶­­¦¢~G!<x¢¸ÃÊÊÃÃ¼¸¼ÃÃÃ¼¼¸¸¸¶­¦¢hdb]bbhooovx~~ovxohbbdhox~~¦±¸¼¼¼ÃÃÊÃÃ¼ÃÊÌÌÐÐÌÊÊÊÃÃÃÃ¼ÃÃÌÕÕÞçàççàççççàççòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøööòööïççàÙÙÙÙÐÐÌÊÊÊÊÃÊÊÌÌÐÌÐÌÊÊÊÌÌÐÐÌÃÃÃÃÃÃÃÃÃÃÃ¼¼¸±±±±¶¶¸¸¶¶¶¶¶¶¶¶±­­­­±¶¼¸¸¶±±©¦¦¢¢xC!Cx­±©¢©­­­±­±­©¦¢¶­¦¦¦­±­©±¸¸Ã¸±±±­¢¢©¦­¸¶¸¼ÃÃ¸¶­­¦©­©©©©¢¦±¸ÃÊÊÌÐÕÕÕÐÐÕÕÙÞàààÙÕÕÐÌÌÊÃÃÊÊÌÕÙÞççïççàààççïïòöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïïçïççàÙÕÕÐÌÌÌÌÊÃÃÃÃÃÃÃÃÊÌÌÌÊÊÃÃÃÃÃÃ¼¶­¦©­¶¸¸¼Ã¼¸¶±­±­±­­­­±±­­©¦¦~vx¦©±­­©¦¦¢¢h3KvhN<3CPh~¦©¦¦¦¢ÊÊÃÃÃÊÌÌÃÃÊÊÊÊÊÃÃ¸¶©¢¢¦©­¶¶¼¼¼¼ÃÃÃ¼¼¸¶¶¶¶¶±­¢¦¦¦¦©¶¼ÊÌÐÕÐÌÌÕÕÕÕÐÙÙÞàÞÞÙÕÐÊÊÃÃÃÊÊÌÕÙÞçïçççàÙÙÞççïçòöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöòçççàÙÃ¶­±¸¼ÃÃ¼¼¼Ã¸Ã¼¼¼ÃÃÃÊÊÊÊÃÃ¼¼¸­ob]do¦±¶¶¶¶­­­©©¦¦©©­­¦¦¦¢T:&&(<To¢¢¢¢¢¢¢o3(,!!3bÊÌÕÐÌÊÊÃÌÌÌÌÃÃÊÊÃ¸¶©¢¢¦©­¶¸¸¼¼¼¼¸¼¼¼¼¸¸¸¶±¶¶©¦©©¢¢¦­¶¼ÃÊÊÌÕÐÐÐÐÌÐÐÕÙÞÞÞÕÕÐÐÌÊÃÃÃÃÃÊÐÙÞàçççààÙÐÙàççïïöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòçàÙÐ±d]]h¦­¶¸¼¼¸¶¶¸ÃÃÊÊÊÃÃ¼¼¸¸±P3!(Kh¢©±­©¦¦¦¦¦©¦¦¦¦¦¦¢¢d,!!:]],3TxÊÊÊÊÊÌÌÊÊÊÊÊÊÊÊÃ¼¸±©¢¢¦­±¶¶¶¶¸¸¸¼¸¸¶¶¸¸¸¸¶±­©©¦¦¦¢©±¼ÃÊÐÌÐÐÐÐÌÌÌÐÐÕÙÙÙÕÐÕÌÌÊÃÃÃÃÃÊÐÕÞàçççààÞÙÞàààçïöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöïçÞÃN3!!&,No¢­­±±¶¶¸¼ÃÃÃÊÃÃ¼¶±­C!3T~¢©©©¦¢¢¢¢¢¢¢¦¢d,,Y~Y,&!3PxÕÐÊÃ¸ÃÊÐÕÌÃ¼¼ÃÌÌÃ¼­¢¦¦¦¦©­­¶¸¸¶¶¶¶¸¸¼¸¸¸¸¸¶±±­©¦¢¦©¶¸ÃÌÐÌÌÌÐÕÐÐÐÐÐÕÙÞÞÙÙÕÐÌÃÃÃ¼ÃÃÊÌÙàçïçççààààççïïòöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïçàÃv3!&<d©­­±¶¸¸ÃÃÊÊÃÃ¼¶©~:3]¦¢¢¢¢¢¢¢¢¢¢¢o3!3bv<!&&((((!<oÊÊÌÌÌÊÊÊÊÌÌÐÌÌÌÃ¼¸±©¦¢¦­©­­±¶¶¶¸¸¸¸¸¸¸¼¸¼¼¸¶±©¦¦¢¢¦­¶¼ÃÌÐÕÕÐÕÕÌÐÌÐÕÙÙÞÞÙÙÕÐÌÊÊÃÃÃÃÌÐÙàçïççççàçççïçïòöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòàÐ<!!!(3b¦­­¶¸¼¼ÃÊÊÊÃ¸¶P!3b¢¢¢¢¢¦¢N!(!((CoY&!(,3,,,&(NxÌÌÌÊÊÌÊÌÊÊÌÌÕÕÌÃ¶±­©­¦­¶¶¶­­­­¶¼¼¸¸¸¼ÃÃÃÃ¼¼¶¶­­©¦©©¶ÃÊÐÕÕÌÌÕÕÕÐÕÐÕÙÞÞÞÞÞÕÕÌÊÊÊÊÃÃÊÐÙàçïïïçççççïïïïöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöçà¢K!&((Go¦­¸¼¼ÃÃÊÌÃÃ¼©o(&&!(&&Kv¢¢¢¢¢o3&((&!&,3&3Y~¢T&!!!&(33(!3oÌÕÙÕÌÃÃÊÌÕÕÕÌÊÊÊÃ¼¶©¢¢¦©­±¶¶¶¶¶¶¸ÃÃÃÃÃÃÊÃÃÃ¸±­©¦©¶¼ÃÊÌÐÕÕÙÞÙÕÐÕÕÙÞàÞÞàÞÕÙÕÕÐÊÃÊÃÌÐÞàçïïçççïççççïòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïÐx3!&!!(,&(P~¦­¶¼ÃÃÃÊÊÌÃÃ¦T!!!&(,,3(!,Y¢¢¦¦¦¢](((&(33:,&CoP!(Chb<3T~ÕÕÐÌÌÌÐÕÐÕÐÐÌÌÌÊÃ¼¶©¢¢¦¦©©­±¸¸¶­­±¸ÃÐÕÕÐÃ¸¼ÃÃÃ¼©¦¦­¼ÌÐÙÙÕÐÙÞÞÕÕÕÕÞàçÞààÞÞÞÙÕÌÊÃÃÃÊÕÞàççïïïïïïïïïòöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöç±N!!!(3,!:o¢­¸¼ÃÃÃÊÊÃÃ¸C!&((,::3(Nx¢¢¢K!&&(,CK<(3b~C&&3P¸ÊP3KoÕÕÌÊÊÌÐÙàÙÐÊÌÌÐÙÐÃ±¦­¶¶¶­­±¶¼ÃÃÃÃÊÌÐÌÊÃ¸±­±­±±¸ÃÊÕÕÙÙÕÙÙÐÕÕÕÙÞààçàÞÕÕÕÐÊÃÃÃÃÃÌÙÞàçïççççççççïöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïÞ:,<:,3Y©±¸¼ÃÃÃÊÃ¸¶~3&((3To<Ghv<!,(,3PTCY~v:!!!3o~C(<hÕÕÐÐÌÐÌÐÐÕÕÐÌÌÌÊ¼¼±¦¢¢¢¦¦­­­­­±¶¸ÃÃÃÃÊÃÊÃ¼¶±­¦¦©±¸¼¼¼¼ÊÐÕÙÐÃ¸ÃÊÕÞÞÕÐÊÊÌÐÐÃ¸­©¶¸ÃÊÊÐÐÐÙÞÙÕÕÕÙàïçòòöýýýýýýýýýýýýýýýýýýýýýýýýýýýýòçÌo(!:doG,N~¢©±¶¸¼ÃÃÃÃ¸­o,!(3hÕ¢3<]o3,,3K­ïo:Pxo3!<d~ÊÊÊÌÌÌÌÃÊÊÊÃÃÃÃ¸­¦~¢¢¢¦­©¢¢¦­±¸¸¶¢¢¦©©©¦­©¦©¦¢¦­±±©¢¦±ÃÐÞçïöøýýýýýýýýýýýýýýýýýýýýýýýýýýöçç¸]!!:~¢P,Gx¢±¶¸Ã¼ÃÃ¼¸¦d(3]P33Txh3(hT:Poh3		:h~¶¶¶¶¶¶¶©¦¢¦¢¢~xooxoooxx~~x~xoooo~~xvooxvhddhhhd]Y]]bbdd]Ybbb]]TTTTY]bYPK<:CGNKG<::<GGGC:33GbÃÐàççöýýýýýýýýýýýýýýýýýýýýýýýýýýöçÞ­P!	,boG(<v¦­¶¸¸¼¼Ã¼¼]&!(Txd3&(((Ko~o3		<dxovvovovhbb]]b]TTTPKGGGGKCC<CCCGCC<<33:33:::3,&&(,33,&&,,&!!	G¸ÙçòöýýýýýýýýýýýýýýýýýýýýýýýýøöòçÙ¢G!!PK!<o¦±¶¸¸Ã¼ÃÃ¼T!	,Txd(	!&(Poo:		Ch~33,,(,(((&!!!!!!		KÃÞöýýýýýýýýýýýýýýýýýýýýýýýýýýòïçÙ¦K!	&&!<o¢­¶¸¼¼ÃÃ¼¸¢](,Tvo3		!,Tx~vC		Ko~														!]©ÕçòøýýýýýýýýýýýýýýýýýýýýýýýøöïàÕ©P&	Gx¢©±¶¼¼ÃÃÃ¸¦o,		3]xvC	3]xT(	(Yx							!!!!!&!(,,,3,,33:3!(h±ÞòøýýýýýýýýýýýýýýýýýýýýýýøïçïçÞ¸d	Gx¦­±¶¶¸¼ÃÃ¸­x3		:bxT(	:h~o<	:h!&,3:CCC3,((((,,,333:<<CGGKKPPTTYbbb]ddb]bdhooooho~vP3(!3h±àøýýýýýýýýýýýýýýýýýýýýýýýöïçÞÕ¸v3	&T¢¦­¶¶¸Ã¼¸¶­K!Go~o:	(NvT(&Px&(((,((((,333:3,3::333,,,33:::<CGGKKTTYbhv~~vooovx~¢¦¢¦©©©±¶¸¸±±¶¸¶¶±¶±±±±¶¸ÃÃÌÕÕÕÙÕÐ±h3CÌçøýýýýýýýýýýýýýýýýýýýýýöïçàÙÊ¸<!			(d¦©©¦¦­¸ÊÊÃ¶©G!	,]xY(	:hoC!<ox~x~vxooxxxhbdohoooxx~¢©±¸¼¼ÃÊÊÃ¸±©¦¦¦­¶¸¼Ã¼ÃÐÕÞÞÙÕÙÙÙÞààÙÕÕÕÕÕÌÊÊÃÃÃÃÊÐÞàççççààÞ­b,NÐçöýýýýýýýýýýýýýýýýýýýýöïàÕÌÃÃ¢],!Go¢©­±¶¸¸¼Ã¸­G!Go~¢xK!3Y¢¢¢oC&,bÊÊÃ¼ÃÃ¸¼¼¼ÃÊÊÊ¸¶¶¶±¦¢¢¢¢©©©©±¶¸¼ÃÃÊÊÌÌÌÊÃ¼¸¸¶¶¸ÃÊÌÐÕÕÙÙÞÞÙÙÞàààààÞÞÞÞÙÕÐÌÃÃÃÃÊÌÙÞàçççïçççÙP(&]¦ÙçøýýýýýýýýýýýýýýýýýöïççÞÕÌÃ¸¦x<!3d¢¦±¸¼Ã¼¸±­­x<!		3h¢o<!(Px¢¢¢¢¢¢¦¢oC&3d¢¢¢¢¦¢ÕÕÕÐÌÌÌÐÐÌÐÐÐÐÌÃÃ¼¸¶©¢¢¦¦©­­±±±¶¶¸¼ÃÃÊÊÊÊÃÃ¸¶¶±¶¸¼ÃÌÕÕÕÕÙÞÞÙÕÙÙààçàÞÞÙÙÙÙÐÌÊÃÃÃÃÌÕÞàççïçççççÙT(&]¦ÙöýýýýýýýýýýýýýýýýýöçÞÐÕÕÕÊ¸¢T3&		!,No¢­­¶¶¶¼¼Ã¸N3Yx¢¦¢¢¢oN,,T~¢¢¢¢¦¢¢¢¢¢¦¦©©©¦¦~]<(!(Ko¢¦¦¦¦¦¢¢¢ÌÕÕÕÙÕÐÕÕÐÕÕÐÐÕÌÃ¼¶­­¢¦¦©©­­­±­±¶±¶¸¼ÃÃÃÃÊÃÃ¼¶¶¶¶¶¸¼ÃÌÐÕÙÙÙÙÙÕÕÙÙàààààààÞÕÕÌÌÃÃÊÃÊÌÐÕàçççïçççççÐK!3o±àýýýýýýýýýýýýýýýýøïçÞÙÕÌÃ¸­¢Y3&Go¢©­¶¶¼Ã¼¼©]((3,!(Gh~¢©©¦¢hP:,,3Po¦¦¢¢¢¦¢¦¢¢¦¦©©­©©©©¢xh]Ybo¢¦©©¦©©©¦¢¢¢ÌÕÕÕÕÕÕÐÐÐÕÕÙÙÐÐÊÃ¼¶©¢¦¦©©­­­¶¶±­±±±¸¸¼ÃÃÃÃÃÃ¼¸¶±­­¶¼ÃÊÐÙÙÙÞÞÞÞÞÙÙÙààççààÞÙÕÕÌÊÃÃÃÊÌÕÙÞççïïçïççççÕ<3o¸çýýýýýýýýýýýýýýýöççÞÕÌÃ¼¶­¦~]3&&3G]o¢¦¦¢¢¦±¼ÊÊ¸v(<hxhPG<GK]o~¢¢¢¦¦¦¦¦¦xv~©©­­©¦¦¦¦¦¦¦¦©©©©­­­±©©¢¢¢¦¦¦©©­©©©¢¢¢¢ÕÕÙÙÕÕÐÐÕÕÙÕÙÕÕÐÌÃÃ±¦¢¢¢¦©©­©±¶¶¶¶¶±±±­¶¸¼¼ÃÃÃÃ¼¼¸¸¸¶±¶¼ÃÐÙÕÙÙÞÞààÞÞÞÞàççççàÞÞÙÐÐÐÊÊÃÃÌÕÞçççïïïïïçïçç¼d3<ÕýýýýýýýýýýýýýýøòçàÙÕÐÃ¼¶­¢~dN:3:<NYhx¢¦­±¶¸Ã¼:3h¢~~¢¢¢¦¦­±­©¢¦©±­©¦¦¦­±±©¦¦©­­©©©­­±±±±­­­©­©­­­­±­±©©¦¢¢¦ÕÕÕÕÙÙÙÕÕÕÕÙÞÞÙÙÌÃÃ¸­©¦¢¢¦©­­¶¶¶¸¸¶¶±¶¶±¶¼¼¼Ã¼ÃÃÃÃ¸¸¶±±¶¼ÃÌÕÞàààÞààààÞààçççççààÞÕÕÌÌÊÊÊÌÙÞççïïòïïïïïïïç¶d3KÞýýýýýýýýýýýýýøïçàÙÐÌÃÃ¶­¢vodddhox~¢¦­­¶¼¢T!,Y¦©©­©¢¢¢¦©©©­­­±±­­­©­±­±±±±­­©¦¦¦¦¦©­­­±­±­±¶¸¶¶¶±±­±¶¶¶¶¶­±­©¦¦¦ÞÙÙÙÙÙÕÙÙÙÙÙÙÙÞÕÐÊ¼¸±­¦¦¦©­¶¶¸¸¸¸¸¶±¶¶¶±¶¸¸ÃÃÃÃÃ¼¼¼¸¸¶¶¶ÃÊÌÙÞààààààÞÞààçïïçïçççÞÕÐÌÌÊÊÌÌÕàçïïòïïïïïòïïçà©T(&Y©çýýýýýýýýýýýýöççÞÕÌÃ¼¸¶­¦~xovox~~¢¦©±¢](!N¦±­­©¦¦¢¢¢¢¢¦©­±¶¶¶¶¶¶¶¶¶¶¶¶¸¸¶±­©­©©©¦¦¦©¶¸¼¼¶±±¶¼ÃÃÃ¸±±¶¸ÃÃ¼¸±­­©©©ÙÙÙÙÕÙÕÕÙÞÞÞÞÞÞÞÙÐÃ¼­­©©©­±¶¸¸¸¼¼¼¸¶¶¶±±¸¼Ã¼¼¸¼ÃÃÃ¼¸¶±­¶¼ÊÕÙÞÞÞÞàçàÞààààçççççààÞÙÕÌÊÊÃÊÌÙàççççïçïïïïçïïçà¢N&(T©çýýýýýýýýýýøòàÙÐÊÊÃ¼¸±©¢~xvovxx~¢¦¦o3:o­±±¶±­¦¢¢¢©­©¢¢¦±¼¼Ã¼¶¶­¶¼ÃÃÃ¼¸±¶¶¸¶±­­©­±¶¸¸¸¸¸¼ÃÃÃÃÃÃÃÃÃÃ¼ÃÃÃÃ¼¶­©©©ÕÕÞÞÞÙÐÕÙÙÞààÞÙÕÕÌÊÃ¶©¦¦©­±¸Ã¼¼¸¼¸¸¶¸¸¶±¶¸¸¼¼¼ÃÃÃÃ¸¶¶¶¶¸ÃÃÌÐÕÙÞÞààÞÙÞÞàçççççàààÙÐÌÊÊÃÃÃÌÕààçççççïççççïçïçÕG&,h¼çøýýýýýýøöïçÞÐÊÃÃ¼¸±©¦~~xovovvx~o:3d­¸¸¸¸¶­­¦¦¢¢¦¢¦¦©±¶¶¼ÃÃÃÃÃÃÃÃ¼ÃÃÊÊÃ¼¸¸¶±­±¶¶¶¸¼¼¼ÃÃÊÌÌÌÌÌÌÌÌÐÐÐÊÃÃÃÃÃÃ¸­¢ÕÙÕÕÕÐÐÌÐÕÞÞÞÞÞÙÐÐÊ¼±­¦¦©­±¸¸¸¼¸¸¼¸¸¶¶¶±±¶¸¸¼¸¸¸¸¸¸¶±­©­¶ÃÊÐÐÐÕÕÙÞÙÞÙÙÙÙààçààÞÙÕÌÊÊÃÃÃÃÊÊÕààïççàààççççççïçÕK!3v¼àòööööòïïàÕÌÊÃÃ¸¶­¦~vvoooooddhoovxxvx~~b3!P±¼ÃÃ¼¸¶¶±­©¦¢¢¢¦©©±¶¸¼ÃÃÃÊÌÐÐÌÌÃÃÃÌÐÕÕÌ¸­­±¼ÃÃ¼¸¶¸ÃÌÕÙÕÕÌÐÕÕÞÙÕÐÌÐÕÕÐÊÃ¼¶¶¶ÐÕÕÐÐÌÊÊÌÌÕÕÙÕÕÕÌÊÃ¸±©¦¦¦©­¶¸¼¸¶¸¼¶¶¶­©¦©­±¶¶¶±­­±±­­¦¢¢©­¸ÃÃÊÊÊÌÌÌÊÊÊÊÌÐÕÐÐÐÌÌÌÃ¼¸¶¶±¶¸ÃÃÌÕÕÕÐÐÌÌÌÕààççççïÐG!3o©ÊÌÊÃÃÃ¼¸­¦~vohb]YPPKGGCCC<<<C<<CC<<<C3(G­¼ÃÃÃÃÃ¼¸¶±­­©¦¦¢¢¦©±¶¸¼ÃÊÌÕÐÕÕÐÐÐÕÕÙÕÙÕÌÌÃÃÃ¼¸¼¼ÃÃÃÊÌÌÐÕÙÞÞÞÞÞÞÞÞÞààÞÙÐÐÊÃÃ¼¸ÌÌÊÃÃ¼ÃÃÃÊÌÐÌÌÌÌÊÃ¼¶©¢¢¦©­±­±­­­­¦¦¢¢¢¦©©¦¢¢¦¦¢¢¢©ÃÙàççïçïÌ~:!(Pdhh]Y]]TPGC<C:33,(!!<x©¼ÃÃÃÊÊÃÃÃ¼¶±©©¦¦¢¢¢¢¦©­¶¸ÃÃÊÌÕÕÙÙÙÙÙÙÙÞÞÞàÞÙÕÌÊÃ¼Ã¼ÃÃÃÌÐÐÕÐÕÙàçïççÞÙÙÞçïïàÕÊÃÊÊÌÃ¶±±­¦¢¦¢¢©±±±±­©¢~x~~vvxvohhhhhhohdbddb]PNNPTTY]TTYY]YTTPNKNPPPNKKKG<<<:3333333333((((:]¸ÐÞàçòïïÊo3								,h¢ÃÊÊÌÌÌÌÌÊÃÃ¼¸¶±©¦¦¦¦¢¢¢¦©©±¶¸¼ÊÐÕÕÙÞÞÞààààààààÞÞÕÕÊÃÃ¼ÃÃÃÌÌÐÕÕÙÞççïççççççççççàÙÐÕÌÊÃÃvvohdhhbbdhdddb]YPTTPKGCCGGGC<<<::3333333,(((,(&&&!!!NÃÕççïïïïÃo3				&T¼ÌÐÌÌÐÐÕÐÌÊÃÃ¼¶¶­¦¦©©¦¢¢¦©­±¶¸¼ÊÌÕÞÞààààçààççççàÞÕÐÌÊÃÃÃÃÃÊÌÌÕÕÞàççççààççççàààÞÙÕÕÐÊ¸¶3((&&(((!!!!					&TÃÙàïòøýö¼d3!!&((,3:]¸ÌÕÐÐÐÕÐÕÐÌÌÌÃ¼¸¶±­±©©¦¢¢¢¢¢¢¢¦©±¶¸¼ÃÊÕÕÞàÞÞÞÙÞççàçààÙÕÌÃÃÃÃ¼ÃÃÃÊÌÐÕÙÞààççççàààààçàÞÕÐÌÊÃÃ¼												&d¦Ðçïòöøýö¸hG33:333:CCGG<<<CCCCGGGGGGGNKKKGKKNPTPTY]]bddoox¶ÊÐÕÐÕÐÕÐÐÌÌÌÌÃ¼¶­©­­­©©¦¢¢¦©©­±¸¸ÃÊÐÙÙÙÙÙÙÙÙÞÞçàÞÙÕÐÌÃÃ¼¼Ã¼¸ÃÃÊÐÐÕÙÞàççààÞàààààÞÞÕÐÌÊÃ¼¸			!!!!&(&((&(((,33:3<<CKPPPPC(3v¶ÙçöòöýýøÌ¦¦¦©©¦¢¢©¶¼ÊÌÐÐÐÐÐÐÌÐÌÌÊÃÃ¸¶¶±­©­­©¦¢¢¢¢¦­­¶¸ÃÃÌÐÕÕÙÕÙÙÞÞÞÞààÞÕÐÊÃÃÃ¼¼Ã¼ÃÊÌÐÕÙÞàààçàçààçààçàÞÙÕÕÊÃÃ¼!!!!&&(((,,,333333(3<<:(!3CNPTYb]]]bhovxoxovvovvx~¢¦©±±±h3:¼àççòøýýýöòöööòòïïïçàÙÐÌÃÃÃÃ¸¶±­­©©¦¢¢¢¦¦±¸ÃÊÌÐÕÕÐÐÌÌÌÌÌÊÃ¼¸¶¶±­­©¦©¦¦¢¢¢¢¦©­±¶¸ÃÃÌÐÕÙÞÙÕÕÙààççàÙÕÐÊÊÃÃÃÃ¸ÃÃÊÌÕÕÙÞàçïççààççççççàÞÕÕÌÊÃÃ::::<<<:3:<CCCGGCCCCCC<<<CGKPYb]]]]]]]]]bdhooovx~~~~xo~vKNx¢¦­±¶¶¶¶¶¸¼ÃÊÃÃÊÃ¼¼¸¶¶¸¼ÃÊÌÕÞÞàçààÞ±d3GÃçïòøýýýýýýýýýýýýýöïçàÙÕÐÌÌÃ¼¸¸¶±±­­©¦¢¢¢¢¦¦©±¸ÃÊÌÐÐÕÐÕÐÐÐÌÌÌÊÃ¼¸¶¶¶¶­­¦¦¢¦¢¢¦¢¢¢¦©±¸¼ÃÊÌÕÙÙÞÞÞÞààççàààÞÕÐÌÃÃÃÃÃÊÌÌÕÕÞàçïïïòçïçïïçïççççÞÙÐÌÊÃ¢¢~~~¢©©¦¦¦¢¦©¦¦¦­­¶¶¸¶±­­©­­¸¸©ÃÌÐÕÙÞÙÕÕÕÕÞçààÞÙÕÕÐÌÌÃÃÃÊÕÙàççïççïçÞ­Y3!PÌàçöýýýýýýýýýýýýýýöïçÞÙÕÕÐÌÌÃÃ¸¸¸¶¶±­©¦¢¦¦¦©©©±±¸¼ÃÊÐÕÙÙÙÕÕÐÐÐÐÌÊÃÃ¼¶±±¶¶¶­©¦¦¦¢¢¦¦¦©­±¸ÃÃÊÐÕÙÞààààççççïççàÙÕÌÊÃÊÃÃÊÊÐÕààççïòòòòòïòïïïòòòçàÞÙÌÊÊÌÌÊÌÌÌÌÊÊÊÌÐÐÌÕÕÐÌÃ¸¶©¦¢¦­±±¸¼Ã¼ÃÃ¸¸¸¸¸¸Ã¼Ã¼ÃÃÃÃÃÃÃÃ¸¸¸¸¼ÃÊÃÌÐÕÕÙÞÞÞÞÞààààààççàÞÕÕÌÊÃÃÊÌÐÞàççïçïïççÙP(,h­ÕïöýýýýýýýýýýýýýýøïïçàÙÕÕÕÌÌÃÃÃÃ¼¸¶¶­©¦¢¢¢¦¦¦©©­±¶¸¸¼ÃÊÐÕÙÞÞÞÙÕÐÕÕÐÌÌÊÃ¼¸¼¼¸¶¶­±©­¦¦¢¢¢¦©±¶¸¼ÃÌÕÙààààçççïòòçïççÞÕÕÌÊÊÊÊÌÐÙÙàççòööøöööööòöòöòöïçàÙÕÐÌÕÙÙÕÕÕÌÐÐÙÙÞÞÞÞÙÕÌÌÃÃ¶­­±¶¸¸¸¼ÃÃÃÃÃÃÃÃÃÃÃÊÊÌÌÊÊÊÊÊÊÃÃ¸¸¸ÃÃÌÕÙÕÙÕÙààààààààààççààÞÙÕÐÊÊÃÃÌÕÞççïïçïïòòçÙN&3o¶ÙòýýýýýýýýýýýýýýýöòïçàÙÕÕÕÐÌÌÊÃÃÃ¼¸¸¶±©©¦¦¦­­±±±¶¸ÃÃÌÐÕÙÞàààÞÙÙÕÙÕÐÌÊÃÃÃ¸¸¸¸¶¶­±©©¦¦¦©©©±¸¼ÃÃÌÕÙàçççççïçïòöòòçàÙÐÐÌÌÌÌÌÕÙÞÞàçïøýøøòöööööøøöòïçààÙÐÌÙÞÞÞÙÕÕÕÙÞÞÞÞÞÙÞÕÕÌÃÃ¸¶¶¶±¸¼ÃÃÃÃÊÊÌÊÊÊÃÃÊÌÌÕÐÐÌÌÌÌÌÊÃÃ¸¸¼ÊÌÙÙÕÙÞÞàçàçàààççïççççàÞÙÌÊÊÃÃÐÕÞçïòòòòöòïççÙG&3ÃòýýýýýýýýýýýýýýýøöòççÞÙÕÕÕÕÐÌÊÃÃÃÃ¼¼¶­­©­­±±¶¶¶¶¼ÃÊÐÕÞÞÞàààÞÞÞÙÕÙÕÕÌÊÃÃ¼¼¼¸¸¸±­­©¦¦¦©©­±¶¼ÃÊÐÙÞàçïïïïçïïöööïççÞÕÐÐÌÌÐÌÐÕÙÞçïòööøöööøöööööòòïççÕÕÌÊÕÞààÞÙÙÕÙÞàààÞÙàÞÕÐÊÃ¸¶¶¶¸¸¼¼ÃÊÊÊÌÊÊÌÌÌÌÌÌÐÐÙÙÙÕÕÌÌÊÃ¼¼¸ÃÃÊÕÞÞÞàààççàçççççççïòççàÙÐÌÊÊÊÐÙàçïòòöøööïòïïÕC!:ÐøýýýýýýýýýýýýýýýöòïçàÞÙÙÙÕÐÌÌÌÌÊÃÃ¼¸¶¶±±±±¶±¶¶¼¼ÃÊÐÐÙÞàççàÞÞÙÞÙÕÕÕÌÊÃ¼¼¼¼¸¸¶±±©¦¦¦¦­©©±¶¼ÃÊÐÕÙàççïççççïòööïçÞÞÕÐÌÌÊÊÌÐÕÕÞàççïòööòòïïïòöòòòççÞÕÐÌÊàààÞÞààÞÞÞàààççààÕÐÊ¼¼¸¸¸¸¸ÃÃÃÊÌÌÕÌÌÊÊÊÌÌÐÕÙÞÙÕÙÕÕÕÌÃÃ¸¼ÃÊÐÙÞÞÞÞççççççàççïïïïïççàÞÙÐÌÊÊÐÕÞçïöööööòòòòïçÃo3!P¢àýýýýýýýýýýýýýýýöòïçààÞÞÕÕÕÐÐÐÌÌÊÃÃ¼¸¸¶±¶¶¶¶¶¸¼ÃÃÊÐÙÙÙÞÞàààÞÙÕÐÐÐÕÐÌÃÃ¸¸¼¸¼¶­©¦¦¦¦¦¦©­­±¸¼ÃÌÐÙÞàçççççïçïïïççÞÕÌÌÊÊÊÊÊÌÐÕÙàçïïïïïïïïïïïïïïïïàÞÕÌÊÊÞÞàààààÞÞÞÞçççççàÙÕÌÃÃ¸¶¶¸¸ÃÃÃÊÌÌÐÌÐÐÌÊÊÌÐÕÙàÞÞÙÙÕÕÐÊÃ¼¼¼ÃÌÙÞàÞÞÞçççççççïïïïïçïççàÙÐÌÊÊÌÕàçïòöòöòöòòïççç¸d3!P©çýýýýýýýýýýýýýýöïïççàÞÙÙÕÕÕÕÐÌÌÐÊÊÃ¼¸¶¸¸¸¸¸¸¸¼¼ÃÊÐÙÞÞÞÞÞàÞÞÙÙÕÕÐÌÊÊÃÃ¼¼¶¶¶¶±­©¦¢¢¢¢©­­¶¸¸ÃÊÌÕàààçççàççïïïçàÙÕÕÌÌÃÃÊÊÌÌÐÙÞàçççïïïïïçïçïïççççÞÕÌÊÃààçàçààààààçççççàÙÐÊÃ¸¶¶¶¸¸¸ÃÃÌÌÌÐÌÐÌÊÌÌÐÕÐÙÙÞÞàÞÕÐÌÃÃ¼ÃÃÊÐÕÙÙÙÞàççççàççïïïïïççààÞÙÕÌÊÃÊÕÞçïïïòòòïïïçïïçà©T,,h¼öýýýýýýýýýýýýýöïïççààÞÞÙÙÙÕÕÕÕÕÐÌÊÃÃ¼¼¼¼ÃÃÃÃ¼ÃÃÌÙÙÙÞàààÞÞÙÞÞÙÙÐÐÊÊÃÃÃ¼¼¸¶±­­­¦¦¢¢¦¦©­±¶¸ÃÃÐÕÙàçàààààçççççÞÕÐÊÊÃÃÌÊÊÊÊÐÕÞàççïïççççïçïçççççÙÕÐÊÃ¼ÞÞÞàààÞÙÙààààçàçÞÕÌÊÃ¸±±±±¶¸¼ÃÊÃÊÊÊÊÊÌÊÊÌÌÕÕÙÙÕÙÙÐÌÊÃ¼¸¸¸ÃÊÐÕÙÙÙÞÞÞààààààçççççààÙÕÐÌÊÃÃÊÐÙÞçïçïïïçïçïçïççÕ¦Y,(hÃöýýýýýýýýýýýøöòçççàÞÞÞÞÞÙÙÙÙÙÞÙÕÌÊÊÊÊÃÃÃÃÃÃÃÃÃÊÌÊÊÙààÞÞÙÙÙÕÙÕÕÌÊÃÃÃ¼¼¸¶¶±±©©¦¢¢¢¢¦­±±¶¸ÃÊÐÙÞÙÙÙÕÙÞÞààÞÞÐÌÃÃ¼Ã¼¸¸¸¸¼¼ÃÃÊÐÕÐÐÌÌÌÌÊÊÃÃÃ¸¸¶±­¢ÞÞÞÞÞÞÞÙÙÞÞàààààÙÐÌÃ¶±­±­­­¶¶¼ÃÃÃÃÃÃÃÊÊÊÊÌÐÕÙÕÕÕÐÐÌÊÃ¼¸¶¸¼ÊÌÐÕÕÕÐÙÕÞÞÞàààààçààààÕÐÊÃÃÃÃÃÐÕÞàçïççïçççççïççàÕP(:ÌöýýýýýýýýýýøöïçïççàÞÞààÞÙÙÙÞÞÙÙÕÌÊÊÊÊÌÊÃÃÃÃÊÊÌÐÊÊÕààÞÕÙÐÕÐÕÌÊÃÃÃ¼¸¶±­­©¢¢¢¦¦¦¦¦¦¦¦¢¢¢~~voooooooohoovoohdb]YYYYPKGC<3<333ÙÙÕÕÕÕÕÐÕÙÕÙÙÞÞàÙÐÊ¸±±­©­©©©±¶¸¼Ã¼ÃÃÃÃÃÊÊÊÌÕÕÕÙÙÕÌÊÃÃ¼¶±¶¸¼ÊÌÐÐÕÕÕÐÕÙÙÞàààÞÞààÞÙÕÌÊ¼Ã¼ÃÃÊÐÕÞàçççççàààççïçïçàP(3ÕøýýýýýýýýýöçççààÞÙÕÐÕÐÕÐÐÌÌÌÌÌÊÃ¼¼¸¸¶¶±­­©¦©©­±­¶¶±©¢~~vvohd]bYYPPPKGGC<CGGKCCCCC<<:33333,((&&!ÕÙÙÙÙÐÐÌÌÕÕÙÞÙÕÕÐÌÃÃ¶­¦¢¢¢¦­±¶¶¸¸¸¼¼ÃÃÃÃÃÃÊÊÌÕÕÙÐÊÃ¼¸¶­­©±¸¼ÃÃÊÊÌÊÃÃÃÃÊÌÐÐÌÕÕÐÐÌÊÃÃ¸±±±¶¸ÃÊÌÕÕÕÐÌÐÕÙààççïïòöÞK&!CÃÙÙÕÐÌÊÃ¼¸­­¦¢¢~voooohh]]YTTTTTTPPNKKG<:3333,(!		ÐÐÐÐÌÃ¼ÃÃÊÌÌÐÐÐÐÌÃÃ¶­¦¢¢¢¦©­±±±­­­­±¶¶¶¸¸¼ÃÃ¼¶­¢¦©¦¢¢¢¦¢¢¢¦©¦¢~xx~~±ÌÞçïïöööÞC&3Pdhhb]TKGGC<:333,,((&&!!	¼¸¸¶¶­¢¢©©©­¶¶¶­¦¢~vvxx~~~~~~xvvxxxxx~xvod]]YTTPPTTT]d]TPPNPPPPKKKNPPKGC<:3,33,,,((,(((&(<o¦ÊÞçïòøýýÐx<!	!!!!!&(,,,3,3333333333xxvood]dddbddddbYYPNKGC<<C<::C<:333:333,33333,,,(!!!!,d¦ÌàïöýýýýÌo:!!!!!!&(,(,,,33:<<CC<CGKKKKKNKNPPPPTYTYbdhoovx~~,(&!&&&&&!!!!!						(h­ÙçòöøýýýÊo3&!!!!!!!&!(&&(,,(,,333333:<<CCCCGKKNPPTTPTTYYTTYY]Y]Yb]bb]b]bbbdddhhooox~~¢¢¦©©©¦©­­©¢¢¢¦©©­±¶¸¼ÃÊÐÕÕÕÕÙÙÞÙÞàçààÞÕÐÊÊÃÃ							<¼Ùçòøýýýý¼~YNNPPPPTY]]]]]]bdhdhooxx~~¢¦­±±¶¸¸¼¸¸¸¸¶­¶¶¶¶±­­©­±­­©©¦¦¦¦©©©­©­±¶¸¼ÃÊÌÐÕÙÙÙÙÙÕÞàààÞÙÐÌÊÃÊÊÊÊÊÃÊÌÕÞàççïïïïïòòòòòòïïççàÞÕÌÊ		!!!!(((33333,33:::CGKTY]bb]G(CÃÞïöýýýýýïÐÃ¼Ã¼¼¼ÃÌÌÊÊÃÃÃÃÃÊÊÌÌÌÌÐÕÕÞàààçàççççççàçààààààçççïïïïïççàààààÞÙÕÐÕÐÐÐÌÊÊÃÃÃ¼¸¸¸¸¸¼ÃÃÃÊÊÌÙÞàçççççàççïçïçàÕÕÐÕÐÌÌÊÌÌÕÙÞççïòöòööøøýöööøøøöïçàÙÐÌ!!!(!&!!((,,,333:<<<<<<<CCGGGGKKKNNTT]]]ddoox~~~~~~~¢­­¶¸¶¸¸b3!PÐçòöýýýýýýýýýýýýýýýýýøöòòòòòïïïïïòöøýýýýýýýýýøøööööòòòïòööøøýøøöïòçïçççàÙÙÙÕÕÙÕÕÌÊÌÃÃÃÃÃÃÃÃÃÊÌÐÐÙÙàççïïçççïòòòòççÞÙÙÐÐÐÐÌÐÕÕÞàçççòøøýøøøøýýøýýýòïçàÞÙÕ33:3<:3::<:::<GKPNGGGGKKNPPPPT]doohd]]doooxx~~¢¢¢¦¦¦­±¶¸ÃÃÃÃÃ¼¸¶¶¶±±¸ÃÌÕÞÞÞàççà¸h3!T¢ÕïøýýýýýýýýýýýýýýýýýýýýýýýòòöøøøøøýýýýýýýýýýýýýýýýøööøøýýýýýýýøøòòòïïççààÞÙÞÞÞÞÕÌÌÌÊÊÃÃÃÃÃÌÌÌÐÐÙàçòïïïòòïïïïòïòççÞÕÕÐÌÌÐÐÕÙÞÞàïïøýýøýýýýýýýýýýööïçÞÙÐ¢¦©±­±­¢¢¢¦©©¶ÃÃÃÃÊÊÃÃÃ¸¶­­±¶¸¼¸¸¸¶¸¸¼¼¼¸¸¼ÃÃÃÊÌÌÌÌÊÊÃÃÃ¼¸¼ÃÌÙàççççççïç­](,h¶àöýýýýýýýýýýýýýýýýýýýýýýýýýøøøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöòööøöòççàÞààààÙÕÕÐÐÊÊÊÊÊÌÌÌÐÐÕÙÞàïïïòòïïïòòöööòçàÞÞÕÕÐÐÌÕÕÙÞàççïòýýýýýøýýýýýýýöòçàÞÙÕÊÊÊÊÌÌÐÊÊÊÊÊÃÊÌÕÐÊ¼¼¸¶±­±­±±¸¼¼ÃÃÃÃÃÃ¸¸¸ÃÃÌÐÙÞÞÞÙÙÕÌÊÃ¼¶¶¸¸¼ÃÃÃ¼¼¸¸¸¸ÃÃ¼Ã¼ÃÃÊÌÌÐÌÌÃÃ¼¼¼ÃÊÐÙàççïïòöòïà¢T(3xÃçýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøööòïïïççàààààÞÙÕÌÊÃÃÊÊÌÌÌÌÐÕÕàççïïòòòïïïïöòòïçààÙÕÐÌÌÐÌÕÕÞàçççòöýýýøøýøýýýýøöïçàÙÐÌÕÕÞÙÕÙÕÐÐÙÞÞÞÙÙÙÙÕÕÌÃ¸¸¶¶¸¸¸ÃÃÃÊÊÌÌÊÊÊÃÃÌÙÞàÞààààÞÙÐÌÃ¸¸¸¼ÃÃÃÃ¼¼¼¼¸¸¸¶¶¸¸ÃÃÊÊÊÌÌÊÊÊÃÃ¼ÃÃÊÐÞççïïïòöööòÞK&!<ÊöýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøööøöòçççççààÞÙÙÙÕÐÊÊÃÊÊÌÌÌÐÌÐÕÞçççççïçïçççïïïççÞÙÕÐÐÌÌÊÌÐÐÙÞààçïòøööòòööøøøööòççàÙÐÌÞÞÞÞÞÙÕÙÙÞÞÞàÙÞÞÞÙÕÐÊ¼¼¸¸¸¼ÃÃÃÊÊÌÐÐÐÐÕÐÌÐÙÞààçççàÞÙÕÐÊÃ¸¼¼ÃÃÃÃ¸¸¸±©¦¢¢¦­¶¸¼ÃÃÊÌÊÊÃÃÃÃÃ¼ÃÊÕÞàïïïòöòòòööÙ<!KÙýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøööòïïçççààààÞÙÕÕÌÊÃÃÃÃÊÊÊÊÌÌÕÕÞàççççààççççççàÞÕÕÐÌÊÃÃÃÌÌÐÕÕÙààçòòòòòòïïöøøöïççàÞÐÌÊÞÞÞÙÙÞÞÞÙÞÞÞàÞÞààÞÙÐÊÃ¼¸¼¸¸¸ÃÃÃÌÐÐÐÐÐÐÐÌÐÙàààçççààÙÕÌÊÃ¸¶¸¼¼Ã¼¸©¢odbdo©¶¸ÃÃÊÊÃÃÃÃÃ¼¼ÃÊÐÙàçïïïöööööòòÌ<!!PàýýýýýýýýýýýýýýýýýýýýýýýýøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöòöòïïçààÞÞààÞÙÐÐÌÊÃÃÃÃÃÃÊÊÌÌÐÕÕÙÞàààÞÞÞàààçÞÞÙÕÐÌÊÃÃÃÃÃÊÊÌÕÙÙàççïïïïïïòòööòïïçÞÕÐÊÊàààÙÞÞÞÞÞÞÕÞààçççÙÕÊÊÃÃ¼¸¸¸¼ÃÊÌÐÌÐÌÌÐÕÕÐÕÙÞààççççÞÙÕÌÊ¼¸¸¸¸¸¸¶©]<(!,Gh¦±¸¼¼¼¼¼¸¶¸¸¼ÃÃÐÙàïïïïïòòïòööïÃo3(]±ïýýýýýýýýýýýýýýýýýýýýýøööøýýýýýýýýýýýýýýýýýýýýýýøýýýýýýøòöööööòöïïçççàààààÞÙÕÌÊÃÊÃÃÃÃÃÊÌÐÌÐÕÕÞàààÙÙÞÙÙÙÞÞÞÕÕÌÊÃ¼ÃÃÃÃÃÊÊÐÐÙÞçïçïïïïïòòòòïïçàÞÕÌÊÊÞàÞÞÙÕÙÕÙÙÞÞààçàÞÕÐÌÊÃÃ¸¶¶¸¼ÃÊÊÌÐÌÌÊÌÐÐÐÕÐÕÞÞÞççàÞÕÌÊÃ¼¶¶¶¶¶±¦P,(T~©­±­±­¶¸¶¶¶¸ÃÌÙàçççïòòòïïòööï¼h3(b¶òýýýýýýýýýýýýýýýýøöööööööøøýýýýýýýýýýýýýýýýýýýøøøøýýýýöööòöòòïïòïïïàçàçççàÞÐÌÊÊÊÊÊÊÊÃÊÊÊÐÐÐÙÕÙÙÙÙÙÙÙÙÕÙÙÕÕÌÊÊÃÃ¼¼¼ÃÃÊÊÌÌÕÙàççïïçïçïïòïïïïàÞÕÌÃÃÕÐÌÕÞààÙÐÐÐÙàààÞÙÐÐÊÃÃ¸¶¶¸¸¼ÃÃÊÌÌÐÌÌÊÌÐÌÐÕÕÕÞÞààÞÙÐÌÃÃ¸¶±­­©¦N!(Y¦¦©©­±¶±¶¶¶ÃÌÙÞàïçòïòòòòòöööç¶],3oÃýýýýýýýýýýýýýýýýøöööøøöööøöýýýýýýýýýýýýýýýýýýøýýýøøöøøöòòïïòòööòòïçççççççàÕÌÊÃÊÃÊÊÊÊÊÊÊÌÌÕÕÕÙÕÙÕÕÕÐÕÕÐÕÐÐÌÊÃ¼¸¸¸¼¼ÃÃÃÊÌÐÙààçççççïççççççàÞÕÌÃ¼¸ÙÙÙÕÕÌÌÐÕÕÙÕÕÕÙÕÙÕÐÊÃ¼¸¶¶¶¸¼¼ÃÃÊÊÌÌÌÌÌÌÌÌÐÐÙÕÞÞÞÞÙÕÌÃ¼¶±­­©¦],&T¦©­©©±­±¶¸¼ÌÕàççïïòöööòïòöøýï¶b,3xÊýýýýýýýýýýýýýýýøøöööööööøøýýýýýýýýýýýýýýýýýøøöööøøýøööòïïòòöööòïïççççççàÞÙÐÌÊÊÊÃÃÃÃÃÊÃÃÊÊÌÌÕÐÐÌÊÊÊÌÌÌÌÃÃ¼¸¶¶­­­­©­­±±±¶¸ÃÃÃÃÃ¼Ã¼¼¸¼¸¸±­­¢ÐÙÞÞÕÌÃÊÌÐÞàÞÐÌÌÐÕÙÐÃ¸­­±¸ÃÃÃÃÃÃÌÐÕÌÌÊÌÌÌÌÕÐÙÙÞÞÞÙÐÌÃ¼¶±­©¦v3		:h¦­­­­±±¶¸ÃÌÕàççïòöööòööøýøýýç¢P,:ÙýýýýýýýýýýýýýýøøööøøöööøøýýýýýýýýýýýýýýýýøööòòòòòòòòïçççççòïçççàààÙÞÐÐÌÃÃ¶­©©©¦¦¢¢¢~vodbddbb]b]YYYb]]TPPPNKGKGC<:3:33,(&ÙÙÐÌÌÐÐÌÌÐÌÐÕÕÕÕÐÌÌÌÃÃ¸¶¶¶¶¸ÃÊÊÌÊÊÌÌÐÌÐÌÌÃÃÕÕÞÞÞÙÕÌÃÃ¼¶­©¦¢P&!P~¦­­±±¶¶¸ÃÌÕççïöòöøøýøýøýýýýýçN(!GÙýýýýýýýýýýøöòïòçççççççççççòööòïçàÞàÞàÙÕÌÊÃ¸¸¸¼¸¶¶±©©©©©¦¢¢¢¢~vxood]]TPPNKKGGG<:<<::3333,,(&!!&!!	ÐÐÕÕÐÌÌÌÊÌÐÐÐÌÐÕÐÐÊÃ¼¼¼Ã¼¸±±¸ÃÌÕÕÌÃÃÃÊÐÕÐÊÃÃÃÌÙààÕÊ¼¶¶±­©¦o3				<o¦©±¶¶¶¶¸ÃÐÙççöòööøøýýýýøýýýýýçG!(PÃÐÕÐÐÌÃÃ¼¸±­¦¢~~xvvohd]YTTPNNG<:3<:333,(&&&&!!										ÌÃÃÊÌÐÌÃ¼¸ÃÊÌÕÐÐÊÃ¼Ã¼¸¶­­±­±¸¸¶¸¸¸¼¼¸¶¶¶±±¶±¶¶¸ÃÃ¼±¦~N!		3]©­­±±±¶¼ÊÕÞàïòòöøýýøöøýýýýýýýýÞ<!!3Td]]TPKKGCC33,(&(((&!					¸¸±±¶­­¦¦©­±±­¶¶­¢~~vvooovxxxvoohhhdPGGG<,				,b¦­±±­±¶¼ÊÐÞççòöööýýöøøýøýýýýýýýÃh3!&!&(,,33333<:<<<CC<<Goooohhddhoood]bdb]bYPG<CGKGG<<3:3:333,3,3,((&((((&							&T¦­­±­¶¶¼ÃÐÞççïïòòöøýøøöýýýýýýýýý¶Y3!!!!!!!!!!!!&&&((((,,3333<<<<CCGKKKKKKKKKNNPPPPTTbdhooovx¦¦¦¢¢(((&&&!&!&!				P¢±¶±­¦©±ÃÌÕÞàçççòöýýöòöøøýýýýýýýýïK,!!!!!!!!!!!!!!&(((((3333333:<<C<CCGGKKPPTTT]bdddbdhoovvvvoooxvvohdhhoooovvx~~¢¦©±¶¼¼ÃÃÌÐÐÕÕÙÙààààÞÕÌÊÃ¼																		&T¦­­±±±¶¶ÃÐÙàçççïööøòöööøýýýýýýýýýï¦v]YY]]Y]]b]]bhdhhohooovx~~~~¢¦¦¦¦¦©©­­±¶¸¼ÃÃÃÃÃÃÊÌÕÕÕÕÐÕÐÌÌÊÊÌÃÃ¼¶­©­­­±­±±±±¶¶¸¼¼¼¼Ã¼Ã¼Ã¼Ã¼Ã¸¸¸­­­©©©©©­±±¶¸ÃÃÌÕÙÙÙÞààççççïïçàÞÕÐÊÊ											3d¦­±¶±¶¸¼ÃÊÐÞïöøøïçïöøýýýööýýýýýýýýøçÕÐÌÊÊÊÊÐÕÌÃÊÊÌÐÐÌÌÊÌÐÕÕÕÕÕÙççïçòçïïïïïïïïïçïçïïïöööòöööøýýýýýýýýöïïïççàÙÌÊÃ¼¸¸¶¶¸¼¼Ã¸Ã¼ÃÃÊÊÊÊÃÃÃÃÊÊÃÃÃ¼¸¶±­­­­­±±¶¸¸ÃÃÌÐÕÞàààççççïòòïççàÙÕÌÊ!&((,(((((33:<CGGKGNKGC3<CC:!				3d¢©­¶¸¶¶¶¼ÃÐÞàçïïöøøøööööøýýýýýýýýýýýýýýýýýýýýýýýýýøøøööööòòöööøýýýýýýýýýýýýýýýøöööøýýýýýýýýýýýýýýýýýýøòïïòïçàÕÌÃ¼¸¼¼Ã¼Ã¼Ã¼ÃÃÃÊÊÊÌÊÊÊÊÃÊÊÊÊÃÃ¸¶¶¶±­­­±­­¶¼ÃÊÌÐÕÙÞààççççïïïïïççÞÐÊÃ,,3333,,,333<GGGKKGKKKNPPPKKKP]hhoooohox~¢¢¢¢~T(					Cx¦©±¶¸¸¸¸ÃÃÐÙçïïööøøöøøøøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøööýýýýýøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöòççàÕÌÃ¼¼¼¼¼Ã¼¼¼ÃÃÃÃÊÊÌÌÌÌÊÊÊÊÃÊÃÃÃ¼¶¶±­­±­±±¶¸¼ÃÊÌÐÙÞààçàççïïïïïççÞÕÌÊÃ~~~~~xvovx~¢©­¶±¶¶¶¶¸ÃÃÃÌÌÕÕÙÕÕÌÊÃ¸¶­­©¢G!		<x­¸¸¶¶±±¸ÊÕÞÞÞàçöýýýøööýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöööòïàÞÕÌÃÃ¸¶¸¼¼¼ÃÃ¼ÃÃÃÃÊÌÌÌÊÊÃÊÊÌÌÌÃ¼¶¶¸¶¶±­­±­¶¸¼ÃÃÊÌÐÙàààààççïïïççàÙÕÌÊÃ¼¶¶¶±©¦¦©©©­¶¸¸¼¼¼¼¶¶¶­©¦©©±±­¶¼ÃÊÊÌÌÌÌÐÐÕÞÞààààààÙÕÌÃ¸¶±­­b,		3d¢©­¶¼¼Ã¼¼ÃÌÕÞçïòöøøýøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýööòïçàÙÌÊÃ¸¸¶¶¸¼Ã¼Ã¼ÃÃÃÃÌÌÌÐÌÊÊÊÊÊÊÊÊÃ¸¸¶¶¶±±±¶¶¶¶¼ÃÊÐÕÙÙàÞàçççççççççÞÞÐÌÃÃÃ¼¸¶¶­­©­­±¶¸¸¼¼ÃÃÃ¼¸¶©¦©­­¶¸¸¸ÃÃÊÌÐÌÐÕÕÕÞÞÞÞààççàÙÐÊÃ¸¸¶¸­­G&Kx¦±±¶¸¼ÃÃ¼ÃÊÐÙçòöøöïïöøýýýýöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøýýýýýýýýýýýýýýýýýýýöòïïççÞÐÊÃ¼¶±¶¸¸¸¸¸¸¼¸ÃÃÊÊÊÌÌÊÌÌÌÌÌÌÊÊÃÃ¼¸¶¶±±±±¶¸¼ÃÃÊÌÕÙÞààÞàçççïçççàÞÕÕÊÃÃÃ¼¸¶±­©¦­­¶¶¶¸¸¼¼ÃÃ¸¶­­©­©­¶¸¼¼ÃÃÊÌÌÐÌÕÐÕÕÙÞààçààÞÙÕÌÃÃ¸¶¶±±¦xC!:o©±¶¸¼¼Ã¼¼ÃÃÊÌÙàïïïòòöööøøööýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøøýøýøýýýýýýýýýýýýýýýýýýýööøýýýýýýýýýýýýýýýýýöòçççàÕÌÃ¼¸¶¶¶¶¶¶¶¼ÃÃÃÃÃÃÊÌÕÐÐÌÐÌÌÐÐÌÊÃÃ¼¼¸¸¶¶¶¶¸¼ÃÃÃÊÐÕÙÞàççççççïçïàààÙÐÊÃÃ¸¶¶±©¢¦©©­¶¸¼¼¸¶¶±©­©©©©­±¶¸ÃÃÃÃÌÌÐÐÕÕÕÐÙÞÞÞçààÕÐÊÃ¼¸¸¶¶¶¶¦vC(3d¦±¸ÃÃÃÃÃÃÃÃÃÊÐÕàççïöööööòòööýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöòöýýýýöøýýýýýýýýýýýýýýýýýøýýýýýýýýýýýýýýýýýýöòïïçààÐÊÃ¼¸¶±¶±¶¶¶¸¼¼ÃÃÊÊÐÐÐÕÐÐÕÐÕÕÕÐÊÊÃÃÃ¼¼¸¶¶¶¸¼ÃÃÊÌÕÕÞàçççççççïçïçàÞÕÕÌÊÃ¶±©ovvx¢¦©­±±¶¶­©¦¢¦¦©­­±¶¸¼ÃÃÊÊÊÊÊÌÌÕÕÙÞÞÞÙÞÞÞÕÌÃÃ¸¸¶¸¸¼¸©xG(!:o±¸¸ÃÃÊÌÌÊÃÃÃÃÊÐÙàçïçïïöøöööòòöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýòçàçççÞÌ¼±­±¶¶¶¶±¶¸¼ÃÃÃÊÌÐÕÕÕÕÕÕÕÕÕÕÕÐÌÊÃÃ¼¼¸¸¸¸¸ÃÃÊÌÐÕÙÞàçïïïççççïçïçàÙÐÊÃÃ­vP:333Gbv¢¢©©©­©¢¢¢¢¦¦¦­­±¸ÃÃÃÃÊÃÊÌÐÌÐÐÐÙÞÞÞÞÙÙÕÌÊÃ¸¶¸¸ÃÃÃ¼¶hN<::Gb~¶ÃÌÌÌÌÌÐÐÌÌÌÃÊÊÌÕÞçïòïòòöööòööööýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøööýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöòççàÞÕÊÃ¸¶±­±­¶¶¸¸ÃÃÃÃÊÌÌÕÕÙÙÙÕÕÕÙÞÙÕÐÊÃÃÃÃ¼¸¸¸¼¼ÃÊÊÌÕÙàçççççççççïïïàÞÙÐÐÌÊY3!(Ch¢¢¢¦¦¢¢¢¢¢¢¢¦±¸¼¼ÃÃÃÊÊÌÌÐÌÐÐÕÙÞàààÞÙÕÌÊÃ¼¸¸ÃÃÊÊÊÃÃ¶©¸ÃÌÌÕÕÙÞÕÙÕÕÐÌÌÊÌÌÕÞçïïöòòööööøöööøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïççàÕÌÃ¼¸¸¶±­¦¦­¸ÃÃÃ¸¸ÃÌÙàÞÕÐÌÕÕÞàÞÕÐÊÃÃÃ¼¸¸¶¶¸¸¸¼ÃÃÌÐÕÙÞçççààààçïçççÞÕÌÌÊÊP,!<d¢¢¢¦¦­­¶¸ÃÃÃÊÊÊÌÐÐÕÕÕÕÙÞàçààÙÕÌÃÃÃÃÃÃÃÊÌÐÐÕÐÌÊÊÊÐÕÙÙÕÙÞààÞàààÞÕÐÌÊÌÕÞçïïïïòööøøøöøøøøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöøýýýýýýýýýýýýýýýýýøöççÞÕÕÌÃ¼¶©©­©­­­­±¸¸¼¼ÃÃÃÊÊÌÐÌÌÌÌÊÊÃÃÃ¸¶­©¦¢¢¢¢¦¦¦¦©±±¶¶¶¸¶¸ÃÌÙàççàÞÕÐÌÊÊÃ(Ko¢¢¢¦©±¶¸¼ÃÊÊÊÌÌÐÐÐÐÕÙÞàçàààÞÕÕÌÊÃÃÃÃÃÌÕÕÙÕÕÕÙÙÞàààçàààçççççàÞÐÐÌÌÐÕÞàçïïïòøøøööööøýøýýýýýýýýýýýýýýýýýýýýýýýýýýýýøøöøýýýýýýýýýýýýýýòïïçöýýøøýýýýýýýýøøøøøøøòçÞÕÊÃ¸¸¶©¢~vovovodYNKKTYTPG<GKPPPKGGGTo¼ÐÙÞÙÕÌÌÃÃÃÃ(Tx¢¦­­¶¼¼ÃÊÊÌÌÌÌÐÐÕÙÙÞàààààÞÕÌÊÃ¼ÃÊÃÌÐÕÕÕÙÙàààçààçççççççççàààÙÐÌÌÌÐÙççïççïòööòïïïïòööøøýýýýýýýýýýýýýýýýøòïïçççççàÞÞÞÞÞÞÞÞçààÙÙÕÕÕÐÃ±©±¸¼¸¶±±±±±©©©¦¦¦¦~o]Y]b]YKC:333:<33,(,,,,,(((&&!!!!	!K¸ÌÕÕÐÌÊÃÃ¼¸	<o¢¢¦¦­¶¸ÃÃÃÃÊÊÊÌÊÌÊÌÕÕÞÞÞÞÙÐÊÃ¼¸¸¸¼ÃÃÌÌÌÕÕÕÙÙÞÞÞÙÞÞàçàààÙÞÕÌÌ¼­­±¶¸ÃÊÕÕÕÐÐÕÕÐÌÊÃÃÃÃÃÃÃÃÊÊÊÌÌÌÌÌÃÃ¼¸±±±­©¢~~~xxxvvooodddYYTPKGGCC:<33((,,((!!!																	P¸ÌÕÕÌÃ¸¸¸¼	&Pv¢©©©©­¶¸¸¸¶±©­±¸¸Ã¼Ã¼Ã¶©¢¢¢¢¢©©¦¢¢¢¢¢¢d]doooo~~~xxxxvvod]]Y]b]]]YYTYTYTTKGCC<:<33(((&(&!													&]¸ÊÊÊÃ¼¸¸¸	:]ovxvoovovx~~~ox~~~~xvohoooooxvood]]TTTTPPNPPNNKKKGCCCC<<<C<<33333,(!!!&&&&(,33333!3o¢¼ÃÃ¼¼Ã¼¼		3CCC<:::::<<<<3333333,3(&&&&(&&!!!!!!&!&!&(!&!!&&!!!!!&!&&!&!&(,,,333CCCGCGGGNPPPTTPTY]dhd]YT]hoxohoo~~]:&:x©ÃÃÃ¼¸¸¸					!!!!!&!&&(((((((,33333::CGGCGGNPTYY]ddddooxxxxox~~~xxxvxvvoooohhhoooooovvx¢¢¦©©¦©­­±±±¶¶±­±¶¶±­©­±¶¼¼Ã¼ÃÃÊÌÕÐÐÊ¦d3!K­¼Ã¼¼¼¸					!!!!&&(&&((,,,,3333<<CGNNPY]bbbdhhhoooooox~~¢¢¦©­­­±¸¼ÃÃÊÃÃÊÌÐÕÙÞààççààààÙÙÞÙÐÊÃÃ¼¸¸¶±­©©¦¦©©©©­­¶¼ÃÃÃÌÕÞÞÞÞÙÞÞÞÞÞÙÙÞÙÕÐÊÊÊÃÊÊÊÌÐÌÌÌÐÕÞÞÞÞààÐ¢T&(]­±±¶¶Ã							!!!(&&(((,,333333<CCCGKKNPPNPPPPTTTT]ddhoovox~~~~~¦­¸¼ÃÃÊÊÌÐÕÐÕÕÌÌÌÌÐÙÙÕÙÙÙÞàààçïïööòøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýòïàÙÐÐÌÊÃ¼¼¸¶±±±¶¸¸¼ÃÃÌÐÕÙààçççççàààçççÞÙÕÐÐÌÌÊÊÊÊÊÊÌÌÐÐÙÕÙÞÞÞÞÙÃP(!T­¶¶¶±	!!!&((333333:::<CGGNPPYY]]Y]Tbdhov~~¦©©©­¶¸¸¸¶¸¶±­©©­©­±¶¸ÃÃÊÐÐÕÕÐÕÌÐÕÕÙÞÞÞççïööýýýýýýýýýýýýýøööööööøøøýøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòççàÙÕÌÊÃÃ¼¼¸¶¶¶¸¼¼ÃÃÊÊÌÐÙàçççççççççàÞàÞÙÙÕÐÐÊÃÃÊÊÊÊÊÊÌÌÌÕÙÙÙÕÕÕÌ¸~C&,]¦­¶¶			!3:<CGNPPPYYbhovxx~¢¦­±¶¶¶¶±±­±¶¸ÃÌÐÙààçòöýýøýýýýýýýýýýøöïçÞÕÐÐÕÙÞàçàççòööòïçïçïïïòòöøýýýýýýýýýýýýýýýýýýýøýýøýøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøïçÞÕÐÐÌÊÃ¼¸¸¶¶¸¸¼Ã¼ÃÊÌÐÕÙÞààçççççààààÞÞÞÞÕÕÌÊÊÊÊÃÊÊÃÊÊÊÌÐÕÙÕÐÕÐÌÊ­x<&,d­±±			&Kbox¢©­¶¶¸ÃÃÊÌÊÊÊÊÊÌÌÐÙÕÙÙÞààÙÙÐÐÐÐÕÞàçïòöýýýýýýýýýýýýýýýýýýýöïçÞÙÙÞààçççïïòöööòïïòïïïïòöøýýýýýýýýýýýýýýýýøøøøøýöööøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòçàÞÕÕÐÌÊÃÃ¼¸¸¸¸¼¼¼ÃÊÌÌÌÕÕààççççççààççàçàÞÙÕÕÌÌÊÊÊÃÃÃÊÊÊÊÌÌÐÕÕÐÕÌÊÃ¦o:!<o©­			<bx¢¢¢¦­¶¼ÃÌÌÊÊÌÕÕÙÙÕÐÕÕÕÙàààÞÞàààÞÞÕÕÐÙÞàçòöøýýýýýýýýýýýýýýýýýýýöïçàÙÕÕÞàçççïïòòïòòïïïïïïòöööøýýýýýýýýýýýýýýýöòòöøýööòòöøøøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòòçàÙÕÌÐÌÊÃÃ¸¸¼¼¼ÃÃÃÃÌÐÕÐÙÞààççïçàààççççàÞÞÙÕÕÐÌÌÊÃÊÊÊÊÊÊÊÌÌÕÐÕÕÌÌÃÃ¢h:Cx©	!Pv¢¢©­­¶¸¼ÃÊÊÌÕÕÕÐÐÐÕÕÕÙÙÙÞÙÙàçàÞÙÕÐÐÐÕÞàçïòøýýýýýýýýýýýýýýýýýýýöççÞÕÙÙÞÞàççïïòöïïïïïïòòïïïïöøýýýýýýýýýýýýýýøööööòòòòööööööøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïçàÙÕÐÌÌÊÃÃ¼¸¸ÃÃÃÊÊÊÊÌÐÙààçàçççïïççççïïïçàÞÙÕÐÐÕÌÊÊÊÃÊÊÌÌÌÐÌÕÕÕÐÌÌÊ¼d3!!G~3]x¦¢¦©©±¶¸¸ÃÃÊÌÕÐÕÌÐÐÐÕÕÐÙÙÙÙÞààààÕÐÐÐÕÕÙÞàçïöýýýýýýýýýýýýýýýýýýýöïçÞÙÕÕÙÞàçççïïïïïòòïïïïïòòööøýýýýýýýýýýýýýýøööòòòööòïïööøøöøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöïççàÞÙÕÌÊÃÃÃÃÃÃÃÃÃÊÌÐÕÕÙÞàçççïïïçïçïïòòïçïàÞÙÕÙÕÐÐÊÊÊÊÊÌÐÐÕÕÕÐÕÌÌÌÌÌÃT(!P(!Kv¢¦¦©©­±¶¸¸ÃÃÌÕÐÕÌÊÌÌÐÐÕÐÕÕÙÞààçÞÙÕÐÌÌÐÕÕÞççöýýýýýýýýýýýýýýýýýýýýöççàÞÙÕÙÞàççïïòòïïçïïòïïïïòòöøýýýýýýýýýýýýýýýöòïïòöòööòïöööýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøöççàÞÕÕÌÌÊÊÃÃ¼ÃÃÊÌÌÐÐÐÕÞàçççïïïïïïçïööøööççàÞÞÞÙÕÌÊÌÌÌÌÐÌÐÕÕÕÕÐÐÐÌÐÌÊ¼G&(TK(3d¢¦¦©­­±¶¶¸ÃÃÊÌÐÕÐÐÐÐÐÐÌÐÕÕÕÙÙÞàçàÞÙÕÕÐÕÕÙÞççöøýýýýýýýýýýýýýýýýýýýøòçÞÕÕÙÙÞààçïïòòòïïïòòòïòòòòïöýýýýýýýýýýýýýýýöööòööòòöööööööøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöçççàÞÕÐÌÊÃÃÃÃÃÃÊÌÌÐÕÕÙÞàçççïòöïïïïòòøöööïçààÞÞÞÙÕÐÌÌÐÐÐÕÐÕÐÐÐÕÐÐÌÌÌÊÊ­o:3xC&3]x¢¦¦©©­­±¶¶¸¼ÃÃÊÌÐÕÕÕÐÌÐÌÐÐÕÕÙÞÞàààààÞÕÐÌÌÕààçòöýýýýýýýýýýýýýýýýýýýýøòïààÞÞÞàçàçïòòïòòïïòòöööòòòòöýýýýýýýýýýýýýýøöòòòòòöòòïïòöøøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýöòççàÞÕÕÐÌÊÊÃÃÃÃÊÊÌÌÕÕÙÕÙààçïïòïçïïïòööööòççàÞÞÙÕÕÐÕÐÐÌÌÌÌÌÌÌÐÐÌÊÊÊÃÊÊÃÃd3©P3!!,Gbx©©±­­­±¶¶¼¼¼ÃÊÌÕÕÕÕÐÕÐÐÐÕÕÕÕÕÞàççççàÞÙÙÕÕÙÞàçòøýýýýýýýýýýýýýýýýýýýýýöççàÞÞààçççïòòòöïòòöööòïòöööøýýýýýýýýýýýýýýøöòòòòòïçïïïòòööøýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýýøòïçàÞÕÕÐÌÊÃÃ¼¼ÃÃÃÃÃÊÌÌÐÕÕÙàçççççïççïïïïçççççÞÕÐÐÐÕÕÌÊÊÃÃÃÌÌÊÊÊÃÃÃÃÃÃÃÃÃÃ¸]3¶©hPG<CN]o¦¦©±¶¸¸¶¶¸¸¼ÃÃÌÌÐÐÕÙÕÕÐÕÕÐÕÙÕÙÞààçççàÞÕÕÕÕÙàççòýýýýýýýýýýýýýýýýýýýýýýøöçÞÞÞààçççïòöòòïïòòööòòòöòööøøýýýýøýýýýýöòòïïïçïçïçççççççïöööøøøýýýýýýýýýýýýýýýýýýýýýýýýýýýøïçàÕÕÌÊÊÃÃ¸¸¶¶¶±±±¶¸ÃÃÊÊÌÐÕÞàààçççççàààççïçàÙÕÌÌÌÌÌÌÌÃÃ¼ÃÃÃÃÃÃÃ¼Ã¼Ã¼ÃÃÃÃ¼¸­T3¶¶­¢x~¢¦­±±¶¸¸¶¶¸¼ÃÊÊÌÐÐÐÕÕÙÙÕÐÐÌÐÕÙÞÞÞàçççààÙÙÕÙÞààïöýýýýýýýýýýýýýýýýýýýýýýøòçÞÕÙÙÞàççççïïïïïçïçïïòòïïïïòööòïòòòöööïïçççççàààÞÞÙÞàÞÞÞàçàçççïçòïööýýøøøòöòòöööòïççàçàÞÞÙÐÃ¸­­©¦¢~xxxxx~¦¸ÃÃÌÌÌÙÞÞàçÞÞàÞààçàààÞÙÕÐÌÌÌÊÃÃÃ¼Ã¼¼¼¼¼ÃÃÃÃ¼¼¼¼ÃÃÃÃ¼¸¶©P(¸¶­©¦¢¢©­¶¸¸¸¶¶¶¸¼ÃÃÃÊÌÌÕÐÕÕÐÕÐÊÌÐÕÙÙÙÙàààçàÙÕÕÐÕÐÙççòöýýýýýýýýýýýýýýýýýýýýöïçÞÕÕÐÕÕÙÙÞàçççççççàçàààààààçàçàààÞààÞÞÞÞÕÕÌÌÊÃÃÃÃ¸¶¶¶¶¶¶±­­±±±±±±­©­©­±©¦¢¢xxvohbTNGC<<::3,(&!!&!&,Px¢¸ÃÊÌÌÕÙÙÞÞÞÞÞÙÞÞÞàÞÞÞÕÕÌÊÊÊÃÃÃ¼¼¸¸¸¶¸¸¸¼Ã¼Ã¸¸¼¸ÃÃÃÃ¼¸¶¦vG¶¶±­­¦¢¢¦©­±¸¸¶¶¶¶¸¸¼ÃÃÌÊÌÌÐÐÌÌÊÃÃÃÃÌÐÕÕÙÕÙÕÕÌÃÃÃÊÌÌÕÙÞàçòïöøýýýýýýýýýøöïïçàÙÌÃ¼¶±¶¶¸¼¼¼¼¼Ã¼¼¸¸±­±­±­­©¦¦¦¦¢~vovoohdb]]YYTPNNNKKKKGGC<33333(((&!!!			C~¦¸ÃÃÌÕÙÙÞÞÞÙÕÙÞÞàÞÙÙÕÕÕÌÌÊÃÃÃÃ¼¼¸¸¶¶¶¸¸¼Ã¼Ã¼¼¼¸¼ÃÃÃ¼¼¸±d¶¶±©©¢¢©­±±­­©©­­­¶¸¸¸¼¼¼ÃÃ¼¶±­­­­±¶¶¸¸¶¶±¦¢¢¦¦¦©¦©­­±±±­­±±­¦~xohdbdhhodhdhdddbYPNKKNKKGCC<<:3333,(&&(!&											G©¼ÊÐÕÙÙÞÞÞÞÞÞÞÞÞÞàààÙÐÌÊÃÃÃÃÃÃ¼¸¶¶¸¸¼¼¼ÃÃ¼Ã¼¸¼¼ÃÃÃÃ¼¸¶­©¢xooddddhoohd]]]YTPPKNNKKKKGGCCCCCCC<:3333,,((&						P­ÃÌÙÞÞÞÞÞÙÞÞÙÞÞÞÞÞÞÙÕÐÊÊÃÊÃ¼¼¼¼¸¸¸¸¼¼Ã¼Ã¼¼¼¼Ã¼ÃÃÃÃÃ¸¶­¢hdbdb]TPNNPPKKKNKKGGG<C<<<<:<33:333,((&&&!!!!				!!!!&&&&!!&&&!&&!!!&(,,(,333,!]¼ÌÐÙÕÙÞÞÞÙÕÙÙÞàààÞÙÕÐÌÊÊÊÃÃ¼¼¸¸¸¸¸¸¸¼¼¼Ã¼¼¸¸ÃÃÃÃÃ¼¸¶±©&&!			!!!!!!!&&(((,(,3333::<CCGGKKKKPTbhooooovoxxxvoooohhh]]dhoovvx~~xhG!3h¢¼ÌÕÙÙÙÕÕÕÕÕÕÙÙÙÙÕÕÐÌÊÃÃÃÃ¼¼¼¶¶±±¶¶¸¸¸¸¶¶¶¶¸¸¼¼¼¸¶±­­©								!!!&&!&&(,,3,,,333:<<CCCKNNPPPPTPPT]]]]b]bbbhddhoooxxxx~¦¦¦¦­­±¸¸ÃÊÐÐÐÌÌÐÐÌÊÌÃÃ¼¼¸¶­¦©­±­©¦©©­©P(3o¦ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÐÌÌÌÃ¼¼¼¸¸¶¶±©­­­­­­±­±­­­­­¶¶¶¶­­¦¢¢			!!!!!!&&((,,33:<<CC<CCKNPYY]Y]Y]]]b]]Ybdooxxxx¢¢¢©­­©­­±±±±­­¶¶¶¶¶±±­©­±±¶¶±¶¶¸¸¸¼¸¸¼¼ÃÊÌÐÕààççççïïïòööööïçàÞÙÙÙÙÙÕÌÃÃ¸¸¸¶¶¶¶¶¶±¶±±­¦xG!G~¦¼ÃÃÃ¼¼¼¼ÃÃÃÃÃÃÃÃÃ¼¼¶¶¶±±­­©©¦¦¢¦¦©­¦¦¢¢¦¦©©©©©¦¢¦¢¢!!!&!!&(,,,3333333<<CCGKGNTTY]]Y]bdhooovx¦©©©©©±¶¸¼¼ÃÃÃÃÃÃÃ¼¸¶±±±¶¸ÃÃÃÊÌÐÐÕÕÐÙÙÞÞÞàÞààçççïçààçàààÞÞÙÙÐÐÌÌÊÊÃÃÃ¼ÃÃÃ¼¼¼¼Ã¼ÃÃÃÃÃÃÊÕààçïçïïçïïöòöòçççààÙÕÕÕÕÐÌÃ¸±±±¶¶±±±­±±¶¶±­¦xC&K¦¶¶±±¶¶¶±¶¶¶¸¼¸¸¸¶¶­­­­­©¦¦¢¢¢¢¢¢¢¢¢¢¦¦¦¢¢¢CGGC<<GKKNKGGPT]b]]]bbddhhhoox~¦©±±±¶¶¶¶¸¸¼¼ÃÊÐÞçççòöýýýýýýýýýýýýýýøòççÞÕÕÐÕÕÙÙàààçççççççïïïççççòöøøòççççïççÞÙÕÕÐÌÌÊÃÃÃÃ¼¸¶¸¸¸¸¸¸¶¶±¶¶¸¼ÃÌÐÞàçççççïïïòöòòïçàÞÙÐÕÕÐÌÃ¼¶­©­­­­­±­±­­±¶¶¶¢o3(Y¦¦©¦¢¦©±­±±­­­©­©­¦¦¦ohoo~¢¢©©­©©­­­­©­­­­¶¶¸¼¼Ã¼Ã¼Ã¼ÃÃÊÊÃÊÊÌÕÕÙÙÕÐÌÌÌÐÕÙÞàççòöýýýýýýýýýýýýýýýýýøöòçàÙÕÕÕÕÞàààÞàçççïçïççççïïïïòööòòïòççççàÞÕÕÐÌÊÃÃÃ¼¸¸¸¶±±­­­©©©­©­­±¸ÃÊÕÕÞàààÞççïööòïïçàÞÙÕÌÐÐÃ±¦¦­©­­­±¶¶±±±o<!(Tvb]]hx¢©©©©¦¦¦¦©¦¢¢]3(!!(<]xÊÊÌÌÊÃÃÃ¸¸¼¼¼ÃÃÃÃÃÃÃÃÃ¼¼¸¼ÃÃÃÃÃÃÃÃÃÊÊÊÊÊÊÊÃÌÌÕÕÕÕÞÙÙÕÕÕÕÕÙÙÞççòöøýýýýýýýýýýýýýýýýýýöïçÞÕÐÕÕÙÙÞÞÞààççççççïççççïïïòöòöòïïçççàÞÙÕÐÐÊÃÃ¼¼¸¸¶­­©©¦¦¦¦¢­¼ÊÐÙÞÞààççòòòòïççàÞÕÕÐÌ¶]KCGPd¢¦©©­­­¶±¶¶¶±Y,(NN3&!<]~¢¢¢¢¢¢¢¢xG!!GdÌÊÊÃÃÊÊÊÃ¼¸¶¸¼ÃÊÊÃÃÃÃ¼ÃÃÃ¸¸¼¸ÃÃÃÃÃÃÃÃÊÊÊÃÊÊÌÌÐÐÕÕÙÕÙÕÐÐÐÕÐÕÙççòöøýýýýýýýýýýýýýýýýýöòïçàÙÕÕÕÕÕÞààççççççïçïççïççïïöööööòïïççàÞÞÙÕÊÃÃ¼¸¸¸¶­¦¦¦¢¢¢vTG<:Kd¦¸ÌÐÕÙÞàççòöøöòïïçàÞÕÌ¢Y3!Go¦­©­­¶¶¸¸¶¶­T(	Go¢¢¢xG3d
\ No newline at end of file
diff -r 8b1af7363833 tutorial/python/presentation/images/fish1.pgm
Binary file tutorial/python/presentation/images/fish1.pgm has changed
diff -r 8b1af7363833 tutorial/python/presentation/images/lettre_a.pgm
Binary file tutorial/python/presentation/images/lettre_a.pgm has changed
diff -r 8b1af7363833 tutorial/python/presentation/images/muscle.pgm
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tutorial/python/presentation/images/muscle.pgm	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,15 @@
+P5
+# Format d'origine visilog
+# Maillage carre
+256 256
+255
+ddhcccchnhcdddn°ÒÎÇÈÜÜÎÇÁÇÇÇÈÇºº¿Á¿ºªª°º¿ÒêóêÜÙÒÒÒÒÎÎÎÈÈÈÈÎÙóöøöçµzzvvv}µÜçÁ}rvvnnrvvrnnnrrrvvvvrnrv}¿áº}}§}®áÕ£}}È¿}}}}}zzvrvrrhhhnz®áóóöÙ}rnnnz£ÕÜÙÕÈÁÁÎÈÇÒÒÎÕÙÜÜÕÕÜÜÕÕÕÜáçöøïªrrvv}}}}}}z}zz}}}}rrnnrnhhhrnhhddºÒÈÇÁÁÎÎÇÁÁÇÇÁ¿ºººÇÇÁ°°µ°¿ÎçóêÜÕÒÒÕÕÒÒÒÈÇÇÈÎÙêöøöÕª}zvrrvz¿çêÎ§}zvzz}vnnnnrrrvvvrnrv¿Î§°°ªÙÙ®}ÁÕ°}}z}}zzz}§®ºÈÜçïóöïµzvnn¿ÙÒÒÕÒÈÇÈÎÎÕÒÒÙÜÜÙÙÙÙÕÕÙÙÙÜáïöóº}rvrvz}}}}}z}}}hvnnrz}rrvvnhdnÇÒÇÁ¿¿ÁÁÁÁÇÁÇÁÁ¿¿ºÇÇÁºººµ¿ÎáóïÜÒÎÒÒÙÒÒÒÎÈÈÇÎÒçóøïÇz}vrvzµáóóáÎ¿ª}zvvrrvrrvvrrnrvÇÇªÇµªÕÙ®£°ÎÈ§}£°ÁÎÕÙÜáêêáÜÜêööÕvrrÈÕÎÎÕÕÎÈÎÎÒÕÕÕÙáÜÜÙÜÙÕÕÙÙÕÙÜêöóÈvzvvz}}}}}}dhnrnrzzrrrrhhrÎÕÇ¿ºº¿ÁÇÈÈÈÈÇÇÁÁ¿Á¿¿¿ÁÁº¿ÎáóçÙÒÎÒÒÕÕÒÒÎÎÈÇÇÎÜóøçµ}}zvvz°áööøöïçÜÕÎµ}zzvvrvrvrnnrvÈÁªµ°£ÒÜ°£®ÁÁ®ÈÒÜáÜÜÙÒÕÕÕÕÕÕÜïöïÁzrºÕÒÒÒÕÙÒÎÎÎÒÕÕÜááááÙÜÙÙÕÙÕÒÒÙçïöÕvvvzz}}}}nnrrnnnrrnnnhhrÕÕÁ¿º¿ÁÇÈÒÒÕÒÈÈÈÁÁÇ¿ºÁÁÁººÈáïÙÒÒÒÒÒÕÙÜÙÒÎÒÈÇÈÜóöÜ°£ª££}µáöøøïÒºÁÎÙáÎµzzvvvrrvrrvÈÁ§°®ÇáºªÇÁºÕÙÙÙÕÒÒÎÒÎÎÈÎÕÒÕçóøçµ}ÈÙÕÕÒÕÕÕÒÒÕÕÜÜááÜááÜÙÙÕÕÙÙÕÒÙÜçóÜ}zzz}rz}rrnrnnhhdnÙÕ¿¿¿ÇÈÎÒÒÕÕÒÒÎÎÎÎÈÇÁÇÇÁÁÁÎçêÙÕÙÙÙÙÜÙááÙÕÒÒÎÈÕêöÕªºÎÜçÙ¿®ÜöóÜÁ§ÁÙáÎ®}zzzvrrnrzÎ¿§ºÜ¿°ÒÎºÁÕÕÕÕÕÕÒÎÎÎÎÎÎÎÕÒÒÙêööçµ£ÇÙÙÕÕÕÒÒÕÒÕÕÕáÜáÜÜÜáÜÜÜÒÕÜÙÕÕÕÜÙêçµ}}ºÁªzvnddr£ÙÙÇÁÁÈÎÎÎÒÕÒÎÒÎÒÕÒÒÎÇÇÈÈÎÎÕçïÜÙÙÙÜÙÜÙÜáçêÜÒÎÎÒêóÒ£ªºÁÇºªÜêÈªvv}§ÁÙÙ¿}}zvrnrvªÙÈ®ÕÁ§ÈêïçÙÕÕÕÕÕÕÒÒÒÒÎÒÒÒÕÙÒÜïøøïçêáÙÕÕÕÒÒÕÙÙÜÙÙÜÙÙááááçÜÙÜáÙÕÒÒÙÜêóÕªÁÇÎÒÎÈÎ¿®}hdzªáÜÕÕÒÎÎÎÎÎÕÒÒÎÎÎÒÒÒÎÈÕÜÕÒÙÙáïáÙÒÎÒÕÙÙÙÜááÜÒÒÒÕçïÇµÜÎzvnrvz}®ÎÜÁ£zvrv}ªÎïÜ°§ÎÈ£§ÁêöêÕÒÕÙÙÙÕÕÕÕÕÒÕÒÒÙÕÒÕêøþþøóáÙÕÕÕÕÕÙÙÙÜÙÜÜÙÙçáçáçáááÜÙÕÒÒÕÜêøóÕ°ÁÇÇÇÇÒÙÙÙÕÈ®zµêçÙÕÕÒÎÎÒÒÒÒÎÎÎÎÒÕÙÕÕçáÒÒÙáêçáÜÕÒÒÒÙÙÙÙÜÙÕÒÒÕÜçê¿£ÁÙ®}vrnnrvvzzÁÙÈª£¿ÒÙÙçïÈ§ÇÒ°¿êöçÙÕÙÙÙÙÕÕÕÕÕÕÕÒÕÙÙÒÒáöþþþóáÜÙÙÙÜáÙÙÜÜÜÜÜÙÜáÜáçáááÜÙÜÙÒÒÕáïøþøá¿ÁÁÁÇÈÈÒÒÕáêçÒµ°ÒïçÒÎÈÒÒÒÒÒÕÙÕÒÎÎÒÕÙÙçêÕÎÎÒáïêÜÙÒÕÙÒÙÙÙÙÕÕÒÒÕÒÙççº§££ÎÇ}zvrnnrrrrv}µÙÙÁº¿ÇÜÜÈ®§ºÜáÁ§ÁáÎªÁïöóóóïáÙÙÙÕÕÙÙÕÕÕÙáÕÒÒÜóøþþöááÜÙÜÜáÜÙááÜáççáÙáááááÜÕÙÜÙÕÕÕáóþþþøïÒ°Á¿ÁÇÇÈÒÎÎÙçïïçêöøêÕÎÒÙÙÕÕÙÙÙÜÙÒÎÒÒÒÕáÜÒÎÎÎÙêçÕÕÒÕÙÙÙáÜÕÒÒÒÒÕÕÙçá°§£®Ò®}zzvrrrnhrvvz¿çóóöïÎªºÜáÁ£¿êá°££ÎóöööóçÜÙÙÙÕÙÙÙÙÕÕÙÜÙÎÎÕçøþþöçÜÜÜÙÙÜÙÙÜÙÜáçáÜÙááççáÜÕÙÕÕÙÙÙÜóöóïïïïêÕ¿®ÁÁÁÇÁÇÈÈÎÕÜááçêöøóÙÒÎÒÙÙÙÕÙÙÙÙÕÕÒÒÎÎÙÕÎÎÎÒÙïçÕÒÙÙÜÙÙááÕÒÒÒÒÒÒÙçá®§ÁÕ}zvvvzvrrhnrvz}£ÕöøóÈ}zz}ºÜáº§¿êáµ§ºµ®§ÕóïçáÙÙÙÙÙÙÙÙÙÜÕÒÒÙÜÙÒÎÎÜöþþöáÕÙÕÒÒÙÙÜÜÙÙáçáÙáááçïáÜÙÕÒÒÙÙÙáóçÈÁÁÁÈÙêïçÈ°§ÇÇÈÈÎÈÈÒÒÒÕÙÙáÜêööáÒÈÎÕÙÙÙÙÜÙÙÙÕÕÎÎÈÒÎÒÒÒÕáóçÕÕÜÜÜÜÜÜÜÙÒÒÒÒÒÕÙáÜª£§ÒÎ}}vzzvvrnrvz}ÁêöÜ§vvvv}¿áÙ°ª§ºêÜ®£µÁµ£®ÜöêÜÕÒÕÙÙÙÜÙÙÙÙÕÒÕÜáÙÒÈÇÕöþþöáÕÕÒÎÎÕÜÜÜÜÜáááááááççáÜÙÙÎÎÕÕÜêçÁ®§£§ª°ÇÜïóáÈ°£ÇÎÒÕÒÒÎÎÒÎÒÒÕÜÙÜóöçÕÎÒÙÙÜÕÕÙÙÕÙÙÙÒÒÒÎÈÎÎÒÕçóçÜÙÜÜáááÜÜÙÕÒÒÒÕÙÙáÙ®µÜ¿zzvz}}zzvrvz}°áïÇzvvvvzÇçÕ®ª£°áÕªµçöçÙÜÙÙÜÜÜÜÙÙÙÙÕÕÕÜáÕÈÇÁÒïþþöáÒÕÕÒÒÜççáÜááçáááÜáááÜÜÙÙÒÎÕÙçïÈ§£§®ÁÎÙêïá¿£ÈÒÒÕÒÕÒÎÎÈÒÒÕÕÕÜïøïÙÕÒÒÕÕÒÎÕÙÜÙÙÕÒÕÒÈÈÈÎÒÕêöçÙÙÙÜçáÜÜÜÜÙÙÙÕÕÜÜçÙªÁÜª}z}}}}}}}}zvz}}ªáá®zrvzvz}§ÎçÎ££§ªÕÎ£ÈóöêÜÙÜáêêáÜÜÙÜÙÙÕÙÜÙÎÇÁÁÈêøþøçÒÒÕÕÜáçïáÜááááÜáçáÜáÜÙÙÕÕÕÙáïÒª££°ººÇÙïçÁ§ÈÎÎÎÒÒÒÈÎÈÒÕÕÕÕáïóóçÙÒÎÒÒÎÎÒÕÜááÕÒÕÒÈÈÈÎÕÙïøçÙÕÕÕÜÜÜÜÙÜÙÙÕÕÕÕÜêÙª§ÎÕ}z}}}zz}}®áÙzvvzzzz}ªÕç¿§ÒÎ§µçøøóÜÕÙÜáççáÜÜÜÙÜÙÙÙÙÎÇ¿¿ÇÜøþþêÙÒÒÕÙÙÜêçááÜÜÜÜáÜáÜÜÜÜÙÜÙÙÜêÙ®££ª®§ªºÕçêÕµÎÎÎÎÎÎÈÎÎÒÒÕÕÒÕççáïïÜÕÒÒÒÎÒÒÕÙÜÙÕÒÕÒÈÎÎÎÒÜóøçÕÕÕÕÙÜÙÙÙÜÙÙÕÒÒÒÜïÕªªÕÈ}}}}}°çÎzzzvvzz}µÜÙ§§ÒÕ®£ºÜöþþóÜÕÕÙÙÜÜááÜÜÙÜÙÙÙÕÈÁºº¿ÕöþøïÜÕÒÒÕÒÙççáÜÜÜÜÜÜÜáÜÙÕÕÒÕÙÙççº££££§£ªµ¿ÕêêÈ£ÎÈÈÎÒÒÎÎÒÈÎÒÒÎÒáááçïáÕÒÒÎÒÕÕÕÕÙÙÕÒÕÒÎÎÎÎÕáóøïÜÙÙÕÙÙÙÙÙÜÜÙÙÕÕÕÜêÕªµÙ¿}ºêÈzz}zzvvz}}ÇÜ¿ªÙÜ°£§°¿ÕêöþþøóÜÕÙÕÙÜááÜÜÙÙÙÙÕÜÙÈÇ¿µ¿ÒóþþóÜÕÕÕÕÒÙáááÜááÜáÜáçÜÕÕÒÒÒÕÜêÙ££££££§°ÈáçÎ®ºÁÁÇÈÎÎÒÕÒÎÒÒÒÒÙáÜÙÜïçÕÙÙÕÕÕÙÒÕÕÒÎÎÎÎÈÎÎÎÕáöøêÜÜÙÙÙÙÙÜáááÜÜÜáÙÙçÒ§¿Üº}}}}}ÁêÎz}}zzvrz}}§ÈÎª§Ùáµ££¿ÎÜáïïöøþþóÜÕÕÙÙáÙÙÜÜÙÙÙÕÕÜÕÈÇÁÁÁÎêøþöçÙÙÙÕÕÜáááçáÜááÜáççÙÕÕÕÕÙáïÇ££®¿ÎÜÜÎÈç¿ÇÇÈÈÎÒÒÒÒÒÒÕÙçÜÕÕÕççÙÙÙÜÜÙÙÕÕÕÒÎÈÎÈÎÎÎÒÕÜóöçÙÙÜÜÜÜÙÜáÜÜÜáÜáÜÙáÒª§Îçµ}zzzz}ÇïÕ}}}}}zvvz°ÎÇª£Ùáµ®ÈçïççêçêïöøöáÕÙÜÜÜÒÎÕÙÜÜÜÙÕÙÕÈÇÇÇÁÈçøþøêÙÜÜÕÕáááçççÜááÜÜááÙÕÕÕÙÜïáª£ª®¿ÜóöøÇÇÈÈÎÒÒÒÒÒÎÎÒÙÜÕÒÒÒÜêáÙÕÙÜÙÕÒÒÒÎÈÈÈÎÎÈÎÒÕÙïóáÕÙÜáÜÙÙÙÜÜÙÙÙÙÙççïç°®Üê°}}zzz}ÈïÙ}zzvvz¿Ò¿§£§£zzÕçºªÁÜêêçÜáçáááçóöêÙÙÜáÙÈÈÕÙááÜÙÒÕÎÈÈÇÁÁÇÜöþþïÜççÜÜÜáçççáÜÜááÜÜÜÒÒÕÎÒáïÇ££ªÁáøþÇÎÒÒÒÒÒÎÎÒÈÎÎÒÒÒÒÒÒÕçêÜÕÒÒÕÒÒÎÎÎÈÎÈÈÈÈÈÈÎÕïïÜÕÒÕÕÙÙÕÙÙÙÕÕÕÕÙáêóïº®Ùá®}}}zz}ÈïÙ}}}zvvz}£ÈÕº£££§§}zvvvÙç¿£®ÎïóêçÜÜÜááááÜçïóçÜÜÜÙÎÎÕÙÙÙÙÕÒÎÎÈÇÇÇÁÇÙöþøöááïçÜÜáçáçáÜÜááááÜÒÒÒÎÒêç®£®ÎïøÈÎÒÕÕÕÕÒÎÎÎÒÎÎÒÎÈÎÎÒÜóêÙÒÒÕÕÕÎÎÎÎÒÒÎÈÈÈÈÈÒêêÙÒÒÒÒÙÕÕÒÕÙÕÕÒÕÕÜáóêµªÙÙ£}}}z}ÎóÙ}}}}zrvz}ªÒÎ®ª§}zvvvvÜïÈ®££§®ºÕïóêáÜÜáÙáÜááÜáêöóçÙÜÙÕÙÙÙÙÙÙÕÒÎÎÈÈÈÈÈÈÙóþþöáÙçááêïïêêçáÜáááÙÙÙÕÕÒáóÕ£µÜöÎÎÒÒÒÒÕÒÎÎÕÙÒÒÒÒÈÈÈÎÙïóáÕÒÕÕÕÎÎÕÕÕÒÎÎÈÈÇÈÒïïÜÕÒÒÒÕÕÒÕÙÜÜÕÒÒÕÜáïç°®ÜÕ}zz}}ÈóÜzzzzrrz}zºÙÁ§z}°êöÙ®§ªÇÜêöóêááÜÜÙÙáÜÜÜÜááêöïáÜÜÙÜáÙÙÙÙÕÒÒÎÎÎÎÒÒÒÜóþþøïÙáçóøøøööïïêçáçáÜÙÒÒÕáïÁªÈóÎÎÒÒÒÕÙÙÕÕÕÜÙÒÎÒÎÈÎÈÒçöêÜÕÒÎÎÎÎÕÕÕÕÒÒÒÈÇÈÙïêÙÕÙÜÕÒÒÒÕÙÜÜÙÒÎÒÙáóç®µáÎ}}}}}}}}ÈóÙ}}}zzzzvvvzrhr§ÎÒ®z}£®µÁÎáöþç°§®ÎêøþöêççççáÜÜÜÜÜÙÙááçïöêÜÙÜçÜÜÕÕÕÒÕÒÒÒÙÜççÜÜÜêøþóçáïøøïÕÙçÙÙêóïçêçáÙÕÜóá®§ÁêÈÈÎÕÕÙÙÕÕÕÕÕÒÎÎÎÎÈÈÎÒáóóçÙÒÎÎÎÒÕÕÙÕÕÕÕÎÈÈÕïïÙÒÕÙÕÕÒÒÕÙÙÕÕÎÎÒÕáóç®ÁçÁ}z}}}}}ÈïÕzzzzzzzzzzznTTr°ÕÇ§®¿ÒÜïööööøøóÁ£µÕóþøøïáááááÜÜÜÜáçÙÙáçááóöçÜáçÜÕÕÕÒÒÕÙáêïïÜÒ¿°®ÇêøøóïóêÎ°§®£ªÇÙêóóêáÙçóÒ££ºáÈÎÎÒÕÕÒÒÕÒÒÕÒÕÕÒÈÈÈÎÒÜïøïáÕÒÒÕÙÕÕÙÕÕÕÕÎÈÎÕïêÙÒÒÕÕÕÒÒÕÙÙÕÕÒÒÒÙáïç°ºáºzz}}}ÈïÒ}zzzz}}}z}}v^L^}ÇÜÇ®§¿ÕáêççÜÜÕÈÁÈáóÙ°®ÕóøøöóçááááÙÜáÜÜÜçáÜÜáááçóïáááÜÙÕÕÒÕáïöïÙº£ªÈïøþøáµ}ªÎêöóêêööÇ££ªª£µÜÈÎÒÎÒÒÒÒÒÒÒÕÕÕÕÕÕÎÎÈÎÙïøøóáÕÙÙÜÙÙÙÕÒÒÒÎÇÈÕïêÒÎÎÒÕÕÕÒÒÕÕÕÕÒÕÙÙÜçç°ºÙ®zvzz}}}}ÇïÕzzzz}}}}r^Xn°ÜçÎ§®ÒêçÎº°§°ÒçÈª§§°ÒóöóïêáááçááÜÜÜÜÜÜçááÜááÜÜêóïççÜÙÙÙÙêöóÙº°Üöþó¿}}}}vv}£¿ÕïöøøöÇ§ª®ÎÎÒÒÎÎÒÒÕÕÕÕÕÕÒÎÎÒÒÎÎÎÙêøþþóçáÙÕÜááÙÒÒÎÇÇÇÒïçÎÈÎÎÒÕÒÒÕÕÒÎÒÙááÙÙçá°¿Ùª}zvvvz}}ÇêÙ}zz}}}}rdd}£ÒóïÇ¿ÜêÕ°ªÈÜÇµºÒóöêááÜÜáçÜÜáÜÜÜÜÜÜááçáççáÜáïóïêÜÜÜáêóÜ¿Çóøá§}zzzzvvzªÈêöþöÇª§¿ÕÙÒÎÒÒÒÒÕÕÒÒÎÎÎÎÎÎÈÈÈÒçøþþøïáÙÒÒÙÙÕÒÎÈÇÁÇÒïêÒÎÈÎÒÒÒÕÙÒÒÒÜóóêÙÙçÙ®ÁÜ§}vvvzÁïÙ}}}}}}zhhzµçïçêÜ¿£}}}§ÒçáêööïáÜááÜááÙÜÜÜáÜÜáÜÙÜçççáêáÙáóøïçáêóóÒªºêöÕ}zvzvzz}}®ÎïøöÈ}z§ºÒÕÕÕÕÕÕÒÒÒÒÎÈÎÎÈÎÈÎÎÎÒçøþþþøóáÙÒÒÕÒÎÈÇÁÁÁÒïçÒÈÎÒÙÙÕÕÙÙÕÙïïçÜÜÜêÕ§ÈÙ£zrrvz}}zÇïÒ}z}}}}rccnÒêóçº}}}}}ºçøøøóçÜÙÙÜáçÜÙÙÙÜÜÙÜÙÜÜÜáçáÜáçááêøøööøøÜª}°áóÈzvvzzzµáööÎvhdhrvÇÒÕÕÕÙÕÎÎÒÎÒÒÎÈÈÎÎÎÈÈÎÒçøþþøöóóêáÙÙÕÒÎÈÁ¿ÁÕïêÕÎÎÒÕÙÕÜÜÙÙáêÙÒÙáÜçÕ££ÎÙvrrv}}}}ÁêÕ}z}}}}}}}}vndrÙóóÈ£}}}z}®ÜöþøïçÙÕÙÜáçÜÜÙÙÕÕÕÙÙÙÜáÜáçÜÜáçáêöþþþøç¿}}ªÜóÇ}zvrv}£ÒóöÎn^XT^^crÒÕÕÕÙÜÙÒÒÒÒÒÒÒÈÎÒÎÈÈÎÎÕçøøêÒÁÇÒÜçççáÙÕÎÈÁÈÜöïÜÕÎÎÎÒÒÙÕÕÕÜÙÒÒÕÙÜáÒ£§ÕÕrrnrz}}}}ÁïÙ}z}}z}}}zz}}zvz°êöá®}}z}}}}}£ÒóøøêÜÜÜÜáÜáÜÜÜÙÕÕÙÙÙÙÜáÜÜÜÜÜÜÙÜçóøþøá¿}}}}§Õï¿}}vrrzºáóÒ£hQQTXXXhvÈÙÕÒÒÙÙÒÒÕÕÕÒÒÈÈÎÎÈÇÇÈÕçêÙÁªª¿ÈÙçêáÜÙÕÙêøöÜÒÈÎÒÒÕÙÕÒÙÕÒÎÎÒÕÙáÒ£§ÕÕvrrv}}}}ÇïÜ}z}}}z}z}}ºêïÁ}zzvz}}}zz}}ÁïöóêÜÜÜÜÜÜÜááÜáÜÜÜÙÕÙÜÙÙÙÜáÜÙÕÙáïþøçº}£ÒïÁ}}zzzvz}ÇêÙ®hXdnh^TcnzÇÕÒÎÈÒÕÒÒÒÕÕÒÎÈÈÈÈÎÈÇÈÙÙÇªªºÎÜêêïóøþöáÒÒÙÙÜáÜÕÎÒÒÎÒÎÎÕÕÜÒ£ªÙÕz}}}zz}}}zz}}}}ÇïÜ§}zz}}}}z}ºêÜª}zvrrz}zvzz}®ÜöóáÜÙÜÜáááÜÜÜÜÜÜÜÕÙÙÜÕÕÙÙÙÕÙÙáêïøöÎª£ÈïÎ}}zz}}}}}§Òçº£vchzvh^X^n§ÎÙÒÈÈÈÎÒÒÎÎÒÒÎÎÎÈÈÈÈÇÎÕº}®ÁÈÙêøøöçÕÕÙÜÜÜÙÕÒÎÎÎÎÎÒÒÒÙÒª£®ÙÒz}}zvvz}}}}}}zzzz}ÁïÜ£zzzz}}}}}¿çÈ}}zvnrvzzvz}ÎïïçÙÙáááÜáçÜÜÜÙÜÙÙÕÜÙÙÙÕÙÕÕÕÜççêöá°ÇêÙ}}}}}}ºçÈ§}hcnnnhd^dv¿êçÕÎÈÎÕÙÕÎÒÒÒÒÎÈÈÇÈÈÎÒÁ}}}}}}}£®ÁáöøïáÜÙÙÒÕÙÙÕÕÒÒÎÎÎÒÒÕÕªªÕÁvrrrrrv}}}}zzzvz}¿êÙ}vz}}}}}}}zzz}Áá°z}}}zrrvz}}zz}}ÈïêçÜÜÜçáÜÜáÜÜÙÙÜáÙÙÙÙÕÙÕÙÙÕÒÕááçêÈºçáª}}}£ÕÜµ£rddhnrvvhr°ÙóÙÜÒÈÈÒÕÙÕÒÒÒÎÈÇÇÈÈÒÕÁ}}z}}}}}£ÁçöóçÙÙÕÒÒÒÕÜÙÕÎÎÎÒÒÕÕÕ®ªÒ°rhnnrrv}}}}}}zvvzºêÎ}vvzz}}}zzz}}zvzz}ÎÙvvzz}zvzz}z}}zzzÇêêçÜÕÙááÜÜÙÙÜÙÙÜçêçÜÙÙÙÙÙÕÒÒÕÙÙÜÜ°}ªÙêºzz}zvv}ÁáÁ§§}nchrr}vªÎïêµÕÙÎÇÈÎÕÕÒÎÎÎÈÈÇÇÎÜÎ£}}}}zz§ÎïïÙÕÒÒÒÒÎÎÎÒÎÎÎÎÒÕÒÒÙ°}ªÎª}nnrrvvz}}vvvºçÁzvv}zzzzzvzzzzzÕÒnnvvz}}}}}}z}}}}¿êêáÙÕÙÜÙÙÕÕÙáÜÜÙÜáÜÙÕÙÜÜÙÕÒÒÒÕÕÜÙª£ÎêÇ}}zvvzzz}}}zzvrr§ÕÒ®ª£vdhvrv§ÁçïÜÁÜÕÎÈÈÎÎÈÎÎÈÎÈÇÇÙÒªzzvzvvv¿çóÜÒÎÎÒÕÒÈÈÈÎÎÎÒÒÒÎÒÕµªÎªvrrvzzz}}}z}}vvvµáºrrv}}zzzz}}zzzvv}®áÁ}ddrz}}}}zzz}}ºçêÜÙÙÙÙÙÙÕÙÕÕÜÙÕÙÕÕÙÕÙáÜÕÕÒÒÎÎÙçÙª¿êÕ}}zzzvrrvzz}zzvrnvÁÙº£rhrrnrª°£®ÙóïáÇÜÙÎÇÇÈÈÎÎÈÈÈÈÒÙºzrrrvvv}}}°ÙïáÕÎÈÎÎÎÎÈÎÒÎÎÒÒÒÎÒÜ¿§ª°Î§zrrrvvvz}}z}zrrr}µç¿rrvzzzz}}}}vvzvnczºçµr^cnz}}}zzz}}}°çêÜÙÕÕÕÙÙÙÙÕÕÕÕÕÙÕÕÙÙÕÙÙÙÕÒÒÎÎÕÜÒ§°Üç®vzzzzvrrzzzzvvrhn}ÒÎª}rrvrnn£¿êóêáz£ÎáÕÈÇÇÎÕÕÈÈÈÎÎºvvvvz}°§}}}ÁçáÙÙÒÈÈÎÎÎÒÒÒÒÎÕÙÒÙçÇ}§£°Î}vnnrzzvzz}zvrnnz®áÇvvzvz}}}}}}vrvvvhcÎê®hX^dvz}}zz}zzv}®ÜêÙÙÕÕÕÕÕÕÕÕÕÕÒÒÕÕÕÜÜÙÕÙÕÕÙÕÒÕÙÜÎ£§ÎïÈvrvvvrvvzzzvrvvrnrµÙ¿£zzvrzÒóöïçvz®ÕáÎÇÇÈÕÎÈÇÎÒº}z}¿µzz}}§ÎÜÕÙÒÈÕÙÜÕÕÕÕÎÎÕÕÕçóÒ}z}zz°Èzrhhrz}}}}}}zvrhhvªÜÁ}}vvzz}}}rrrvrhnÙê§h^^hrz}}zzzzz}}}}vv}ªÙáÙÙÕÕÕÕÕÕÙÙÕÕÒÕÕÕÙáÜÙÙÕÙÕÜÜÕÕÕÜÈ}}Áçá£zvvrrrzzvzvvrrrrrrzÎÕ®§}}}°çóóïêrz}¿ÜÕÈÇÇÈÇÇÈÙÈ}}ª°°°ª}}zz}}}°ÕÙÒÎÒÜêçÜÕÕÕÒÎÎÎÕêöá§}zzzzrvµÈzrhnrz}zzzvz}vrnhv®Üµzzvrz}}}}rnnnrhrªçç§hX^drzz}}z}}zz}}vrv}ªÜáÙÕÕÙÙÙÕÙÜÕÙÙÕÕÕÙááÙÜÙÜÙÕÙÙÕÒÒÜÎzz}µáïºzvrvv}zvz}zvrnrrrvºÜÁ£ÈïóïêênvzÎÙÈÁÁÇÇÈÕÕ®}}}®°}}}}}}}zz}§ÎÜÕÕÕÙÙÕÕÒÒÕÙÒÎÎÕïøêªzvzzzzz}ÁÎzvnnrzz}zvzzvz}zvrvºáµvvvvz}zzz}zrnnnnhvªçáhXXhvzz}}}}z}}}zvrrzµááÙÕÕÙÙÜÜáÜÙÜÙÙÜÜÜçÜÙÕÕÙÕÕÕÙÕÒÕÜÒ}z}§ÕóÒ}zvvv}}zzzvvrnr}£ÕÙ°ªÙóóêççnnrzºÙÒÇÁÁÇÒÕ¿}}z}}zz}}}}zzÇÙÙÜÜÜÕÒÒÎÎÎÒÎÈÎÙïøïº}}ºÇzvvvvzzzzz}®Ùêºzzvvvvzzz}zrnhnnnrªáÕdX^hvzz}}}}}}zrrr}¿ççÜÙÕÒÒÕÙááÜÜÙÙÙÙÙÜÜÙÒÕÕÕÕÒÙÕÒÒÜÎ}}}}Áïá§zzzvzzzz}zzzvnr}}ÁçÎ§°áóïêáçnhnv£ÎÜÈÁ¿ÇÕÇ}zzzz}zzzz}}}µÙÒÈÙÜÙÎÒÒÈÈÈÈÎÎÜóøøÎ§£°°§ÁÇvvvvzzz}ªºÁÈÒÕÙÙÙÜêööÎ}zvvvzz}zrnhnhhr£áÎcX^nzzzz}}}}}vrv}ºáêáÜÙÒÒÒÒÕÙÙÙÙÕÕÕÙÜÙÕÕÕÙÕÒÒÕÕÕÒÜÎ}}z}°áï¿z}zz}vz}}zzzvvzz§Ùáºµáïççáávrhr}µÙÒÇÁÎÕªvzz}}}zzz}}}}}}§ÎÕÇÎÕÕÈÈÈÇÈÎÈÎÕáöþøÜª§££ÇÁvrnrªÁÕÜçáÜÙÙÜÜáçïöøá§}zzzvvzz}zvnnhhdhÜÈhddrzzzz}}}}}zzrvz§ÒáÜÙáÙÒÒÒÒÙÙÕÕÕÙÙÙÜÙÕÕÕÙÙÕÎÒÒÕÕÜÎ}}zrr}ÕóÕvv}zzzz}}}}z}}zvzv¿áÒª£¿çêççççnrrrzÈÜÎÒáÎzvz}}}}}}}}}zzz}ºÒÈÇÈÎÎÈÈÈÈÎÒÕáïöøþï®zvvvvzºº}rnrzÁÕáïêáÜÙÕÒÒÕÒÕÙáïøó¿}z}}vvvzzzvndc^chÜÕvnr}}}}}}}}zzvvvºÙÙÙáÜÕÒÒÒÒÕÕÙÙÙÕÙÙÕÙÕÕÕÕÒÎÎÎÒÙÜÈ}zrhdnÈóê®zrvvz}zzz}}zzvzzvzÕáÁ£Èïêçççánrvrz®Ùáêê¿zzz}}}}}}z}zzzvz}§ÎÒÈÈÎÒÎÎÕÙáçççêóøþöÈzrnnrrv¿µ}nr}ÇçóêççÜÙÕÒÎÎÎÎÎÕÙçóöÜ£}vz}zvvvvvrh^XXdz®çç§zvz}}zzz}}zvrvªÕÜÕÙÜÕÕÙÙÕÒÕÙÙÕÕÕÙÙÒÙÕÒÙÒÎÎÎÒÕÜÎ}}}}vd^XdºêóÎvrvz}}z}}}zvv}vrrÁêá¿§£ª§£®ÙóïçáçÜvnvvv}Èïöç®}}zzz}}}}zz}zvvzzÈçÙÒÒÕÕÜêïçÜÕÕÙáïøøá£}rrvzzzÁ®}v£ÎççáÜÙÜÙÙÕÒÎÎÒÎÒÒÙáçóóÈzvzvrvrnnnrhhv®Ùóï°rvzzzz}}}}zz}zvrv}ÈÜÙÕÙÒÒÕÙÕÒÕÙÙÙÒÕÜÜÕÕÒÒÕÒÎÈÎÎÙçá®}}zndTTh}µêöç®}vv}}}}}}}}zv}znr}®çóáÇµ¿ÒÜÜÙÕÁ®ªÈïóïááÜÜznrrrzºáóÜ£}}vvz}zzz}}}}zzz}}vvrrz¿êïçççêêêçÙÒÎÎÕÙáïöóÎ}z}}}}Áµ°ÙáÙÕÒÒÕÙÜÙÕÒÈÎÎÎÎÒÕÙÜçóêºvrhdhnr§ª°¿ÕêöøöÇrrzzvvvzzz}z}}}zvrvz¿ááÙÙÒÒÙÕÒÒÕÕÙÙÙÙáÜÕÒÎÎÒÒÎÎÎÎÙïóÕª}zzncXXh°çööÈzz}}}}z}}}zzvvvrr}ÕóöïêïóóïïïêáÈºÇçøöóïáÜánnrrrv§ÕóÙ}z}}zz}}vzz}}z}}zz}}}zvvzºêööóïáÙÕÙÕÎÈÎÒÕÙÜïöêµ}zz}ÇÇ®¿ÜáÒÎÎÈÎÎÒÕÙÕÒÎÎÈÎÎÒÒÒÙáïöÜ£}rc^d£ÈáêïïóöøøþøÜvnzzzvvzz}}}}}}}zzzvvz®ÜçáÜÙÕÜÙÒÒÒÕÙÙÜááÜÙÒÎÎÒÒÒÈÎÒáóøóáÎÇµªn^^h°êööá£}}}}}}}}}zzvvvrrz¿ïööøóçáÙÕÙÙáêêïöøøóêçÜÙrvvzrv}ÇêÕznnvzz}}vvz}}}}zz}}}¿êöóêáÕÎÎÒÕÒÈÎÒÒÕÙáïöÙ£z}}}ÎáÜáÜÒÎÎÎÈÎÒÒÎÒÕÒÎÎÎÈÈÎÒÒÙçáïï¿rcd¿çööóïêêêïóøþóºvvzzvvzz}}}}}}zvz}}zz}ÒêçÜÙÕÕÙÒÒÕÕÕÙÜáÜÙÙÕÒÎÎÒÎÎÎÙêóïêêçáÙÜÒÇ°£ª®£}c^h}°êöøïº}}zzzzzzzvvvvrnn}®áöööçÕÒÒÈÈÕÙÜïøøþøóêçáÜz}zzrvz¿çÙvnhnvzvz}zrv}}}z}}}ÎïóïÜÕÒÒÎÒÕÒÎÎÒÒÕÒÕÜïóÎzzÒóóçÕÒÎÎÎÎÎÒÕÎÎÒÒÎÎÎÎÎÎÒÕÙááçóÕ}zÎïöóçÜÜÜÙÙáçêóøÜ§}zzzzvvv}}}}zrv}}zÎïïáÜÙÙÜÜÜÜÜÙÙÙÙÕÕÕÒÎÈÈÒÒÕÜêïçÙÙÜáÙÕÜÜáçÙÁ£zhXXdzµêöøöÎzzzz}zvvvvvvndhv£ÜööêÙÎÎÈÇÈÎÕÙáïøøøïçáááv}}zvrvz°áÜzrrrvvzzzzvvz}}zzzzzzzz}ªÙïêáÙÒÒÒÒÒÒÕÎÎÎÒÒÎÎÕçóïÁ}}§ÙóïáÒÒÒÎÎÒÎÎÒÒÒÒÒÒÎÎÎÎÎÕÙÜÙÙçöóÎµÁáöøóÜÒÒÒÕÒÕÙÜÜçóöÎzzzzvvvz}}zrrrz}}zÈóöóóïóóóóóêáÕÕÕÒÒÕÎÈÈÈÒÜêóóçÜÕÕÜÙÒÕÙÙÙáááÎ§}vnhcdn¿êöøøá£zrv}z}zzzvvz}znv}§áöóáÎÈÈÈÇÈÎÒÕÙÜóøøïáÜáÜvzzzvrrv£ÒÙ£}zrrzzzzz}zz}}}}}}vvvzz}ºçêÜÙÒÕÙÕÒÒÒÎÎÎÎÎÎÎÎÒÜêóêº¿êóçÕÎÒÎÎÎÒÎÎÒÒÕÕÒÎÎÎÒÒÒÙÜÙÒÒÜïøøóöøøöÜÎÎÎÎÒÒÒÒÕÕÜêöïÁ}}}}zzz}}}}vnnrzz}ÙóöóóïïóöøøöóêÜÕÕÒÒÒÒÎÎÕêööêÙÕÕÕÜÙÕÒÕÒÒÙÙÜÜÎª}zvrrv°Îçóøøóµvrzzz}zz}£®µ°ªµºÎïöóÜÎÈÎÈÇÈÎÎÒÒÙçóøïáÜÜÙzvvrrrrvzÈÙ§}vvvz}zz}}}z}}zvvvv}ÈïêÙÒÒÙÜÕÒÒÕÒÒÎÎÈÎÎÈÎÒÜïöç¿ªºÜöïÜÕÎÎÒÒÎÒÒÎÎÒÕÒÎÎÎÎÎÎÒÜÙÕÒÒÙêøøþþøóáÕÎÒÎÎÎÒÒÒÒÕÙÙïöçª}}}z}zzzzvrnnvzÁêóïçÜÜÜÜáçêïïóóêáÙÕÜçÙÙçóøóÙÒÒÎÒÙÙÕÒÒÎÎÕÕÒÕÙÒ®}§µ®ªºÙóøöÈzzzzz}£ÁÒáêïïêïóöøøïÜÒÎÎÈÎÈÎÈÈÎÒÙçöïáÙÙÕ}vrrrrrzÁá°zvvvzzzz}}zz}}zrv}ÒêáÙÕÒÕÙÕÎÒÕÕÕÒÎÎÈÎÈÈÈÕçóöêáêööêÙÕÒÒÕÕÕÒÒÒÒÒÕÕÒÒÒÎÎÎÒÙÒÒÕÕÕçöþþøóÙÎÎÎÎÒÎÒÒÒÕÕÕÕÕÜïóÈ}}zzzzz}}zrvvrnrµáççáÜÕÕÕÕÙÙÙÜááçêêêáÜççêöþøçÎÈÒÎÒÕÒÕÒÎÎÎÒÒÎÒÙçáÁª£°¿®µÙóöÙ}zzz§ÁáóööïçêêêóøþøêÙÕÙÙÒÎÎÎÎÎÎÎÒÜïïáÙÕÕ}vrnrrvºçÁzvvvz}}}}zz}vrz§ÙçÙÕÕÎÎÎÎÒÒÕÕÒÒÎÎÎÈÈÈÈÒÙêöøøþøóçÙÒÕÕÕÕÙÙÕÕÒÒÕÕÕÒÕÒÎÎÒÙÎÎÒÒÒÜöøøöçÕÎÒÕÒÒÒÒÒÒÕÕÒÒÒÕÜóêµ}zvvzz}}zrvzzvvÒÜÙÜáÕÒÒÒÕÙÙÙÜÙÙÕÕÒÙáçêóöþøóÙÈÇÎÒÕÕÕÕÕÎÎÎÒÎÎÒÕçóóÜÒÈÁªzzºáöçª}zv£ÇáóöóçáÕÒÕáÙêöþöáÙÕÜçÙÒÎÒÒÎÎÎÎÕáïáÜÙÜnzvrnrrrºáÎzvvzz}}zzzzzvrµááÕÒÒÒÎÈÎÕÕÕÒÒÎÎÎÎÎÎÈÈÎÎÜóøþþøóÕÒÎÒÕÕÒÕÒÒÕÕÒÕÒÒÒÒÎÎÎÒÜÒÈÒÒÎÙóøöêáÜÕÕÙÙÕÒÎÎÒÒÒÒÎÎÒÙçóÙ§}zvvz}}zvvvzzv}°ÙÕÒÕÙÕÒÒÒÒÕÕÕÕÕÒÎÈÈÎÒÜóøøþøáÈÇÈÕÙÙÕÒÒÒÎÎÒÒÎÎÒÕáóöøøïÁvrv£ÎïïÁzªÕóöóáÙÒÎÈÇÎÜÙÜêóóáÕÒÕÜáÙÕÒÒÎÈÎÈÎÜïçÙÜçnzzrrrnr®ÙÕzvzvvz}}}}}vv}zvrrvvvvÇáÙÎÎÎÎÎÎÎÕÙÒÒÒÒÎÎÎÒÎÎÎÈÈÕáóøþøïÒÈÎÕÕÕÒÒÒÎÕÒÕÒÒÒÎÒÒÒÎÎÙÒÎÒÕÒÙêöçÙÙÙÙÕÒÕÕÕÒÎÎÒÒÒÎÈÎÎÙêïÁvvvvvz}}zzzzzvÇÙÎÎÒÙÕÒÎÒÕÕÕÕÒÒÒÎÈÈÈÎÕêøþøóÜÈÈÈÎÒÒÕÒÒÕÒÕÕÎÎÒÕÕÕçöøøÙ§}zrr}µáóÜªªÙööêÙÎÈÈÎÈÁÇÙÙÕÜçóáÕÎÒÕÕÕÕÒÒÎÎÎÎÒÙêêáÜárvvvrrrv}ÎÕ}vrnrz}}}}zz}}}}zrvzzvrrrvz}ÎÜÕÎÈÈÎÒÒÒÒÒÒÒÒÒÒÒÒÒÒÒÎÎÈÎÕçöøøêÒÎÎÒÙÕÕÕÒÒÕÒÕÕÕÕÒÒÒÒÎÎÒÒÎÒÒÎÕêóÜÒÒÕÙÒÒÒÒÕÕÕÒÕÕÒÒÎÎÎÕÜïÜª}vvvvvzz}}}}}£ÕÕÎÈÒÕÕÒÒÕÕÕÕÕÒÕÕÎÈÈÎÎÕçöøöçÎÇÇÇÈÎÎÒÙÕÕÕÕÒÒÎÒÕÎÈÕïøêº}}}vvz§ÒïóÕÇÜóøïÜÒÇÁÈÒÎÇÇÕáÙÙáïáÕÒÎÒÒÒÒÒÒÎÎÈÎÎÕçêçáÜrvvvrrz}}¿Õ®znhrvz}}}}z}zvvzzvnnrvv}§ÕÙÒÎÎÒÎÎÒÒÒÒÒÕÒÒÕÕÒÎÒÒÎÎÈÎÒáöøøçÎÎÒÒÒÙÜÙÕÙÕÒÕÙÜÜÕÕÒÒÎÎÒÒÎÎÎÈÒçïÙÎÈÒÕÕÕÕÒÒÒÙÙÙÜÕÕÒÒÒÒÕçóÎ}vvvvvz}z}ÁáÕÈÈÎÒÎÒÕÕÙÙÕÒÒÒÕÕÎÎÈÎÕáöøêÕÇÇÈÎÎÎÎÒÕÒÒÒÒÒÒÎÒÎÇÇÈáöÙ£}}}vvz}ºçööóöøöáÒÎÈÇÈÈÎÈÈÒÕÕÕÜçáÕÒÎÒÒÒÒÒÎÎÈÎÎÎÒÜêçÜárrvvrvz°Õº}z}}}zz}zvvz}vrnnrv°ÕÕÒÎÒÒÒÎÎÎÒÒÒÙÕÕÜÙÕÒÒÒÎÒÎÈÒÙïööÜÈÎÎÎÒÒÙÙÙÙÙÕÒÕáÜÙÕÕÒÎÎÒÒÎÎÈÈÎÜçÙÎÈÎÎÒÕÜÕÕÕÙÜÙÙÙÕÎÒÒÒÒÜóçµzrvvv}z}}z£ÕÜÎÈÈÎÎÎÒÒÒÕÙÙÒÒÒÒÕÎÇÎÒÒáóöáÎÈÎÈÎÎÎÎÎÒÎÎÎÒÒÒÎÎÈÇÁÇÜïÎ}}}zvvv§ÕóöøøøïÙÎÈÎÎÈÈÈÈÎÎÒÒÒÕçáÕÒÎÒÒÒÙÕÎÈÎÎÈÎÎÕêïçávrrnrvvz®ÕÒª£££zzz}}zvvz}z}}}}zrrrnrÁÙÕÎÈÎÒÎÎÎÒÒÒÒÕÜÙÙÙÕÒÒÎÎÎÎÈÎÙçóöÜÒÙÕÒÒÒÒÒÕÙÙÕÒÙÜÙÕÕÒÒÎÒÕÒÈÈÎÈÒááÒÒÒÎÒÎÕÙÙÕÙÕÕÕÕÕÕÒÒÒÒÎÒêóÙ£}vvz}}}}z}ºáÕÈÈÈÈÎÎÎÎÒÕÕÕÒÒÕÕÈÇÇÈÒÕÜóóÙÎÈÎÎÎÈÎÎÒÎÎÎÎÎÎÒÎÈÈÈÁÇçï¿}zvvv}ÇïöøøóÜÕÎÈÎÎÎÈÎÎÒÒÎÒÒÒççÙÒÒÒÎÎÕÙÒÎÈÈÎÈÎÕáóïçrvzrrvvz}®Õçº}vvzzvv}vvzzr}ªÕÜÒÎÎÎÒÎÎÎÕÕÕÕÙÜÜÙÕÙÕÕÒÎÎÎÎÒÕÜêóçÕÕÙÕÕÒÒÎÕÕÕÕÕÙÙÙÕÒÒÒÎÒÒÒÎÎÒÎÕçÜÎÎÒÒÒÒÒÕÙÕÕÕÕÙÕÕÕÕÒÎÎÎÎáöóÈ}z}}zzzÈáÒÈÈÈÎÎÒÎÎÒÕÕÕÒÒÕÒÈÇÇÈÎÒÙïóÜÒÒÒÒÎÎÎÒÎÎÎÎÎÎÈÎÎÈÎÈÎÒêáª}}vvvrvµçöøöêÙÙÒÎÈÈÈÎÎÎÒÒÒÎÎÎáïÜÕÒÒÎÈÎÒÎÈÎÎÈÎÎÕÜïóórv}vrrvvz£ÈêÕ£zvz}}£ª®µ°ª£ÒêáÕÎÎÒÕÎÈÎÕÕÙÕÕÕÜÜÕÕÙÕÒÒÎÎÒÕÙÙçïçÕÒÕÕÒÒÎÒÙÕÒÕÕÕÙÙÕÒÎÎÒÕÕÕÒÎÈÈÒçÜÒÒÕÕÕÒÒÕÕÕÕÕÕÕÙÕÕÕÒÒÒÒÎÙóøóÎ§}zzzªÙçÕÎÈÈÎÎÒÎÎÎÒÒÒÒÒÒÕÎÈÈÈÈÒÙêêÜÕÕÒÒÒÎÎÒÒÒÎÎÒÒÈÎÈÎÎÈÈÕêÎ}}vrrªÜöööÜÒÈÎÒÒÈÎÎÒÕÒÒÒÎÎÈÙïçÕÕÒÒÎÎÎÈÎÈÈÎÈÎÕÙêóênnvzvvzvvºççº}}ºº§£®¿ÎÙÜáêêçÜÎµª§®ÎïöçÙÒÎÒÒÎÈÎÎÕÕÕÕÙÙÜÕÒÕÒÕÒÎÈÕÜÜÜçóïÙÕÙÙÕÒÒÕÜÕÒÕÕÙÕÒÕÕÒÒÕáêáÒÎÈÎÒçÙÒÕÙÕÒÒÕÒÒÒÕÕÕÕÙÙÕÒÎÎÒÎÎÕïöøöáÇº°£ÈïêÙÒÒÒÎÕÕÒÒÒÕÒÒÕÙÙÕÕÒÎÈÎÎÙçÙÕÕÕÎÎÒÒÎÎÎÒÒÒÒÎÈÎÎÎÎÎÒÙçÁ}z}}vv}ÕöööáÒÈÈÈÒÎÒÒÎÕÙÕÒÎÈÈÒçêÙÒÕÒÒÒÎÎÎÈÎÈÎÈÒÒáóïnhnrvz}}°áóÙªªºÙçÙÙÜÜÙÜáÙÜÙÎÒÒÒÒÒáïøøêÙÒÒÒÒÎÒÎÎÒÕÒÒÙÙÜÕÒÎÒÕÕÒÕÙÙÙÜêööêáççÜÙÕÜÜÕÒÒÕÕÕÎÒÒÒÒÙÜÜÙÒÈÈÈÒáÕÎÒÕÕÕÒÒÒÒÒÕÕÕÕÕÕÒÒÒÒÒÒÈÎçöøþøöóóçÙÒÒÜóøóÙÒÒÒÎÙÙÒÒÒÒÒÒÕÙÙÙÕÎÎÈÈÎÙáÙÒÒÕÒÒÕÕÕÒÒÕÕÕÒÒÒÎÎÒÈÎÒÙá°z}zz}zzz}zz}ÈóöóÜÒÒÈÈÇÎÎÒÒÒÒÙÙÒÎÈÎáïáÕÕÒÒÙÕÒÎÎÎÈÎÈÎÎÙêónrrvrv}ªÙóóÙÈÈÈÇÈÜêïçÒ¿°§ªª§®®§ªµÎçöøøêÙÒÒÒÒÒÒÒÒÒÒÎÕÕÙÙÕÒÒÒÒÒÒÒÒÒÕÜêöøöóóóêÜÜçáÙÙÕÒÒÕÒÎÎÒÒÒÎÒÎÈÇÇÇÕáÒÈÒÒÒÒÒÒÒÒÕÕÒÕÙÙÕÕÕÒÒÎÎÈÈÙóøøþøøøøþøøþþþóÙÎÎÎÎÒÙÒÒÒÒÒÒÙÙÕÕÒÎÈÈÇÎÜçÙÒÕÕÕÕÕÒÒÎÒÙÜÙÕÕÙÕÒÒÎÒÒÙÙ§}}z}zzvvvrzÁêöóÜÈÎÎÎÈÈÎÈÕÕÎÒÕÕÎÎÈÜóêÕÒÒÒÒÕÒÎÎÎÎÈÎÎÎÕáözvzzzzz}zªÙóööêáÈµµ¿ÇÈÁ§§ÁçööêÙÒÒÕÕÎÒÒÒÒÎÎÒÕÕÕÕÒÒÒÕÒÕÕÒÕÕÜêöóÜÜêöïáÙççÜÙÒÎÎÎÒÎÎÎÒÒÎÈÈÇÇÁÇÙáÒÎÒÎÎÎÎÒÕÙÙÕÒÒÕÕÕÕÕÕÒÎÈÎÈÙóøøöóïóöøøþøþøóÙÎÈÈÎÒÕÒÒÒÎÎÒÕÒÒÒÎÎÈÇÇÎççÙÙÙÙÕÒÒÒÎÎÎÕÙÙÒÕÕÒÎÒÎÒÙÜÒ}}}zzzvvrnrv°çóóÙÎÈÈÎÎÎÎÈÕÕÎÈÒÒÒÈÈÒêïÙÎÎÎÒÎÎÈÈÎÈÎÈÎÈÎÙóvzrz}vrnnv®ÙóóçÈ®£}zz}£ÇêóêÙÒÒÒÎÎÎÎÒÒÒÎÒÒÒÕÕÒÒÒÒÒÒÒÒÕÕÜÜÒºª§¿áïÜÕáçÙÒÎÎÒÒÎÎÎÎÒÒÎÎÈÈÁÁÇÙçÒÎÒÒÎÒÒÕÕÕÕÒÕÕÕÒÒÒÕÒÒÒÈÈÎÜóöïçáÜÜççïöøþøöÜÈÈÈÎÎÒÎÎÒÎÎÒÒÎÎÈÈÎÎÈÈÕêáÙÜáÜÙÕÕÕÒÎÒÕÕÕÒÕÒÒÒÒÒÒÕáÎ}zzzzzvvrnrv£ÕóóáÎÈÈÈÒÒÒÎÒÕÎÎÎÒÒÎÎÎáïÙÎÎÒÒÎÈÈÎÈÈÈÇÇÈÈÕçrvrrrhhhr}£ÒïÙ¿£}}zzzvz}zªÒêêÜÕÒÒÒÎÒÒÒÕÕÒÒÒÕÕÙÕÒÒÒÈÎÎÒÕÜÙµµÙçÜááÕÒÒÒÎÎÎÎÈÎÒÎÈÎÎÇÇÁÇÙçÕÒÕÕÕÕÙÜÕÒÒÕÕÙÙÕÒÒÒÎÎÒÈÈÒêêçáÜÕÒÒÕÕÙçïöøöáÎÇÁÇÈÎÎÎÎÎÎÎÎÎÈÎÈÈÎÈÎÙêáÙÜçççÜÜÕÒÒÕÕÕÒÒÒÒÎÎÎÎÒÕáÒ£zzzvzvvrnrv}ÈïöêÕÈÈÈÈÈÈÒÕÙÎÎÎÎÎÎÎÎÙïáÒÎÎÎÎÎÈÈÈÇÇÇÇÇÇÎÜnnnh}}hhhrrzÈá¿}zzzz}}vz}}z}°ÕçÜÕÕÒÒÒÒÒÒÕÕÒÒÕÕÒÕÙÒÒÒÈÈÎÎÕÜÁz}}zzªÎçáÜÙÕÒÒÎÒÎÎÈÎÎÎÎÎÎÈÇÇÇÙêÙÒÒÙÙÙÜÙÒÒÕÙÙÙÕÕÒÒÒÈÎÎÈÒáçÙÒÕÙÎÈÎÎÎÎÕÙêöøêÎÁÁÁÈÎÈÎÎÈÎÒÎÈÎÈÈÇÈÈÒçïÜÕÙáçÜÙÜÙÒÒÕÒÒÒÎÎÒÒÒÒÎÎÕáÈzzvvzzzvrrv}¿êöïáÒÈÈÎÈÎÒÕÒÎÎÈÎÎÈÎÎÙêçÒÎÎÒÎÈÎÈÈÈÈÈÈÈÇÈÒvnnhvrhhhvz}ÈÎ§}}zzzvrzz}}zz}zvvz}¿ÜÜÕÒÎÎÎÎÒÕÙÕÒÕÕÒÒÒÕÒÒÒÎÒÒÎÙÒ£zrrrrrv§ÒááÙÒÎÎÎÎÎÈÎÈÈÒÒÒÒÒÈÇÈÜáÕÒÒÕÙÜÙÒÎÎÕÙÕÕÒÎÎÒÎÇÇÈÒáêÙÎÎÒÕÒÎÈÈÈÎÎÒÙêöïÕÇÁÇÇÈÎÒÎÈÎÒÎÎÎÒÈÈÈÈÒçêÙÒÕÙÜÜÕÙÕÒÕÒÒÒÎÒÎÎÎÎÎÎÎÒÜ¿zvvvrrvvrvvz°çóóáÙÕÒÒÎÎÒÕÒÎÎÎÒÎÎÎÎÒçêÙÎÒÎÎÎÎÈÈÈÎÒÇÇÇÈÎrnnnvnhhvzrrÈÁ}}}vvv}zzvz}zz}zvvz}}ªÕáÕÎÈÈÎÎÒÕÙÕÕÕÕÕÕÕÒÎÎÒÒÎÒÒÕ¿rrnnhnnvªÕçÜÒÎÒÎÈÈÎÎÈÎÒÕÎÈÎÈÇÇÙÜÒÎÒÒÕÙÕÒÎÎÕÒÒÒÎÎÎÈÈÇÁÈÜêáÒÎÎÒÕÙÒÒÈÈÈÎÒÒÜóóÙÇÁÇÇÈÒÎÎÈÈÒÎÎÎÈÈÎÈÈÒçáÕÒÕÕÙáÙÕÕÕÒÒÒÎÒÒÎÎÎÈÎÈÈÒÜº}}}zzzrrrvvvvzªÜóóçÙÕÕÒÒÒÒÕÒÎÎÎÎÎÎÎÎÒÜêÜÒÎÒÒÎÎÈÈÇÁÁÇÁÁÇÈvhhr}rnhnvnrÒ¿}zz}zvv§zzzvv}}}}}}z}z}£ÒáÕÒÎÎÎÒÕÕÕÕÕÕÕÕÕÒÎÎÒÒÒÒÒÙÒrnnndhnrvv®ÙçÕÎÎÎÈÈÎÎÈÈÎÒÈÇÇÇÁÇÕÜÒÎÎÎÒÎÒÎÎÎÎÒÒÒÎÎÈÈÎÈÈÕêçÕÎÈÎÕÙÒÒÒÎÈÈÈÎÎÒçöáÈÁÁÈÎÎÎÎÈÎÎÎÎÎÈÈÎÈÈÕêÜÕÕÕÒÕÜÙÕÕÕÒÒÒÒÒÒÒÒÈÈÇÇÈÕÜ°}zzzzzrrrrrrrz}ÎïöêÙÒÒÎÒÕÕÕÒÒÒÎÎÈÈÎÒÎÕïçÒÎÎÒÒÈÈÎÇ¿¿ÁÇÁÇÈzrnrzvnnnnn¿Õ°zvz}}z}®®}zvvzzz}}zvvz}ÈáÜÒÈÎÒÒÕÙÕÕÕÕÕÒÒÎÎÎÕÕÕÕÕÜÁnhhhhrvzvnv¿ááÒÎÈÎÈÈÇÇÇÎÒÒÎÇÁÁÁÕçÕÈÎÎÎÎÎÎÎÒÒÒÒÒÈÈÈÎÎÎÒççÙÒÎÈÒÕÕÎÎÒÎÈÈÈÎÈÈÜóïÒÁÁÇÈÒÒÎÎÎÎÈÎÒÈÈÈÈÎÕêÜÕÕÒÎÒÒÕÙÒÕÒÕÒÒÒÎÎÎÈÈÇ¿ÇÕÜª}zzzzzvrrrnnrvz¿êöóÜÒÎÎÎÒÕÕÕÒÒÎÈÈÎÒÒÎÕêêÕÎÎÎÎÈÈÎÈÇÇÈÎÈÈÎrrnnnnrnnnrÕÒvrzzzzzz}vnnv}¿çÜÎÈÎÎÒÕÕÙÒÒÕÕÒÒÎÎÎÎÎÙÜÜÕªznnhv}zrnnz¿ÜÕÎÎÎÎÈÈÇÇÇÎÒÈÁÁÁÁÙáÒÈÎÎÈÈÎÎÎÒÕÒÒÒÎÇÇÇÈÒÜêÜÒÎÎÎÒÕÒÎÒÒÒÎÈÈÈÎÈÕïóÙÁÁÁÇÎÒÎÎÎÎÈÎÎÎÈÈÎÈÙêÜÕÕÈÎÎÎÕÙÕÕÕÕÒÒÎÎÎÈÈÈÇÁÇÕÙ£}zzzzzzzvrrnrrvv}§ÙóóáÒÎÈÎÎÎÎÒÒÒÎÎÈÎÒÒÒÒáïÜÎÈÎÈÈÈÈÎÇÇÇÎÒÎÎnrrnnnhhhnz®ÜÁzvzv}}vv}}}}zvz}vrrz}°ÜáÒÎÒÒÒÒÕÕÒÒÒÒÒÒÕÕÒÈÈÒÜÜÁzrrzzz}vrrnnrzÇÙÕÕÒÒÎÎÒÒÒÈÈÎÁÁ¿ÁÙÙÈÇÈÈÎÈÎÎÎÎÒÒÒÒÈÇÁÈÙçïçÕÒÎÎÎÒÕÒÒÒÒÒÈÈÇÇÇÈÒçóçÇ¿ÇÇÈÎÎÎÎÎÈÇÈÈÈÎÈÈÕçÜÕÒÎÎÒÎÒÕÙÕÕÕÒÎÎÎÈÈÈÎÇÁÁÕÙ}}zzzzzvvvrrvrnvÇêóêÙÎÎÎÎÎÎÎÎÎÎÈÎÎÎÒÕÒÜêÜÎÈÈÈÇÁÈÇÁ¿ÁÇÈÎÇz}vhccdn}µÙ®}vz}}z}}}}}zvrzz}}}}}}vrrrv§ÕçÕÎÒÒÕÕÕÕÒÒÎÕÕÕÕÕÎÈÈÎÙÒ£}zzzvnnhnrnnhrv}§ÒÜÕÒÒÒÈÈÒÒÈÇÇÁÁ¿ÇÙÒÇÇÎÈÎÎÎÎÎÒÒÒÕÕÈÇÎÜïöóáÕÎÎÎÎÕÕÒÒÎÎÎÈÎÈÇÁÁÈÙóïÒÁÇÇÈÈÎÎÈÎÈÇÇÇÎÈÇÎÙêÜÕÒÎÎÎÎÒÕÕÒÒÒÎÎÎÎÎÈÈÈÇÁÁÕÕvvzzzzzvzvvvzvnhr}®áóóÜÒÎÎÕÒÎÎÎÒÎÎÎÎÒÕÕÒÙêÜÎÈÈÇÇÁÁÁÁ¿¿ÁÇÁÁr}zzrdc^^hÁÎzvvz}zzvzz}zvvvv}}vzzvnnnv}ÇáÜÒÎÒÕÒÒÒÒÎÈÒÕÒÎÎÎÎÎÒÙÁzzvrhhhhhnhhnhrv°ÕÕÈÎÎÇÁÇÈÈÈÇÈÈÇÈÙÒÇÇÈÈÎÈÎÎÎÒÎÒÒÎÈÒçóïïçÙÒÒÒÎÎÕÒÎÎÈÎÈÎÈÎÇÁÁÇÎêóáÎÈÈÈÎÎÎÈÎÈÇÇÁÇÇÇÈáïÜÕÒÎÎÎÎÎÒÒÒÒÒÎÎÈÈÈÈÈÇÁÁÇÒÒvrvvzzzzzzzvnhnvÕóóçÕÕÕÕÕÒÎÎÒÕÙÒÈÕÜÕÎÒáÜÎÇÈÇÁ¿¿¿¿¿¿¿ÁÇÎhhhhhcdcdvÒÇvrnrvvrnrz}zvzzv}}vzzzvnrr}°ÜÙÒÎÎÒÒÎÒÎÈÇÎÎÎÈÎÎÒÒÕÒ£zrnnhddnhhndchhhrv¿ÙÒÎÈÇÁÈÎÎÈÇÎÎÁÎÜÒÇÇÈÎÈÎÎÎÎÒÎÎÎÒÕçïçççÙÎÎÒÒÒÎÒÒÎÒÎÈÈÈÎÎÈÇÁÁÈÜóïÕÒÎÎÈÈÎÎÈÇÇÁÁÁÇÁÎáïáÜÙÜÜÙÕÙÕÕÕÕÒÎÈÈÁÁÁÈÁÁ¿ÇÕÒvnrrz}zzzz}}rnnnrÇêóïáÕÒÒÙÕÕÈÎÕÙÒÎÎÕÒÎÈÙÜÎÇÇÈÇ¿¿º¿¿¿¿ÇÒçnhnhnr®ÎêÇzvrrvvvrnzzvvz}vvzz}}zzzrrrzÈÕÎÎÒÕÎÎÎÎÈÈÎÎÎÒÈÈÎÒÙµndddhdhnhdhhdhdhnn}ÈÕÒÒÎÒÕÙÒÈÇÇÁÁÒáÜÎÇÈÈÒÕÒÎÎÎÈÈÎÒáêáÜçáÒÈÎÎÒÎÎÎÎÎÒÎÎÈÈÎÒÈÇÁÇÇÕïóçÙÕÒÕÕÕÕÕÎÈÇÇÁÁÇÒçêÜÕÕÜáççÜÙÕÕÕÒÈÈÇµ°º¿ÁÁÇÈáÒzvvvz}}}}}}}zrnnhn°çóïáÕÎÎÒÒÒÎÎÎÎÎÎÎÎÎÎÇÒáÕÈÇÎÎÇ¿º¿¿¿ÇÙêï}rrvªÁÈÈÕçïÕ}zvvvvzvrvvrvvzvrv}z}zzzvrrvzºÒÎÈÎÒÎÈÎÈÎÎÒÎÎÕÒÎÎÕÈrhccdndhnnhnhhhhhhnrªÈÒÎÎÈÇÒÒÈÈÇ¿ÇÙïêÙÈÈÎÒÒÈÇÈÈÈÈÒÒÙÙÕçêÜÎÈÈÎÈÈÈÎÎÎÒÒÎÎÈÎÎÎÇÁÇÇÒçöóêçêêïóïïêáÕÒÈÇÈÙïïáÕÒÎÒÙÕÕÒÒÎÎÒÎÇÁº°°ºÁÇÒÜêÒ}zzvrvzz}zzzvrnhdnz£ÙóóáÒÎÎÎÎÒÒÒÎÎÎÎÎÎÎÈÁÎááÒÇÁÇÁÇÁÁÁÎÜïá¿µ£®ª£ªºÒÕ§vrrvzz}zzzvrrzvrrz}z}}}zvrnnrv®ÕÒÈÈÈÇÈÈÎÒÕÒÒÎÒÙÒÕÕµ}hhddhhnrnhdhnhnhhhhrvºÎÇÁÇ¿¿Á¿ÁÁÁÎÙêçÕÒÎÈÈÈÈÈÈÈÇÇÎÕÎÒÙêêÙÒÎÎÎÈÈÎÎÎÎÎÕÒÎÎÎÎÈÁÇÁÇÎáóööööïçççêïïïêáÜÜïöóçÙÒÎÎÒÎÈÎÒÈÈÈÇÇÁÁÁ¿ÁÎÙçóöÙzvvvvvvzvvzvrnhdhvÎïóçÕÎÈÎÈÎÕÕÒÎÈÎÒÎÈÇÁÈáïáÈÁÁÁÇÇÎÕáêÒ°çÎ®vrhnv¿°vnrv}zrrzzzvzz}zz}}}zvnrrz}ÎÙÎÎÈÇÈÈÎÒÒÎÈÎÎÙÙÕÎrhdddhnrrvnhhhnnhnhhnrzÇÎÈÇ¿¿¿º¿ÁÈÙÜçáÎÎÈÁÇÈÈÎÎÈÈÇÎÕÒÕáïçÕÎÎÎÒÎÎÈÎÎÈÎÒÒÎÎÎÎÈÇÇÁÁÒçöööïçÜÕÕÙÙÜÜçïóóöøøöêÕÒÒÒÎÈÈÎÎÎÇÇÇÇÈÕÙÜçêóöøøá§}rrvvrvzzvvrrnnhhnºçóêÙÈÈÈÎÎÒÒÎÒÈÈÒÒÎÈÈÎáóïÙÇÁÁÇÎÜêáÁ}ïÈrcc^Xcddv°rhnvz}}}vvz}}zvzvvzz}}vrvvz}¿ÙÒÈÈÈÈÎÎÎÎÈÈÈÈÒÜÜºhddcchhhnrrhdhnnnnhnrnv¿ÙÕÎÈÇÁÇÎÙáçááÜÕÈÁÁÇÒÜáêêçÜÙÙÕÜïóáÎÈÈÎÎÎÎÎÈÈÈÈÒÒÒÎÎÎÈÇÇÇÇÒçóöêÜÜÕÎÎÎÒÒÕÜááêóöøøïÙÒÎÎÒÇÇÈÎÎÈÈÈÕçïóóïêçêóöê°}z}zrrvzrrrnnhnhhz®çóóáÎÎÎÎÎÎÎÎÎÎÇÈÎÇÈÈÎáóöçÎÁÈÒÜçÕ®}zvÙ£rcX^^Xc^^h}£vnrrrrvzzzzz}zzzvv}}zvvzzvz®ÙÕÈÈÎÎÎÒÎÈÈÈÈÈÒÜÙrhdccdddhdhrhcchhhhhhnnnµááÙÕÒÜáïóóïççêÜÎÇÎÙêïçÜÜçêïêêïöóÜÈÇÈÈÎÈÎÎÈÈÈÎÒÕÒÎÎÎÈÈÇÇÇÕêóêÜÙÙÒÎÎÎÎÒÒÙÕÕÙçóøöïÕÈÈÈÈÈÇÇÈÎÎÕÜêïçÙÒÁµ°ºÎáêÇ}}vnrrrnnnhhhhdr§ÜóóçÒÎÎÎÈÈÈÎÎÎÈÇÇ¿ÁÇÈÜïöóÜÕÙáÒº}vvrrºzd^X^^Xcc^dr}nnnvnrvr}zvzz}zzvzzzvnnnrv£ÕáÎÈÈÎÎÎÈÈÈÈÈÈÕáÙndcc^cccddhrndccdhhhhnnh}µçïïêêïêçáçêêïóïÜÜêïçÁ§§µÈáïóöïÙÈÇÇÈÎÎÎÎÈÎÈÎÒÒÒÎÒÎÎÎÈÈÎÜóïÜÕÒÒÕÒÎÎÈÎÒÒÒÕÙáêóöïÒÈÇÇÇÇÇÁÇÎÜçêÜÈ°§§ÁÜÕ§}v}}rrrnnhhhhdccnÙóóêÕÎÈÎÎÎÎÈÎÈÇÇÁ¿ÇÇÈÕêööóïêÒ§zvrrrnhcc^^^XX^cch§nhnvvrrrr}vvv}}}vrzzz}zvnhddrzÒêÜÒÎÎÎÈÇÇÇÇÇÎÙÜÇnccc^cddddhnnhhddhnnvrnnÁçóóóïáÒÎÎÒÕÙçóööóöá°zvz}°ÎêóêÒÇÈÈÈÎÎÎÎÎÎÎÎÒÒÒÎÎÎÎÎÈÇÎáóêÙÒÎÒÒÒÎÎÎÎÒÒÒÕÙÜáêóïÕÈÇÇÇÇÇÈÒÜÜÒÁ°§ÁÎµzvvvvrnnnrhhdc^XdÒïóóáÒÈÎÒÈÈÈÈÈÁÇÇÁÈÈÈÒÜïööïÒ£}vrzvrnr^^^^^^TTXc^^z§zrnrvvvrnvzvvz}}vrz}zvvrnhddr}ÒïêÜÎÈÎÈÈÈÈÇÇÎÙÁrdcccdhhndhhhhnhhrnnzzzvÒïïïçÙÕÈÁÇÇÈÎÙêöööç°}nnnrv}ªÒïçÒÁÎÒÒÎÒÒÕÕÎÈÎÎÒÕÒÎÎÈÈÈÇÒêïÜÕÎÎÎÒÒÎÎÒÒÒÒÒÕÙÕÙáïïÙÎÎÈÈÈÎÕÙÎµ§£}ªµ£zzzzrrnnhhdcTTcÒïóóïÜÎÈÎÈÈÈÈÈÁÁÈÇÇÈÎÒÕêööÙ§}zvv}zrndXX^^^^^TXX^Xh£º}zrvrrrnrzvvvzzrvzzzrnnnhhdrºáóóêÙÎÎÒÎÎÈÈÈÕÕ£}rdccccdnnhhhdddhhhhdcnzzzÕïïçÙÒÕÈÇÁÇÇÇÒáïöóÎnhnrvrv}µÜÜÈÇÇÕÙÒÎÎÒÒÎÎÎÎÎÎÒÎÎÇÇÁÇÕïçÕÎÎÎÎÎÒÒÕÕÕÕÒÒÕÕÒÕÙêóçÒÎÈÎÒÕÒµ£}v}§®}zvnnnnhdhhd^^h§ÜïóöóêÕÎÈÈÇÇÇÈÇÇÈÇÁÈÒÒÕçóóÈvvvvzzrn^T^^X^^^XXXTXcÇ§}vvrnhnz}zvrvvvvvrvvrnhhrz°ÙêêïïáÕÕÒÒÈÎÒÕÙ¿rnd^^^dnrvhdddddhhhhhdnnnz®áêÜÜÕÎÒÎÇÇÈÈÇÎÙïóêµ}rrnvzvvv}¿ÒÈÇÁÈÒÎÈÈÎÎÎÎÎÎÎÈÎÎÈÇÁÁÈáïÜÎÈÎÈÈÎÒÕÕÕÕÕÒÒÕÕÒÒÕçóïÜÒÒÙáÎ®}zz}}}}§}z}vhhdhr}£ÎïóöööïÙÒÎÁÁÇÇÈÇÁÇÇÁÇÈÎÕçóóÈvrrnnnrr^TXXTX^cccc^cc¿ª}zzvnnnrzzzvrrrvvnhnrrnhrªÁÕÙÙÜÜáêêáÕÒÒÕáêÜ£vdhhcX^dr}nhnrrhddnhhhhhÁçÜÕÒÈÇÎÎÈÇÈÒÈÎÙçóÙ£zrvrnrvrrz}£ÇÇÇÇÈÈÈÈÈÈÎÎÈÈÎÎÎÈÎÈÈÇÇÎçïÕÈÈÎÎÈÎÒÕÕÒÒÒÒÒÒÎÎÎÒáóóïáçïá°}zzzzz}}zz}§}vnrrnv}ºÎÕÒÈÈÈÙêööööóáÙÙÈ¿ÁÁÇÁ¿ÁÁ¿ºÇÈÕêóïÁznnnnhhrTXXXX^^^c^^dc^v®®}z}vvrnhnrvvzzvvrzvnhnnhhhzªÒÙÒÈÈÒÎÒÜïïáÒÒáïóÕnddnc^^cd}££}nnvvndhhhhhhv£ÕÜÕÎÎÈÇÈÎÈÇÈÒÈÈÕçêÁvrzvrrvvvvz}ºÇÇÇÇÈÈÈÈÎÎÎÎÈÎÈÈÈÈÎÇÁÁÕïçÎÇÇÈÎÈÎÒÒÒÒÒÒÎÒÒÒÒÒÒÜïóöóóêÎ}zzzzvvz}zz£®vdhnvºÕáÙ¿ª£ÁáóóöóáÙáÙÁ¿ÁÇ¿º¿¿ººÁÎÙêóçµzvrrrrnhvLT^XX^^^dcX^XTd§¿rrnrrnhnrrvvzzvvvvvrhnhdh¿ÙÒÇÁÇÇÁÇÒÜïïááêóóÇ}hc^hn^^X^dvznhhddhdcchrÇÜÙÎÈÈÈÈÈÈÈÇÈÎÎÎÒÜÜ®vv}vrrz}zrv}°ÈÇÇÇÇÇÇÈÎÎÒÎÎÈÈÈÇÇÈÈÁÇÜïçÎÇÁÈÎÒÒÒÒÒÒÒÒÎÒÒÒÒÎÕÙêóöïÙÇª}}}zvvvzzzzº°nnvºÕÎ°rd^chzºÜïóïÜÎÕáÈººÁÁ¿¿º¿ÁÇÎÜïóç°vrnrrrnnrLTX^X^^^^XTXTTh§Èvrrrrrnrnnrvvvvvvzzvhhdh}®ÎÎÇÇÁÁÁÁÁÇÒçïóóóöóºr^XXcvncXX^chz}rncdccc^^d}°ÙÙÎÎÈÈÇÇÈÎÈÈÈÈÎÈÎÙÕ§zzzvvz}}vv}§ÈÈÈÈÇÇÇÈÎÎÒÒÒÎÈÇÇÇÈÈÇÎáóÜÎÈÇÈÎÒÎÒÒÕÕÒÎÈÎÎÎÈÎÎÕçóóÜ°}zvrvvvvv§Ç®ºÈ°n^TQLT^hv°ÙïïáÎÈÜÕÁºº¿ÇÇÇÈÎÒÙçïöêºznnnrvzTTXXTX^^XTXXTTn®ÙµzvrrrrrhnnrvrrrvvvvnddzªÎÎÁÁÁÁ¿ÁÇÁÇÈÙêóöööê®nXXT^hndcXcdchvrd^chhcc^r§ÕÙÒÈÎÎÈÇÇÎÎÈÇÇÈÇÇÎÕÈrr}zzzz}}vvv}ÇÒÈÎÎÈÈÈÎÎÎÎÎÎÈÇÇÇÇÈÇÒêïÜÎÈÈÈÈÎÎÒÕÕÒÒÎÈÎÎÈÈÈÈÎÙçïÈ}zzrrzrnrvzºÕÈÎÕÈv^TTQLLLTXcnµáïêÕÇÎÕÎÁÁÁÈÙÜÙÒÈÒÙêóïÇ}vnnnrv}}QTTTTTXXXTX^TXn§ÜÕ£}zrrrnhnrrrrvvvvnnhdrÎÜÎÁ¿¿¿º¿ÁÇÁÈÎÜïóööê§hXXX^chhcchdcchnhdcdhhchÎÙÎÎÎÈÈÈÈÈÈÈÈÈÇÎÈÈÎÙÈrv}zzzz}}vrvzºÕÕÎÈÎÈÎÒÎÈÎÈÈÈÈÈÇÇÇÈÕïïÜÎÈÈÎÈÎÒÒÕÒÒÒÒÎÎÎÎÈÎÎÎÒááµ}}zvrvznrrzªÙêêÜ§vcTXTQLLLX^cdrÎêïáÈ¿ÇÈÈÎÕÙÙÇª£ºÙêÕ£znnnnrrrHTTQTTQQTXcdc^h£ÙçÎ®£§£vrnnhrz}vnhcdhÁÜÕÈÁ¿¿ººÁÈÁÁÇÈÕÜçïóáhX^^cdhhcdhccdhv}ndnv¿ÜÕÈÈÈÎÈÈÈÎÈÈÈÇÈÎÎÈÒÙÇrzzvvzzzvvvvv}§ÕÙÎÇÈÇÈÒÒÈÈÈÈÈÈÈÎÇÇÈáóïÜÎÈÈÎÈÈÎÒÕÒÎÒÕÕÕÙÒÎÎÎÎÒáÙª}z}}}vrz}nnrv}ÎïïÎd^T^cTLQLLX^cd}°ÜïçÒÁ¿ÁÈÕÎºvnhrz®ÕÜ¿zrnhhnrhCLTQLQTQTX^cc^h£ÙïêÙÒÕÕÕÒÇªvnhrzzrhhcXhÎÕÈÇ¿ÁÁ¿¿ÇÎÇÁÇÎÒÕÕáïÙdX^ddhrhddccdhhv}rhzÁÙÕÇÇÈÈÎÎÎÈÈÇÇÇÇÈÈÈÈÎÕÇzzzvvzvvrrvrvv}ÈÜÒÇÈÈÇÈÎÈÈÈÈÈÈÈÎÇÇÒêóêÜÒÈÎÎÈÎÎÒÕÒÒÕÕÕÕÒÒÎÎÒÎÒÜÒ}}}}}}vnvnnnvzÇêê¿d^TcdXTTQLQX^^nÎêïÜÈÇÇÒÇ}rhdc^dnr£ÈÕ®rndhrrhCFQLQTTQQTXXXXh§ÜêÙ¿ª£§µÈÙÙÇ§rvzznhd^^}°ÈÇÇ¿¿ÁÇÇÁÇÎÈ¿ÁÈÎÎÈÒçÙhchnndhhhdddhhccdccdhµÜáÈººÇÇÈÎÎÎÈÇÁÇÈÈÈÈÈÎÕÈzvnnz}zvvrrvvv}ÁÙÒÈÇÇÇÇÈÈÈÎÈÈÇÇÇÇÈÙïïçÙÕÈÈÎÎÒÒÒÒÒÒÒÒÒÒÎÎÎÒÒÎÒÜÇ}z}}}zvnvrhnrzÇêÙ§zdd^ccXXXTXXT^Xd}°áïêÜÙÜÇvhhdccXcddn}£ÎÎzhhdnrhFFLQTcXQQTXTX^r®ÜÙªndhr£µÎÒ°}zrhdccn£ÁÇÇÁÇÁÁÇÇÇÇÇÁ¿ºÁÈÇÇÎÜÙddv}nccdhnndcc^XX^ccÁçÕÁµµ¿ÁÇÈÎÈÈÇÇÎÒÈÇÇÇÎÒÈ}rhrv}vvvrnvzvv°ÕÎÇÁÁÁÁÇÇÈÈÈÈÇÇÁ¿ÈÜóïÙÒÒÈÎÎÎÒÒÎÎÒÒÒÎÎÎÎÎÎÎÎÎÕÜ¿z}}znv}rnnr}Èáµnddhd^^^TXX^X^^crÕêóïïÜ£vhccdc^^cdcdn}®ÕÁrhhhnvHFLQTc^T^XTTXcvµÕ°}d^XXXcn}ºÈºvhddnÁÕÒÎÈÈÈÁÁÇÁÁÁÁÁ¿ÁÇ¿ÁÈÕÙdXcnzvd^dhrrd^^d^c^XdÒÜÎº°µº¿ÇÈÈÈÇÇÎÙÕÈÇÁÁÈÕÎ}nnvvvvvrnnvzvv£ÈÎÁÁÇÁÇÇÇÇÈÇÇÇÇ¿¿ÈçóêÕÎÎÎÎÎÎÒÒÒÎÎÒÎÎÎÎÎÎÎÈÎÈÕÙ°}}}z}}}zv}znnnrzÎÕvd^chdcc^XTTTTX^^h¿çïóê¿hdX^ccXXcc^ccnÈá°vnhnhHHHXQTTTXXTTXd}¿Îh^XX^^^^^hºº£ndnz£ÎÒÒÒÈÇÇÇÇÁÁÁÁ¿¿¿ÇÁÁÁÇÎÙ®n^X^^cccdhnndXXc^^^cvµÙÕÇµµµµº¿ÇÇÁÁÇÈÎÇÁÇÁÇÎÕÎvrrvvvzrrrvrrzÁÒÇÇÇÇÇÇÇÇÇÇÇÇÁ¿¿ÎêïáÒÎÎÎÒÒÎÒÒÒÎÒÒÎÎÒÎÎÎÎÈÈÎÕÒ§}zz}}}zzvvvnnnnzÒÈhc^^dddd^XXXQTX^^dvªÜïïá§rdcXX^^^X^X^^cd}ºçÕ£}vrrhLHLcTXTQTXTQXcÈÁ^TTXXXTXX^drª°ªrrµÕÎÇÈÈÇÈÈÇÁ¿ÁÁ¿¿ÁÇÁÇÇÁÇÙÁc^c^XX^cdhdcXXXXXcdÒÜÈÁºµµ¿¿¿¿ÁÇÁÁÇÇÁÁÁÁÈÒÙÒ£zzvrrv}zrrnrrrvµÙÒÈÇÈÈÈÇÇÁÇÁÁ¿¿¿ÒêïÙÈÈÎÒÒÒÎÎÎÎÈÒÒÎÒÒÒÒÒÎÎÈÒÙÈzv}}z}}}zvzrnnnnz£Õºzc^^chdddc^c^QT^^^cnÒêïÒnd^XX^cc^XXXX^cnÒá¿rnrnHFLXXTTQTXQQTdÈªrQLTTQQLT^^^^h}µµ§£¿ÙÙÈ¿¿ÇÁÇÇÁ¿¿ÇÇ¿ÁÇÇÁÇÇ¿ÁÒÎhdnc^^^^dnd^^cX^cc}µÜÕÇ¿ºµºÁÁ¿¿ÇÈÇÇÇÁÁÁÁÇÈÕáÒ}}zvzzvvvrnrnnr}§ÕÕÇÇÈÎÈÈÇÇÁÁÁ¿¿¿ÙïêÕÈÇÈÈÈÎÈÈÈÎÈÒÒÒÒÒÒÒÒÒÎÈÒÕÎzvvz}z}}}}}zz}vrrnrz§ÕªnX^X^ddddccccXXXX^chÁçêÁ}hh^Xc^cdd^^XXXccv£ÕÙ§zrnnLHLT^TXQQQLQTr®º^QLQTLLLQ^cXX^hzºÎÕçêÙÁ¿¿ÇÁÁÁÁÁÁÁÁ¿ÁÇÇÁÁÇ¿ÁÈÎnhnddcX^dhccccX^cnÙáÎÇÁ¿¿ÁÁÁÁ¿ÁÇÇÇÇÁÁÁÁÁÈÕêÒzvzvrvrrrrrrrnnrzÎÙÈÁÁÇÇÇÇÇÇÇÁÁ¿ÇáïáÒÈÇÈÎÎÎÎÈÈÒÒÒÒÎÎÒÕÒÒÒÒÎÒÙÇzzzvz}}}zz}}}zzzvvvrnrzªÕ£hTX^T^^^ccddcc^XX^^dz°áêºzccc^ccchd^^^XXTX^z°ÜÎzhdTLLX^XTQLLLTX}µ£dTQLQQLLLTX^TTXcdz£ÎçïêÕÁ¿ÁÁÁÁÇÇÇÁÁ¿ÁÁÁÈÈÁÇÇÈÈÎ§rdc^cd^^cdc^c^XcnÁáÜÎÁÁÇÇÁÁÇÁÁÇÇÁÁÇÇÁÁÁÇÈÙêÒzvrnnrnnrrrrvnhrvÁÜÎÁÇÁÇÇÇÇÇÇÇÇÁÈçêÙÈÈÇÈÎÈÎÎÎÎÎÒÕÒÒÎÒÒÒÒÒÒÎÒÙÇzzz}}}}}}}}}}zzzvvrnnn}®Õ£cQTXT^^X^ccccXc^^c^^n£Ùê¿z^^cc^^^cc^^XXXXTTdÁáÁndTLLT^XQQLLQTcºXTQLLQQQQTX^TQXXcnµÜêçÎÁ¿¿¿ÁÇÎÈÇÇÇÁÁÇÇÈÎÁÇÈÇÁÈµ}cXXXc^^ccc^^^X^r§ÙáÒÈÇÇÇÇÁ¿¿ÁÇÇÁÁÁÁÇÈÇÁÁÈÕçÇzrnhnnhnrrrrvnnnrµáÙÈÇÁÁÁÇÈÒÎÈÁÇÕêêÕÈÎÎÈÈÎÎÎÎÎÎÎÒÒÒÎÎÒÒÒÒÒÎÒÙÇzzz}}}}}}}}}zzzzvrnhn}ºÙ§cQTTTX^X^^^^^XTTX^X^hÕêÇcXTTTT^^^^^XXXTQTXdÒÙ®nHLQQTTQQQQQXh®vQTTLQTTXXX^^TQT^^dvÎçÜÈ¿º¿¿ÇÎÎÈÇÁÇÁÁÁÇÇÇ¿ÁÁ¿¿ÎÁdXXXX^^ddc^X^XcÁáÜÎÇÇÇÇÁÁÁÁÁÈÈÇÁÁÇÇÈÈÇÇÈÕÙµrnhhnhnrrrrrvnhrvµçáÕÈÈÇÇÇÎÈÈÇÇÎáóïÕÎÈÎÎÎÈÎÎÎÎÎÈÎÎÎÎÎÒÒÒÒÎÎÒÕÁ}}}}}}}}}zvzvrrnhnÈá°hTTXXX^c^XX^XTTT^^^^dÈêÒcTTQTTX^cXTXTXTTTXTr®ÙÕª}HLLLQLLQTQQcz®§dQQQQQTXX^XcccTXXXcd}°ÜÕÁººº¿ÁÇÇÇÁÁÁ¿¿ÁÇÇÁ¿¿ÇÇÁÈÎh^XXTTXcc^X^c^hÙçÕÎÈÈÈÇÇÇÇÇÇÇÈÇÇÇÈÈÈÈÇÇÇÎÒ®nhhnzzrvrrrvvnhhn¿çïêáÕÒÎÈÇÁÁÇÎÜïóóÜÒÈÇÈÎÎÈÎÎÈÎÎÈÈÎÒÕÒÒÒÎÎÈÒÕÁ}}z}}}}zzvrvrrnrr}ªÙêÇzXXTXTcc^XXXXXTT^ccXc}¿çÜd^TQTTTXcXTTXXTTTQQX}ºÜÕHHQLLLLLQQTc¿^TQLQXTTX^^ccddXXTXcnÒÕ¿¿¿¿ºº¿ÁÇÁÁÁÁ¿¿ÁÁÁÁÁÁÈÎÎÕªrc^XTX^^^^^^cc}ÁçáÒÈÈÎÇÇÁÁÇÇÇÇÈÇÈÎÈÈÈÇÇÁÇÎÒ§}rhvvrrrrnnhhdnÈêïïïïêáÙÈÇÁÇÕçóóóçÕÈÇÇÇÎÈÈÎÈÈÎÎÎÎÒÕÕÕÒÒÎÈÒÕÇ}}z}}}zzvvvrrhhn}£ÒêïÕ^TXXX^cXTTXXXXX^ccXXn®áç®rcTTXXXTTTQQXXXTQLLQ^ºÜºQLQQQLLLHLTdÁcTQQTXTT^^cddhncXXTXdÇÒÁÁÁ¿¿ºº¿ÁÁÇÁÇÁ¿¿ÁÁÁÁÁÇÎÒÕ°vcXXXXX^ccXX^dÙêÜÈÇÇÇÇÇÇÁÁÇÈÇÇÁÇÎÎÈÈÇÁÁÇÎÈ}}vrnnrnnnhhdn§ÜêêêêïïóïáÕÒÒÜïóóóêÜÕÎÈÈÎÎÎÈÈÈÎÎÈÎÒÕÕÒÒÒÎÎÎÒ¿}zzzz}}}z}zvrnnr£Èçïóç§dXTX^^^TTTTXX^^Xcc^TdÕêÁcTTXTXXTTQQTTTTTQQLL^ÇÕLLQLTTQLHLXh£ÁXQLLQQQT^^cdnhh^^^TQd¿ÎÇÁ¿º¿ººµ¿Á¿ÁÁÁºº¿Á¿Á¿¿ÁÇÒÁ}^XTTTTXhcT^^z¿ççÒÇÁÇÇÁÇÇÁÇÇÈÈÇÇÇÎÎÇÁÁÇÇÇÈÇvnnnnnrrrnhddÇçáÕÒÒÕÜçêóïêêïóïçÙÎÈÕÕÕÕÒÒÎÎÎÎÎÎÎÎÎÎÎÒÒÎÎÎÎÒº}}}zvzvvz}}zvvrrv§ºÎÕáïïï¿rTTTXXTX^cdhdcX^c^XT^ÈêÕhXXQQXTTXTQQQTQTTQLLQhÒTLLLQTQQXTXnª°cLHQLQXX^^cccccXT^TXdµÎÁ¿º¿º¿ºº¿¿¿Á¿ºµ°µº¿ºººººÇÁXTTXXTX^^TTdÒêáÎÁÁÁÇÇÇÇÁÇÇÇÇÈÈÎÎÇÁÇÁÇÈÈÈ¿zzzrhhnrnnnrrnhd}°ÜáÒÇÁ¿¿¿ÇÎÜêóóóÜÇµ§ºÈÕÕÕÕÎÎÎÒÎÒÒÎÎÎÒÒÎÈÎÎÎ°}}zzvvvvvv}vvvr}ÇÒÇ°®ºÕêïÙTLTQQQXX^ddhdcXXXXTXz¿çá§r^TQQTTXTTTTTQQXTQQHQXnXQQTTQQQTT^z°£rv^LQLQX^^cc^XX^XXXX^h}°ÎÁ¿ºÁ¿µºÁÁ¿ÁÁºº°®®ºÁ¿ºµµµ¿Ç^T^hd^TTTQTnªáêÜÎÇÁÁÇÁÁÁÇÇÇÇÁÇÎÈÈÇÁÇÇÇÇÇÈµrnhddhnrrrrrrnhv£ÕÜÒÒÈÇ¿µµµ°¿ÒêïÜ°°ÈÙÙÕÎÎÒÈÈÎÎÒÒÒÕÒÎÎÎÎ°}}}}rvvrrzzvv§ÈÒµªÈáçµdHQQQQQTTTX^cc^^XXXXn®áçºz^XXTTXTTTTTXTQXXXLLQT^vQTT^TQQHQT^µ^rzdTQQXXdnhc^Xc^^^dddzªÎÇººÁ¿ºº¿ÇÇÇÁ¿ºº®®¿Á¿µµ¿ÇÈÒµhQXXTTQLHLTv¿ççÕÇÁÁÁÇÇÇÇÁÁÇÁÁÁÁÇÇÇ¿ÁÇÇÇÈÈ§rnhhhhnnrvvrnnrÇÜÒÈÈÎÈÁº°µªªÁçáºz}}§ºÎÕÒÒÎÎÈÎÎÒÎÈÎÒÎÈÎÈ§}}z}}rrrrrvzz°ÎÇª}zz}£ÈçÙTLQQTQLQTXX^cc^XXTQh®áêÈdXX^cXXXTTTXTXX^^QLTTXdQQTTQQLHQXd°zTXnvdTTT^dvndcccccccddv§ÎÇº¿¿¿ºº¿ÁÁ¿¿¿¿¿°µÁÁ¿¿ÈÙÙÕÙÁzQLHLLHHCFXÎêáÎÁ¿ÁÇÇÁÇÁÁÇÇÇÇÁÁÁ¿¿¿ÁÁÇÇÈÈ}rhnnhnhnrzvnnvºÕÒÇÁÁÁÇ¿ºµº°ªÁáÙrrz}zz}£ºÎÕÒÎÎÎÎÎÎÈÎÈÈÈÎÇ}zzz}}zvrrrrrrrzµÒ¿£zzvvzªÒçÇzLHQTTQQT^^dccc^XTTn°áïÙhXTX^XX^XXTXXX^cTQTTXX^LTTQQTQLTcn®zQLcz}dXT^hrnc^cc^cc^ccnÈÇ¿ººº¿¿º¿¿ºµºµµµº¿¿ÇÈÒÒÈÈÙÒc^c^^TLCFd§áêÙÁ¿¿¿ÁÁÇÁÇÈÈÈÇÇÁÁÁ¿¿¿¿ÇÈÈÈ¿zrhdhhnnrvrnnn¿ÜÕÈÁºº¿ººµµº°®ÁáÒrrv}zvrr}}ªÁÒÕÒÒÎÎÒÎÎÈÈÇÒÇ}vzzzzzvvrrrnn}ªÁÒµ}zvvrv}µÜáªXHLQQTTXX^hc^c^XTXh§Ùêáªn^XXXX^c^XXX^^XXTQTTTXTHQTQQTTXccr£ªnLQTcrdX^cnnh^X^c^c^^ccnÎÇºµºµººµººººµµµµºº¿¿Á¿ºµÁÙçÇªª°°®£ncÇêïÙÁºº¿ÁÁÈÇÇÎÒÎÇÁÁÁÁÁ¿¿ÁÁÈÈÎ°rhdnrzvrrhddhrÒÜÒÈÁÁ¿¿¿¿ºµ°®°ÎçÈvvz}zzvrzz}ºÎÕÒÒÕÕÒÎÎÇÈÒÁzzzzzzzzzvrvrrºÕÎ°}}zrrvvvvÁáÒ}QLLQXXXX^c^cc^TTT^¿çêºzcX^XXX^XX^^c^XXQLLLQQQHLQLLTTT^cv§hQTXTTTTchhdcXX^c^^^^ccnÇÇµ°µ°µµººº¿ºµºµºµ°µµºµººÇáïêÙÒÙÙÜÜÙÁµÇáïïÙÁº¿ÁÁÁÇÇÁÇÈÈÁ¿¿ÁÁÁÁÁÇÁÇÈÎ§rhnzrndhdhrz§ÕÙÎÈÇÁÁÁÁÇÁº°ºÎáç¿vzz}}}zzzzz}}}}°ÎÕÕÙÜÕÒÈÇÇÕµ}zvrvvvvrvrvzz£ÒÒ°}zzrnrrrn}Îá°hQQLQTXXXX^ccXTTQThÙêÒd^^^X^cXX^^ccXQHC??FHLHLLLHQLTTdªhcXXQQTXcddcXX^^^XXTX^^cºÈ¿ººº¿¿¿ÁÈÈÇÁÁÇÁ¿µµµºº¿ÈÙêêÙÁµµº¿ÈÒÙáêóóïÒ¿º¿ÁÁÁÇÇÁÁÁÇÁÁÁÁ¿ÁÁÇÁÇÇÎÇ}rv}}vrhhrvrrrºÙÕÈÇÁÇÇÁÇÁÁÁÇÒÜÜÙ®zz}}zvzz}zzz}}§ºÒÜçáÕÈÇÇÒ°}}zvrnnrrrnnv}ÁÒ®}zvrrrrnv®ÙÕ^LLQTTXX^^c^XXTTTcÈêÜ§n^^c^^cX^^c^^TLC5..3?HQLLLHLLLXhª}dcXQQTXX^^X^X^XX^cXXXXX^}ºÒÈÇÇÇÈÈÎÙááááççÜÎÇÁººÁÈÙççÕÇ°ªªªª®µÁÈÜêïïÙ¿µ¿ÁÇÇÈÈÇÁÁÁÇÇÁ¿¿¿ÁÁÁÁÇÎµ}zzvnhnnnvzrnvÎÜÒÈÁÁÁÁÇÇÇÁÁÎÕÒÒÇ}zz}zzv}}zzz}}}°ÕçêÜÎÇÈÕ°z}}rrvrhhv¿È®}z}}vrvvrnrzÈáµnQHLQXcXXX^X^cXTXXvµçêºv^^^^XX^X^XXXQF;.+++3;TTQQHHLLXh§rXXTTTX^^^XXXXcccdc^XXXXc}ÁáÙÕÒÒÎÎÎÒÕÒÕÙÜáççÜÙÒÕÜáêêÙÈ¿®ª§£§ªª®ºÈÜïïÜÁ¿¿ÁÁÁÈÎÇÁ¿ÇÇÁÇÁÁÇÁ¿¿ÁÈÎ£}zvrnhhnrnhhhnºÜÜÒÇÁÇÁÇÇÁÇÈÇÁÇÇÎº}}zzzvz}zz}}µÙççÒÈÕÜµ}ªµº}rnnµÈ®}}}vrrnvvrvvrnnr®ÙÙXQHLXcc^^^X^^XTTTh£ÜêÒd^^XT^^^XTTXQH;...+.?XQTLLLHLQh£nXTTT^^^TTTT^T^ccccc^^cXcÇçáÒ¿®££°¿ÎÙçêïóïÜÎÁµ®ª§§§ª§ª°ºÎêïçÈ¿ÁÁÁÁÁÇÇÁ¿ÁÁÁÁÁÁÁ¿¿¿ÁÎ¿}zvnhhdnrhnhnrÎçÙÎÈÈÈÇÁÇÁÁÈÇÇÇÎÒ®z}}}zvzzz}}}zz}°ÎÜÙÕáçº}ª°rn°Î°}zzzvvrnrvrvrnhnnvÇáµhLHLQTX^dd^X^^TQQ^ÒêÜ£n^^TQT^^XQQTQH?33;CHTQQQQQLLLTh£dTTQX^^XTXTX^XX^^^c^XXX^hÒÜÁ£}zvvvzzrhnr}°ÙêóïçÈ¿º°®ªªª°°®®°°ÁáïçÎÁ¿ÁÁ¿ÁÇÁÁ¿ÁÁÁÁÁÁ¿º¿ÁÇÎ°zzzrnnnnhhnnn}°áÜÎÇÇÈÇÇÇÁÇÇÈÈÈÎÒÈ£}vz}}z}}z}}}z}zzz}£ÇáçêêÈzvrnvzrrz§È°}zzzzz}}vrrvvrnhhhr°ÜÒTLQQQQXdh^XX^XQLTz¿çç°r^^XXTXXTQQTQLFFQhªTQLQTQQLQv§c^^TX^XXT^XXdcXXX^XTTTTTh£ÕÁvrhhnnnndccnrrzºáïêÕ¿°°®®ªªª°µµ°®§µÒççÒÁÁÁ¿¿¿Á¿¿¿ÁÁ¿Á¿¿¿¿¿ÁÎÈzvvvrnnvhhdhhnÎáÒÁ¿ÁÁ¿ÁÁÁÁÁÇÈÈÈÎÇzvz}}}}}}}}}}zvvrv§ÒêïïÙ£zrhdhhhhvÁµ}zz}}}zz}zvrvvrhhhvÎá°nQLLTQQ^dcX^XXQHLhªáêÁ}^XT^^^^TQQTTXh£¿ÈÁµQQLTXQLLTª}X^cTX^XTTXXTccXXXcXTQQQQrµÒ§rrrhhnnnhdhhnrnnzÈçáÎµ°®ª®ª§ªªªªª§£ªÁÙáÒÈÇÇÁ¿ÁÁ¿º¿¿ÁÁÁ¿ºµºÁÇÎºvrnhddvvhdddhzªÙÙÇ¿Á¿¿¿ÁÁÇÇÇÁÇÇÇÈÇzvv}}}}}}zrrrvzÁçïïçºvhhdhhnµ¿zz}}zvvz}zvvrnhhhn¿áÒXHLTTQTcc^XXXTHHXÕêÒcTTTXXTTQQ^h®ÈÒÇªrQLLQQHFHQ§zXT^XXXXTTXXTXXT^XXcXQLQTÈÎrhrrhdhrnnrznnrdhh}®ÕÜÁµ®ªª®®ª§§§§££££®ÁÕÒÇÁÇÁÁÇÁÁÁÁÁÁ¿¿ºµµº¿ÇÇ£}vrhc^cnhdcccnÁÜÎÁ¿Á¿¿ÁÁÇÇÇÇÁÁÇÁÈÎvrvz}}}}zz}vrzzvºáïïïÜÁ®zrddrÈ°}}}}zzzvrnrvvvrrnnhhhz§ÙçµrQHLQQLQTTXTTTQHL}ÈêÜdTQQQQTQTcz£ÁÎ¿£rdXQLQTQFCCHzrQLTXTT^^TQTTXXQXXXcdTLTn§Õ¿rnrzrhnnnnrrdddc^cnÈÕ¿µ°®®®®ªª§§££§°ÎÕÇ¿ÁÁÈÎÇÁÁÁÁÁÁ¿¿ºº¿ÁÇ°zvndc^ccdhdddvÒÜÈÁÁ¿¿ÁÁÇÁÇÇÁÁÇÁÁÈÎvrvz}}}}}}zvvz}ºáïïóïáÒÈÇµ}¿Õ®}zz}}zvzvrrrvzzrvrnhrnrÎçÙ^LHHHFFLTTTTTTQLnºçç°nXQHHHLQhµ¿µndcXTQQLLHC??FrnLLQTTTX^QQTTX^TXTTcndThÎÈzhhnzznhhnnhnd^cccchÈÎ¿°®°®ª®°ª§ª§££§ªÁÙÈ¿¿ÁÈÒÒÈÇÇÁÇÇ¿¿¿¿¿ÇÁ}vvnhd^^cdnhdh°ÜÕÇÁ¿¿ÁÁÁÇÈÈÈÇÇÇÇÁÒÎvvv}}}}}zzvz}ÁçïïêáÒÈÈÎÎÇ¿ºÈáÜ§}zzvv}zvv}zvvrrzzvzzrnnhn¿çêÇXHQH??FQXXXQQQHX£ÜêÇzXQFCCHd¿®zhcXX^XTQLLHHFC;H}®zLFHQQQTXTXXTTTTTTQTXccÁÕ®zhdcchrndhnhhdndcdchz£ÈÇµ®®®ªª®°°ªª§§££§£§ºÒÎÁ¿ÁÇÒÒÇÁÁÁÁÁÁ¿ÁÁÁÁ®vrrhhd^^cdhddnÎáÒ¿ÁÁÇÁÁÁÇÇÈÈÇÁÈÈÈÕÈvrvzv}zzzzvz}ÒçïïçÒÇÇÇÈÈÒÕáïïÙ£}zvzzzvvvzzzrrrvzzzvnnhh}°Üêá°n^XTXh}vhTLHQÕêÒ^LF??cµvhcXTQQXTQdTQT^hhcvªÎXHLQQLLT^^XXTQQQQLLTQcÎÈddc^^dhvnnrnhhrncccrªÈº®®®ªªª®°®ª§§§ªª§§§°ÎÎÁ¿¿ÁÈÇÁ¿ÁÁÁÁÁÁÁÁÁµzrrndccchrhndcv®ÜáÎº¿ÇÁÁÁÁÇÇÇÁÁÇÈÇÇÒÈzvvz}}}}zvzzvvzvzz}ªÙçáçÜÒÁÇÎÕÈÎÕáïïÎ}zvvvvrvvzzzvrnrvrrrnnhdr£ÕêïáÈµ£®¿ÈÒÎºªnTXÙïá£^H?5L°dXX^TTLQXTQz}§®®¿ÙêÁrLQQLLHQXX^XTTLLLLLQTdÎ°zhdc^ccdvvrnhhdnhdddn°Á°®®®ªªª§ªªªª§§ª®§§§®ÈÒÁººÁÇÁ¿¿ÁÁÁÁÈÈÇÁ¿}vrrnddccrvrrhhz®ááÈµºÁÇÁÁÁÇÇÇÇÁÁÎÈÇÎÁ}zzzv}}}}}z}zvvvvvvvzz°ÜáÙÕÎÒÈÈÕÎÇÇÈÙêêÁvvvrvzzvrvvzzzvnrrrvvnhhchÎêïïïçÜÜáêêïïïçáÙÁ§ÇçóïÁrHCCz°^QLTTTTTTXTQÒºµ°®ª®ºÎáïÙXQLQHHQTXXTLQQQLHFLTh§Çrnnhccccdnrndcccccchrº¿®ª®ª§§§§§§ª®®ªªªª§§ªÁÒÈ¿¿ÁÁÁ¿¿ÁÁÁÁÇÎÎÈµzrnrhddccnrrnnnzµÜÕ¿°ºÁÇÁ¿ÁÁÇÈÇÇÇÈÈÈÎº}zvrrvzz}}}}}zvvzzzvvzzºÜÜÒÈÁÇÇÈÎÈÇÇÁÈÜáµdnrrrzzrvvzzzznrvvvzvnnddÁçïïïçÜÙÙááÜáçááçáÜÜêóóöÜ^XncHHLLQTTTTXTQÜºz}ªÇáç°nTLQFFT^QTQHHLQHFCHXz°ºhdrndc^ccddhhcX^chhnv¿µªª§§££§ªªªª®°®ªªªª§ª¿ÕÒÁÁÁÇÇÁÁÁÁ¿¿ÁÈÎÇªvnrnhcc^chnnhhnºáÎµ®µÁÁÁÇÁÁÇÇÈÈÇÇÇÇÎºzvzvrvvz}}}zzvz}zvrvzÈÕÎÇÇÈÇÇÈÈÇÇÈÁÇÒÙ°zvrrrvvrvzvvvrnvvvvvvrdhÁçêêáÒÈÈÎÒÒÈÎÒÎÎÎÈÈÕêóóóï¿®hQLQLLLQTLQXXQµrhddhv¿ÙÒdTTLH^dQTQHLLLHCFLcµ§zhdhhccddcdddh^^X^nrr§º®§§§£§§§ª®ªªª®®§§§ª§§ºÙÕÇÁ¿¿ÇÇÁÁÁ¿¿ÁÇÇ°vnnnhdc^^dr}zvnnÇáÈººÈÈÇÇÁ¿ÁÁÇÇÈÈÇÁÇÎÁ}vvzvrvzv}}}}}zzzrrzzvrv®ÒÇÇÇÁÈÈÇÇÇÇÇÒÈÁÈÕµzv}}}}zvvvvvvvrrrrnhnÇçêáÎÈÁÁÇÎÈÁÁÇÇÇÁ¿¿ÈÕêóóóáÁÎÈXQQQQLHQXLHTTTzcTXdhchzÇÙ¿}^XQH^^TTQLHFHLFHQdºrhhdhhhvhcdcc^X^^^drv°µªª§§ª§ªªªªªªªª§£§ªª£§µÒÜÈÁ¿ºÁÁÁÇÁÁÁÁÈÁzhhhnhdcc^dnrÕçÕÎÎÒÎÈÇÁ¿ºÁÇÇÇÇÈÇÇÎÇzvzvvrvvrz}}}}}zzvrvvvrvÁÎÁÁÇÇÇÇÇÇÁÁÇÎÎÇÇÒ¿}}}z}}zzz}zzzvvvrnnvÕçáÕÎÇÁÁÇÈÈÇÁÁÁÁÇÁ¿ÁÎÜïóóóêçÈ^XTX^QLQXQLQTT^LFL^dccnz§ÎÕ§rXQLLQQQLFFFHHHHTnª°nhcdnnhrnddc^^X^ccdhrµµªªªªªªªªª§§§§§££§ª§§§°ÎáÕÁ¿º¿ÁÇÇÁÁÁÇÈµrrhhhdcc^^n}n}°áêáÒÇ¿ÁÈÈÁÁ¿ÁÇÈÈÇÇÇÇÈÁzrvvvvzvvz}}}}zzzzvvvvrz§ÎÎ¿ÁÇÇÇÇÁÁÁÇÁÈÎÇÇÎÁzzzvvz}zzzzzvvzzzvrvºááÕÈÇÇÇÁÇÇÇÇÁÇÁÁÁÁ¿¿ÇÕêóóóóïÇ}cXT^^TLLTTLQXTLHFFHTX^drvºÜÒdQLLLLQLFFCCHHHXºvnhhhhhdcdddddc^ccddhr¿µªª®ªª§ªªªª§§§££££ªª£§®ÁÜÕÁ¿¿ÁÁÁ¿¿ÁÁÈÈnhrhdddcXQTcddhhrÈêçÕ¿µµºÁÈÈÇÇÇÈÎÈÇÇÇÁÈÁzrzzzzzzvvvzz}zz}zvvvv¿ÒÈÁÁÇÈÎÈÈÇÇÁÇÇÇÇÈÎÈzrvzzvvzzzzz}vzzvvvzvrrz£ÒçÙÈÁÇÁÁÇÇÇÇÇÁÇÇ¿¿¿ººÁÒçóóóóïµv^TXTXTQQTXTQXX^^LFFHTX^dn}ªÕáÁXLHLQLLHFC?CFLd§Ánhhndcccccddcccdd^chdr£Çºª®°°®ª§ª®®§£§§£§ª§££ªºÙÜÇ¿¿¿Á¿¿¿¿ÇÒ¿zXXddc^^XTQT^ccdr¿áêçÒ¿¿ºº¿ÇÁÁÇÈÈÈÈÇÇÈÈÈ¿vrz}zzzvvvzzzzz}zzvrv§ÎÒÈÁÁÁÈÎÈÈÇÇÇÁÇÇÇÈÒÒª}vrzzzvvvvvvzzvzvvvvzzrvµááÎÇÁÁÇÁÁÈÇÇÇÇÇÁ¿¿¿ºº¿Îáïóóóê°r^QQQTTLQXXQQ^XrhhnvrdhzÇáÜªhLHLQLLLHC?CFQÁµzdddddccc^cccc^cddccdnz°Îµªªªµ°®ª®°®§§ªª£££§ª§§§°ÒáÒÁ¿ÁÇ¿¿¿ÇÎÜºnLLTX^XX^dhrz§ÁÜïïêÕ¿¿º¿ÁÁÁÁÇÈÇÇÈÈÇÈÈÎ¿vvz}}z}}zvvzzvzzrz¿ÒÈÇÁÁÁÇÇÈÈÈÈÇÁÇÇÁÇÎÙºrnrvvvzzzvrrrvzvvvvvvrvÈáÕÎÈÁÇ¿ÁÇÈÎÇÇÇÁÁ¿ÁÁ¿¿¿ÇÙïóóóêªnXQLHQTQLTXQQ^^ºÁºº°ªddn§ÒçÎTLLLLQQLHHLHhªÒ£h^ccdhddcc^cddddc^cchrÁÎ°ªªª®®ªª®°®ªª®®£§§§ª®ªª°ÈáÕÇÇÇÁ¿¿ÁÈÜïÈzHFLTcnzª°º¿¿ÇÒáêïóïÕ¿º¿¿ÇÇÇÇÇÇÇÁÇÇÇÇÇÎÇzvzz}}zz}zzzzv}ÎÎÇÁÁÁÁÁÁÈÈÈÈÇÇÇÇÁÁÈÕÈvrrvrvvz}zvvrz}}zvvrvrv£ÕÙÒÈÈÁÁ¿ÁÇÈÈÇÇÇÇÁ¿ÁÁ¿ÇÁÇÕçóóóêªnXTLHQTTQQTTXc^d£µ¿µhcchv°ÜáºrQLHHQQTTXLQÈÎXTX^^^cdcXcchrvnc^cdnrÈÎ°ªªªªª®ª®®ª§§ªª§£ªª§ªªª®¿ÙÙÇÁ¿¿¿¿ÇÙêóÜ£rnv£µÈÎÎÈÇÇÁÁÇÈÕáêïïÙÁ¿ÁÇÈÎÈÈÇÇÇÇÁÁÇÇÇÈÇzz}}}zzz}zvvzzµÒÈÇÇÇÁÁÁÇÇÇÈÈÇÇÇÁÇÇÈÕÙzvvvrrvzzzzvv}vrrrrµÙÕÈÇÁÁÁ¿ÁÇÇÈÇÇÇÇÁÁÁÁ¿ÁÁÁÎáïóóï®nXTQLQTXTQQ^cdhT^hvzvh^XcchnvÇçÙcQLHLTTXQCX§ÜÁvTTX^XTXcc^^cdhndcccdhrÎÈ®ªªªªª®®®ª§£§£§££§ª§§§ªªµÎÙÈºµººÇÕêïóïÕÁÇÒÜççÜÎ¿ºººº¿¿ÇÈÒÙçïÜÇ¿ÇÈÎÈÈÈÈÈÈÈÇÇÇÁÇÎÇ}zz}}}zzzzzzzzvvzÇÒÈÇÇÁÁÁÁÁÁÁÇÇÇÈÈÇÈÈÇÕÙ§zrvvvvzzzzvvnvzzrrnvÈÙÎÇÁÇÁÇÁÁÇÇÈÈÇÇÇÁ¿ÁÁº¿¿¿ÇÙïóóï°n^XXTXXXXTTXchnTTTXX^XXX^ccdn}§ÕçÈcQHFLFHFHv¿ÜªdQQT^X^^dhd^^cc^X^^chnv£ÎÁ®§ªª§§ªªª§§£££££§§ªª£§ª°ÇÕÈ¿ººÁÒçïóêÜÒÎÕÜáÙÈÁºµººººº¿¿ÇÇÎÕçáÈ¿ºÇÈÇÇÈÎÒÒÈÇÇÇÇÈÎÇzvz}}}}zzvzzz}}zvrªÒÎÇÇÇÇÇÁÁÁÁ¿¿ÁÇÇÈÈÈÇÁÒÙ®}rrrrvzzz}zvrrvzzvrrvªÒÕÇÇÇÇÇÇÇÇÇÇÈÈÇÇÇÁÁÁÁ¿¿¿¿ÁÕêóóïµr^Xc^^T^^XXccdvXTQQTXXXX^cdddnºáçÁ^LHFFCCTÎÒTLTXc^^cnnhc^^cc^^^cnvz£È¿®ªªª§§§§§§§£££§££££§®§§§ªºÒÎÁ¿ÁÇÙêïçÒÈÁºµ¿¿¿º°µµµººº¿Á¿¿¿ÁÇÒÜÕ¿¿ÇÇÇÈÎÈÈÈÇÇÇÇÇÈÈÎª}rrvvzzzzzzzzz}}}}vrºÒÈÇÇÇÇÇÇÇÇÁ¿¿ÁÁÁÇÇÁÁÁÈÕµrnrrrnrv}}vvrrrvzvv}ºÒÎÇÇÇÁÁÁÇÇÈÈÈÇÇÇÇÇÁÁ¿ÁÁºº¿ÎêóóïºvcTccXTXXTXXccv^XXTXX^c^^cddddvÒêç¿}cTLF?Cd®Õ°hLHT^^XXchhdcXcc^^^^chr}£Çµªª§§§ªª§§§§£§£§§§§££§§£§ª°ÈÙÈÁÁÒçêáÎ¿ººº°µ°°ºµººººµº¿ÁÇ¿¿¿ÁÇÒÙÈÁÇÇÇÎÒÈÇÇÇÇÇÇÇÇÎÕµhnrrvvvzvz}zzzzvzzvÈÎÇÁÁÇÇÇÇÇÇÁÁ¿¿ÁÁÁÇÁÁÁÈÙÁvrrvvdhnz}zvvvvvzzvzÈÕÎÁÁÇÁÁÁÁÇÇÎÈÇÇÈÇÇÁÁ¿ÇÁºµºÇáóóïµzdXcdXTXXTTX^^nccdc^^^^^X^ddnnvºáïÜ®}dcXQXÇÒ^LLXX^^^dhhhc^^XXddhdhr}§Çµª®ª§§®ª§§ª§ªª§§§ªª££§££§®ÁÙÙÈÎáçÙÇµ°µµµººµ°µºº¿¿¿ºµ¿¿ÇÁÁ¿¿ÁÈÙÕÈÈÈÇÎÒÎÇÇÇÇÇÁÁÁÎÜÁnnrvvzvrv}}zzzrz}}ªÕÈÇÁÁÁÇÇÇÇÁÁ¿¿ÁÁÁÁÁÁÁ¿ÁÕÈvnnnrd^drvvvvvvrvzv}ªÒÒÈÁÁÁÁÁÇÁÁÇÎÈÇÇÇÇÁÁ¿¿Á¿¿ººÇáïóïºzcX^^XXXTTTXT^hdchdcc^X^X^^chnr}§ÙïïÙº§§££¿áÈ}TTXX^c^drhhhc^X^cnzndhv°Èµªªª§ªªª§ªª®®®ª§££ª££££££§§¿áêáçêÙÇ°®ª°¿µµ¿ºµ°ºº¿¿¿ºº¿¿ÁÁÁ¿¿¿ÁÕÜÙÒÎÈÈÈÇÇÇÁÁÁÁÁ¿ÎçÎrnrvvrrrz}}}zzrrrvºÕÈÇÁÁÁÇÇÇÇÁÁÁÁÁÁÁÁ¿Á¿¿ÁÎÈvhhhnhdhrvrrrrrrv}}ºÕÎÇÁÁÁÇÁÇÁÇÇÈÈÇÇÇÇÁÁÁÁÁººµµÇáïóïÇ}^TXXTT^XXX^X^hddhc^^^X^^XX^^cdzÎêïïáÙááááêóÎvHHLQX^chvncdc^XX^cndhhrÇÙ¿®ªªªªª§§ª°ºµ®®®§£§§£££££ªÁáïóïáÁ°°°°°¿¿º¿¿µ°µ¿¿¿¿ºº¿¿ÁÁÁ¿¿ÁÁÈÙáÕÎÈÈÈÈÈÎÈÇÁ¿ÁÁÒêÙvnrvrnrzzzvvzzrrnrÈÙÈÁ¿¿ÁÇÇÁÁÇÇÇÇÇÁÁÁÁ¿¿¿ÁÎÒª}hrzzzrnrrvrrnnrv}zÁÒÈÇÇÇÇÇÁÇÇÇÇÎÈÇÇÇÇÇÇÁÁ¿ºµµµÇáïóóÕ^QXTTQ^^XX^XXcdhc^^^X^cdc^^^^drÇêïçÙÒÕáêïóóÙHCFLTXchrznccXXXTXX^dnv£ÕçÎµ®ª§§§ªªªµµ®ªªª§£§£££§ºÕêïóïÕ°ª®°°°ºº¿¿¿µµºººÁÁÁ¿ÁÁ¿¿ÁÇÇÁÁÁÎÜÜÒÈÈÎÎÒÎÈÁ¿º¿ÇÕêç°}rnvvzvvvvvvzzzvrvÒÕÈÁÁÁÁÇÁÁÁÇÁÇÇÁÁÇÁÁÁ¿ºÁÈÙ¿}vrrrrrnhhnrvzÇÎÈÇÈÈÁÁÁÇÁÇÈÈÈÇÁÁÁÇÁÁÇÁºº°µÇáïóóádTXXTX^c^^XTQXdccX^^^^^cc^^X^cnÁççÒÁ¿ºÇÕÜçêá§T?FQXXchnvvhd^TTTXXXch¿áêáÈµ®§£§ªªª®ª§£££££££§µÎçïóóêÎª££§®®µº¿ÁÁ¿ººº¿¿ÁÁÁÇÁ¿ÁÇÇÇÇÁÁÇÙáÒÎÈÈÎÎÇÁÁ¿ººÇÜêïÇrnvzzrnrrrvvzzzv}ªÎÈÇÁÇÁÁÇÁÁÁÇÇÁÁÁÁÇÁÁ¿¿º¿ÇÙÎ}vrvrrrnnhhhdnvz£ÎÒÁÁÇÇÁÁÇÈÇÇÈÈÈÇÁÁÁÁÁÇÁÁºµµºÒêóóóê°nXccXX^cXXXLLTccc^XXXX^^XX^^Xch¿çÜÇµ°°µÁÎÕÙáÈ}HFQ^^^ccdhdd^LTTTT^h}ªÕïïïÜÎºª§£§§§§ª§£££°ÁÕçïóóóïÈª££§®µ¿¿ÁÇÇÁ¿¿¿¿¿¿¿ÁÁÁÁÈÇÇÁÁÁÁÒáÙÈÇÇÎÈÁ¿º¿º¿ÈÜïóÙrrrvrrrrrrvvvvvzºÎÇÁÁÁÁÇÇÇÁÁÁÇÇÇÇÇÇ¿¿Á¿¿¿ÇÕÙ§}nnrrvrnhnndddhnv°ÒÎÁÁÇÁÇÇÇÈÈÈÈÈÈÈÇÁÁÇÇÇÁ¿°µºÈáïóóóóÎ^ccXXX^TTTLLQc^ccXX^^XTTT^c^^dÁáÕº°µ°°ºÁÈÈÒÕ®nLQT^^cccccXTLQTXXrµÒçêïïïçÒµ§£§£§§§ªª££££§°ÁÎÙçêïïóóóÜÁª£ª®°ººµ¿¿ÇÇÁ¿¿¿¿¿¿ÁÇÁÁÈÇÇÁÇÁÇÎÜÜÈÁÇÈÈÁÁºµº¿Îáïóêµ}vvrvvrrrrrrrrrvÁÎÁÁÁÇÁÁÇÇÇÇÇÇÇÇÇÇÁ¿¿Á¿Á¿ÇÕçÁrrvvzvrrnnhdccnzÈÙÒÇÁÁÇÈÇÇÇÈÈÈÈÈÇÁÁÁÇÁÁ¿ºµµÇÙïóïóóóá£d^^XTXXTTQQLHd^cdcdvrd^TTX^^chÈáÎº°µµµµº¿¿ÁÎÎ£nXT^cdddhcTTLTcr£ÁÎÒÕÜáçïïçÎµª££££££§££§£ª¿ÒÕÒÎÒÕÙáïïóáÈºµººº¿Á¿¿¿¿¿Á¿ÁÁÁÁ¿ÁÁÁ¿ÁÇÁÁÁÁÁÈÕÜÕÁ¿ÁÈÇÁ¿¿ÁÈÒçïóïÒ}zvvzvrvvvnrnnvÈÇº¿ÁÁÇÇÇÇÇÇÇÇÈÈÇÇÇÁ¿ÁÇÇÈÎÜïáµzrhzÇááÙÎÇÁÇÈÇÇÇÁÇÈÈÇÇÇÁÇÁÁ¿ºººÇÙççÜÜêóóïºv^XXTXXTTTQQLd^cnhhzrc^X^cdnÒÙÇº°µºµµººº¿ÇÒÇ§vX^dhcX^^TX^nªºÁÁ¿¿ÁÈÈÎÕáçáÒ¿ª£££§µÈÜÙÈ¿º¿ÁÈÎÙçïáÁµµÁÁ¿ÇÇÁÁ¿µ¿¿ÁÁÁÁÁÁÁÁ¿¿ÁÇÁ¿¿¿ÁÁÎÜÙÈ¿¿ÁÁ¿¿ÁÈÒÜêïóóçº}vvzzvzrnnnz§ÎÇ¿¿ÁÁÁÇÁÇÇÁÁÁÇÈÇÁÁ¿¿¿ÁÁÈÕçïóçÈÇÒÙÙÕÒÒÎÈÁª£ÎêïçÙÎÇÁÇÇÇÇÇÇÁÁÁÇÇÈÇ¿¿¿¿¿¿ÇÙáÈº°µÈçóóÒdXXTTTQTTQQQd^^dhddn}zhc^^cvªÕÎÁº°µ¿ººººµºÁÎÕÎdXdhXQLQXz§¿Á¿ºººµµÁºº¿ÇÎÙçÙÁ°ª£®ÎáÕÁºµ°º¿¿ÁÈÒÙáÈº°ÁÎÈÎÈÇ¿ººº¿ÁÁ¿¿¿ÁÁÇÇÇÇÇÇÁÁÁÁÇÈÙáÒÇÁÁ¿¿¿ÁÎÒÈÈÈÒÙÜÕªzvvzz}§vr}°ÎÇÁÇÇÁÇÇÇÇÁÁÁÇÇÈÇÁÁ¿¿¿¿¿ÇÕêóóïáÒÇÁÁº¿¿ÁÎÕÕÒÎÙêóóáÒÈÁÇÇÇÇÇÇÇÁ¿ÁÁÇÇÁº¿¿ÁÇÈÒÒÁÁçïáªrXXTXTQQQQLQc^X^c^X^hvvnc^Xd¿ÕÈÁº°µµººººº¿ÇÈÎÙÁ}XTXTHFLh§ÇÈÁµµ°µµ°µº°°µµ¿ÎáêáÎÁ®ªÈáÙÁ°°µµº¿µºÁ¿ÇÕÒÁµ¿ÎÎÎÈÇÁ¿¿¿¿ÇÇÁ¿ºº¿ÇÈÇÇÇÇÁÇÁÇÈÈÕçÜÈÇÁÁÇÈÎÁªªÁÈ°zvvvz}£zr¿ÈÇÁÁÁÁÇÈÎÈÁ¿ÁÁÇÈÇÁÁ¿¿¿¿ÁÇÕççÙÎ°zz}}µÎÜïïóóáÎÈÁÁÁÁÇÇÇÇÁÁÁÁÇÁ¿µºÁÁÈÈµ£zvzv}ÒêïÈdTTTQQLLQLHddccXXTX^cdhd^^nÈÎÁ¿ºººµºÁ¿¿ºº¿ÇÇÎÒªnQHHFF^¿ÒÇº°°µ°µµµµµ°°°ºÁÕÙáçáÇ§ªÇáÜÇ®®µºº¿µµµºµ¿ÈÙÎ¿¿ÁÇÎÈÁÁÁÁ¿¿ÁÇÇÁ¿µµÁÇÁÁÁÁÁÁÁÇÇÈÕáçÕÈÈÈÎÎµ}rrrvvµÎ¿zvrrv}vnrÇÎÁÁÁÁÁÇÇÈÈÇÁÁÇÇÇÇÁÁ¿ÁÁÁÁÈÕÙº£nnhccdcchrºÙêïïáÈÇÁÁÁÈÈÇÇÇÇÁÁÁÇÇÁºº¿ÁÇ°zrnrvnrµáïÜ£rXQTQLLLLHFrhdc^XQQ^cdhhc^vªÈÁ¿ºº¿ºµµ¿¿¿¿º¿ÁÁÇÎÈcCCH^®ÁÇ¿ºµ°µµººººµ°°°µ¿ÁÇÎÜêÙµ£®ÈççÎ°ª®°µº¿µµ°µ°ºÁÒÕÇÁÁ¿ÇÁ¿ÁÁÇ¿¿¿ÁÁ¿ººµ¿¿¿ÁÁÁÁ¿¿¿ÁÇÈÙêêÜÕÕÇªrhddhhhnn°ÒÇzrnnhhdrÎÎÁÁÁÁÁÁÁÇÈÈÈÇÁÇÁÇÁÁÁ¿¿¿ÇÎÕº}vnc^cc^^^^cdhrªÕêïáÈÁÁÇÈÈÎÎÈÇÇÇÁÁÁÁÁºµ¿Á°rhnhnvhhvÒêçº}^QQQHHLHFFnd^T^^Q^hdcdddµÇ¿ºµ¿Áºµµº¿¿¿º¿Á¿ÁÇÎÈXH^°ºµ¿Á¿µ°µº¿¿µ°°°°°°µºº¿ÒáçÒººÎçêÙ¿®ª®µµº¿ºµ°°µµ¿ÈÙÎÁº°º¿¿ÁÈÇÁ¿¿¿Á¿¿µµ¿º¿Á¿Á¿¿¿¿ºÁÈÕêóïáÇzhdhhhhddhcc}ªÇÁrnnnhn}®ÒÈÁÁÇÁÁÁÁÁÇÈÈÇÇÇÇÁÁÁÁ¿ºº¿ÎÈznnhcXcc^^^^ccdnh}ªÕêáÎÇÁÇÈÈÎÎÈÈÈÇÁÁ¿¿¿ººÇµvndhdhrddhºáïÒdTQLFHLLQT}vndn}n^^^hÁÁ¿¿º¿ÁººººÁÁ¿ººÁÁ¿¿ÁÎÁr°¿°°µ¿ºµµ°º¿¿µµ°°µ°µ°µµºÁÎáêÜÜêïÜÁººººµººººººµµµµÇÕÕÇ¿µºÁÁ¿ÇÈÁÁÁÁÁÁ¿¿¿º¿¿ÁÁÁÁ¿ÁÁ¿¿ÇÕêïçÁrddddhnd^chcXdzº¿£vnnnr¿ÒÇÇÈÁ¿ÁÇÁÁÇÇÇÈÇÇÇÇÁ¿¿º¿ºÁÎ°hddhc^^c^^^^^^^nhnºáÜÎÇÁÇÇÁÇÈÈÇÇÇÁ¿¿ºººÇº}rhdcchhccdr£ÕêáªrTHFFH^zdnz§¿Ç¿°rXXX}°ÇÇÇÁ¿º¿ººº¿ÁÁ¿¿¿ÁÁ¿º¿ÇÎÎµ¿Ç¿µµµµµµµµ¿Áºµµµ°µµµµµµµ¿ÁÕêïóóêÎº°ºÇÁºººµºººº¿ºº¿ÎÜÙÈ¿ºÁÁÁÇÇÇÁÁÁÁÁÁÁÁ¿¿ÁÇÈÈÈÁ¿ÁÁ¿ÁÒêïÎrhddddhnhc^cc^cdv°º£rhhvÎÙÈÇÁ¿¿¿ÁÁÇÁÇÈÎÈÇÇÁÁÁÁÇÇÁÇÁrddcdc^^^^^XXX^TcdhrÕÜÎÇÁÁÁÇÇÇÇÇ¿ÁÁ¿ºººÇÁ}rndcX^hhccchÁçêÁ}XHCHn¿ÎÙccrª®ªª}cXTd¿ÁÁ¿ººµµºµºº¿¿¿º¿¿Á¿ºº¿ÒçêÜÇº¿ÁÁ¿µµµµº¿ºººµµµµµµ°°µµ¿ÈáïóïÙÁ°ª®ºÇ¿°ºµµµµº¿ºµ¿ÇÕáÎ¿ÁÁÁÁÁÁÁ¿¿ÁÁÁ¿¿ÁÁÁÁÁÇÇÁÁº¿ÁÁÇÒçáªzddddd^cnvc^X^ccchr°§vr¿ááÒÈ¿¿¿¿ÇÇÁÇÁÇÇÇÇÁÁ¿¿ÁÁÈÈÇ§zd^ccccc^XTXXXXXTQXXcÎÙÎÈÈÁÇÈÈÈÇÁ¿¿ÁÁºµ¿Ç®rnhd^T^ddc^cdv®ÜêÕcHHh£°ª£^^drnhhhd^XX^z®¿ºµµµµºº¿ºº¿ºººº¿Á¿ºº¿ÁÒçïáÁµµºÈÎÁºµµµµµººµ°µµµº°°°µµÁÜïóáÈº®ªªµÈÇµººµµ°ººµºº¿ÇÙÕÁÁÁÁÁÇÁÁÇÁÇÁ¿¿ÁÇÈÇÁÁÁ¿¿¿ºÇÇÇÇÕçÇndccdc^^dnd^^^d^^dhnv®®°ÙïçÕÈÁÁÁÇÇÇÁÇÁÁÇÇÇÇÇÇÁ¿º¿Èºhc^ccc^^XXTXXXXXTQQT^ÈÙÎÇÇÁÇÇÈÎÇÁÁÁ¿ÁºµÁ¿zhhd^XX^dddc^^nÕêçµzchzcX^dd^XQTQTTTTTcººµ°ºµºº¿ºµº¿ººµµ¿¿¿ºº¿ÇÎçïÕ¿°°°¿¿ººººµµµµºµµµµµ°µ°µ°µÁÙïïÙº°®®®°ÁÁºµºµµµºµµµººÁÕÜÈ¿¿ÁÁÇÈÇÁÁÁ¿º¿¿ÁÁµ¿Á¿ÁÁ¿ÁÎÈÇÇÕÜ§rc^^^^^^^chdc^X^^^dhdhrªºÇÙêïêÙÎÈÇÇÇÇÇÇÇÇÁÇÇÇÇÒÕÎÁºÁÇ§vdcTX^^XX^XTTQTTXXTQQXz¿ÙÎÇÁÁÁÁÇÈÈÁÇÁ¿Á¿¿Ç§}ndc^XTcccccc^XcÈêêÕª^FCFCnrcQQTTTQQQQd§ºµ°µµµºººµµ¿¿ºººººººººº¿ÈáêÒº®®°ºµµµµººµ°ººººµµµµ°°µººÁÕêêÎµ®®®°°µºµµºµµÁ¿µµµµº¿ÎáÕÇ¿ÈÎÈÈÈÇÁ¿¿¿¿¿Á¿µ¿¿¿¿¿ÁÇÈÁÁÇÒÈcXXT^XTX^cddc^X^XXdddddn§ÎçïïêÙÒÈÇÇÁÁÁÇÈÇÇÈÈÈÎÈÎÎÈ¿ÇÇhc^TTTXX^^^TTQQQQQTQQTrµÕÎÇÁÁÁÁÇÇÁÁÇÁ¿¿ÁÈµr^T^XQcrcXcc^TT^}ºçïêÙÇ£hF??C?^hcQLTTQLFFQ}µµ®ª®°µºººµºººµºººµµººµº¿ÇÙçÎº°®°µµµµµººµ°º¿ÇÇ¿ººµµ®µºº¿ÒççÇ°°°°°µµµµµºº¿Ç¿ºººµº¿ÁÙáÒÈÒÙÈÇÁÇÁÁÁ¿¿ÁÁ¿ºº¿¿º¿ºº¿ÁÁÈÕ°v^TQT^^XX^^cc^^^XX^ddhhdch¿áïïêÙÈÇÁÁÁÁÇÇÇÇÇÈÇÇÁÁ¿ÁÈÇÇ°}cTQLQT^^^^cXTTTTQLQQQQn°ÙÈÁÁÇÁ¿¿ÁÁÁÁÁ¿¿ÇÇznXQTTTnzXT^^XTQTn£ÕêïêÒTC;???HQXTTTLLFCCX¿®ª§®°°µºµºººººººµµµººµµ¿ÁÕÜÇº¿¿µºµºººµµ°µº¿ÈÈÁ¿ºµ°°°°°ºÈááÇµºµ°µµµµººº¿Ç¿ºµºººµµºÈááÙÕÎÇÁÁ¿Á¿¿ºº¿ÁÁÁ¿¿º¿¿ºµµº¿ÈÎdXTX^c^X^^ccc^^TX^Xccddd^dr£ÙêïêÕÇÁÁÁÁÁÇÇÇÁÁÁÁ¿¿ºº¿ÁÇºhXTQLQ^cXTQX^TQXcTLQQQThªÜÒÁÇÇÁÁ¿¿¿¿¿¿¿ÁÈ°rd^TQQX}rQQcccTQTdÇçêïÈ}L?;????H^cXQHCC;Cnµºª§ª®°°µµººººÁÇÁ¿ººººµµµº¿ÒÙ¿µ¿ÈÈ¿¿¿º¿µµ°µº¿¿¿ººµµµ°°°°µÈáÜÇºµµµµµµºººµº¿¿µ°µµµµ°°ÁÜêçÕÎÈÈÁÁ¿º¿¿º¿ÁÇÁ¿¿¿ºººµµµºÇÇc^cc^^c^^c^^cc^X^h^XX^^c^hrÎêïçÒÁ¿¿¿ÁÁÁÁÇÇÇÁ¿¿¿ººº¿Ç®zccdhrhcTQLQQTQHLTQLLLQTdªÜÒÁÁÁÇÁ¿ºººµº¿ÈÇznc^TQQ^}dHQcdcXQQXz°Üêê¿rF;55;??FTTLHFCC?HÇºªªª®®°µµµºµµÁÇÁ¿º¿¿¿ºµµººÈÙ¿°°ÁÈÇº¿¿¿µµ°ººººººµµ°°®®°°µÈçÕ¿µ°°µµºµººµµ¿¿¿µ°µ°µµ°µÇÜïêáÙÕÕÎÇÁ¿ºº¿ÁÁÁÁÁ¿¿¿ÁÁ¿ºµ¿Èµz^^ddc^ccccc^chdXczcTXXX^XdhzºçêçÒÁ¿º¿ÇÁÁÁÈÈÈÇÁ¿ºººº¿Çn^^cdndTQQTQLQLHFLHLQHHQhªÜÒÇÇÁÈÁ¿ºººµµ¿Ò¿vhc^XTQdzXLLcd^XTQQhÕêç°hC5535?QHFCCCCFFC^ªÈ°§§ªª®®°°µµµ°º¿ººº¿ºµººµººÈÒ¿®®°º¿¿ºººµµ¿¿¿ºµµºµ°°°®®°µµÇÜÒ¿º°µ°µ°°µµµµºÁÇ¿µ°°°µ°µÇáïïïïïçÜÕÈÁ¿¿ÁÁ¿¿ÇÇ¿º¿ÇÈÈÇÇÈÎ§hXTT^XXcc^^c^cdcXcv^QTXXXTXXd§ÜêçÕÁº¿¿ÁÁÇÇÎÎÈÈÇÇÁÁºµÁÁcTQQLLLQQQTQLLLHHHFLLHHQr°ÜÙÈÇÁÇÇ¿ºµµµºÈÙ°rd^X^XQdhTQL^dTX^XTcÇçç®cC5.35;dhcXcTHQHFhºÇª£ªªªª°ºµµººµµµºµºººµµµÇÒ¿°°°µ¿¿¿ºººº¿Á¿¿ºººµ°°°°®°°µÇÜÎ¿¿ºµ°µ°µµºµ°µµÇÇµ®°®°°µÇáïïêáÜÜçáÙÎÇÁÁ¿º¿ÇÇÁ¿º¿ÁÈÒÎÕÎcQLQXcccc^^^^^^^XXhXXXTXXTQTXÒêçÒÁ¿ÁÁÁÁÇÇÇÁ¿ÈÈÇÈÈÁÁÈ¿zXQQQHLLLLLLLFHLLFHFHHHHT}¿çáÕÈÈÇÇ¿¿ºµµ¿ÒÒ£}nd^Xc^Tc^QLLcdTT^hc^zºçá®c?335;?££§r^Q}¿Á§§ª£§°ºµµºµµ°µººµ¿µµ°µÈÕÇ°°°®º¿¿ºº¿ºº¿¿¿ºº¿ºµµµµ°°µµÈÜÈºº¿µµµµ°ºÁ¿µµ°µÁ¿°®ª®®°ÈáïáÇª§ª¿ÒçáÕÎÁ¿¿ÁÁÁÁºº¿¿¿Á¿Çº}^TLTX^^Xcc^^TTQXXXdX^^^XXTLLL}ÇçêÙÈÁÁ¿ÁÁÁ¿¿ººÁÎÇÁÁÇÈÕµrTQLLQTTTQQHHCFLLHFFHFFH^ÒêêáÙÕÎÈÁ¿¿ºµÁÙÁzhc^X^X^^TLHLchXTTXXXv°áç®cC35C;?Á°®µººµ£r¿¿§£§££ª°µµµ°°®°ºµµµµ°°µÎÜÇ°°®ª°º¿ºººººº¿º¿¿¿¿µµµ°°µ°ºÒÜÇºµºµµµºµµ¿ºµµ°°º¿µ°®§§°Èáá¿}£ÁÕáÜÎÁÁÇÈÁÁºº¿ººººÇªhTTT^^X^X^ccc^XTX^^ccXchdXQQFFhµçêáÒÁº¿ÁÁÁ¿ººµ¿Ç¿¿º¿ÈÒ§dTLLLLQT^XQQLCFLQQQQHHFQr®ÜïïïêçÜÙÎÈÁÁÇÒÙ°vhc^XXXXXTLHLcd^TQQLQnªÜç®dC35F??}rhnr£§µº§£ª®®®°®°°µµµº¿µ°¿ÒÜÈ°®ª®°º¿¿ººººº¿¿¿¿ºµµµµµ°µ°µÒÙÁµµºµ°µºµµººº°°®°°µµ®ªªµÈÜÇvrnnrz£¿ÒÕÒÈÇÇÁÈÁ¿¿¿ºº¿Ç^QTTXXXXXXcnrvzrd^X^c^X^d^TLFCX§ÜêêÜÇ¿ÇÈÈÈÇ¿ºµ¿¿º¿¿ÁÒÕcQLHLQQLQTQLLCCLTQQQHHQdÎêêïïïêççáÙÕÕÙçÜ§znd^^^^XTTTLQHc^TTQQLQdÕç°dF5;FF;C??;?L^r£§°µª£ª®®ª®°°µµ°µ¿¿µµ¿ÎÜÕµª§ª°º¿ººµºººº¿¿ºµµµºµµµµµºÙÜÇµº¿¿µµºººººµµ®®®®°°°®®°ÎÕ£rdddhhnrzºÎÕÎÇÇÕÕÈÁ¿ººÇÁQQX^XTTTTT^cchvhcXXX^XTXc^TTHCXÙêïêáÙÜÜáÙÕÒÈÇÁÁº¿ÇÒáá£^HHLLLLLLQLLLFCHLHHLQQdÈáêêçáÜÒÒÜçêêêïïÙvhcXcccTLTT^XL^TLTXLLTdÒç¿nH?CFF;333.3?FTn£®¿µ§£ªª®®°®°°°°°µµ°ºÎáÜÁ®§ª°µººµºººººº¿ºµµºººµ°µ°¿ÜÜÇºº¿Ç¿µºµº¿ºµµ°®®®®°®®®ºÒÇccdhddccdhvµÈÎÕÒÎÈÇ¿µºÈµnFQXXXTLQTQXXXXXTQQQXX^XXTXTTLFTÕêêïêççÜÜÙÙÕÕÕÕÎÈÎÙêóá^HCFLLLHLQQLLFCFHLLQQcÇáçÙÇµª£°ÎáïïïïÎndccchcTLQQchTXTQTXQLQcÇçÇzH?CFC;..3335;CQrµÈÁª£ª®°µ®®°µ®®®°°ºÒçêÒµ®µµº¿ººº¿¿ºº¿Áºµµºººµµ®°ÇáÜÁ°®µÇ¿ºµ°µººººº°°µ°°°®µÁÕºvXXcd^XXXddchrµÇÈÁÇÁ¿¿ÁÕ®^CLQTXXQQXQQTQQTXXTTTX^^XTTQQLCQÙêêçÜÒÈÈÇÇÇÁÇÎÕááêïóóá^LCFLQQLQQQLHC??CFHQcÁááÎ§}zvrrµÕçïêÁhdhhd^TTTQLX^T^cc^XTQLXzºáÒH?CLLC5355333;CX}°ÒÎª§®ºº®ª®°®§§ª®¿ÙêïÜÁÁÇ¿ººµºº¿ºº¿ÇÁººµµµºº°®µÎêÜÇ°®°ÁÁºµ°°°º¿¿º°ºÁ¿°®°µÈÕªrX^^cTTTcdhhddnvµÇÎÈÇÎÕÜ§TFQLQTXTTXQLQLLTX^^XTXXcXTQLLFCQÙêçÜÎÇÁÁ¿ºº¿¿¿ÈÕáïïïóá^QHHLQQQQQQLH?55??FTz°ÙçÈ}nddc^Xchz£Òçç¿hcddXQLQTQLTQQLTchnXQQTr®áÙL??QXF;;;55;55;FcÈÕµ£ª®°°§§ªª§§ª°ÇÜïïçÎÇ¿°µµººº¿ºº¿¿¿µµµµµºµ°®ºÒçÙÇ°®°ººµµ°°°µ¿ººµº¿¿µµ°ºÎ¿^QT^^XQXdddddddhrz°ÕÜÙÜêç°^CFLQXXTQTQQHFHLTXXXTXTTTXXQHFFTÙçÜÎÁ¿ÁÁººº¿ººÁÈÙçïïïÜ^QHHQTTQQTQQTQLQLHHcÎçÕ£vcX^XQTTTTXvªÕá¿hdcXTQLQ^TQTQQHFHcvcQQQh£ÜÜX?5HXH;;5;;???55HzµÕÇ££§ª£££§§ª°ÁÕçïïêÒµ®ª®µµµº¿¿ºº¿¿µµµ°µµ°°®µÒçÕÁµ°µµµµ°µµµµµºµµ°°°µµ°¿È£nTLQTTQQ^h^XXX^Xccch¿áêêïïÈ}LHTTTTQHLQQLFHLQTXXTXTTTQTQLHH^§ÜáÒÈÁ¿¿Á¿¿¿¿¿º¿ÁÎÙçïïáXLFHLQXTTTQTh}zdvµÜáµz^TQXXQQTQLLT}°Ùºnd^TTTTQX^TTXLFCHX}dHLQ^Õçª^C;?QF5;;;?CFC53;XÒÕº££§££§®µºÈÒÕÜáêïÕºª§ª°µºº¿¿º¿¿ºµµºµµ°°®®ºÕáÎº°µººµ°µ°µ°µµµµ°°°®°°°ÇÈ^LHQQHLT^^T^XXTX^^XXnÒêêïïáºXTTTQLHLQQ^^QLX^TTXTTTQLQLQQQnµÜÕÈÇ¿º¿ÁÁ¿º¿ººº¿ÁÎÕçêÜXLFCFHQQQLHHXvzvÎçÎ^QLLX^TTXTLFLcÒÁnncXXccXXXXTTLFCFcnFHLXÒç¿dC;;LL5;;??CFF;++CrºÙÒµ§®®µ¿ÎÕÒÎÇÁ¿ÇÕççÎ®§ª°ººººººººººµµºµ®ªªªºÙáÈµ®°¿Á¿°µµµµµµµµµµ®®®®°È¿vXLHQQHLX^TTX^cTT^XQQTvºáêêïêÜº}rcXQHHHLT^TQX^TXTQQQTHHLHHLzÁÕÈÇÇ¿¿ÁÇÇÁ¿¿¿º¿¿¿ÇÎÙêá£cQC;CFLLFC?C??FHHQvºÜÙªrTHLLTXXXXQHFCL}ÇÇnc^XT^^XXXXTTLFFF^nFHHTÈçÇvF;5FH5;5;?CFF?3+5XÕáÈ§ª°µ¿ÈÕÜáÙÈµ®®®®ºÎáÙº§§°ºµµºµ°µµºµ°°µ°ªª§ª¿ÙáÇ°®°µÁÁµµº¿µ°µ°°ºº®ªª®ºÒ®hXQHLQLQ^XTQXdcTTXTQHLc§ÜêêêÜÈ¿°ª§rTHFFHLTTTQQQQLHQQHFFC?HÇÈÁÇÇÁ¿ÁÁÁÁÁÁ¿º¿¿¿ÇÈÙáçµrQCCFHLLCCC?;335;TÒáÁcTQHLQX^TQQF?CHnµÇnXTX^^^X^XX^^QLFFTznLLQX}ÇçÈ}QC;?F;;;???CCC;33HÈçÜº£®ÁÎÒÕÙÜÙÕÈÁµª§§§§§µÈÕÈ®ª®°°µ°°°°µ®®ª®®ª§£§ªÁááÁ®ª®°ººµ°°µµµº¿µ°µ°®®°ÁÒdTQLLLLQXTQQXd^XT^THCCT£ÙêêÕµ£ªºµn^XQLQQLHQQLLHLQFCC;;QÎÁ¿ÁÁ¿º¿¿¿ÁÇÁ¿¿º¿¿ÇÈÎÒÙÇTFFHHHHC??;5.++;hµÜÒh^TQQQLQTTLF??CHc¿n^X^^^^^^c^ccTLHHLXcXXXTvºáÒXL;;C?????C?;;;3.?hµáçÎª£ºÈÙááÜÕÎÇ¿µµµ°ª§§§§££°ÈÒºª®®®®°®®®®ªªªª®ª££ªÇááÁ°ªª®°°®®°°µºÁ¿µ°°°°µºÈÁ^TTQQQLQTTQQ^^^^X^^LC;X£ÜáÒ°}ºÈº£hLLLLLQQQLLQQLQLC;dºÒÇºÁÁÁ¿¿¿¿ÁÁÁÁÁÁ¿¿ÁÇÇÇÈÒ£cLHHLHHC;5;?.%%FÒÙªr^THFLLLLQQTHFFFFQºn^XccX^^^c^TTLLLLHHQT^XXh§ÜÙ^LC;F??;;???53;3+3QÕêÜÇµºÎáêçÜÈ¿µµ°°°®µ°®ªªª£ªºÈÇµ®®®®°ªªª§§§ªªª§££®ÎçÜ¿ª§§ª°µ®ªª®®°º°®®®°°ºÁÕµnTQTTX^TTTXQHQX^cXTXL??c®ÙÈ§}zvr}°ÈÒÇTHLLQQLQLLLQXccHCÈÒÁº¿¿ÁÁ¿¿¿ÁÇÇÁÁÁÇÁÇÇÇÁÇÒºrQHLLHF?53;;.!.cµÜÁ^LFCCHQLLLHLHHHFFHvµ£rX^hcXX^^dXQHHQLLHFHHQTQcÒÜXF;?Q555;?;;55;5+.FÈçêÜÕáêçÙÁ°ªª§ª®°°µ°°°°®§§£§°ºÈÇµ°®®®ª§§§§§§ªª§££°ÒêÜº£§ª®ªªªªªª®®®ªª°µ¿ÈÕ£cTXdhddd^X^QHQndXTTQHCFrºÁ§}zzzvrrv}£ÇÙµzQHFLLHHLLLLHHFFQÕÎÁ¿¿¿ÁÁ¿¿¿ÁÁÇÇÇÇÇÇÇÁÁÇÎÕÎXQQQHHC;33.%!?ÒÕhTLFFHQTQQHHLLLFFFFdªªvc^cXTX^Xc^LLHLQQHCFLTQLXÇÜªXC55?.335;????CC53?nºçêêêçÙ¿£££§®°°µµ®µ°®ª£££®º¿ÎÇ¿µ°°ªª°µ°°®®®ª§§§¿Üêá¿§§ª®µ°µµµ°®®®®®®ª®µ¿ÒÎ^TdvrcXTX^^QLnnXTLQHCLº§vzvrhnv}}v¿Î°zLFFCCCFFHFC;5?n¿ÙÎÇÁÁ¿¿¿ºº¿ÁÁÇÇÇÇÇÁÁÁÁÁÈÒÙªdQQQLFC?553+3c°ÜÇTFCFHQLQLLFHHHF??CFXª}c^^XTTXTTXXTLHLQHHHQXTQTr°ÜµhH?553.35?C;?CFF?5?d°áêêÙÇºz£ª®°µ°°®°°®ª§§££ª°µÈÙÕÈÇ¿ÁÈÒÕÒÎÈÈÇÁ¿µ¿ÒêïêÎ¿¿ÇÈÎÎÎÒÒÒÎÁºµ°®®°µÁÙÁzQTcc^TTQT^X^hdTTTXTHX£}zzzrnhnzvnnvµÎªnHC?CCCFQTQFCLÎÜÒÇ¿¿º¿ÇÁ¿¿ÁÇÁÇÇÇÁÁ¿ÁÁ¿¿ÁÕµhLHLLHFC??5;TÕáºrH??;?FCCHHFFLF??;??L§d^^XXTTQQT^cTLHLLLLX^QQQd£ÙÁrQHCC5335;5333553.5^ªÜçÙ¿§§§£ª®°µ°°®®®ª§ª§§£§ª®°ÁáççÜÙÙÜÕÎÇÈÈÈÈÎÒÕÙçïóïáÒÁ¿ÁÁÇÁÇÈÒÕÕÒÈÇ¿ººÁÒá°cHHQTTXTXXX^vh^X^hvrXv§}zzzvrndnhhdhrz}ª¿£nLCCHTnµÜçÎ¿¿ÁÁÁÇÁ¿¿ÁÁÇÁÇÇÇÁÁÁÁÁ¿ÁÕÁnHFCFFHHFFHcÒçç°hC;;5;CC?FHFFTLFFCCCHn£h^Xc^XXLLQchXLHHLHLXXQQLXÕÈzHC?H55555...++.+%3XªÜÙÈµ££££§§§ª®®®®®®®®ªªª§§§®µ°®¿ÜêêçÈº§zv}ª¿ÙêïïêÙÁ®ª®°®ª®®µº¿ÇÈÒÎÎÒÕÙÜ£Q;?FLX^XXXX^r}cX^cdzzhh£}zrnnv}rd^^cdhnvrv®Èªz^^zµÇÈÈÈÈÎÜïêÙÇÁ¿¿Á¿¿¿º¿ÇÁÁÇÇÇÈÇÇÁ¿ººÎÈzHFCFFHQXh}§Òçêç®dF;;5;???FF?CHLQQHHFHh§£r^^c^XcTLT^hdLFLQHHTXTQQXÇÒL?;C;555;33.++%+%.^®ÕÈº®§ª§§ª®®®®®®®ª®ª®ª§ª°ºÁµ®ºÜêÜ°n^THHQX^^chµáêïÜÇ°§§ªª§£ªªª®°°°ºÈÙáçáÙC35CHQ^^^^XX^^TX^X^^XTr£vnndccnvvndcchdnvvrrÇÙÁ§£ºÇÇÇÁÁÁÇÒÜçêáÎÁ¿º¿ºº¿ÁÁÇÇÁÁÁÇÇÇÁ¿¿ºµÎÒLCCCFQd§ºÕçêïçªdLC?;;?;?FH;?CCFFCCFLd£°dX^^TXTLTTchQCHTHFLTTTQTrµÕQC55;55;;;33+++%!3dµÒÇµ§££§§ª®®®®®®°®®®®®ª§ª°®ªª¿ÜÜ®vXLHFHHHQLLLThÕêçÒºª§§§ªªª®®ªªªªª®ºÈÙçêÜC.3CLQX^c^^^^^XXXQQQQX§vhhd^^cr}zrhhnhnvrrn°ÜçáÜÒÁºµµ¿ººÇÎÙêçÒÇÁ¿º¿ººÁÁÇÇÁ¿¿ÁÁÁÇÁ¿¿ºÈÙLCFFLdµÈÁÈÙçïá®rdXFCFFFHLQC?C?FFCCHLcºdc^XXXXLQTXhQFCHHCFLQQQQd§Õ§XF53;555??;5...%3}ÁÎÁµª£§ªªª®°°°®®®®ªªªªª££§§£§ÇÜµvTLLHFFLQLHFLLXÈçÙ¿®ª§ªª®®®°®ª§ª§ª°º¿ÈÜêá?..CQQXccc^^^^^^TQQTTh}rhvrdcchvvvhhnnhhc^dv§ÕêêáÈºµ°µµµµ¿ÁÈÜçÜÎÁÁ¿¿ººÁÁÁÇÁ¿¿ÇÁÇÇÁ¿º¿ÈÕLCL^vª®ª§ÁÜçµ}zdHHQQHLLLFCFHdhHCCFQºhc^XXndLLQTXLHFCCFHHLLQL^Õ°c?555333;CLF53+!!HÒÈµ®ª®ª££ª®®ª®®°°®®®®ªªª§§£££®ÒÒQFFHLFCHHFCCFHTÈáÈ°ªªªª®°°°µ°®ª®®ªµÁººÎáçF5;FTX^ddd^^dcXXXTTTXªznhr}}zhdcdnnhnhndcXXdÒççÕÇºººººµµººÁÎÜáÒÈÈÇÇÁº¿ÁÇÇÁÇÁÁÁÇÇÁÁ¿ºÁÙ®cTv§vvncnµÕµzh^LHTTLHFFFFLX}QCCCH}¿rdc^dzdLLLTQLLHCCCFFFFFFTÒÇr;.33...3?LH?3%!+n¿ÙÁª§£ª®ª§ªª®ªªª®°°®ª®ª§§££§¿Õ®c?CFFHF;;?CCCFHXÕÜ¿ªªªª®®®°°°°°®°°ª®ººµÁÒáªHCQT^^cdcc^cccc^XTXXdªrhhhrrdcdnnnhnhhc^T^ÈççÒÁµ¿¿ºººº¿ÁÈÈÕÜÕÇÇÇÈÈÁÁÁÇÁÇÁÁÁ¿ÇÇ¿¿¿µÁÙÎµÁnXTXTQQ^µ¿XTQLLLLHCCFLTTrnQCCCFn°®znhcX^THLQTQQHC?;;???CCCLÈÕC..3.33.3555.!;ÒÙµ£ª°°®ªªª®®®®°®®ªª§§£ªÎÈ}F;CHFFC;5;;?CFHd°ÜÙµª§§ª®®ª®®°°°µµµªªµºµµÇÙ¿^CH^hccc^^^^^cc^X^^Xvªzhdhh^cddccdhnhhdnhdXT^ÈçÜÈº°ººººº¿ÁÎÕÈÈÙÜÈ¿¿ÁÈÎÇÁÁÇÁÁÁ¿¿¿Á¿ºµµ¿ÜçÕÙÕ®vTLQLLHCF^°£hTHFFLQQHFFHLFLTQF?CFc§°}dh^LLQQQQTQQL?;;5???;;;HvÁÜ§Q;;.+33..3.+%L®ÜÎ§ªµ°®ªª®°®®®®®®ªª§§£¿ÙªQ;;CLHCCC555;?FFv¿áÒ°ª§§ªª®®ª®®°°°µº°ª°ººµ¿ÕÈvFFHTXX^^XTQT^^ccccd°rhnrnd^XcccddhddhnhcTQXÇçÜÇ¿°°µººº¿µÁÒÎ¿ÎáÈµº¿ÇÁ¿¿ÁÁÇÇÁ¿º¿¿¿ººµ¿Üêïç¿^LHLFCC;?Hdµ}LC?FQXXHFFHF?CHQLFFH^°}^TLHTTQ^XQQTQ?;53;;533;LrºÜµc;;++.3333.%!hÁá¿§®®®®ª°µ®ª®°®ª§§§£®ÒÒ};3;FHHFFF?5;?CFHzÁáÒ®§§§ªª®ªª®®®°µ°ºµª®º¿ººÎÒXXLHQX^XXTLQX^^cccd®nhhhdc^^^ccddhhhhndcXQXÇáÕÁººµ°µºº¿µºÈÒ¿ÁÙÒºµº¿º¿ºÁÇÇ¿¿¿¿¿¿º¿ºµÁÜêáÁ^TLFC??C?5?QµTF?FQQQHHLLFFFFLXXXLT°XLFCLTL^cHHLL?;3+.....ChÇáÎvC;%++..33..ÒÜµ£®®®°°°µ°ªª®°®®ªª§£ÁáµQ35?FHFCHHF;?CFFHvÁáÎ®£§§ªª®ªªªª®°µºµµ°ªµºººÇÎhhXLQXXXXTTXXXcc^Xn£§}zrnccXX^^X^cddnnhnnhcXcÇáÕ¿µµº¿ÁÁÁ¿ººÇÒ¿¿ÕÜÇººº¿º¿ÁÇÁÁ¿º¿¿ººººµÇáÜµdQLQLQHCC?5;Fd§ªnFCFHFHLQXXLQTLCCHLFHz°cLFFHTTdrddc^LC5.+++3LzªÇÜêÜL?++++...%F§ÜÙ®£ª§§ª°µ°®®ªªª®®§£§£®ÒÜ;.;;CFFFHLF??CFCFr¿áÎ®§£§ª®®®®®®®°µµµµ°°®°µºÁÈ£dTQLQTTX^cdcX^dc^^rª}znddccc^^X^cdhnhnnhdchºÜÒ¿µ°ºÁÇÁÁºººÁÈ¿µÎçÒ¿ººººº¿ÁÁÁÇÁº¿¿¿ºººÎÙ°cQHLXrdLF?;?CLµQFFFFHLXdvdXQQC;;;;Ch®°zXTXh§ª§§rdcXThÇÜçêïêºc;33....%dÇÜÎ§}£§ª®°®®ªªªªªª£££ÁáÕv335;;CFHLLF???CCFvÁáÈ®££§ª®°®ª®®®°°°°°µ°°®°ººÁ®rQQXQLLT^nrcX^d^XXv§vhdhrrdcccc^^cddhhhhhddv}µÜÒ¿µµµ¿º¿ººµ°µ¿¿µÈçáÎ¿ºµº¿¿¿¿¿ÇÇ¿¿ººººÁÕÇdTLHLXdrcLFC?CCCd§£dHFFCFLQcvhH?CC?;53?d°È§§µºº¿¿ÁÁÇÇÁ¿¿ºµ°¿ÙçïïïïïÕ5XLC53++ÕÕ¿}}£§®®®®®ªªªª§££µÕçÁd3335;?FQLFFFCCC?FÈáÈ®££§§®°®ª®®°°°µ°°°µ°ª®µº¿°zXThhLLTcdhdcnh^X^§ddddhrhhhnhccccchhhnhhhnv®ÙÒÁº°µµºººµµ°°µÁÁÎçêÜÇµ°º¿¿ººº¿¿¿¿µµµºÈÕ£r^QQHTXLLLHHFCFFCLªvLHFFFHLT^^F;5;;;53?nºÜÒÁÁÁºµ°®°°°ºµµºÁÈÎÎÎÙáêïïóóóêªF§}dQ5!
+?§ÕÇ§}}£§ªª®®°®ªªª£®ÈáÜ£Q35;5?HHHF?CHF???LÒÙÁ®££§ª®®ªª®°¿ºµ°°®µ°°ªªµº¿º^TcvdQXXX^cchcTT^°dddc^ddhvvhccdddhhnnhdchz®ÕÈ¿ºµµµ¿¿¿¿ºµ°°µÇÙçïçÕ¿µºººº¿º¿¿ººµººÁÒ¿}^TLLHQQHHHLFFCFCCCh£QFFHLLLQQQH?5555;3?zÈçáÕÁº°°ª§ª®®°®®®°µµµµÁÇÈÕáêïïïÎhÈºµ®rL.!c¿Òµ}££ªªªª®°®ªª§§µÙáµn?3;;;?HHFFC?CFC;;TÒÕ¿ª££ªªªªª®µº°°°°°°ºº°®µµµºdTThznc^X^^TTQLHdªºddd^cdddrzrddhnhhhnhnd^d}°ÕÈ¿¿ººµº¿¿Á¿µ°®®¿ÈÜêïáÈºº¿¿¿ÁÁÁ¿ººº¿ÇÎÒ^LLQHFFFHHHHHHFCC;?TXFFLLQTQFLQFC;5;;;HÕçÙÈº°®®ª§ª®ªª§ª®®®®®ªª®®¿ÎÜêïïá®º®vrÕÎ®}}§ªªªªªªªªªª§§£¿ÜÈzF5;;??;CFHHCC??C;?c®ÜÙ¿ª£§ªªª®°°®°°µ°°°º¿µ®ª§®¿£rXTTcc^XX^XTQLFFrµ¿hddddhhhnrrnhdnndhhddd^hºÙÎÁ¿µµººººººº°°®°¿ÒáïçÎºµº¿ÁÇÁ¿ººººÇÒÙÁ}TLLQLFFCFFFHFFC??;;Fz£nFHLLQXXHFQTH?55;C^ªÜÜÈº°®ªª§§ª®®ª§ªªªªª°ª£§§®ºÇÕáïêÁ^LXz®¿ÁÕçÙ°£®µ°ªªªª®ªª§§£££®ÇÜ£L55????;;FLLCCCCC??n¿ááÁª£§ªª®®®®°µµµ°µ°µµµª§§®¿°zTLHFFLTX^TTQF?F¿°ndnhhnhrrhhhhdhhhdhdccchºÙÒÇÁºµµµ¿¿ººµ°°°°µÈÜêçÎ¿ººº¿¿Á¿¿¿ººÇÕÙªdTQQXQHFFC?CHHFCC;;5Ch§LFHLL^cQFHLF;5;;F}ÈáÒº°°ªª®®®ªª®§§§§ªªª®ªª§§ªª°¿ÕçêáF?CQddd}§ÈÜêáº£ª°®ª®ªªªª§§££££ªµÒÈv?35?CCC??FLL??????FzÇçáÇª£§ª®®®®®°µµµµµº°®®£ª°°ÁÈvTFFQcndd^XQFHcÁ£rcchnhhhrrnhnnnhhdddc^^cnºÙÒÈÇºµµµº¿¿¿ºµ°°°µ¿ÎÜáÒ¿µµ¿ººººº¿¿ÁÎÙÒXTQLQQQTQHCHQHCCC?;5;X£XFHHHQc^HFC;55;;QÙÙÁ°®ªª®®°®®®®ªª§ªª§®®ªªª§ªªª°¿ÕçêC;?CLQQTn¿ÜçÁ££££§§ªª®®ªªª§§£§§£§®ÁÒT535?FFCCHFFH????CFLÒççÈª£§ª®®®®®°°µººµº®ª£§ª®ÈÜÒ°r}ªª£zhrÇÒhX^dhdnrvrnhnrrndcddc^cdhµÙÎÈ¿ººµµº¿ÁÇÁº°°°°°¿ÎáÕÁ¿¿¿¿Á¿ºº¿ºÁÒÜ¿rHLQQLLQcdcLQXLFCF?;55Q°nHHHFHXXQF?5533;^µÜÒº®§ªª§§§ªª°µ®®ª§§§°°®ªªª§ª®°µÇÙêF??CHLHHQhÇáÈª§§§§ª®ªªª®ª§§£§§££ªµÈºnF;55?FFCCHFFF??C?FFTÕêçÎª£§§®®ª®®®µµµµµºµª££§°ÒçêÜÇºÈÒÒÈÁ¿¿¿¿°µÎçá®rX^dddnrz}rhhnrddcccc^ddhºÙÎÁºµµµµµ¿¿¿Ç¿°®°µ°°ÁÙÕÁ¿¿¿ÁÁ¿ºººº¿ÒÙ£^CFQQHLLLQLHLXQFFFC;55H}°LHFFCQTHC?;5+%5rÇÜÇ®ª§ªª££§ªªªª§®°®§§µ°®ª®®ªª®®®ºÈáC??FFHFFHTrªÙÎ®§§££§§£§®ªªªªª®ª§§ª®ª§®¿ÇQ?;5;?CCCFFCFCCFF???TÕçêÒ®§§ªªª®®®®µµµ°µº®£££§ª¿ÙêïçÕÒÕÈÁ¿µ°ºÁÈÕáêïê¿vX^ccdcdv}nddhhhdc^^ccchnºÜÎ¿ºµºººººº¿¿º°°®®°°ºÈÕÇ¿ººº¿¿¿ºº¿ÁÒÇQCCLQLLLFCCCFQLLLLC;55CdªTQFFCQcLHHF;+!;ÒÙÁ®ªªª®®§ªªª§§§ª°°ªª°°®®®°°°ª§§®ºÎC?CCCCCHHH^ÎÕº°°§£ªªªª§ªªªª§§§ª®®ª°¿ªd?;?;???CCFCCFCCCC?5?TÒáçÒ®§§ªª§ªªª®°°µºµ°°°ª£§§®µÇáêÜÕÕÒÇº°°µ°µ¿ÁÒáïïïÎ}Xc^^^QThrrhdhnnd^^cddddnºÜÎ¿ºººº¿ºµºº¿¿µµ°µ°°µÁÒÎ¿µµµµº¿¿¿¿ÇÒ°nHCCHQQHFFFF?CHHQTQC55;?X£cHC?CFXQHFF;+!CÙÙ¿®ªª§ª®§§®ª§£§§ªª§§®°®ªªµ°®ª§§ª®¿FCCFC??FHFQvµÙÇµµª£££§§§§§ªªªªª§§£§ª®®µ¿Q;;???FCFCC??CCC?C???TÎÜçÒª§£§ªªªªª®°°µµµ°®ª®ª®°°ºÒááÎÇÇÇº°°°µµº¿ÁÈÙçêïÕddcc^QQchnnhnnnd^ccddhhn¿áÒºµºº¿¿¿ºººº¿¿µ°µ°°°ºÎÒ¿°°µµµº¿º¿ÁÇXFCCFQQHFFFFFCFFFLLF?5?CTµvLC???FLH?;3+!Q®áÕ¿®ªªª££§§ª®ªª§§®®ªªªªªªªªªªª§§ªª°HFFHHCCCFFLcÒÒºª§£§§§§£§§®ª§ª§§§££§ª®¿§dF?CFC?CCFF??CCC??HHHLXÎÜçÎ£§ª§ª®®ª®°µµµ°®ª°°°µºÁÙÜÎÇ¿¿µµºµ°°°µÁÁÁÎÙçêáªzd^^XTT^dhnnnrnddddddhdn¿ÜÒº°µ¿ÁÁ¿ººººº¿º°µµ°°µÁÒÇº¿º°°µµº¿ÇµzQFCCFLTLCCCFHFFFFFHC??FFLÁXFCC5;FF?.+%+dÁçÙ¿®ªªªª§£§ª®®ªªª®®ªª®®®ªªª§ªªªª§§®FFHQTQC?CFHTÇÕ¿ª§§§§§£§§§ª§§§£££££§ªµ®vF;?CFFC??FFCFC?CCCFFLQXÎáêÈ££§ªªª®®ªª®®°ºº®®®ªª®°ÎÙÒÈÇ¿ººµººµ°°º¿Áº¿ÈÙáÜº}h^X^^c^dhhnrvrhdcccccchÁáÎµ°µµº¿º¿¿º¿¿¿ººººµµ°¿ÈÎÁ¿µ£ª°µµ¿ÁcHFCCFFLLCCCCFFFFFFFC??CCFÈ®rXTHCCTcXLF?FÕçÙµª§§ª°ª§ª®°°ª§ªªªªª®°µ°®®§ªªª®ª§ªHHHQTQLFCFHLn®ÕÇ°ªªª®ª§ªª®ª§§£§§££®°L????CCC;?FLFCCCCCFCCLLTÎççÈ££§ª®®°®®ªª®®µ¿µ°®ª§ªºÎÎÇÁºµµººµººµºµº¿ºº¿ÇÒÕ¿nc^vvhhnnnvvnddhcc^chÁáÒºµººµµµº¿¿¿¿¿¿º¿¿ººµºÇÎÇµª£µµµ¿ºTLF?CFFHHFCC??CHHHHFC????C}ÈÈvrrzªªÁçêÜµ§§ª§®®®°º¿¿°§§§§ªªª°°°°°ª§§§ªªªªLQQQQLTQCFHL^ÎÒº®ªª®°ªª®®®ª§£§§§§°£c??C?????;;CLHF?CCFHCCHLTÎççÈª££§§ª°°®ªª®®®®°°°°ª§®ÇÒÈ¿ºµ®®®®°ºÁ¿ºµº¿ºµºº¿ÇÇndr®º£rrrnnvrhdrrdcchÈçÕ¿µºµºººº¿¿¿¿ºµº¿ººººººÈÇº°£®µµº¿§dQXcQFFFLLHC????FHHLH??C??F}ÎáÒºµ¿ÇÈÈÈÇÈÎÎÙçïïÜ¿§§ª§§°°°µ¿¿°ªª§§ªªª®ªª®®ª§§§§§§§LLLQLQTQHHFFQz¿ÙÎº°§ªª§§ªª§§§§£££££®°}C5?C?CCC?;??FFFCCFFHCFLQTÈçêÒ°®ªª§§®°®®ªª®®®ªªªªªªµÎÎÇººµ®ªª®µ¿¿ÁÁ¿¿¿¿ºµµµºÁµhhr}}rnnrrrnhdrh^dhÎçÕÇ¿ºº¿¿º¿¿¿¿ºººµººµ¿ÇÇÁÁÇÁ¿°µºº¿¿TLc}zXHHHLHFCC?CFFFHC?;CCCLÒçêçÙÕÈÁº°°ºÇÎÙêïïçÇª£®ªª®®®®®°®ªªªªª®ªª®ª®®ªª§§§£££LLLLLQQLHHFFHh°áÜÎ¿ª§££§§§ªª§£££££§º£X33;???CC?;??CCFFFHFHCFLTXÇçêÜÁµ®ªªª°ºµ°®ªªªª§§§§ª®¿ÒÎÁµ°µ®°°°¿ºµ¿¿Á¿¿¿¿ººµº¿¿h^ccdvrhrrrvhhdrnccnÇáÕÇ¿¿¿ÁÁÁ¿¿¿ºººººººººÁÇÇÁÈÈÈÇ¿µºÁ°vLFH^^QFFHHLHHHHCCCCCC??CFCQÕêêÜÈ¿°®°ªª°º¿ÇÙçïçÈ°ª®®®ª®®®ªªªªª§ª®®ªªªª®®§§§§££HHFFHHHFCFFFFc®áçÜÎ¿®£££§ª°°ª£££§°¿C.35;;;?CCC?;CCFFCFFHFFLTXÈêêçÈºµµµººµµµ°®®ªª§£££§°ÈÕÇº°µµ°ºµ°µµ°µ¿Á¿¿º¿º¿¿º¿¿ªvccc^cr}vnrrnnrhhnzndn¿ÜÒÁÁÁ¿¿ÁÁ¿Áºººººº¿¿µºººº¿ÈÕÒÈÇº¿Ç£cFCCCCCCLLHHFCLLCCCCCCC?CCCX£ÜçáÈ¿°®ªª§®°°µµÁÙçêÕ¿°ªªªª§ªªªªªªªªª®°®§ªª®®§§£§£?;;5;??;;CFFFcªÜçêáÎµ®ªªª®°°ª§º®c5..3;;??FFFFFFHHHFFHLHHHTcÈêçÎ°ª®ºÁÇÁ¿¿¿º°®®ªª§££ªÁÙÙÇµ°µµµµ°°°µ°µ¿Á¿¿¿¿¿¿¿ººº°hc^^^drvrrnnrnhhhnnhh}µÜÒÁ¿¿¿ºÁÁÁÁººµµººµºµµ°°°µÇÙÙÒÈÁÁÁQC?CCFFCFQHHC?FHFFCFL?;;??Fr¿áÜÒÁ¿µ®ª§§®®®®°µÇÜêÜÁµ°°°®ªªªª®°®°°®®°µ®ªªª®ª§§££.+%!+35;;Fd°áççêÙÈºµ°®§§§£§ªºH3333;???FFHLTXcTLHLQ^THHTdÎçÒzr}£µÁÎÈÇÇ¿ºµ®°µµ°ºÕçÕÇµµººµµµ°µ°µµºººº¿¿ºººµººº£vc^^cdhnhhhhnhnrhcdhdvªÙÕÁ¿ºµºººººµµµµºµ°µµµ®ª®°¿ÜçáÙÎÈ¿vHFFFFHLFCFFF??FFCCFHLC555?LÒÜÎÁ¿º°®®ª®®®®°°°ºÎççÎº°µµµ°®®®®°®®®®®®°°ª§ªª§§§§§£!
+
+!%3LÁÜÙÜçÜÒÁº°®§££ª®°µ°®h5..35;?CCFHLQ^h^QLQT^^QLLThÒÜ®rXQT^dz°¿ÈÈÈÇ¿ºÁÎÎÕçêÙÈÁÇÁÁÁ¿ºµµµºººµµ¿¿¿¿¿ºººº¿ºnhdddhnnhddhhnrhc^ccn£ÕÒÁ¿¿ºµµµ°ººµµµºµµ°µ°®ªª®¿ÙïïçÜÜ¿nC;???FQTHCCC??CFCCFCCC;5;?c®ÕÎÁµ°°°®°°°ª®°µ®ª°ÇáêÙº®°°®®°®®ªªªª®®®®ª®ª§§§§§§§ª§FzªÁºµ¿ººÁÁÁº°§®ÎÕÒÁµF+++.3;?CFFHHLLLHHHQT^XLLL^n§ÙÈ^LFLLLT^hv®¿ÇÇÁÁÇÎáêçÒÇÁÇÇÈÇ¿¿¿¿¿ÇÁ¿ºµºÁÁÁÁÁ¿ºººÁ§zndddhhnnhhhhhhdcccdn£ÕÕÇÁÁÁÁµ°µ¿ººµ°ººº°°®°®§ªºÙêïïïêºhF;??CCHLHC??;?CC???;?C???LÇÎÁ¿º°°µ°µ°®ª®µ°®ª®¿ÜêçÇ°ª®®ª®ª®ªª®ªª®ªªª§§§§§§§§§ª£F°®°Á¿®£ºÙÕ¿®§h.%+..35;CCFFLLHFHHHLQTQHHLXrªÕ°nQHHHHFHQQQTcn}ªºÇÕçïáÒÁµººº¿¿ÈÎÇÈÈÇÈÁº¿Á¿¿¿¿ºµººÁºdccddnnnhhhhddddchhr§ÙÙÇ¿º¿¿ºµ¿ºµºµ°µµµ®®°®ª§ª¿Üïïïóê°hLFCFCFFCCCCC;?CC?;?CC?CFHdªÎÁº¿¿µµ°®®®®ª®°µ®ªªµÒççÒµ®®®ªª®®®®ª®ªªª§ª§§§§§§££§§§5¿ªhrrrnhdn£¿Á®§ÇÕ°£F!%.33.35?CCHLQHLLHQQQQLLQTXvªÁcTQQHHFFFHHHLQTX^n¿ÜêêáÎ¿µµµ°µ¿ÇÁÁÁ¿ºÈÒÈ¿¿µºµµµ°µº¿ÁhX^cdhhnrhhddccdccnzµááÈº°ºº¿º¿º°µµµµ°°°ª®ª§§°Èáçêêïê°cF?;??FF?CHHFC;????CHLC;?LÁÈÁµºÁººµ®ªªªªª®°°®ªªÇÜêÕµ°®ª§ª®ª®ªª®ªª§§§ª§£§§££§£XnTTcdddXT^dzÁÈÇÒÒ®ª§r3!%.5.3;5;??FHLLQQLTXTTQQ^^c°§vXXcQHLLFFHHHFFFHHLdÇáêÜÎÁººµ°µ¿ººµºººÁÒÒÁ¿µµµµ°µµººÇªv^^^cchhhhdc^^^c^ch¿ççÙ¿µ¿¿ººº¿µµººµ®°°ªª§£ª¿ÕÙÒÎÕáê°cF?5;CCF?;FF??;;?CCFFHC;Fc£ÇÁºµµµµµ¿µªªªªªª®®°°ªºÕçÕµªªª§£££§§§ªªªª£§§ª§£§£
+3TQC;CL^cc^XQQXcrÁÕáÒ¿Áª^%!%.3.5C55;;CFLLHLHTTXTTTXXdµhTHFCCHHCHQHC??CCCCQhÒçÜÈÁµµµ°°ººµµµºµ¿ÁÁ¿¿ººµºµµµººÁº^T^^c^cdhh^^XTX^nvÒêêçÎ¿º¿ºººººµµº°ª®ª§§§®¿ÎÎ¿µµºÒá¿dF?;;CCF;55;;;?;?CHQF??HnÁÁµ°°°®°°µº°®ªªªª®ª°°ªªÁÜÕµ£§§££§§ª®®ª§§§ª®ª§£3+!3FXd^XTTTXX^nÈÜÜÕÒ§H%%...3??;?;CFHFFHHLTXTTLLTdºhXF???CHCCLLFC;?C?CHQzºáÜÎÁµ°°°°µµµµµ°µµººº¿ºµµµµµµµº¿ÁcXX^^X^Xdnc^TT^rºÜêïçÕ¿º¿¿¿ºº¿µ°º°®ªªªªµÇÈÇ¿®§§®ÁÙÇvH?;;;?C?5555;;;?CHHCCCXÇÒÁºµ°°°°®®µµ°ªªªªªª®®ª£°ÎÙ¿ª§§££§ªªª§§ª®ªª§£§ª®§§£§!5Qc^TQXXcXT^v§ÒáçÙ?%+..+3???;?CFFFFFLTXTLHLXhÇ^LFCFCCFCCCCHF;??CC?C^ÕÜÒÇµ®°®µºµµ°µ°°°µµººµ®®°µµµºº¿Ç®rc^^^^XTXchnnz®µÈÜçïêÕÁººº¿¿¿ºº°µ°ª§ª°¿ÎÈº°°ª£ª¿ÎÎL;;;;;;;5.335?C;?;;;CCcªÕÕÁºµµ°®®ªª®ººª§ªªªªª§ª§§¿ÕÇª®®ª®ªª®ª§§§§ªª§£££§§ªª£§.H^TTQTXXQQXh¿áêÕ;!!%+....;C;;?CFHHCCLXXQHHQTn®ÎL?;5;CFFC?CCLH??CC?5;QÁÕÎ¿µ®°°µºµ°°°°°°°µµºµ®®µµµºººµÇÇhcXXXXQXh£ªµ°ª§ºÎçêÕÁµ°µºº¿¿µ°°°®®µÈÒÎ¿®®®ª£ªµÇÎ£X????55;3.3;?FC;5555;ChµÙÈÁµ°µ°®®ªªª°µ®§§§§ª§££°ÕÎ®§ªª§££§££££§§§§£§§££§££+HTXTLLQQLQT^r§ÕçÎr3+%%+....;??;?;;CFCFQTTHFFFQzÁÒL;5335;???CCFF??CC;;;Fh®ÒÎÇµ°®µµµ°°°°®®®µµµµºº°µµµ¿ºµºÁÒ°vc^X^ch}§ºº§vvªÈáÙÁµººººººµ°®°µÁÎÒÇ¿µ®ªªª§£§®ºÈµhCCC;53...3CCC;;?535FQ}¿Î¿µ°°°°®ªª§ª®µ°ª§ªª§§£££®ÒÕ°££££££££££§§§ªª££§££ª§££.HXXTQQLQQQQTcÈáÁc%!!%+.+.3;??;55;;??FHLLF???LÒÕL?5335;5?C?;;?;;CCC?;?XÈÎÇºµ®°ººµ°°°®®®µµµ°µ¿ºµ°µºµ°µ¿ÒÈndhv°°£zrvnhvªÒÜÒ¿ºµº¿ººº°°ºÎÕÎÁ¿°®ª§§§ªª§ª°ÇÇF;;53...3;??;5CQ?35CTÇÁµ°°ª®ªªª®ª®®µ°ªª§§§§ªÎÙº§£ª§£§§£§ª®ªª°®§§ªªª§£+CTXTTXQQLLLQX}µÙºT%...3?C???;;5;HQHFHC?CHdªáÜQ;;;;5;5?C?;???;CF??;?L¿È¿µµºµ¿Á¿º¿¿µµµµµ°°°µµ°°°µµ°°µÒÜ¿ª®§vnhhvznnvz°ÙÕÁºµº¿¿ÇÁÁÁÎÕÎ¿ººµ°®®®®°µ®®®ÁÒL55533335??;;5?H;55?^ªÈµ®°®ªª®ªªª§ªªª®®®§§££§ÎÜÇª££ª§§§§££§ª§ª®ª§ªª®ª§££§
+%?LXXXXTQLLQQTn£Î¿d%!+.35CHHFFF?5?hz^Xdhv}§Îçá§Q55FHFC;?C???C?;?C;;;?Fn®Çºµºº¿º¿¿ÇÎÁºº°°°°°°µµº°®°µ°°ºÒçáÈµºªzvvrhddhr}zrvvzÁÕÈººµºÁÎÒÕÕÕÎÁ¿µºººµµººµ°®ªª°Î°^5555355;CC;5533333Cz¿Èµ®°®ª®®ªª§£§§§ªªª§§§££ÇáÎ®££§££££§££§ª®ª§§§§££§!;LX^XTTQQHHTT^ÁÒF%!%3;??FQX^^ccc^n®ªµÁÈÒÙçïêªQ533?HH?;;;?CFHCCH;55;C^Á¿ººººµ°µ¿Á¿µµµµ°°µµµµºµªª°°°¿ÕêïçÈ£rddhhhhdcdhnrrnr}§ÎÎÁºººÇÒÜÕÎÈ¿µµ°®®®®®°µ®®®ªª®¿¿v;55335?CCC?53.3335HÈÁ°µº°°µ®§§££§§ªª§§§ªª§££££¿áÙº£££££§§§£§§§ª®§££££§£§ªH%;HXXTQQLQHFLTQrºÕµhdhv}zzz®ºÇ¿ÁÁÇÈÎÎÙáêê°^;5.5?C?;;;?CFLLHH;5;;?Q¿ºµµºµº°°µµµµºµººµµººµµ°ªª®®°ÁÜêïÙ§}nhcddhhhcccdddndhrÁÕÎÈÁÇÎÙÒÇ¿ºµ°®®®®ªª§ªªª®µµ®ªµÇH;C;35?CCFC533;55;^®Èºµ°®®®µ°ª£§§§ª§ª§§§£££¿ááÈ°§£££££££§§£§§®ª££§§£§®C
+!3?HQTQLQLLQHFHFn°ÕÈµ§££®°°°µ¿ÁÇÎÈµ®°ºµµµ°°°ºº¿ÁÎÜêºd?.+3?FF;5;FHFHLH?55;;?H}º¿µ°°µµµ°°ºº¿º°µºµµµºµµµ°°°°°ÁÜêçÁrnhccddcc^cchccdcch}ªÙáÜÙÕÕÒÁº°°°°°®®®®ª§§ª®®°µ°ª°ÇªT;C?555;?HF;55??5?r¿Î¿°ªªª®ºµª§®§§§§§§£¿ÜêÜÇºµ®ª£££££££§®ª£££§!5CLTQQQLHHLLC?CrµÒÈºª§§ªª®°ºÇÒÕÒÇ°ª®°®®®®ªª®°°µÁÒçÈzF5..3?HC;;FHFFLH;555;;FvºÇºµ°®µÁµ®ºÁÁ¿µ°µµµ°µµµ¿ºµ°µµÇÜïÕ£zdccdccddcc^^cc^^X^crÒçêêáÒÎ¿°®®®®°®®°®°°ª®°µ°°°ª®Áºn5.5?;5;;FC??;C?;FÈÁ°ªªªª®µº®£ªµª££§£££ºÜêêáÙÕÒÁµ®ª££§§££££ªª§§£v%5CTXTQLLHFCCC?H¿Áºµª£§££ª®°ºÈÒÇ°§£§§§£§ª§§§ªª®µÈÜÙQ;3...;C;;?C?FLC55555?Hz¿È¿µµ®°º°°µºµºµµµµµµµµµµµµ°µµÁáçÁhc^^ccdnddd^^XX^^XdhhÇçêêÜÈÈÁµµ°®®®®°®°¿Áµ°°µµ°®ªªµÇF.353555;;;?;;;;QÈµ°ª§§®®°®ª§£ª°®£££§§§££µÙêïïïïêáÙÎÁµ®ª®§££££ªª§T+;FLXXTQLLLFCCC^£¿µ°°ª£££§ª®°µºÁ°££§££§£§ª°¿Õçµd?533.5;;;;??FLH??;55?H}¿Î¿ºº°®°®°°°°ººµµµ°µµµµ°µµ°°µÇáÜªvc^cdcchhhdhcXXX^^^nndºáêêÙÁ¿º¿¿º°®°°®®®ºÇ¿°°®°µªª§®Èµd5..3335;;;?;;;;d°Áµ°®ª®ªª®ª§§§§°®ª££§§ª§£§¿ÜïïêêáÙÙÕÙÕÒÇ¿¿®£££££§cF
+%3CLLQ^XQTTQLC;Czººª§®ª§£§ª®ª°°°°§£§§£§£§®ºÕáÎzC533555;;;;?HHHC?55;?Hr®Ç¿¿Áº°°°°°°µµ¿ºµµ°µµº°µµµµµµÈÜÇhcchd^dnnhhdc^XXcc^^^cz°ÜêêÒ¿º°°º¿º°µ°®ª®µµºµ°®®®ªªª®ÎÕL3.35;55535;?5C}ººª°°®®§§§§§§§§ª®ª§£ª§ª§£§ÁáçáÕÇºµµµ¿ÁÈÎÒÎÁ°ª££§£rF;
+!3?FLQT^XQTXTLC3FÈµ££ªª§£§ª°®®°®ª£££££§§§§®¿ÒçÜL;55;?;5?;;?FFFC;;;;;F^¿¿º¿¿ººµµµµ¿¿Á¿ºµµµºµµº¿µ°°ºÇÇ£vdcchdcchdhdhddcchcXXXcrªÙêáÈµ®®®°ºººº°®®®°°®°°°®ª§§§°ÕçÇH55;?;33..355H¿°®®®ª§£§£§§§§£§ªª§§ª§§££§ªÎÜÒ¿°ª£££§ªª°ÁÈÒÈ¿°ª§£§®°°Q?5
+%3?FHQQTcXTTTTLC;cºÒ®§ª££ª®®°°ª§§£§££££§§ªªª®°¿Îáç£Q?;;;?;5??C??CCC?;;5;CLh¿µµµº¿¿Á¿º¿ºº¿ºµ¿Á¿ºµº¿ºµµ¿Á§}nc^ccc^chddddndcddcc^X^nÕêÜÈµ°°°°°°°µ°®ª®®®®ª®®ªª££§µÕêç¿vH;;FC.+++33;^ª¿°®ªªª§§§§§£§£§§ª§§£ª£§££ºÎÇ®£££§°¿ÈÎÇº°µ¿ÇÈµn?3.%+5?HQLQQTX^XTXTTLXÎÎ££§§£§ª®ª®®§£§££ª§§§§§®®°®®°µºÈÜç§THFC????;CFCCCCCC?;;CHHQµ¿ºµ°ºº¿ºººµµ¿¿µº¿¿ºµººµµµ¿ºhd^X^^^^dddhhdhdcXchdcXcnÒçÒÁµµµºµ°°°°°®ªª®®®®®®°°®§§¿ÜïïÜ®vXLdd;%%+.3;z¿º®ªª°°ªªªª§§§§®ªªª§£§£§§§£ÁÁª££°ÇÒÎÈÒÕÜáªQ3%%;!!!%.55CLQTTTTTX^^^^X^dºÜÎ£££§ª®®®££§§£®ª§£§ª®°µ°°°ºÁÙçµcFLTTHHF?CC?FHFFF?;;CFCFr°ÇÁºµººµºµµº°º¿µµºººº¿ººµ°¿®z^^^cc^X^dddnrdccccdrd^^cnÎáÎµµºµ°°°°°°®®°°®°®ª®°µ¿º®ªÇáïêÜÇ®^.!!%+FÁº®ªª®®®®ª§§§ªª®ªª°ª££§§ªÇµ£°ÇÕáçêïÙC.%X.+.55;?CFHTTTTTQQXc^dhhnµÙçÎ£§ª°°®££ª££ªª££§ªª®®°°°µ¿ÒçÈr?;FTQFFF?;?HHCCHHC;5??Cc§ÇÇºµµºµµºµ°°µººµµººº¿¿¿¿¿Á§hTX^^c^^ccccdnddccdhdhnddhÈáÎµ°µ°°°µµ®®®®µµµº®ªªªª®µ°°ÎáÜÎµ£ª®µ¿hC+!3^ªÈº°ªªªª®ª§§§§ªªªªª®§££§£º¿ª£®ÈáêïïÇr?+!L35?CCCHQQXTTXXQT^dr®ÈÜçÎ§££§®°°®§ª°ª£§ª§££§ª®®®ª°º°µºÎçÙF33;CCCLLCCFF?;CLH?;?;?TÎÒÇµ°µµµµ°°°°º¿ºµµºÁ¿¿¿¿ÇÇdX^XTX^hdccc^chdhhhhdvnhÈáÎ¿°°°µººµ°®®ª°°°µµ®ªª§ª®°ºÎÈ°zv}ª°®X?QÎÎµª§ªª§ªªª§§§§§§££§§£§£®¿®§££µÒêïç®^3!¿zF;?CFFHQQTXT^XX^rª§ª°ÇÙÎ®§ª®®®®ª°º®ªªªª§§ªª®®®®°ºµººÈáç°X?5;???FLLC;C?;;CFC;?;;HÎÜÎ¿µºµµµµµ°°µµµµµº¿ºµºÇÒÁhvvdXXdrnc^^X^dnrnnnnzzvnhÇáÕÁµ®®®µºµ°®®®ª®®®°°µ®ª§§°¿¿rhc^dhnz£°£ÎáÒ¿ª§ª®ªªªªªª§§§§£££££§££¿º§ªÇáêÜL+ÎªcCCFHLHHQTXTXdn}°µªd^ch¿Èª£ªªªª®®µ°®ªª®ª§ª°®µ°®°°°°µ¿ÇÙêÒhCF;??C??H;5;53;;;;5;;5CzÈáÒÇµµ°µº¿µ°µµµµºµ¿¿º°¿ÒÜµrn}hXcnhdX^XXdrnnvvzrcccnÁáÒ¿°®®®®°µµ®µµ°®ªªª°µµ®ªªµ¿znd^XXX^^^^r®ÇÙçêÙºª®ªª°ª§ªªª§§§££°Èª§µÒêÜC%
\ No newline at end of file
diff -r 8b1af7363833 tutorial/python/presentation/images/pex1.pgm
Binary file tutorial/python/presentation/images/pex1.pgm has changed
diff -r 8b1af7363833 tutorial/python/presentation/images/runways.pgm
Binary file tutorial/python/presentation/images/runways.pgm has changed
diff -r 8b1af7363833 tutorial/python/presentation/images/surimp.ppm
Binary file tutorial/python/presentation/images/surimp.ppm has changed
diff -r 8b1af7363833 tutorial/python/presentation/images/vertebre.pgm
Binary file tutorial/python/presentation/images/vertebre.pgm has changed
diff -r 8b1af7363833 tutorial/python/presentation/muscle.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tutorial/python/presentation/muscle.py	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,57 @@
+# UjoImro, 2010
+# CeCILL free-software license
+
+from pink import *
+pink = cpp
+
+
+# sol_muscle
+# extract the cells of a musle-fiber-cut image
+def extract_cells(image, threshold=24):
+
+    # creating the structuring element 
+    elem = pink.char_image([3,3])
+    elem.fill(1)
+    elem.center=[1,1]
+
+    grad = pink.gradmorph( muscle, elem )
+    seuil = pink.seuil( grad, threshold )
+    frame = pink.frame( pink.char_image(image.size), 255 )
+    dilated = pink.geodilat( frame, seuil, 8 )
+    skeleton = pink.skeleton( dilated, 0, 8 )
+    inv = pink.inverse(skeleton)
+    eroded = pink.erosball( inv, 5 )
+    inv = pink.inverse(eroded)
+    skeleton2 = pink.skeleton( inv, image, 4 )
+
+    return skeleton2
+
+muscle = pink.readimage("images/muscle.pgm")
+imview(muscle)
+
+cells = extract_cells(muscle)
+
+def th(q):
+    return pink.seuil(muscle, q)
+manipulate(th, 0, 255)
+
+elem = pink.char_image([3,3])
+elem.fill(1)
+elem.center=[1,1]
+
+grad = pink.gradmorph( muscle, elem )
+imview(grad)
+
+def ec(q):
+    return extract_cells(muscle, q)
+
+manipulate(ec, 0, 100, muscle)
+
+
+
+
+
+
+#imview(cells)
+
+# LuM end of file
diff -r 8b1af7363833 tutorial/python/presentation/pex1.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tutorial/python/presentation/pex1.py	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,52 @@
+# Michel Couprie, 2010
+# CeCILL free-software license
+
+# Correction of global bias in image
+
+from pink import imview as imview
+from pink import manipulate as manipulate
+from pink import cpp as pink
+inv = pink.inverse
+
+debug = False
+
+# bias correction
+def correctbias(img, alpha):
+    smooth = pink.gaussianfilter(img, alpha/200.)
+    mm = pink.minmax(smooth)
+    s = smooth - mm[0]
+    res1 = img - s
+    minmax = pink.minmax(img)
+    res = pink.normalize(res1, minmax[0], minmax[1])
+    return pink.float2byte(res)
+
+global image
+#image = pink.readimage("../images/uo.pgm")
+image = pink.convert2float(pink.readimage("images/pex1.pgm"))
+
+# try gaussian filtering (acts on global 'image' - for use by 'manipulate')
+def gaussian(alpha_int):
+    alpha = alpha_int / 200.0
+    res = pink.gaussianfilter(image, alpha)
+    return res
+
+def ss(q): return pink.seuil(image, q)
+
+if debug: 
+    manipulate(ss, 0, 255)
+
+#a_int = manipulate(gaussian, 1, 200) # let the user choose parameter value
+
+def cb(q): return correctbias(image, q)
+
+a_int = manipulate(cb, 1, 255)
+
+res = correctbias(image, a_int)
+
+def s2(q): return pink.seuil(res, q)
+
+manipulate(s2, 0, 255)
+
+imview(res)
+
+# LuM end of file
diff -r 8b1af7363833 tutorial/python/presentation/vertebre.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tutorial/python/presentation/vertebre.py	Mon Jan 13 15:50:10 2014 +0100
@@ -0,0 +1,23 @@
+# UjoImro, 2010
+# CeCILL free-software license
+
+# Michel's TP-4 for 3D images
+
+from pink import *
+pink = cpp
+
+inv = pink.inverse
+
+debug = False
+
+lettre_a = pink.readimage("images/lettre_a.pgm")
+if debug:
+    view3d(lettre_a)
+
+### General skeletonization with toposhrink
+shrunk = pink.toposhrink(lettre_a, pink.distc(lettre_a,0), 26, 1, 1, 1, 1)
+if debug: # for package generation
+    view3d(shrunk)
+# if debug: # for package generation
+#render(lettre_a, shrunk)
+render(lettre_a)
